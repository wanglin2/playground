var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __require = /* @__PURE__ */ ((x2) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x2, {
  get: (a2, b) => (typeof require !== "undefined" ? require : a2)[b]
}) : x2)(function(x2) {
  if (typeof require !== "undefined")
    return require.apply(this, arguments);
  throw new Error('Dynamic require of "' + x2 + '" is not supported');
});
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require2() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all2) => {
  for (var name in all2)
    __defProp(target, name, { get: all2[name], enumerable: true });
};
var __copyProps = (to2, from2, except, desc) => {
  if (from2 && typeof from2 === "object" || typeof from2 === "function") {
    for (let key of __getOwnPropNames(from2))
      if (!__hasOwnProp.call(to2, key) && key !== except)
        __defProp(to2, key, { get: () => from2[key], enumerable: !(desc = __getOwnPropDesc(from2, key)) || desc.enumerable });
  }
  return to2;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// ../simple-mind-map/node_modules/eventemitter3/index.js
var require_eventemitter3 = __commonJS({
  "../simple-mind-map/node_modules/eventemitter3/index.js"(exports, module) {
    "use strict";
    var has = Object.prototype.hasOwnProperty;
    var prefix = "~";
    function Events() {
    }
    if (Object.create) {
      Events.prototype = /* @__PURE__ */ Object.create(null);
      if (!new Events().__proto__)
        prefix = false;
    }
    function EE(fn, context, once) {
      this.fn = fn;
      this.context = context;
      this.once = once || false;
    }
    function addListener(emitter, event, fn, context, once) {
      if (typeof fn !== "function") {
        throw new TypeError("The listener must be a function");
      }
      var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
      if (!emitter._events[evt])
        emitter._events[evt] = listener, emitter._eventsCount++;
      else if (!emitter._events[evt].fn)
        emitter._events[evt].push(listener);
      else
        emitter._events[evt] = [emitter._events[evt], listener];
      return emitter;
    }
    function clearEvent(emitter, evt) {
      if (--emitter._eventsCount === 0)
        emitter._events = new Events();
      else
        delete emitter._events[evt];
    }
    function EventEmitter2() {
      this._events = new Events();
      this._eventsCount = 0;
    }
    EventEmitter2.prototype.eventNames = function eventNames() {
      var names2 = [], events, name;
      if (this._eventsCount === 0)
        return names2;
      for (name in events = this._events) {
        if (has.call(events, name))
          names2.push(prefix ? name.slice(1) : name);
      }
      if (Object.getOwnPropertySymbols) {
        return names2.concat(Object.getOwnPropertySymbols(events));
      }
      return names2;
    };
    EventEmitter2.prototype.listeners = function listeners(event) {
      var evt = prefix ? prefix + event : event, handlers = this._events[evt];
      if (!handlers)
        return [];
      if (handlers.fn)
        return [handlers.fn];
      for (var i2 = 0, l2 = handlers.length, ee = new Array(l2); i2 < l2; i2++) {
        ee[i2] = handlers[i2].fn;
      }
      return ee;
    };
    EventEmitter2.prototype.listenerCount = function listenerCount(event) {
      var evt = prefix ? prefix + event : event, listeners = this._events[evt];
      if (!listeners)
        return 0;
      if (listeners.fn)
        return 1;
      return listeners.length;
    };
    EventEmitter2.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt])
        return false;
      var listeners = this._events[evt], len = arguments.length, args, i2;
      if (listeners.fn) {
        if (listeners.once)
          this.removeListener(event, listeners.fn, void 0, true);
        switch (len) {
          case 1:
            return listeners.fn.call(listeners.context), true;
          case 2:
            return listeners.fn.call(listeners.context, a1), true;
          case 3:
            return listeners.fn.call(listeners.context, a1, a2), true;
          case 4:
            return listeners.fn.call(listeners.context, a1, a2, a3), true;
          case 5:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
          case 6:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
        }
        for (i2 = 1, args = new Array(len - 1); i2 < len; i2++) {
          args[i2 - 1] = arguments[i2];
        }
        listeners.fn.apply(listeners.context, args);
      } else {
        var length2 = listeners.length, j;
        for (i2 = 0; i2 < length2; i2++) {
          if (listeners[i2].once)
            this.removeListener(event, listeners[i2].fn, void 0, true);
          switch (len) {
            case 1:
              listeners[i2].fn.call(listeners[i2].context);
              break;
            case 2:
              listeners[i2].fn.call(listeners[i2].context, a1);
              break;
            case 3:
              listeners[i2].fn.call(listeners[i2].context, a1, a2);
              break;
            case 4:
              listeners[i2].fn.call(listeners[i2].context, a1, a2, a3);
              break;
            default:
              if (!args)
                for (j = 1, args = new Array(len - 1); j < len; j++) {
                  args[j - 1] = arguments[j];
                }
              listeners[i2].fn.apply(listeners[i2].context, args);
          }
        }
      }
      return true;
    };
    EventEmitter2.prototype.on = function on2(event, fn, context) {
      return addListener(this, event, fn, context, false);
    };
    EventEmitter2.prototype.once = function once(event, fn, context) {
      return addListener(this, event, fn, context, true);
    };
    EventEmitter2.prototype.removeListener = function removeListener(event, fn, context, once) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt])
        return this;
      if (!fn) {
        clearEvent(this, evt);
        return this;
      }
      var listeners = this._events[evt];
      if (listeners.fn) {
        if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
          clearEvent(this, evt);
        }
      } else {
        for (var i2 = 0, events = [], length2 = listeners.length; i2 < length2; i2++) {
          if (listeners[i2].fn !== fn || once && !listeners[i2].once || context && listeners[i2].context !== context) {
            events.push(listeners[i2]);
          }
        }
        if (events.length)
          this._events[evt] = events.length === 1 ? events[0] : events;
        else
          clearEvent(this, evt);
      }
      return this;
    };
    EventEmitter2.prototype.removeAllListeners = function removeAllListeners(event) {
      var evt;
      if (event) {
        evt = prefix ? prefix + event : event;
        if (this._events[evt])
          clearEvent(this, evt);
      } else {
        this._events = new Events();
        this._eventsCount = 0;
      }
      return this;
    };
    EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
    EventEmitter2.prototype.addListener = EventEmitter2.prototype.on;
    EventEmitter2.prefixed = prefix;
    EventEmitter2.EventEmitter = EventEmitter2;
    if ("undefined" !== typeof module) {
      module.exports = EventEmitter2;
    }
  }
});

// ../simple-mind-map/node_modules/deepmerge/dist/cjs.js
var require_cjs = __commonJS({
  "../simple-mind-map/node_modules/deepmerge/dist/cjs.js"(exports, module) {
    "use strict";
    var isMergeableObject = function isMergeableObject2(value) {
      return isNonNullObject(value) && !isSpecial(value);
    };
    function isNonNullObject(value) {
      return !!value && typeof value === "object";
    }
    function isSpecial(value) {
      var stringValue = Object.prototype.toString.call(value);
      return stringValue === "[object RegExp]" || stringValue === "[object Date]" || isReactElement(value);
    }
    var canUseSymbol = typeof Symbol === "function" && Symbol.for;
    var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for("react.element") : 60103;
    function isReactElement(value) {
      return value.$$typeof === REACT_ELEMENT_TYPE;
    }
    function emptyTarget(val) {
      return Array.isArray(val) ? [] : {};
    }
    function cloneIfNecessary(value, optionsArgument) {
      var clone = optionsArgument && optionsArgument.clone === true;
      return clone && isMergeableObject(value) ? deepmerge(emptyTarget(value), value, optionsArgument) : value;
    }
    function defaultArrayMerge(target, source, optionsArgument) {
      var destination = target.slice();
      source.forEach(function(e2, i2) {
        if (typeof destination[i2] === "undefined") {
          destination[i2] = cloneIfNecessary(e2, optionsArgument);
        } else if (isMergeableObject(e2)) {
          destination[i2] = deepmerge(target[i2], e2, optionsArgument);
        } else if (target.indexOf(e2) === -1) {
          destination.push(cloneIfNecessary(e2, optionsArgument));
        }
      });
      return destination;
    }
    function mergeObject(target, source, optionsArgument) {
      var destination = {};
      if (isMergeableObject(target)) {
        Object.keys(target).forEach(function(key) {
          destination[key] = cloneIfNecessary(target[key], optionsArgument);
        });
      }
      Object.keys(source).forEach(function(key) {
        if (!isMergeableObject(source[key]) || !target[key]) {
          destination[key] = cloneIfNecessary(source[key], optionsArgument);
        } else {
          destination[key] = deepmerge(target[key], source[key], optionsArgument);
        }
      });
      return destination;
    }
    function deepmerge(target, source, optionsArgument) {
      var sourceIsArray = Array.isArray(source);
      var targetIsArray = Array.isArray(target);
      var options = optionsArgument || { arrayMerge: defaultArrayMerge };
      var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;
      if (!sourceAndTargetTypesMatch) {
        return cloneIfNecessary(source, optionsArgument);
      } else if (sourceIsArray) {
        var arrayMerge = options.arrayMerge || defaultArrayMerge;
        return arrayMerge(target, source, optionsArgument);
      } else {
        return mergeObject(target, source, optionsArgument);
      }
    }
    deepmerge.all = function deepmergeAll(array2, optionsArgument) {
      if (!Array.isArray(array2) || array2.length < 2) {
        throw new Error("first argument should be an array with at least two elements");
      }
      return array2.reduce(function(prev2, next2) {
        return deepmerge(prev2, next2, optionsArgument);
      });
    };
    var deepmerge_1 = deepmerge;
    module.exports = deepmerge_1;
  }
});

// ../simple-mind-map/node_modules/jszip/dist/jszip.min.js
var require_jszip_min = __commonJS({
  "../simple-mind-map/node_modules/jszip/dist/jszip.min.js"(exports, module) {
    !function(e2) {
      if ("object" == typeof exports && "undefined" != typeof module)
        module.exports = e2();
      else if ("function" == typeof define && define.amd)
        define([], e2);
      else {
        ("undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : this).JSZip = e2();
      }
    }(function() {
      return function s2(a2, o2, h2) {
        function u2(r2, e3) {
          if (!o2[r2]) {
            if (!a2[r2]) {
              var t2 = "function" == typeof __require && __require;
              if (!e3 && t2)
                return t2(r2, true);
              if (l2)
                return l2(r2, true);
              var n2 = new Error("Cannot find module '" + r2 + "'");
              throw n2.code = "MODULE_NOT_FOUND", n2;
            }
            var i2 = o2[r2] = { exports: {} };
            a2[r2][0].call(i2.exports, function(e4) {
              var t3 = a2[r2][1][e4];
              return u2(t3 || e4);
            }, i2, i2.exports, s2, a2, o2, h2);
          }
          return o2[r2].exports;
        }
        for (var l2 = "function" == typeof __require && __require, e2 = 0; e2 < h2.length; e2++)
          u2(h2[e2]);
        return u2;
      }({ 1: [function(e2, t2, r2) {
        "use strict";
        var d = e2("./utils"), c3 = e2("./support"), p2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
        r2.encode = function(e3) {
          for (var t3, r3, n2, i2, s2, a2, o2, h2 = [], u2 = 0, l2 = e3.length, f3 = l2, c4 = "string" !== d.getTypeOf(e3); u2 < e3.length; )
            f3 = l2 - u2, n2 = c4 ? (t3 = e3[u2++], r3 = u2 < l2 ? e3[u2++] : 0, u2 < l2 ? e3[u2++] : 0) : (t3 = e3.charCodeAt(u2++), r3 = u2 < l2 ? e3.charCodeAt(u2++) : 0, u2 < l2 ? e3.charCodeAt(u2++) : 0), i2 = t3 >> 2, s2 = (3 & t3) << 4 | r3 >> 4, a2 = 1 < f3 ? (15 & r3) << 2 | n2 >> 6 : 64, o2 = 2 < f3 ? 63 & n2 : 64, h2.push(p2.charAt(i2) + p2.charAt(s2) + p2.charAt(a2) + p2.charAt(o2));
          return h2.join("");
        }, r2.decode = function(e3) {
          var t3, r3, n2, i2, s2, a2, o2 = 0, h2 = 0, u2 = "data:";
          if (e3.substr(0, u2.length) === u2)
            throw new Error("Invalid base64 input, it looks like a data url.");
          var l2, f3 = 3 * (e3 = e3.replace(/[^A-Za-z0-9+/=]/g, "")).length / 4;
          if (e3.charAt(e3.length - 1) === p2.charAt(64) && f3--, e3.charAt(e3.length - 2) === p2.charAt(64) && f3--, f3 % 1 != 0)
            throw new Error("Invalid base64 input, bad content length.");
          for (l2 = c3.uint8array ? new Uint8Array(0 | f3) : new Array(0 | f3); o2 < e3.length; )
            t3 = p2.indexOf(e3.charAt(o2++)) << 2 | (i2 = p2.indexOf(e3.charAt(o2++))) >> 4, r3 = (15 & i2) << 4 | (s2 = p2.indexOf(e3.charAt(o2++))) >> 2, n2 = (3 & s2) << 6 | (a2 = p2.indexOf(e3.charAt(o2++))), l2[h2++] = t3, 64 !== s2 && (l2[h2++] = r3), 64 !== a2 && (l2[h2++] = n2);
          return l2;
        };
      }, { "./support": 30, "./utils": 32 }], 2: [function(e2, t2, r2) {
        "use strict";
        var n2 = e2("./external"), i2 = e2("./stream/DataWorker"), s2 = e2("./stream/Crc32Probe"), a2 = e2("./stream/DataLengthProbe");
        function o2(e3, t3, r3, n3, i3) {
          this.compressedSize = e3, this.uncompressedSize = t3, this.crc32 = r3, this.compression = n3, this.compressedContent = i3;
        }
        o2.prototype = { getContentWorker: function() {
          var e3 = new i2(n2.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new a2("data_length")), t3 = this;
          return e3.on("end", function() {
            if (this.streamInfo.data_length !== t3.uncompressedSize)
              throw new Error("Bug : uncompressed data size mismatch");
          }), e3;
        }, getCompressedWorker: function() {
          return new i2(n2.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize", this.compressedSize).withStreamInfo("uncompressedSize", this.uncompressedSize).withStreamInfo("crc32", this.crc32).withStreamInfo("compression", this.compression);
        } }, o2.createWorkerFrom = function(e3, t3, r3) {
          return e3.pipe(new s2()).pipe(new a2("uncompressedSize")).pipe(t3.compressWorker(r3)).pipe(new a2("compressedSize")).withStreamInfo("compression", t3);
        }, t2.exports = o2;
      }, { "./external": 6, "./stream/Crc32Probe": 25, "./stream/DataLengthProbe": 26, "./stream/DataWorker": 27 }], 3: [function(e2, t2, r2) {
        "use strict";
        var n2 = e2("./stream/GenericWorker");
        r2.STORE = { magic: "\0\0", compressWorker: function() {
          return new n2("STORE compression");
        }, uncompressWorker: function() {
          return new n2("STORE decompression");
        } }, r2.DEFLATE = e2("./flate");
      }, { "./flate": 7, "./stream/GenericWorker": 28 }], 4: [function(e2, t2, r2) {
        "use strict";
        var n2 = e2("./utils");
        var o2 = function() {
          for (var e3, t3 = [], r3 = 0; r3 < 256; r3++) {
            e3 = r3;
            for (var n3 = 0; n3 < 8; n3++)
              e3 = 1 & e3 ? 3988292384 ^ e3 >>> 1 : e3 >>> 1;
            t3[r3] = e3;
          }
          return t3;
        }();
        t2.exports = function(e3, t3) {
          return void 0 !== e3 && e3.length ? "string" !== n2.getTypeOf(e3) ? function(e4, t4, r3, n3) {
            var i2 = o2, s2 = n3 + r3;
            e4 ^= -1;
            for (var a2 = n3; a2 < s2; a2++)
              e4 = e4 >>> 8 ^ i2[255 & (e4 ^ t4[a2])];
            return -1 ^ e4;
          }(0 | t3, e3, e3.length, 0) : function(e4, t4, r3, n3) {
            var i2 = o2, s2 = n3 + r3;
            e4 ^= -1;
            for (var a2 = n3; a2 < s2; a2++)
              e4 = e4 >>> 8 ^ i2[255 & (e4 ^ t4.charCodeAt(a2))];
            return -1 ^ e4;
          }(0 | t3, e3, e3.length, 0) : 0;
        };
      }, { "./utils": 32 }], 5: [function(e2, t2, r2) {
        "use strict";
        r2.base64 = false, r2.binary = false, r2.dir = false, r2.createFolders = true, r2.date = null, r2.compression = null, r2.compressionOptions = null, r2.comment = null, r2.unixPermissions = null, r2.dosPermissions = null;
      }, {}], 6: [function(e2, t2, r2) {
        "use strict";
        var n2 = null;
        n2 = "undefined" != typeof Promise ? Promise : e2("lie"), t2.exports = { Promise: n2 };
      }, { lie: 37 }], 7: [function(e2, t2, r2) {
        "use strict";
        var n2 = "undefined" != typeof Uint8Array && "undefined" != typeof Uint16Array && "undefined" != typeof Uint32Array, i2 = e2("pako"), s2 = e2("./utils"), a2 = e2("./stream/GenericWorker"), o2 = n2 ? "uint8array" : "array";
        function h2(e3, t3) {
          a2.call(this, "FlateWorker/" + e3), this._pako = null, this._pakoAction = e3, this._pakoOptions = t3, this.meta = {};
        }
        r2.magic = "\b\0", s2.inherits(h2, a2), h2.prototype.processChunk = function(e3) {
          this.meta = e3.meta, null === this._pako && this._createPako(), this._pako.push(s2.transformTo(o2, e3.data), false);
        }, h2.prototype.flush = function() {
          a2.prototype.flush.call(this), null === this._pako && this._createPako(), this._pako.push([], true);
        }, h2.prototype.cleanUp = function() {
          a2.prototype.cleanUp.call(this), this._pako = null;
        }, h2.prototype._createPako = function() {
          this._pako = new i2[this._pakoAction]({ raw: true, level: this._pakoOptions.level || -1 });
          var t3 = this;
          this._pako.onData = function(e3) {
            t3.push({ data: e3, meta: t3.meta });
          };
        }, r2.compressWorker = function(e3) {
          return new h2("Deflate", e3);
        }, r2.uncompressWorker = function() {
          return new h2("Inflate", {});
        };
      }, { "./stream/GenericWorker": 28, "./utils": 32, pako: 38 }], 8: [function(e2, t2, r2) {
        "use strict";
        function A2(e3, t3) {
          var r3, n3 = "";
          for (r3 = 0; r3 < t3; r3++)
            n3 += String.fromCharCode(255 & e3), e3 >>>= 8;
          return n3;
        }
        function n2(e3, t3, r3, n3, i3, s3) {
          var a2, o2, h2 = e3.file, u2 = e3.compression, l2 = s3 !== O2.utf8encode, f3 = I.transformTo("string", s3(h2.name)), c3 = I.transformTo("string", O2.utf8encode(h2.name)), d = h2.comment, p2 = I.transformTo("string", s3(d)), m3 = I.transformTo("string", O2.utf8encode(d)), _2 = c3.length !== h2.name.length, g = m3.length !== d.length, b = "", v2 = "", y3 = "", w = h2.dir, k = h2.date, x2 = { crc32: 0, compressedSize: 0, uncompressedSize: 0 };
          t3 && !r3 || (x2.crc32 = e3.crc32, x2.compressedSize = e3.compressedSize, x2.uncompressedSize = e3.uncompressedSize);
          var S2 = 0;
          t3 && (S2 |= 8), l2 || !_2 && !g || (S2 |= 2048);
          var z = 0, C = 0;
          w && (z |= 16), "UNIX" === i3 ? (C = 798, z |= function(e4, t4) {
            var r4 = e4;
            return e4 || (r4 = t4 ? 16893 : 33204), (65535 & r4) << 16;
          }(h2.unixPermissions, w)) : (C = 20, z |= function(e4) {
            return 63 & (e4 || 0);
          }(h2.dosPermissions)), a2 = k.getUTCHours(), a2 <<= 6, a2 |= k.getUTCMinutes(), a2 <<= 5, a2 |= k.getUTCSeconds() / 2, o2 = k.getUTCFullYear() - 1980, o2 <<= 4, o2 |= k.getUTCMonth() + 1, o2 <<= 5, o2 |= k.getUTCDate(), _2 && (v2 = A2(1, 1) + A2(B(f3), 4) + c3, b += "up" + A2(v2.length, 2) + v2), g && (y3 = A2(1, 1) + A2(B(p2), 4) + m3, b += "uc" + A2(y3.length, 2) + y3);
          var E = "";
          return E += "\n\0", E += A2(S2, 2), E += u2.magic, E += A2(a2, 2), E += A2(o2, 2), E += A2(x2.crc32, 4), E += A2(x2.compressedSize, 4), E += A2(x2.uncompressedSize, 4), E += A2(f3.length, 2), E += A2(b.length, 2), { fileRecord: R.LOCAL_FILE_HEADER + E + f3 + b, dirRecord: R.CENTRAL_FILE_HEADER + A2(C, 2) + E + A2(p2.length, 2) + "\0\0\0\0" + A2(z, 4) + A2(n3, 4) + f3 + b + p2 };
        }
        var I = e2("../utils"), i2 = e2("../stream/GenericWorker"), O2 = e2("../utf8"), B = e2("../crc32"), R = e2("../signature");
        function s2(e3, t3, r3, n3) {
          i2.call(this, "ZipFileWorker"), this.bytesWritten = 0, this.zipComment = t3, this.zipPlatform = r3, this.encodeFileName = n3, this.streamFiles = e3, this.accumulate = false, this.contentBuffer = [], this.dirRecords = [], this.currentSourceOffset = 0, this.entriesCount = 0, this.currentFile = null, this._sources = [];
        }
        I.inherits(s2, i2), s2.prototype.push = function(e3) {
          var t3 = e3.meta.percent || 0, r3 = this.entriesCount, n3 = this._sources.length;
          this.accumulate ? this.contentBuffer.push(e3) : (this.bytesWritten += e3.data.length, i2.prototype.push.call(this, { data: e3.data, meta: { currentFile: this.currentFile, percent: r3 ? (t3 + 100 * (r3 - n3 - 1)) / r3 : 100 } }));
        }, s2.prototype.openedSource = function(e3) {
          this.currentSourceOffset = this.bytesWritten, this.currentFile = e3.file.name;
          var t3 = this.streamFiles && !e3.file.dir;
          if (t3) {
            var r3 = n2(e3, t3, false, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
            this.push({ data: r3.fileRecord, meta: { percent: 0 } });
          } else
            this.accumulate = true;
        }, s2.prototype.closedSource = function(e3) {
          this.accumulate = false;
          var t3 = this.streamFiles && !e3.file.dir, r3 = n2(e3, t3, true, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
          if (this.dirRecords.push(r3.dirRecord), t3)
            this.push({ data: function(e4) {
              return R.DATA_DESCRIPTOR + A2(e4.crc32, 4) + A2(e4.compressedSize, 4) + A2(e4.uncompressedSize, 4);
            }(e3), meta: { percent: 100 } });
          else
            for (this.push({ data: r3.fileRecord, meta: { percent: 0 } }); this.contentBuffer.length; )
              this.push(this.contentBuffer.shift());
          this.currentFile = null;
        }, s2.prototype.flush = function() {
          for (var e3 = this.bytesWritten, t3 = 0; t3 < this.dirRecords.length; t3++)
            this.push({ data: this.dirRecords[t3], meta: { percent: 100 } });
          var r3 = this.bytesWritten - e3, n3 = function(e4, t4, r4, n4, i3) {
            var s3 = I.transformTo("string", i3(n4));
            return R.CENTRAL_DIRECTORY_END + "\0\0\0\0" + A2(e4, 2) + A2(e4, 2) + A2(t4, 4) + A2(r4, 4) + A2(s3.length, 2) + s3;
          }(this.dirRecords.length, r3, e3, this.zipComment, this.encodeFileName);
          this.push({ data: n3, meta: { percent: 100 } });
        }, s2.prototype.prepareNextSource = function() {
          this.previous = this._sources.shift(), this.openedSource(this.previous.streamInfo), this.isPaused ? this.previous.pause() : this.previous.resume();
        }, s2.prototype.registerPrevious = function(e3) {
          this._sources.push(e3);
          var t3 = this;
          return e3.on("data", function(e4) {
            t3.processChunk(e4);
          }), e3.on("end", function() {
            t3.closedSource(t3.previous.streamInfo), t3._sources.length ? t3.prepareNextSource() : t3.end();
          }), e3.on("error", function(e4) {
            t3.error(e4);
          }), this;
        }, s2.prototype.resume = function() {
          return !!i2.prototype.resume.call(this) && (!this.previous && this._sources.length ? (this.prepareNextSource(), true) : this.previous || this._sources.length || this.generatedError ? void 0 : (this.end(), true));
        }, s2.prototype.error = function(e3) {
          var t3 = this._sources;
          if (!i2.prototype.error.call(this, e3))
            return false;
          for (var r3 = 0; r3 < t3.length; r3++)
            try {
              t3[r3].error(e3);
            } catch (e4) {
            }
          return true;
        }, s2.prototype.lock = function() {
          i2.prototype.lock.call(this);
          for (var e3 = this._sources, t3 = 0; t3 < e3.length; t3++)
            e3[t3].lock();
        }, t2.exports = s2;
      }, { "../crc32": 4, "../signature": 23, "../stream/GenericWorker": 28, "../utf8": 31, "../utils": 32 }], 9: [function(e2, t2, r2) {
        "use strict";
        var u2 = e2("../compressions"), n2 = e2("./ZipFileWorker");
        r2.generateWorker = function(e3, a2, t3) {
          var o2 = new n2(a2.streamFiles, t3, a2.platform, a2.encodeFileName), h2 = 0;
          try {
            e3.forEach(function(e4, t4) {
              h2++;
              var r3 = function(e5, t5) {
                var r4 = e5 || t5, n4 = u2[r4];
                if (!n4)
                  throw new Error(r4 + " is not a valid compression method !");
                return n4;
              }(t4.options.compression, a2.compression), n3 = t4.options.compressionOptions || a2.compressionOptions || {}, i2 = t4.dir, s2 = t4.date;
              t4._compressWorker(r3, n3).withStreamInfo("file", { name: e4, dir: i2, date: s2, comment: t4.comment || "", unixPermissions: t4.unixPermissions, dosPermissions: t4.dosPermissions }).pipe(o2);
            }), o2.entriesCount = h2;
          } catch (e4) {
            o2.error(e4);
          }
          return o2;
        };
      }, { "../compressions": 3, "./ZipFileWorker": 8 }], 10: [function(e2, t2, r2) {
        "use strict";
        function n2() {
          if (!(this instanceof n2))
            return new n2();
          if (arguments.length)
            throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");
          this.files = /* @__PURE__ */ Object.create(null), this.comment = null, this.root = "", this.clone = function() {
            var e3 = new n2();
            for (var t3 in this)
              "function" != typeof this[t3] && (e3[t3] = this[t3]);
            return e3;
          };
        }
        (n2.prototype = e2("./object")).loadAsync = e2("./load"), n2.support = e2("./support"), n2.defaults = e2("./defaults"), n2.version = "3.10.1", n2.loadAsync = function(e3, t3) {
          return new n2().loadAsync(e3, t3);
        }, n2.external = e2("./external"), t2.exports = n2;
      }, { "./defaults": 5, "./external": 6, "./load": 11, "./object": 15, "./support": 30 }], 11: [function(e2, t2, r2) {
        "use strict";
        var u2 = e2("./utils"), i2 = e2("./external"), n2 = e2("./utf8"), s2 = e2("./zipEntries"), a2 = e2("./stream/Crc32Probe"), l2 = e2("./nodejsUtils");
        function f3(n3) {
          return new i2.Promise(function(e3, t3) {
            var r3 = n3.decompressed.getContentWorker().pipe(new a2());
            r3.on("error", function(e4) {
              t3(e4);
            }).on("end", function() {
              r3.streamInfo.crc32 !== n3.decompressed.crc32 ? t3(new Error("Corrupted zip : CRC32 mismatch")) : e3();
            }).resume();
          });
        }
        t2.exports = function(e3, o2) {
          var h2 = this;
          return o2 = u2.extend(o2 || {}, { base64: false, checkCRC32: false, optimizedBinaryString: false, createFolders: false, decodeFileName: n2.utf8decode }), l2.isNode && l2.isStream(e3) ? i2.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file.")) : u2.prepareContent("the loaded zip file", e3, true, o2.optimizedBinaryString, o2.base64).then(function(e4) {
            var t3 = new s2(o2);
            return t3.load(e4), t3;
          }).then(function(e4) {
            var t3 = [i2.Promise.resolve(e4)], r3 = e4.files;
            if (o2.checkCRC32)
              for (var n3 = 0; n3 < r3.length; n3++)
                t3.push(f3(r3[n3]));
            return i2.Promise.all(t3);
          }).then(function(e4) {
            for (var t3 = e4.shift(), r3 = t3.files, n3 = 0; n3 < r3.length; n3++) {
              var i3 = r3[n3], s3 = i3.fileNameStr, a3 = u2.resolve(i3.fileNameStr);
              h2.file(a3, i3.decompressed, { binary: true, optimizedBinaryString: true, date: i3.date, dir: i3.dir, comment: i3.fileCommentStr.length ? i3.fileCommentStr : null, unixPermissions: i3.unixPermissions, dosPermissions: i3.dosPermissions, createFolders: o2.createFolders }), i3.dir || (h2.file(a3).unsafeOriginalName = s3);
            }
            return t3.zipComment.length && (h2.comment = t3.zipComment), h2;
          });
        };
      }, { "./external": 6, "./nodejsUtils": 14, "./stream/Crc32Probe": 25, "./utf8": 31, "./utils": 32, "./zipEntries": 33 }], 12: [function(e2, t2, r2) {
        "use strict";
        var n2 = e2("../utils"), i2 = e2("../stream/GenericWorker");
        function s2(e3, t3) {
          i2.call(this, "Nodejs stream input adapter for " + e3), this._upstreamEnded = false, this._bindStream(t3);
        }
        n2.inherits(s2, i2), s2.prototype._bindStream = function(e3) {
          var t3 = this;
          (this._stream = e3).pause(), e3.on("data", function(e4) {
            t3.push({ data: e4, meta: { percent: 0 } });
          }).on("error", function(e4) {
            t3.isPaused ? this.generatedError = e4 : t3.error(e4);
          }).on("end", function() {
            t3.isPaused ? t3._upstreamEnded = true : t3.end();
          });
        }, s2.prototype.pause = function() {
          return !!i2.prototype.pause.call(this) && (this._stream.pause(), true);
        }, s2.prototype.resume = function() {
          return !!i2.prototype.resume.call(this) && (this._upstreamEnded ? this.end() : this._stream.resume(), true);
        }, t2.exports = s2;
      }, { "../stream/GenericWorker": 28, "../utils": 32 }], 13: [function(e2, t2, r2) {
        "use strict";
        var i2 = e2("readable-stream").Readable;
        function n2(e3, t3, r3) {
          i2.call(this, t3), this._helper = e3;
          var n3 = this;
          e3.on("data", function(e4, t4) {
            n3.push(e4) || n3._helper.pause(), r3 && r3(t4);
          }).on("error", function(e4) {
            n3.emit("error", e4);
          }).on("end", function() {
            n3.push(null);
          });
        }
        e2("../utils").inherits(n2, i2), n2.prototype._read = function() {
          this._helper.resume();
        }, t2.exports = n2;
      }, { "../utils": 32, "readable-stream": 16 }], 14: [function(e2, t2, r2) {
        "use strict";
        t2.exports = { isNode: "undefined" != typeof Buffer, newBufferFrom: function(e3, t3) {
          if (Buffer.from && Buffer.from !== Uint8Array.from)
            return Buffer.from(e3, t3);
          if ("number" == typeof e3)
            throw new Error('The "data" argument must not be a number');
          return new Buffer(e3, t3);
        }, allocBuffer: function(e3) {
          if (Buffer.alloc)
            return Buffer.alloc(e3);
          var t3 = new Buffer(e3);
          return t3.fill(0), t3;
        }, isBuffer: function(e3) {
          return Buffer.isBuffer(e3);
        }, isStream: function(e3) {
          return e3 && "function" == typeof e3.on && "function" == typeof e3.pause && "function" == typeof e3.resume;
        } };
      }, {}], 15: [function(e2, t2, r2) {
        "use strict";
        function s2(e3, t3, r3) {
          var n3, i3 = u2.getTypeOf(t3), s3 = u2.extend(r3 || {}, f3);
          s3.date = s3.date || /* @__PURE__ */ new Date(), null !== s3.compression && (s3.compression = s3.compression.toUpperCase()), "string" == typeof s3.unixPermissions && (s3.unixPermissions = parseInt(s3.unixPermissions, 8)), s3.unixPermissions && 16384 & s3.unixPermissions && (s3.dir = true), s3.dosPermissions && 16 & s3.dosPermissions && (s3.dir = true), s3.dir && (e3 = g(e3)), s3.createFolders && (n3 = _2(e3)) && b.call(this, n3, true);
          var a3 = "string" === i3 && false === s3.binary && false === s3.base64;
          r3 && void 0 !== r3.binary || (s3.binary = !a3), (t3 instanceof c3 && 0 === t3.uncompressedSize || s3.dir || !t3 || 0 === t3.length) && (s3.base64 = false, s3.binary = true, t3 = "", s3.compression = "STORE", i3 = "string");
          var o3 = null;
          o3 = t3 instanceof c3 || t3 instanceof l2 ? t3 : p2.isNode && p2.isStream(t3) ? new m3(e3, t3) : u2.prepareContent(e3, t3, s3.binary, s3.optimizedBinaryString, s3.base64);
          var h3 = new d(e3, o3, s3);
          this.files[e3] = h3;
        }
        var i2 = e2("./utf8"), u2 = e2("./utils"), l2 = e2("./stream/GenericWorker"), a2 = e2("./stream/StreamHelper"), f3 = e2("./defaults"), c3 = e2("./compressedObject"), d = e2("./zipObject"), o2 = e2("./generate"), p2 = e2("./nodejsUtils"), m3 = e2("./nodejs/NodejsStreamInputAdapter"), _2 = function(e3) {
          "/" === e3.slice(-1) && (e3 = e3.substring(0, e3.length - 1));
          var t3 = e3.lastIndexOf("/");
          return 0 < t3 ? e3.substring(0, t3) : "";
        }, g = function(e3) {
          return "/" !== e3.slice(-1) && (e3 += "/"), e3;
        }, b = function(e3, t3) {
          return t3 = void 0 !== t3 ? t3 : f3.createFolders, e3 = g(e3), this.files[e3] || s2.call(this, e3, null, { dir: true, createFolders: t3 }), this.files[e3];
        };
        function h2(e3) {
          return "[object RegExp]" === Object.prototype.toString.call(e3);
        }
        var n2 = { load: function() {
          throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
        }, forEach: function(e3) {
          var t3, r3, n3;
          for (t3 in this.files)
            n3 = this.files[t3], (r3 = t3.slice(this.root.length, t3.length)) && t3.slice(0, this.root.length) === this.root && e3(r3, n3);
        }, filter: function(r3) {
          var n3 = [];
          return this.forEach(function(e3, t3) {
            r3(e3, t3) && n3.push(t3);
          }), n3;
        }, file: function(e3, t3, r3) {
          if (1 !== arguments.length)
            return e3 = this.root + e3, s2.call(this, e3, t3, r3), this;
          if (h2(e3)) {
            var n3 = e3;
            return this.filter(function(e4, t4) {
              return !t4.dir && n3.test(e4);
            });
          }
          var i3 = this.files[this.root + e3];
          return i3 && !i3.dir ? i3 : null;
        }, folder: function(r3) {
          if (!r3)
            return this;
          if (h2(r3))
            return this.filter(function(e4, t4) {
              return t4.dir && r3.test(e4);
            });
          var e3 = this.root + r3, t3 = b.call(this, e3), n3 = this.clone();
          return n3.root = t3.name, n3;
        }, remove: function(r3) {
          r3 = this.root + r3;
          var e3 = this.files[r3];
          if (e3 || ("/" !== r3.slice(-1) && (r3 += "/"), e3 = this.files[r3]), e3 && !e3.dir)
            delete this.files[r3];
          else
            for (var t3 = this.filter(function(e4, t4) {
              return t4.name.slice(0, r3.length) === r3;
            }), n3 = 0; n3 < t3.length; n3++)
              delete this.files[t3[n3].name];
          return this;
        }, generate: function() {
          throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
        }, generateInternalStream: function(e3) {
          var t3, r3 = {};
          try {
            if ((r3 = u2.extend(e3 || {}, { streamFiles: false, compression: "STORE", compressionOptions: null, type: "", platform: "DOS", comment: null, mimeType: "application/zip", encodeFileName: i2.utf8encode })).type = r3.type.toLowerCase(), r3.compression = r3.compression.toUpperCase(), "binarystring" === r3.type && (r3.type = "string"), !r3.type)
              throw new Error("No output type specified.");
            u2.checkSupport(r3.type), "darwin" !== r3.platform && "freebsd" !== r3.platform && "linux" !== r3.platform && "sunos" !== r3.platform || (r3.platform = "UNIX"), "win32" === r3.platform && (r3.platform = "DOS");
            var n3 = r3.comment || this.comment || "";
            t3 = o2.generateWorker(this, r3, n3);
          } catch (e4) {
            (t3 = new l2("error")).error(e4);
          }
          return new a2(t3, r3.type || "string", r3.mimeType);
        }, generateAsync: function(e3, t3) {
          return this.generateInternalStream(e3).accumulate(t3);
        }, generateNodeStream: function(e3, t3) {
          return (e3 = e3 || {}).type || (e3.type = "nodebuffer"), this.generateInternalStream(e3).toNodejsStream(t3);
        } };
        t2.exports = n2;
      }, { "./compressedObject": 2, "./defaults": 5, "./generate": 9, "./nodejs/NodejsStreamInputAdapter": 12, "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31, "./utils": 32, "./zipObject": 35 }], 16: [function(e2, t2, r2) {
        "use strict";
        t2.exports = e2("stream");
      }, { stream: void 0 }], 17: [function(e2, t2, r2) {
        "use strict";
        var n2 = e2("./DataReader");
        function i2(e3) {
          n2.call(this, e3);
          for (var t3 = 0; t3 < this.data.length; t3++)
            e3[t3] = 255 & e3[t3];
        }
        e2("../utils").inherits(i2, n2), i2.prototype.byteAt = function(e3) {
          return this.data[this.zero + e3];
        }, i2.prototype.lastIndexOfSignature = function(e3) {
          for (var t3 = e3.charCodeAt(0), r3 = e3.charCodeAt(1), n3 = e3.charCodeAt(2), i3 = e3.charCodeAt(3), s2 = this.length - 4; 0 <= s2; --s2)
            if (this.data[s2] === t3 && this.data[s2 + 1] === r3 && this.data[s2 + 2] === n3 && this.data[s2 + 3] === i3)
              return s2 - this.zero;
          return -1;
        }, i2.prototype.readAndCheckSignature = function(e3) {
          var t3 = e3.charCodeAt(0), r3 = e3.charCodeAt(1), n3 = e3.charCodeAt(2), i3 = e3.charCodeAt(3), s2 = this.readData(4);
          return t3 === s2[0] && r3 === s2[1] && n3 === s2[2] && i3 === s2[3];
        }, i2.prototype.readData = function(e3) {
          if (this.checkOffset(e3), 0 === e3)
            return [];
          var t3 = this.data.slice(this.zero + this.index, this.zero + this.index + e3);
          return this.index += e3, t3;
        }, t2.exports = i2;
      }, { "../utils": 32, "./DataReader": 18 }], 18: [function(e2, t2, r2) {
        "use strict";
        var n2 = e2("../utils");
        function i2(e3) {
          this.data = e3, this.length = e3.length, this.index = 0, this.zero = 0;
        }
        i2.prototype = { checkOffset: function(e3) {
          this.checkIndex(this.index + e3);
        }, checkIndex: function(e3) {
          if (this.length < this.zero + e3 || e3 < 0)
            throw new Error("End of data reached (data length = " + this.length + ", asked index = " + e3 + "). Corrupted zip ?");
        }, setIndex: function(e3) {
          this.checkIndex(e3), this.index = e3;
        }, skip: function(e3) {
          this.setIndex(this.index + e3);
        }, byteAt: function() {
        }, readInt: function(e3) {
          var t3, r3 = 0;
          for (this.checkOffset(e3), t3 = this.index + e3 - 1; t3 >= this.index; t3--)
            r3 = (r3 << 8) + this.byteAt(t3);
          return this.index += e3, r3;
        }, readString: function(e3) {
          return n2.transformTo("string", this.readData(e3));
        }, readData: function() {
        }, lastIndexOfSignature: function() {
        }, readAndCheckSignature: function() {
        }, readDate: function() {
          var e3 = this.readInt(4);
          return new Date(Date.UTC(1980 + (e3 >> 25 & 127), (e3 >> 21 & 15) - 1, e3 >> 16 & 31, e3 >> 11 & 31, e3 >> 5 & 63, (31 & e3) << 1));
        } }, t2.exports = i2;
      }, { "../utils": 32 }], 19: [function(e2, t2, r2) {
        "use strict";
        var n2 = e2("./Uint8ArrayReader");
        function i2(e3) {
          n2.call(this, e3);
        }
        e2("../utils").inherits(i2, n2), i2.prototype.readData = function(e3) {
          this.checkOffset(e3);
          var t3 = this.data.slice(this.zero + this.index, this.zero + this.index + e3);
          return this.index += e3, t3;
        }, t2.exports = i2;
      }, { "../utils": 32, "./Uint8ArrayReader": 21 }], 20: [function(e2, t2, r2) {
        "use strict";
        var n2 = e2("./DataReader");
        function i2(e3) {
          n2.call(this, e3);
        }
        e2("../utils").inherits(i2, n2), i2.prototype.byteAt = function(e3) {
          return this.data.charCodeAt(this.zero + e3);
        }, i2.prototype.lastIndexOfSignature = function(e3) {
          return this.data.lastIndexOf(e3) - this.zero;
        }, i2.prototype.readAndCheckSignature = function(e3) {
          return e3 === this.readData(4);
        }, i2.prototype.readData = function(e3) {
          this.checkOffset(e3);
          var t3 = this.data.slice(this.zero + this.index, this.zero + this.index + e3);
          return this.index += e3, t3;
        }, t2.exports = i2;
      }, { "../utils": 32, "./DataReader": 18 }], 21: [function(e2, t2, r2) {
        "use strict";
        var n2 = e2("./ArrayReader");
        function i2(e3) {
          n2.call(this, e3);
        }
        e2("../utils").inherits(i2, n2), i2.prototype.readData = function(e3) {
          if (this.checkOffset(e3), 0 === e3)
            return new Uint8Array(0);
          var t3 = this.data.subarray(this.zero + this.index, this.zero + this.index + e3);
          return this.index += e3, t3;
        }, t2.exports = i2;
      }, { "../utils": 32, "./ArrayReader": 17 }], 22: [function(e2, t2, r2) {
        "use strict";
        var n2 = e2("../utils"), i2 = e2("../support"), s2 = e2("./ArrayReader"), a2 = e2("./StringReader"), o2 = e2("./NodeBufferReader"), h2 = e2("./Uint8ArrayReader");
        t2.exports = function(e3) {
          var t3 = n2.getTypeOf(e3);
          return n2.checkSupport(t3), "string" !== t3 || i2.uint8array ? "nodebuffer" === t3 ? new o2(e3) : i2.uint8array ? new h2(n2.transformTo("uint8array", e3)) : new s2(n2.transformTo("array", e3)) : new a2(e3);
        };
      }, { "../support": 30, "../utils": 32, "./ArrayReader": 17, "./NodeBufferReader": 19, "./StringReader": 20, "./Uint8ArrayReader": 21 }], 23: [function(e2, t2, r2) {
        "use strict";
        r2.LOCAL_FILE_HEADER = "PK", r2.CENTRAL_FILE_HEADER = "PK", r2.CENTRAL_DIRECTORY_END = "PK", r2.ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK\x07", r2.ZIP64_CENTRAL_DIRECTORY_END = "PK", r2.DATA_DESCRIPTOR = "PK\x07\b";
      }, {}], 24: [function(e2, t2, r2) {
        "use strict";
        var n2 = e2("./GenericWorker"), i2 = e2("../utils");
        function s2(e3) {
          n2.call(this, "ConvertWorker to " + e3), this.destType = e3;
        }
        i2.inherits(s2, n2), s2.prototype.processChunk = function(e3) {
          this.push({ data: i2.transformTo(this.destType, e3.data), meta: e3.meta });
        }, t2.exports = s2;
      }, { "../utils": 32, "./GenericWorker": 28 }], 25: [function(e2, t2, r2) {
        "use strict";
        var n2 = e2("./GenericWorker"), i2 = e2("../crc32");
        function s2() {
          n2.call(this, "Crc32Probe"), this.withStreamInfo("crc32", 0);
        }
        e2("../utils").inherits(s2, n2), s2.prototype.processChunk = function(e3) {
          this.streamInfo.crc32 = i2(e3.data, this.streamInfo.crc32 || 0), this.push(e3);
        }, t2.exports = s2;
      }, { "../crc32": 4, "../utils": 32, "./GenericWorker": 28 }], 26: [function(e2, t2, r2) {
        "use strict";
        var n2 = e2("../utils"), i2 = e2("./GenericWorker");
        function s2(e3) {
          i2.call(this, "DataLengthProbe for " + e3), this.propName = e3, this.withStreamInfo(e3, 0);
        }
        n2.inherits(s2, i2), s2.prototype.processChunk = function(e3) {
          if (e3) {
            var t3 = this.streamInfo[this.propName] || 0;
            this.streamInfo[this.propName] = t3 + e3.data.length;
          }
          i2.prototype.processChunk.call(this, e3);
        }, t2.exports = s2;
      }, { "../utils": 32, "./GenericWorker": 28 }], 27: [function(e2, t2, r2) {
        "use strict";
        var n2 = e2("../utils"), i2 = e2("./GenericWorker");
        function s2(e3) {
          i2.call(this, "DataWorker");
          var t3 = this;
          this.dataIsReady = false, this.index = 0, this.max = 0, this.data = null, this.type = "", this._tickScheduled = false, e3.then(function(e4) {
            t3.dataIsReady = true, t3.data = e4, t3.max = e4 && e4.length || 0, t3.type = n2.getTypeOf(e4), t3.isPaused || t3._tickAndRepeat();
          }, function(e4) {
            t3.error(e4);
          });
        }
        n2.inherits(s2, i2), s2.prototype.cleanUp = function() {
          i2.prototype.cleanUp.call(this), this.data = null;
        }, s2.prototype.resume = function() {
          return !!i2.prototype.resume.call(this) && (!this._tickScheduled && this.dataIsReady && (this._tickScheduled = true, n2.delay(this._tickAndRepeat, [], this)), true);
        }, s2.prototype._tickAndRepeat = function() {
          this._tickScheduled = false, this.isPaused || this.isFinished || (this._tick(), this.isFinished || (n2.delay(this._tickAndRepeat, [], this), this._tickScheduled = true));
        }, s2.prototype._tick = function() {
          if (this.isPaused || this.isFinished)
            return false;
          var e3 = null, t3 = Math.min(this.max, this.index + 16384);
          if (this.index >= this.max)
            return this.end();
          switch (this.type) {
            case "string":
              e3 = this.data.substring(this.index, t3);
              break;
            case "uint8array":
              e3 = this.data.subarray(this.index, t3);
              break;
            case "array":
            case "nodebuffer":
              e3 = this.data.slice(this.index, t3);
          }
          return this.index = t3, this.push({ data: e3, meta: { percent: this.max ? this.index / this.max * 100 : 0 } });
        }, t2.exports = s2;
      }, { "../utils": 32, "./GenericWorker": 28 }], 28: [function(e2, t2, r2) {
        "use strict";
        function n2(e3) {
          this.name = e3 || "default", this.streamInfo = {}, this.generatedError = null, this.extraStreamInfo = {}, this.isPaused = true, this.isFinished = false, this.isLocked = false, this._listeners = { data: [], end: [], error: [] }, this.previous = null;
        }
        n2.prototype = { push: function(e3) {
          this.emit("data", e3);
        }, end: function() {
          if (this.isFinished)
            return false;
          this.flush();
          try {
            this.emit("end"), this.cleanUp(), this.isFinished = true;
          } catch (e3) {
            this.emit("error", e3);
          }
          return true;
        }, error: function(e3) {
          return !this.isFinished && (this.isPaused ? this.generatedError = e3 : (this.isFinished = true, this.emit("error", e3), this.previous && this.previous.error(e3), this.cleanUp()), true);
        }, on: function(e3, t3) {
          return this._listeners[e3].push(t3), this;
        }, cleanUp: function() {
          this.streamInfo = this.generatedError = this.extraStreamInfo = null, this._listeners = [];
        }, emit: function(e3, t3) {
          if (this._listeners[e3])
            for (var r3 = 0; r3 < this._listeners[e3].length; r3++)
              this._listeners[e3][r3].call(this, t3);
        }, pipe: function(e3) {
          return e3.registerPrevious(this);
        }, registerPrevious: function(e3) {
          if (this.isLocked)
            throw new Error("The stream '" + this + "' has already been used.");
          this.streamInfo = e3.streamInfo, this.mergeStreamInfo(), this.previous = e3;
          var t3 = this;
          return e3.on("data", function(e4) {
            t3.processChunk(e4);
          }), e3.on("end", function() {
            t3.end();
          }), e3.on("error", function(e4) {
            t3.error(e4);
          }), this;
        }, pause: function() {
          return !this.isPaused && !this.isFinished && (this.isPaused = true, this.previous && this.previous.pause(), true);
        }, resume: function() {
          if (!this.isPaused || this.isFinished)
            return false;
          var e3 = this.isPaused = false;
          return this.generatedError && (this.error(this.generatedError), e3 = true), this.previous && this.previous.resume(), !e3;
        }, flush: function() {
        }, processChunk: function(e3) {
          this.push(e3);
        }, withStreamInfo: function(e3, t3) {
          return this.extraStreamInfo[e3] = t3, this.mergeStreamInfo(), this;
        }, mergeStreamInfo: function() {
          for (var e3 in this.extraStreamInfo)
            Object.prototype.hasOwnProperty.call(this.extraStreamInfo, e3) && (this.streamInfo[e3] = this.extraStreamInfo[e3]);
        }, lock: function() {
          if (this.isLocked)
            throw new Error("The stream '" + this + "' has already been used.");
          this.isLocked = true, this.previous && this.previous.lock();
        }, toString: function() {
          var e3 = "Worker " + this.name;
          return this.previous ? this.previous + " -> " + e3 : e3;
        } }, t2.exports = n2;
      }, {}], 29: [function(e2, t2, r2) {
        "use strict";
        var h2 = e2("../utils"), i2 = e2("./ConvertWorker"), s2 = e2("./GenericWorker"), u2 = e2("../base64"), n2 = e2("../support"), a2 = e2("../external"), o2 = null;
        if (n2.nodestream)
          try {
            o2 = e2("../nodejs/NodejsStreamOutputAdapter");
          } catch (e3) {
          }
        function l2(e3, o3) {
          return new a2.Promise(function(t3, r3) {
            var n3 = [], i3 = e3._internalType, s3 = e3._outputType, a3 = e3._mimeType;
            e3.on("data", function(e4, t4) {
              n3.push(e4), o3 && o3(t4);
            }).on("error", function(e4) {
              n3 = [], r3(e4);
            }).on("end", function() {
              try {
                var e4 = function(e5, t4, r4) {
                  switch (e5) {
                    case "blob":
                      return h2.newBlob(h2.transformTo("arraybuffer", t4), r4);
                    case "base64":
                      return u2.encode(t4);
                    default:
                      return h2.transformTo(e5, t4);
                  }
                }(s3, function(e5, t4) {
                  var r4, n4 = 0, i4 = null, s4 = 0;
                  for (r4 = 0; r4 < t4.length; r4++)
                    s4 += t4[r4].length;
                  switch (e5) {
                    case "string":
                      return t4.join("");
                    case "array":
                      return Array.prototype.concat.apply([], t4);
                    case "uint8array":
                      for (i4 = new Uint8Array(s4), r4 = 0; r4 < t4.length; r4++)
                        i4.set(t4[r4], n4), n4 += t4[r4].length;
                      return i4;
                    case "nodebuffer":
                      return Buffer.concat(t4);
                    default:
                      throw new Error("concat : unsupported type '" + e5 + "'");
                  }
                }(i3, n3), a3);
                t3(e4);
              } catch (e5) {
                r3(e5);
              }
              n3 = [];
            }).resume();
          });
        }
        function f3(e3, t3, r3) {
          var n3 = t3;
          switch (t3) {
            case "blob":
            case "arraybuffer":
              n3 = "uint8array";
              break;
            case "base64":
              n3 = "string";
          }
          try {
            this._internalType = n3, this._outputType = t3, this._mimeType = r3, h2.checkSupport(n3), this._worker = e3.pipe(new i2(n3)), e3.lock();
          } catch (e4) {
            this._worker = new s2("error"), this._worker.error(e4);
          }
        }
        f3.prototype = { accumulate: function(e3) {
          return l2(this, e3);
        }, on: function(e3, t3) {
          var r3 = this;
          return "data" === e3 ? this._worker.on(e3, function(e4) {
            t3.call(r3, e4.data, e4.meta);
          }) : this._worker.on(e3, function() {
            h2.delay(t3, arguments, r3);
          }), this;
        }, resume: function() {
          return h2.delay(this._worker.resume, [], this._worker), this;
        }, pause: function() {
          return this._worker.pause(), this;
        }, toNodejsStream: function(e3) {
          if (h2.checkSupport("nodestream"), "nodebuffer" !== this._outputType)
            throw new Error(this._outputType + " is not supported by this method");
          return new o2(this, { objectMode: "nodebuffer" !== this._outputType }, e3);
        } }, t2.exports = f3;
      }, { "../base64": 1, "../external": 6, "../nodejs/NodejsStreamOutputAdapter": 13, "../support": 30, "../utils": 32, "./ConvertWorker": 24, "./GenericWorker": 28 }], 30: [function(e2, t2, r2) {
        "use strict";
        if (r2.base64 = true, r2.array = true, r2.string = true, r2.arraybuffer = "undefined" != typeof ArrayBuffer && "undefined" != typeof Uint8Array, r2.nodebuffer = "undefined" != typeof Buffer, r2.uint8array = "undefined" != typeof Uint8Array, "undefined" == typeof ArrayBuffer)
          r2.blob = false;
        else {
          var n2 = new ArrayBuffer(0);
          try {
            r2.blob = 0 === new Blob([n2], { type: "application/zip" }).size;
          } catch (e3) {
            try {
              var i2 = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
              i2.append(n2), r2.blob = 0 === i2.getBlob("application/zip").size;
            } catch (e4) {
              r2.blob = false;
            }
          }
        }
        try {
          r2.nodestream = !!e2("readable-stream").Readable;
        } catch (e3) {
          r2.nodestream = false;
        }
      }, { "readable-stream": 16 }], 31: [function(e2, t2, s2) {
        "use strict";
        for (var o2 = e2("./utils"), h2 = e2("./support"), r2 = e2("./nodejsUtils"), n2 = e2("./stream/GenericWorker"), u2 = new Array(256), i2 = 0; i2 < 256; i2++)
          u2[i2] = 252 <= i2 ? 6 : 248 <= i2 ? 5 : 240 <= i2 ? 4 : 224 <= i2 ? 3 : 192 <= i2 ? 2 : 1;
        u2[254] = u2[254] = 1;
        function a2() {
          n2.call(this, "utf-8 decode"), this.leftOver = null;
        }
        function l2() {
          n2.call(this, "utf-8 encode");
        }
        s2.utf8encode = function(e3) {
          return h2.nodebuffer ? r2.newBufferFrom(e3, "utf-8") : function(e4) {
            var t3, r3, n3, i3, s3, a3 = e4.length, o3 = 0;
            for (i3 = 0; i3 < a3; i3++)
              55296 == (64512 & (r3 = e4.charCodeAt(i3))) && i3 + 1 < a3 && 56320 == (64512 & (n3 = e4.charCodeAt(i3 + 1))) && (r3 = 65536 + (r3 - 55296 << 10) + (n3 - 56320), i3++), o3 += r3 < 128 ? 1 : r3 < 2048 ? 2 : r3 < 65536 ? 3 : 4;
            for (t3 = h2.uint8array ? new Uint8Array(o3) : new Array(o3), i3 = s3 = 0; s3 < o3; i3++)
              55296 == (64512 & (r3 = e4.charCodeAt(i3))) && i3 + 1 < a3 && 56320 == (64512 & (n3 = e4.charCodeAt(i3 + 1))) && (r3 = 65536 + (r3 - 55296 << 10) + (n3 - 56320), i3++), r3 < 128 ? t3[s3++] = r3 : (r3 < 2048 ? t3[s3++] = 192 | r3 >>> 6 : (r3 < 65536 ? t3[s3++] = 224 | r3 >>> 12 : (t3[s3++] = 240 | r3 >>> 18, t3[s3++] = 128 | r3 >>> 12 & 63), t3[s3++] = 128 | r3 >>> 6 & 63), t3[s3++] = 128 | 63 & r3);
            return t3;
          }(e3);
        }, s2.utf8decode = function(e3) {
          return h2.nodebuffer ? o2.transformTo("nodebuffer", e3).toString("utf-8") : function(e4) {
            var t3, r3, n3, i3, s3 = e4.length, a3 = new Array(2 * s3);
            for (t3 = r3 = 0; t3 < s3; )
              if ((n3 = e4[t3++]) < 128)
                a3[r3++] = n3;
              else if (4 < (i3 = u2[n3]))
                a3[r3++] = 65533, t3 += i3 - 1;
              else {
                for (n3 &= 2 === i3 ? 31 : 3 === i3 ? 15 : 7; 1 < i3 && t3 < s3; )
                  n3 = n3 << 6 | 63 & e4[t3++], i3--;
                1 < i3 ? a3[r3++] = 65533 : n3 < 65536 ? a3[r3++] = n3 : (n3 -= 65536, a3[r3++] = 55296 | n3 >> 10 & 1023, a3[r3++] = 56320 | 1023 & n3);
              }
            return a3.length !== r3 && (a3.subarray ? a3 = a3.subarray(0, r3) : a3.length = r3), o2.applyFromCharCode(a3);
          }(e3 = o2.transformTo(h2.uint8array ? "uint8array" : "array", e3));
        }, o2.inherits(a2, n2), a2.prototype.processChunk = function(e3) {
          var t3 = o2.transformTo(h2.uint8array ? "uint8array" : "array", e3.data);
          if (this.leftOver && this.leftOver.length) {
            if (h2.uint8array) {
              var r3 = t3;
              (t3 = new Uint8Array(r3.length + this.leftOver.length)).set(this.leftOver, 0), t3.set(r3, this.leftOver.length);
            } else
              t3 = this.leftOver.concat(t3);
            this.leftOver = null;
          }
          var n3 = function(e4, t4) {
            var r4;
            for ((t4 = t4 || e4.length) > e4.length && (t4 = e4.length), r4 = t4 - 1; 0 <= r4 && 128 == (192 & e4[r4]); )
              r4--;
            return r4 < 0 ? t4 : 0 === r4 ? t4 : r4 + u2[e4[r4]] > t4 ? r4 : t4;
          }(t3), i3 = t3;
          n3 !== t3.length && (h2.uint8array ? (i3 = t3.subarray(0, n3), this.leftOver = t3.subarray(n3, t3.length)) : (i3 = t3.slice(0, n3), this.leftOver = t3.slice(n3, t3.length))), this.push({ data: s2.utf8decode(i3), meta: e3.meta });
        }, a2.prototype.flush = function() {
          this.leftOver && this.leftOver.length && (this.push({ data: s2.utf8decode(this.leftOver), meta: {} }), this.leftOver = null);
        }, s2.Utf8DecodeWorker = a2, o2.inherits(l2, n2), l2.prototype.processChunk = function(e3) {
          this.push({ data: s2.utf8encode(e3.data), meta: e3.meta });
        }, s2.Utf8EncodeWorker = l2;
      }, { "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./support": 30, "./utils": 32 }], 32: [function(e2, t2, a2) {
        "use strict";
        var o2 = e2("./support"), h2 = e2("./base64"), r2 = e2("./nodejsUtils"), u2 = e2("./external");
        function n2(e3) {
          return e3;
        }
        function l2(e3, t3) {
          for (var r3 = 0; r3 < e3.length; ++r3)
            t3[r3] = 255 & e3.charCodeAt(r3);
          return t3;
        }
        e2("setimmediate"), a2.newBlob = function(t3, r3) {
          a2.checkSupport("blob");
          try {
            return new Blob([t3], { type: r3 });
          } catch (e3) {
            try {
              var n3 = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
              return n3.append(t3), n3.getBlob(r3);
            } catch (e4) {
              throw new Error("Bug : can't construct the Blob.");
            }
          }
        };
        var i2 = { stringifyByChunk: function(e3, t3, r3) {
          var n3 = [], i3 = 0, s3 = e3.length;
          if (s3 <= r3)
            return String.fromCharCode.apply(null, e3);
          for (; i3 < s3; )
            "array" === t3 || "nodebuffer" === t3 ? n3.push(String.fromCharCode.apply(null, e3.slice(i3, Math.min(i3 + r3, s3)))) : n3.push(String.fromCharCode.apply(null, e3.subarray(i3, Math.min(i3 + r3, s3)))), i3 += r3;
          return n3.join("");
        }, stringifyByChar: function(e3) {
          for (var t3 = "", r3 = 0; r3 < e3.length; r3++)
            t3 += String.fromCharCode(e3[r3]);
          return t3;
        }, applyCanBeUsed: { uint8array: function() {
          try {
            return o2.uint8array && 1 === String.fromCharCode.apply(null, new Uint8Array(1)).length;
          } catch (e3) {
            return false;
          }
        }(), nodebuffer: function() {
          try {
            return o2.nodebuffer && 1 === String.fromCharCode.apply(null, r2.allocBuffer(1)).length;
          } catch (e3) {
            return false;
          }
        }() } };
        function s2(e3) {
          var t3 = 65536, r3 = a2.getTypeOf(e3), n3 = true;
          if ("uint8array" === r3 ? n3 = i2.applyCanBeUsed.uint8array : "nodebuffer" === r3 && (n3 = i2.applyCanBeUsed.nodebuffer), n3)
            for (; 1 < t3; )
              try {
                return i2.stringifyByChunk(e3, r3, t3);
              } catch (e4) {
                t3 = Math.floor(t3 / 2);
              }
          return i2.stringifyByChar(e3);
        }
        function f3(e3, t3) {
          for (var r3 = 0; r3 < e3.length; r3++)
            t3[r3] = e3[r3];
          return t3;
        }
        a2.applyFromCharCode = s2;
        var c3 = {};
        c3.string = { string: n2, array: function(e3) {
          return l2(e3, new Array(e3.length));
        }, arraybuffer: function(e3) {
          return c3.string.uint8array(e3).buffer;
        }, uint8array: function(e3) {
          return l2(e3, new Uint8Array(e3.length));
        }, nodebuffer: function(e3) {
          return l2(e3, r2.allocBuffer(e3.length));
        } }, c3.array = { string: s2, array: n2, arraybuffer: function(e3) {
          return new Uint8Array(e3).buffer;
        }, uint8array: function(e3) {
          return new Uint8Array(e3);
        }, nodebuffer: function(e3) {
          return r2.newBufferFrom(e3);
        } }, c3.arraybuffer = { string: function(e3) {
          return s2(new Uint8Array(e3));
        }, array: function(e3) {
          return f3(new Uint8Array(e3), new Array(e3.byteLength));
        }, arraybuffer: n2, uint8array: function(e3) {
          return new Uint8Array(e3);
        }, nodebuffer: function(e3) {
          return r2.newBufferFrom(new Uint8Array(e3));
        } }, c3.uint8array = { string: s2, array: function(e3) {
          return f3(e3, new Array(e3.length));
        }, arraybuffer: function(e3) {
          return e3.buffer;
        }, uint8array: n2, nodebuffer: function(e3) {
          return r2.newBufferFrom(e3);
        } }, c3.nodebuffer = { string: s2, array: function(e3) {
          return f3(e3, new Array(e3.length));
        }, arraybuffer: function(e3) {
          return c3.nodebuffer.uint8array(e3).buffer;
        }, uint8array: function(e3) {
          return f3(e3, new Uint8Array(e3.length));
        }, nodebuffer: n2 }, a2.transformTo = function(e3, t3) {
          if (t3 = t3 || "", !e3)
            return t3;
          a2.checkSupport(e3);
          var r3 = a2.getTypeOf(t3);
          return c3[r3][e3](t3);
        }, a2.resolve = function(e3) {
          for (var t3 = e3.split("/"), r3 = [], n3 = 0; n3 < t3.length; n3++) {
            var i3 = t3[n3];
            "." === i3 || "" === i3 && 0 !== n3 && n3 !== t3.length - 1 || (".." === i3 ? r3.pop() : r3.push(i3));
          }
          return r3.join("/");
        }, a2.getTypeOf = function(e3) {
          return "string" == typeof e3 ? "string" : "[object Array]" === Object.prototype.toString.call(e3) ? "array" : o2.nodebuffer && r2.isBuffer(e3) ? "nodebuffer" : o2.uint8array && e3 instanceof Uint8Array ? "uint8array" : o2.arraybuffer && e3 instanceof ArrayBuffer ? "arraybuffer" : void 0;
        }, a2.checkSupport = function(e3) {
          if (!o2[e3.toLowerCase()])
            throw new Error(e3 + " is not supported by this platform");
        }, a2.MAX_VALUE_16BITS = 65535, a2.MAX_VALUE_32BITS = -1, a2.pretty = function(e3) {
          var t3, r3, n3 = "";
          for (r3 = 0; r3 < (e3 || "").length; r3++)
            n3 += "\\x" + ((t3 = e3.charCodeAt(r3)) < 16 ? "0" : "") + t3.toString(16).toUpperCase();
          return n3;
        }, a2.delay = function(e3, t3, r3) {
          setImmediate(function() {
            e3.apply(r3 || null, t3 || []);
          });
        }, a2.inherits = function(e3, t3) {
          function r3() {
          }
          r3.prototype = t3.prototype, e3.prototype = new r3();
        }, a2.extend = function() {
          var e3, t3, r3 = {};
          for (e3 = 0; e3 < arguments.length; e3++)
            for (t3 in arguments[e3])
              Object.prototype.hasOwnProperty.call(arguments[e3], t3) && void 0 === r3[t3] && (r3[t3] = arguments[e3][t3]);
          return r3;
        }, a2.prepareContent = function(r3, e3, n3, i3, s3) {
          return u2.Promise.resolve(e3).then(function(n4) {
            return o2.blob && (n4 instanceof Blob || -1 !== ["[object File]", "[object Blob]"].indexOf(Object.prototype.toString.call(n4))) && "undefined" != typeof FileReader ? new u2.Promise(function(t3, r4) {
              var e4 = new FileReader();
              e4.onload = function(e5) {
                t3(e5.target.result);
              }, e4.onerror = function(e5) {
                r4(e5.target.error);
              }, e4.readAsArrayBuffer(n4);
            }) : n4;
          }).then(function(e4) {
            var t3 = a2.getTypeOf(e4);
            return t3 ? ("arraybuffer" === t3 ? e4 = a2.transformTo("uint8array", e4) : "string" === t3 && (s3 ? e4 = h2.decode(e4) : n3 && true !== i3 && (e4 = function(e5) {
              return l2(e5, o2.uint8array ? new Uint8Array(e5.length) : new Array(e5.length));
            }(e4))), e4) : u2.Promise.reject(new Error("Can't read the data of '" + r3 + "'. Is it in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?"));
          });
        };
      }, { "./base64": 1, "./external": 6, "./nodejsUtils": 14, "./support": 30, setimmediate: 54 }], 33: [function(e2, t2, r2) {
        "use strict";
        var n2 = e2("./reader/readerFor"), i2 = e2("./utils"), s2 = e2("./signature"), a2 = e2("./zipEntry"), o2 = e2("./support");
        function h2(e3) {
          this.files = [], this.loadOptions = e3;
        }
        h2.prototype = { checkSignature: function(e3) {
          if (!this.reader.readAndCheckSignature(e3)) {
            this.reader.index -= 4;
            var t3 = this.reader.readString(4);
            throw new Error("Corrupted zip or bug: unexpected signature (" + i2.pretty(t3) + ", expected " + i2.pretty(e3) + ")");
          }
        }, isSignature: function(e3, t3) {
          var r3 = this.reader.index;
          this.reader.setIndex(e3);
          var n3 = this.reader.readString(4) === t3;
          return this.reader.setIndex(r3), n3;
        }, readBlockEndOfCentral: function() {
          this.diskNumber = this.reader.readInt(2), this.diskWithCentralDirStart = this.reader.readInt(2), this.centralDirRecordsOnThisDisk = this.reader.readInt(2), this.centralDirRecords = this.reader.readInt(2), this.centralDirSize = this.reader.readInt(4), this.centralDirOffset = this.reader.readInt(4), this.zipCommentLength = this.reader.readInt(2);
          var e3 = this.reader.readData(this.zipCommentLength), t3 = o2.uint8array ? "uint8array" : "array", r3 = i2.transformTo(t3, e3);
          this.zipComment = this.loadOptions.decodeFileName(r3);
        }, readBlockZip64EndOfCentral: function() {
          this.zip64EndOfCentralSize = this.reader.readInt(8), this.reader.skip(4), this.diskNumber = this.reader.readInt(4), this.diskWithCentralDirStart = this.reader.readInt(4), this.centralDirRecordsOnThisDisk = this.reader.readInt(8), this.centralDirRecords = this.reader.readInt(8), this.centralDirSize = this.reader.readInt(8), this.centralDirOffset = this.reader.readInt(8), this.zip64ExtensibleData = {};
          for (var e3, t3, r3, n3 = this.zip64EndOfCentralSize - 44; 0 < n3; )
            e3 = this.reader.readInt(2), t3 = this.reader.readInt(4), r3 = this.reader.readData(t3), this.zip64ExtensibleData[e3] = { id: e3, length: t3, value: r3 };
        }, readBlockZip64EndOfCentralLocator: function() {
          if (this.diskWithZip64CentralDirStart = this.reader.readInt(4), this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8), this.disksCount = this.reader.readInt(4), 1 < this.disksCount)
            throw new Error("Multi-volumes zip are not supported");
        }, readLocalFiles: function() {
          var e3, t3;
          for (e3 = 0; e3 < this.files.length; e3++)
            t3 = this.files[e3], this.reader.setIndex(t3.localHeaderOffset), this.checkSignature(s2.LOCAL_FILE_HEADER), t3.readLocalPart(this.reader), t3.handleUTF8(), t3.processAttributes();
        }, readCentralDir: function() {
          var e3;
          for (this.reader.setIndex(this.centralDirOffset); this.reader.readAndCheckSignature(s2.CENTRAL_FILE_HEADER); )
            (e3 = new a2({ zip64: this.zip64 }, this.loadOptions)).readCentralPart(this.reader), this.files.push(e3);
          if (this.centralDirRecords !== this.files.length && 0 !== this.centralDirRecords && 0 === this.files.length)
            throw new Error("Corrupted zip or bug: expected " + this.centralDirRecords + " records in central dir, got " + this.files.length);
        }, readEndOfCentral: function() {
          var e3 = this.reader.lastIndexOfSignature(s2.CENTRAL_DIRECTORY_END);
          if (e3 < 0)
            throw !this.isSignature(0, s2.LOCAL_FILE_HEADER) ? new Error("Can't find end of central directory : is this a zip file ? If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html") : new Error("Corrupted zip: can't find end of central directory");
          this.reader.setIndex(e3);
          var t3 = e3;
          if (this.checkSignature(s2.CENTRAL_DIRECTORY_END), this.readBlockEndOfCentral(), this.diskNumber === i2.MAX_VALUE_16BITS || this.diskWithCentralDirStart === i2.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === i2.MAX_VALUE_16BITS || this.centralDirRecords === i2.MAX_VALUE_16BITS || this.centralDirSize === i2.MAX_VALUE_32BITS || this.centralDirOffset === i2.MAX_VALUE_32BITS) {
            if (this.zip64 = true, (e3 = this.reader.lastIndexOfSignature(s2.ZIP64_CENTRAL_DIRECTORY_LOCATOR)) < 0)
              throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");
            if (this.reader.setIndex(e3), this.checkSignature(s2.ZIP64_CENTRAL_DIRECTORY_LOCATOR), this.readBlockZip64EndOfCentralLocator(), !this.isSignature(this.relativeOffsetEndOfZip64CentralDir, s2.ZIP64_CENTRAL_DIRECTORY_END) && (this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(s2.ZIP64_CENTRAL_DIRECTORY_END), this.relativeOffsetEndOfZip64CentralDir < 0))
              throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");
            this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir), this.checkSignature(s2.ZIP64_CENTRAL_DIRECTORY_END), this.readBlockZip64EndOfCentral();
          }
          var r3 = this.centralDirOffset + this.centralDirSize;
          this.zip64 && (r3 += 20, r3 += 12 + this.zip64EndOfCentralSize);
          var n3 = t3 - r3;
          if (0 < n3)
            this.isSignature(t3, s2.CENTRAL_FILE_HEADER) || (this.reader.zero = n3);
          else if (n3 < 0)
            throw new Error("Corrupted zip: missing " + Math.abs(n3) + " bytes.");
        }, prepareReader: function(e3) {
          this.reader = n2(e3);
        }, load: function(e3) {
          this.prepareReader(e3), this.readEndOfCentral(), this.readCentralDir(), this.readLocalFiles();
        } }, t2.exports = h2;
      }, { "./reader/readerFor": 22, "./signature": 23, "./support": 30, "./utils": 32, "./zipEntry": 34 }], 34: [function(e2, t2, r2) {
        "use strict";
        var n2 = e2("./reader/readerFor"), s2 = e2("./utils"), i2 = e2("./compressedObject"), a2 = e2("./crc32"), o2 = e2("./utf8"), h2 = e2("./compressions"), u2 = e2("./support");
        function l2(e3, t3) {
          this.options = e3, this.loadOptions = t3;
        }
        l2.prototype = { isEncrypted: function() {
          return 1 == (1 & this.bitFlag);
        }, useUTF8: function() {
          return 2048 == (2048 & this.bitFlag);
        }, readLocalPart: function(e3) {
          var t3, r3;
          if (e3.skip(22), this.fileNameLength = e3.readInt(2), r3 = e3.readInt(2), this.fileName = e3.readData(this.fileNameLength), e3.skip(r3), -1 === this.compressedSize || -1 === this.uncompressedSize)
            throw new Error("Bug or corrupted zip : didn't get enough information from the central directory (compressedSize === -1 || uncompressedSize === -1)");
          if (null === (t3 = function(e4) {
            for (var t4 in h2)
              if (Object.prototype.hasOwnProperty.call(h2, t4) && h2[t4].magic === e4)
                return h2[t4];
            return null;
          }(this.compressionMethod)))
            throw new Error("Corrupted zip : compression " + s2.pretty(this.compressionMethod) + " unknown (inner file : " + s2.transformTo("string", this.fileName) + ")");
          this.decompressed = new i2(this.compressedSize, this.uncompressedSize, this.crc32, t3, e3.readData(this.compressedSize));
        }, readCentralPart: function(e3) {
          this.versionMadeBy = e3.readInt(2), e3.skip(2), this.bitFlag = e3.readInt(2), this.compressionMethod = e3.readString(2), this.date = e3.readDate(), this.crc32 = e3.readInt(4), this.compressedSize = e3.readInt(4), this.uncompressedSize = e3.readInt(4);
          var t3 = e3.readInt(2);
          if (this.extraFieldsLength = e3.readInt(2), this.fileCommentLength = e3.readInt(2), this.diskNumberStart = e3.readInt(2), this.internalFileAttributes = e3.readInt(2), this.externalFileAttributes = e3.readInt(4), this.localHeaderOffset = e3.readInt(4), this.isEncrypted())
            throw new Error("Encrypted zip are not supported");
          e3.skip(t3), this.readExtraFields(e3), this.parseZIP64ExtraField(e3), this.fileComment = e3.readData(this.fileCommentLength);
        }, processAttributes: function() {
          this.unixPermissions = null, this.dosPermissions = null;
          var e3 = this.versionMadeBy >> 8;
          this.dir = !!(16 & this.externalFileAttributes), 0 == e3 && (this.dosPermissions = 63 & this.externalFileAttributes), 3 == e3 && (this.unixPermissions = this.externalFileAttributes >> 16 & 65535), this.dir || "/" !== this.fileNameStr.slice(-1) || (this.dir = true);
        }, parseZIP64ExtraField: function() {
          if (this.extraFields[1]) {
            var e3 = n2(this.extraFields[1].value);
            this.uncompressedSize === s2.MAX_VALUE_32BITS && (this.uncompressedSize = e3.readInt(8)), this.compressedSize === s2.MAX_VALUE_32BITS && (this.compressedSize = e3.readInt(8)), this.localHeaderOffset === s2.MAX_VALUE_32BITS && (this.localHeaderOffset = e3.readInt(8)), this.diskNumberStart === s2.MAX_VALUE_32BITS && (this.diskNumberStart = e3.readInt(4));
          }
        }, readExtraFields: function(e3) {
          var t3, r3, n3, i3 = e3.index + this.extraFieldsLength;
          for (this.extraFields || (this.extraFields = {}); e3.index + 4 < i3; )
            t3 = e3.readInt(2), r3 = e3.readInt(2), n3 = e3.readData(r3), this.extraFields[t3] = { id: t3, length: r3, value: n3 };
          e3.setIndex(i3);
        }, handleUTF8: function() {
          var e3 = u2.uint8array ? "uint8array" : "array";
          if (this.useUTF8())
            this.fileNameStr = o2.utf8decode(this.fileName), this.fileCommentStr = o2.utf8decode(this.fileComment);
          else {
            var t3 = this.findExtraFieldUnicodePath();
            if (null !== t3)
              this.fileNameStr = t3;
            else {
              var r3 = s2.transformTo(e3, this.fileName);
              this.fileNameStr = this.loadOptions.decodeFileName(r3);
            }
            var n3 = this.findExtraFieldUnicodeComment();
            if (null !== n3)
              this.fileCommentStr = n3;
            else {
              var i3 = s2.transformTo(e3, this.fileComment);
              this.fileCommentStr = this.loadOptions.decodeFileName(i3);
            }
          }
        }, findExtraFieldUnicodePath: function() {
          var e3 = this.extraFields[28789];
          if (e3) {
            var t3 = n2(e3.value);
            return 1 !== t3.readInt(1) ? null : a2(this.fileName) !== t3.readInt(4) ? null : o2.utf8decode(t3.readData(e3.length - 5));
          }
          return null;
        }, findExtraFieldUnicodeComment: function() {
          var e3 = this.extraFields[25461];
          if (e3) {
            var t3 = n2(e3.value);
            return 1 !== t3.readInt(1) ? null : a2(this.fileComment) !== t3.readInt(4) ? null : o2.utf8decode(t3.readData(e3.length - 5));
          }
          return null;
        } }, t2.exports = l2;
      }, { "./compressedObject": 2, "./compressions": 3, "./crc32": 4, "./reader/readerFor": 22, "./support": 30, "./utf8": 31, "./utils": 32 }], 35: [function(e2, t2, r2) {
        "use strict";
        function n2(e3, t3, r3) {
          this.name = e3, this.dir = r3.dir, this.date = r3.date, this.comment = r3.comment, this.unixPermissions = r3.unixPermissions, this.dosPermissions = r3.dosPermissions, this._data = t3, this._dataBinary = r3.binary, this.options = { compression: r3.compression, compressionOptions: r3.compressionOptions };
        }
        var s2 = e2("./stream/StreamHelper"), i2 = e2("./stream/DataWorker"), a2 = e2("./utf8"), o2 = e2("./compressedObject"), h2 = e2("./stream/GenericWorker");
        n2.prototype = { internalStream: function(e3) {
          var t3 = null, r3 = "string";
          try {
            if (!e3)
              throw new Error("No output type specified.");
            var n3 = "string" === (r3 = e3.toLowerCase()) || "text" === r3;
            "binarystring" !== r3 && "text" !== r3 || (r3 = "string"), t3 = this._decompressWorker();
            var i3 = !this._dataBinary;
            i3 && !n3 && (t3 = t3.pipe(new a2.Utf8EncodeWorker())), !i3 && n3 && (t3 = t3.pipe(new a2.Utf8DecodeWorker()));
          } catch (e4) {
            (t3 = new h2("error")).error(e4);
          }
          return new s2(t3, r3, "");
        }, async: function(e3, t3) {
          return this.internalStream(e3).accumulate(t3);
        }, nodeStream: function(e3, t3) {
          return this.internalStream(e3 || "nodebuffer").toNodejsStream(t3);
        }, _compressWorker: function(e3, t3) {
          if (this._data instanceof o2 && this._data.compression.magic === e3.magic)
            return this._data.getCompressedWorker();
          var r3 = this._decompressWorker();
          return this._dataBinary || (r3 = r3.pipe(new a2.Utf8EncodeWorker())), o2.createWorkerFrom(r3, e3, t3);
        }, _decompressWorker: function() {
          return this._data instanceof o2 ? this._data.getContentWorker() : this._data instanceof h2 ? this._data : new i2(this._data);
        } };
        for (var u2 = ["asText", "asBinary", "asNodeBuffer", "asUint8Array", "asArrayBuffer"], l2 = function() {
          throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
        }, f3 = 0; f3 < u2.length; f3++)
          n2.prototype[u2[f3]] = l2;
        t2.exports = n2;
      }, { "./compressedObject": 2, "./stream/DataWorker": 27, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31 }], 36: [function(e2, l2, t2) {
        (function(t3) {
          "use strict";
          var r2, n2, e3 = t3.MutationObserver || t3.WebKitMutationObserver;
          if (e3) {
            var i2 = 0, s2 = new e3(u2), a2 = t3.document.createTextNode("");
            s2.observe(a2, { characterData: true }), r2 = function() {
              a2.data = i2 = ++i2 % 2;
            };
          } else if (t3.setImmediate || void 0 === t3.MessageChannel)
            r2 = "document" in t3 && "onreadystatechange" in t3.document.createElement("script") ? function() {
              var e4 = t3.document.createElement("script");
              e4.onreadystatechange = function() {
                u2(), e4.onreadystatechange = null, e4.parentNode.removeChild(e4), e4 = null;
              }, t3.document.documentElement.appendChild(e4);
            } : function() {
              setTimeout(u2, 0);
            };
          else {
            var o2 = new t3.MessageChannel();
            o2.port1.onmessage = u2, r2 = function() {
              o2.port2.postMessage(0);
            };
          }
          var h2 = [];
          function u2() {
            var e4, t4;
            n2 = true;
            for (var r3 = h2.length; r3; ) {
              for (t4 = h2, h2 = [], e4 = -1; ++e4 < r3; )
                t4[e4]();
              r3 = h2.length;
            }
            n2 = false;
          }
          l2.exports = function(e4) {
            1 !== h2.push(e4) || n2 || r2();
          };
        }).call(this, "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
      }, {}], 37: [function(e2, t2, r2) {
        "use strict";
        var i2 = e2("immediate");
        function u2() {
        }
        var l2 = {}, s2 = ["REJECTED"], a2 = ["FULFILLED"], n2 = ["PENDING"];
        function o2(e3) {
          if ("function" != typeof e3)
            throw new TypeError("resolver must be a function");
          this.state = n2, this.queue = [], this.outcome = void 0, e3 !== u2 && d(this, e3);
        }
        function h2(e3, t3, r3) {
          this.promise = e3, "function" == typeof t3 && (this.onFulfilled = t3, this.callFulfilled = this.otherCallFulfilled), "function" == typeof r3 && (this.onRejected = r3, this.callRejected = this.otherCallRejected);
        }
        function f3(t3, r3, n3) {
          i2(function() {
            var e3;
            try {
              e3 = r3(n3);
            } catch (e4) {
              return l2.reject(t3, e4);
            }
            e3 === t3 ? l2.reject(t3, new TypeError("Cannot resolve promise with itself")) : l2.resolve(t3, e3);
          });
        }
        function c3(e3) {
          var t3 = e3 && e3.then;
          if (e3 && ("object" == typeof e3 || "function" == typeof e3) && "function" == typeof t3)
            return function() {
              t3.apply(e3, arguments);
            };
        }
        function d(t3, e3) {
          var r3 = false;
          function n3(e4) {
            r3 || (r3 = true, l2.reject(t3, e4));
          }
          function i3(e4) {
            r3 || (r3 = true, l2.resolve(t3, e4));
          }
          var s3 = p2(function() {
            e3(i3, n3);
          });
          "error" === s3.status && n3(s3.value);
        }
        function p2(e3, t3) {
          var r3 = {};
          try {
            r3.value = e3(t3), r3.status = "success";
          } catch (e4) {
            r3.status = "error", r3.value = e4;
          }
          return r3;
        }
        (t2.exports = o2).prototype.finally = function(t3) {
          if ("function" != typeof t3)
            return this;
          var r3 = this.constructor;
          return this.then(function(e3) {
            return r3.resolve(t3()).then(function() {
              return e3;
            });
          }, function(e3) {
            return r3.resolve(t3()).then(function() {
              throw e3;
            });
          });
        }, o2.prototype.catch = function(e3) {
          return this.then(null, e3);
        }, o2.prototype.then = function(e3, t3) {
          if ("function" != typeof e3 && this.state === a2 || "function" != typeof t3 && this.state === s2)
            return this;
          var r3 = new this.constructor(u2);
          this.state !== n2 ? f3(r3, this.state === a2 ? e3 : t3, this.outcome) : this.queue.push(new h2(r3, e3, t3));
          return r3;
        }, h2.prototype.callFulfilled = function(e3) {
          l2.resolve(this.promise, e3);
        }, h2.prototype.otherCallFulfilled = function(e3) {
          f3(this.promise, this.onFulfilled, e3);
        }, h2.prototype.callRejected = function(e3) {
          l2.reject(this.promise, e3);
        }, h2.prototype.otherCallRejected = function(e3) {
          f3(this.promise, this.onRejected, e3);
        }, l2.resolve = function(e3, t3) {
          var r3 = p2(c3, t3);
          if ("error" === r3.status)
            return l2.reject(e3, r3.value);
          var n3 = r3.value;
          if (n3)
            d(e3, n3);
          else {
            e3.state = a2, e3.outcome = t3;
            for (var i3 = -1, s3 = e3.queue.length; ++i3 < s3; )
              e3.queue[i3].callFulfilled(t3);
          }
          return e3;
        }, l2.reject = function(e3, t3) {
          e3.state = s2, e3.outcome = t3;
          for (var r3 = -1, n3 = e3.queue.length; ++r3 < n3; )
            e3.queue[r3].callRejected(t3);
          return e3;
        }, o2.resolve = function(e3) {
          if (e3 instanceof this)
            return e3;
          return l2.resolve(new this(u2), e3);
        }, o2.reject = function(e3) {
          var t3 = new this(u2);
          return l2.reject(t3, e3);
        }, o2.all = function(e3) {
          var r3 = this;
          if ("[object Array]" !== Object.prototype.toString.call(e3))
            return this.reject(new TypeError("must be an array"));
          var n3 = e3.length, i3 = false;
          if (!n3)
            return this.resolve([]);
          var s3 = new Array(n3), a3 = 0, t3 = -1, o3 = new this(u2);
          for (; ++t3 < n3; )
            h3(e3[t3], t3);
          return o3;
          function h3(e4, t4) {
            r3.resolve(e4).then(function(e5) {
              s3[t4] = e5, ++a3 !== n3 || i3 || (i3 = true, l2.resolve(o3, s3));
            }, function(e5) {
              i3 || (i3 = true, l2.reject(o3, e5));
            });
          }
        }, o2.race = function(e3) {
          var t3 = this;
          if ("[object Array]" !== Object.prototype.toString.call(e3))
            return this.reject(new TypeError("must be an array"));
          var r3 = e3.length, n3 = false;
          if (!r3)
            return this.resolve([]);
          var i3 = -1, s3 = new this(u2);
          for (; ++i3 < r3; )
            a3 = e3[i3], t3.resolve(a3).then(function(e4) {
              n3 || (n3 = true, l2.resolve(s3, e4));
            }, function(e4) {
              n3 || (n3 = true, l2.reject(s3, e4));
            });
          var a3;
          return s3;
        };
      }, { immediate: 36 }], 38: [function(e2, t2, r2) {
        "use strict";
        var n2 = {};
        (0, e2("./lib/utils/common").assign)(n2, e2("./lib/deflate"), e2("./lib/inflate"), e2("./lib/zlib/constants")), t2.exports = n2;
      }, { "./lib/deflate": 39, "./lib/inflate": 40, "./lib/utils/common": 41, "./lib/zlib/constants": 44 }], 39: [function(e2, t2, r2) {
        "use strict";
        var a2 = e2("./zlib/deflate"), o2 = e2("./utils/common"), h2 = e2("./utils/strings"), i2 = e2("./zlib/messages"), s2 = e2("./zlib/zstream"), u2 = Object.prototype.toString, l2 = 0, f3 = -1, c3 = 0, d = 8;
        function p2(e3) {
          if (!(this instanceof p2))
            return new p2(e3);
          this.options = o2.assign({ level: f3, method: d, chunkSize: 16384, windowBits: 15, memLevel: 8, strategy: c3, to: "" }, e3 || {});
          var t3 = this.options;
          t3.raw && 0 < t3.windowBits ? t3.windowBits = -t3.windowBits : t3.gzip && 0 < t3.windowBits && t3.windowBits < 16 && (t3.windowBits += 16), this.err = 0, this.msg = "", this.ended = false, this.chunks = [], this.strm = new s2(), this.strm.avail_out = 0;
          var r3 = a2.deflateInit2(this.strm, t3.level, t3.method, t3.windowBits, t3.memLevel, t3.strategy);
          if (r3 !== l2)
            throw new Error(i2[r3]);
          if (t3.header && a2.deflateSetHeader(this.strm, t3.header), t3.dictionary) {
            var n3;
            if (n3 = "string" == typeof t3.dictionary ? h2.string2buf(t3.dictionary) : "[object ArrayBuffer]" === u2.call(t3.dictionary) ? new Uint8Array(t3.dictionary) : t3.dictionary, (r3 = a2.deflateSetDictionary(this.strm, n3)) !== l2)
              throw new Error(i2[r3]);
            this._dict_set = true;
          }
        }
        function n2(e3, t3) {
          var r3 = new p2(t3);
          if (r3.push(e3, true), r3.err)
            throw r3.msg || i2[r3.err];
          return r3.result;
        }
        p2.prototype.push = function(e3, t3) {
          var r3, n3, i3 = this.strm, s3 = this.options.chunkSize;
          if (this.ended)
            return false;
          n3 = t3 === ~~t3 ? t3 : true === t3 ? 4 : 0, "string" == typeof e3 ? i3.input = h2.string2buf(e3) : "[object ArrayBuffer]" === u2.call(e3) ? i3.input = new Uint8Array(e3) : i3.input = e3, i3.next_in = 0, i3.avail_in = i3.input.length;
          do {
            if (0 === i3.avail_out && (i3.output = new o2.Buf8(s3), i3.next_out = 0, i3.avail_out = s3), 1 !== (r3 = a2.deflate(i3, n3)) && r3 !== l2)
              return this.onEnd(r3), !(this.ended = true);
            0 !== i3.avail_out && (0 !== i3.avail_in || 4 !== n3 && 2 !== n3) || ("string" === this.options.to ? this.onData(h2.buf2binstring(o2.shrinkBuf(i3.output, i3.next_out))) : this.onData(o2.shrinkBuf(i3.output, i3.next_out)));
          } while ((0 < i3.avail_in || 0 === i3.avail_out) && 1 !== r3);
          return 4 === n3 ? (r3 = a2.deflateEnd(this.strm), this.onEnd(r3), this.ended = true, r3 === l2) : 2 !== n3 || (this.onEnd(l2), !(i3.avail_out = 0));
        }, p2.prototype.onData = function(e3) {
          this.chunks.push(e3);
        }, p2.prototype.onEnd = function(e3) {
          e3 === l2 && ("string" === this.options.to ? this.result = this.chunks.join("") : this.result = o2.flattenChunks(this.chunks)), this.chunks = [], this.err = e3, this.msg = this.strm.msg;
        }, r2.Deflate = p2, r2.deflate = n2, r2.deflateRaw = function(e3, t3) {
          return (t3 = t3 || {}).raw = true, n2(e3, t3);
        }, r2.gzip = function(e3, t3) {
          return (t3 = t3 || {}).gzip = true, n2(e3, t3);
        };
      }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/deflate": 46, "./zlib/messages": 51, "./zlib/zstream": 53 }], 40: [function(e2, t2, r2) {
        "use strict";
        var c3 = e2("./zlib/inflate"), d = e2("./utils/common"), p2 = e2("./utils/strings"), m3 = e2("./zlib/constants"), n2 = e2("./zlib/messages"), i2 = e2("./zlib/zstream"), s2 = e2("./zlib/gzheader"), _2 = Object.prototype.toString;
        function a2(e3) {
          if (!(this instanceof a2))
            return new a2(e3);
          this.options = d.assign({ chunkSize: 16384, windowBits: 0, to: "" }, e3 || {});
          var t3 = this.options;
          t3.raw && 0 <= t3.windowBits && t3.windowBits < 16 && (t3.windowBits = -t3.windowBits, 0 === t3.windowBits && (t3.windowBits = -15)), !(0 <= t3.windowBits && t3.windowBits < 16) || e3 && e3.windowBits || (t3.windowBits += 32), 15 < t3.windowBits && t3.windowBits < 48 && 0 == (15 & t3.windowBits) && (t3.windowBits |= 15), this.err = 0, this.msg = "", this.ended = false, this.chunks = [], this.strm = new i2(), this.strm.avail_out = 0;
          var r3 = c3.inflateInit2(this.strm, t3.windowBits);
          if (r3 !== m3.Z_OK)
            throw new Error(n2[r3]);
          this.header = new s2(), c3.inflateGetHeader(this.strm, this.header);
        }
        function o2(e3, t3) {
          var r3 = new a2(t3);
          if (r3.push(e3, true), r3.err)
            throw r3.msg || n2[r3.err];
          return r3.result;
        }
        a2.prototype.push = function(e3, t3) {
          var r3, n3, i3, s3, a3, o3, h2 = this.strm, u2 = this.options.chunkSize, l2 = this.options.dictionary, f3 = false;
          if (this.ended)
            return false;
          n3 = t3 === ~~t3 ? t3 : true === t3 ? m3.Z_FINISH : m3.Z_NO_FLUSH, "string" == typeof e3 ? h2.input = p2.binstring2buf(e3) : "[object ArrayBuffer]" === _2.call(e3) ? h2.input = new Uint8Array(e3) : h2.input = e3, h2.next_in = 0, h2.avail_in = h2.input.length;
          do {
            if (0 === h2.avail_out && (h2.output = new d.Buf8(u2), h2.next_out = 0, h2.avail_out = u2), (r3 = c3.inflate(h2, m3.Z_NO_FLUSH)) === m3.Z_NEED_DICT && l2 && (o3 = "string" == typeof l2 ? p2.string2buf(l2) : "[object ArrayBuffer]" === _2.call(l2) ? new Uint8Array(l2) : l2, r3 = c3.inflateSetDictionary(this.strm, o3)), r3 === m3.Z_BUF_ERROR && true === f3 && (r3 = m3.Z_OK, f3 = false), r3 !== m3.Z_STREAM_END && r3 !== m3.Z_OK)
              return this.onEnd(r3), !(this.ended = true);
            h2.next_out && (0 !== h2.avail_out && r3 !== m3.Z_STREAM_END && (0 !== h2.avail_in || n3 !== m3.Z_FINISH && n3 !== m3.Z_SYNC_FLUSH) || ("string" === this.options.to ? (i3 = p2.utf8border(h2.output, h2.next_out), s3 = h2.next_out - i3, a3 = p2.buf2string(h2.output, i3), h2.next_out = s3, h2.avail_out = u2 - s3, s3 && d.arraySet(h2.output, h2.output, i3, s3, 0), this.onData(a3)) : this.onData(d.shrinkBuf(h2.output, h2.next_out)))), 0 === h2.avail_in && 0 === h2.avail_out && (f3 = true);
          } while ((0 < h2.avail_in || 0 === h2.avail_out) && r3 !== m3.Z_STREAM_END);
          return r3 === m3.Z_STREAM_END && (n3 = m3.Z_FINISH), n3 === m3.Z_FINISH ? (r3 = c3.inflateEnd(this.strm), this.onEnd(r3), this.ended = true, r3 === m3.Z_OK) : n3 !== m3.Z_SYNC_FLUSH || (this.onEnd(m3.Z_OK), !(h2.avail_out = 0));
        }, a2.prototype.onData = function(e3) {
          this.chunks.push(e3);
        }, a2.prototype.onEnd = function(e3) {
          e3 === m3.Z_OK && ("string" === this.options.to ? this.result = this.chunks.join("") : this.result = d.flattenChunks(this.chunks)), this.chunks = [], this.err = e3, this.msg = this.strm.msg;
        }, r2.Inflate = a2, r2.inflate = o2, r2.inflateRaw = function(e3, t3) {
          return (t3 = t3 || {}).raw = true, o2(e3, t3);
        }, r2.ungzip = o2;
      }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/constants": 44, "./zlib/gzheader": 47, "./zlib/inflate": 49, "./zlib/messages": 51, "./zlib/zstream": 53 }], 41: [function(e2, t2, r2) {
        "use strict";
        var n2 = "undefined" != typeof Uint8Array && "undefined" != typeof Uint16Array && "undefined" != typeof Int32Array;
        r2.assign = function(e3) {
          for (var t3 = Array.prototype.slice.call(arguments, 1); t3.length; ) {
            var r3 = t3.shift();
            if (r3) {
              if ("object" != typeof r3)
                throw new TypeError(r3 + "must be non-object");
              for (var n3 in r3)
                r3.hasOwnProperty(n3) && (e3[n3] = r3[n3]);
            }
          }
          return e3;
        }, r2.shrinkBuf = function(e3, t3) {
          return e3.length === t3 ? e3 : e3.subarray ? e3.subarray(0, t3) : (e3.length = t3, e3);
        };
        var i2 = { arraySet: function(e3, t3, r3, n3, i3) {
          if (t3.subarray && e3.subarray)
            e3.set(t3.subarray(r3, r3 + n3), i3);
          else
            for (var s3 = 0; s3 < n3; s3++)
              e3[i3 + s3] = t3[r3 + s3];
        }, flattenChunks: function(e3) {
          var t3, r3, n3, i3, s3, a2;
          for (t3 = n3 = 0, r3 = e3.length; t3 < r3; t3++)
            n3 += e3[t3].length;
          for (a2 = new Uint8Array(n3), t3 = i3 = 0, r3 = e3.length; t3 < r3; t3++)
            s3 = e3[t3], a2.set(s3, i3), i3 += s3.length;
          return a2;
        } }, s2 = { arraySet: function(e3, t3, r3, n3, i3) {
          for (var s3 = 0; s3 < n3; s3++)
            e3[i3 + s3] = t3[r3 + s3];
        }, flattenChunks: function(e3) {
          return [].concat.apply([], e3);
        } };
        r2.setTyped = function(e3) {
          e3 ? (r2.Buf8 = Uint8Array, r2.Buf16 = Uint16Array, r2.Buf32 = Int32Array, r2.assign(r2, i2)) : (r2.Buf8 = Array, r2.Buf16 = Array, r2.Buf32 = Array, r2.assign(r2, s2));
        }, r2.setTyped(n2);
      }, {}], 42: [function(e2, t2, r2) {
        "use strict";
        var h2 = e2("./common"), i2 = true, s2 = true;
        try {
          String.fromCharCode.apply(null, [0]);
        } catch (e3) {
          i2 = false;
        }
        try {
          String.fromCharCode.apply(null, new Uint8Array(1));
        } catch (e3) {
          s2 = false;
        }
        for (var u2 = new h2.Buf8(256), n2 = 0; n2 < 256; n2++)
          u2[n2] = 252 <= n2 ? 6 : 248 <= n2 ? 5 : 240 <= n2 ? 4 : 224 <= n2 ? 3 : 192 <= n2 ? 2 : 1;
        function l2(e3, t3) {
          if (t3 < 65537 && (e3.subarray && s2 || !e3.subarray && i2))
            return String.fromCharCode.apply(null, h2.shrinkBuf(e3, t3));
          for (var r3 = "", n3 = 0; n3 < t3; n3++)
            r3 += String.fromCharCode(e3[n3]);
          return r3;
        }
        u2[254] = u2[254] = 1, r2.string2buf = function(e3) {
          var t3, r3, n3, i3, s3, a2 = e3.length, o2 = 0;
          for (i3 = 0; i3 < a2; i3++)
            55296 == (64512 & (r3 = e3.charCodeAt(i3))) && i3 + 1 < a2 && 56320 == (64512 & (n3 = e3.charCodeAt(i3 + 1))) && (r3 = 65536 + (r3 - 55296 << 10) + (n3 - 56320), i3++), o2 += r3 < 128 ? 1 : r3 < 2048 ? 2 : r3 < 65536 ? 3 : 4;
          for (t3 = new h2.Buf8(o2), i3 = s3 = 0; s3 < o2; i3++)
            55296 == (64512 & (r3 = e3.charCodeAt(i3))) && i3 + 1 < a2 && 56320 == (64512 & (n3 = e3.charCodeAt(i3 + 1))) && (r3 = 65536 + (r3 - 55296 << 10) + (n3 - 56320), i3++), r3 < 128 ? t3[s3++] = r3 : (r3 < 2048 ? t3[s3++] = 192 | r3 >>> 6 : (r3 < 65536 ? t3[s3++] = 224 | r3 >>> 12 : (t3[s3++] = 240 | r3 >>> 18, t3[s3++] = 128 | r3 >>> 12 & 63), t3[s3++] = 128 | r3 >>> 6 & 63), t3[s3++] = 128 | 63 & r3);
          return t3;
        }, r2.buf2binstring = function(e3) {
          return l2(e3, e3.length);
        }, r2.binstring2buf = function(e3) {
          for (var t3 = new h2.Buf8(e3.length), r3 = 0, n3 = t3.length; r3 < n3; r3++)
            t3[r3] = e3.charCodeAt(r3);
          return t3;
        }, r2.buf2string = function(e3, t3) {
          var r3, n3, i3, s3, a2 = t3 || e3.length, o2 = new Array(2 * a2);
          for (r3 = n3 = 0; r3 < a2; )
            if ((i3 = e3[r3++]) < 128)
              o2[n3++] = i3;
            else if (4 < (s3 = u2[i3]))
              o2[n3++] = 65533, r3 += s3 - 1;
            else {
              for (i3 &= 2 === s3 ? 31 : 3 === s3 ? 15 : 7; 1 < s3 && r3 < a2; )
                i3 = i3 << 6 | 63 & e3[r3++], s3--;
              1 < s3 ? o2[n3++] = 65533 : i3 < 65536 ? o2[n3++] = i3 : (i3 -= 65536, o2[n3++] = 55296 | i3 >> 10 & 1023, o2[n3++] = 56320 | 1023 & i3);
            }
          return l2(o2, n3);
        }, r2.utf8border = function(e3, t3) {
          var r3;
          for ((t3 = t3 || e3.length) > e3.length && (t3 = e3.length), r3 = t3 - 1; 0 <= r3 && 128 == (192 & e3[r3]); )
            r3--;
          return r3 < 0 ? t3 : 0 === r3 ? t3 : r3 + u2[e3[r3]] > t3 ? r3 : t3;
        };
      }, { "./common": 41 }], 43: [function(e2, t2, r2) {
        "use strict";
        t2.exports = function(e3, t3, r3, n2) {
          for (var i2 = 65535 & e3 | 0, s2 = e3 >>> 16 & 65535 | 0, a2 = 0; 0 !== r3; ) {
            for (r3 -= a2 = 2e3 < r3 ? 2e3 : r3; s2 = s2 + (i2 = i2 + t3[n2++] | 0) | 0, --a2; )
              ;
            i2 %= 65521, s2 %= 65521;
          }
          return i2 | s2 << 16 | 0;
        };
      }, {}], 44: [function(e2, t2, r2) {
        "use strict";
        t2.exports = { Z_NO_FLUSH: 0, Z_PARTIAL_FLUSH: 1, Z_SYNC_FLUSH: 2, Z_FULL_FLUSH: 3, Z_FINISH: 4, Z_BLOCK: 5, Z_TREES: 6, Z_OK: 0, Z_STREAM_END: 1, Z_NEED_DICT: 2, Z_ERRNO: -1, Z_STREAM_ERROR: -2, Z_DATA_ERROR: -3, Z_BUF_ERROR: -5, Z_NO_COMPRESSION: 0, Z_BEST_SPEED: 1, Z_BEST_COMPRESSION: 9, Z_DEFAULT_COMPRESSION: -1, Z_FILTERED: 1, Z_HUFFMAN_ONLY: 2, Z_RLE: 3, Z_FIXED: 4, Z_DEFAULT_STRATEGY: 0, Z_BINARY: 0, Z_TEXT: 1, Z_UNKNOWN: 2, Z_DEFLATED: 8 };
      }, {}], 45: [function(e2, t2, r2) {
        "use strict";
        var o2 = function() {
          for (var e3, t3 = [], r3 = 0; r3 < 256; r3++) {
            e3 = r3;
            for (var n2 = 0; n2 < 8; n2++)
              e3 = 1 & e3 ? 3988292384 ^ e3 >>> 1 : e3 >>> 1;
            t3[r3] = e3;
          }
          return t3;
        }();
        t2.exports = function(e3, t3, r3, n2) {
          var i2 = o2, s2 = n2 + r3;
          e3 ^= -1;
          for (var a2 = n2; a2 < s2; a2++)
            e3 = e3 >>> 8 ^ i2[255 & (e3 ^ t3[a2])];
          return -1 ^ e3;
        };
      }, {}], 46: [function(e2, t2, r2) {
        "use strict";
        var h2, c3 = e2("../utils/common"), u2 = e2("./trees"), d = e2("./adler32"), p2 = e2("./crc32"), n2 = e2("./messages"), l2 = 0, f3 = 4, m3 = 0, _2 = -2, g = -1, b = 4, i2 = 2, v2 = 8, y3 = 9, s2 = 286, a2 = 30, o2 = 19, w = 2 * s2 + 1, k = 15, x2 = 3, S2 = 258, z = S2 + x2 + 1, C = 42, E = 113, A2 = 1, I = 2, O2 = 3, B = 4;
        function R(e3, t3) {
          return e3.msg = n2[t3], t3;
        }
        function T3(e3) {
          return (e3 << 1) - (4 < e3 ? 9 : 0);
        }
        function D2(e3) {
          for (var t3 = e3.length; 0 <= --t3; )
            e3[t3] = 0;
        }
        function F(e3) {
          var t3 = e3.state, r3 = t3.pending;
          r3 > e3.avail_out && (r3 = e3.avail_out), 0 !== r3 && (c3.arraySet(e3.output, t3.pending_buf, t3.pending_out, r3, e3.next_out), e3.next_out += r3, t3.pending_out += r3, e3.total_out += r3, e3.avail_out -= r3, t3.pending -= r3, 0 === t3.pending && (t3.pending_out = 0));
        }
        function N2(e3, t3) {
          u2._tr_flush_block(e3, 0 <= e3.block_start ? e3.block_start : -1, e3.strstart - e3.block_start, t3), e3.block_start = e3.strstart, F(e3.strm);
        }
        function U(e3, t3) {
          e3.pending_buf[e3.pending++] = t3;
        }
        function P(e3, t3) {
          e3.pending_buf[e3.pending++] = t3 >>> 8 & 255, e3.pending_buf[e3.pending++] = 255 & t3;
        }
        function L(e3, t3) {
          var r3, n3, i3 = e3.max_chain_length, s3 = e3.strstart, a3 = e3.prev_length, o3 = e3.nice_match, h3 = e3.strstart > e3.w_size - z ? e3.strstart - (e3.w_size - z) : 0, u3 = e3.window, l3 = e3.w_mask, f4 = e3.prev, c4 = e3.strstart + S2, d2 = u3[s3 + a3 - 1], p3 = u3[s3 + a3];
          e3.prev_length >= e3.good_match && (i3 >>= 2), o3 > e3.lookahead && (o3 = e3.lookahead);
          do {
            if (u3[(r3 = t3) + a3] === p3 && u3[r3 + a3 - 1] === d2 && u3[r3] === u3[s3] && u3[++r3] === u3[s3 + 1]) {
              s3 += 2, r3++;
              do {
              } while (u3[++s3] === u3[++r3] && u3[++s3] === u3[++r3] && u3[++s3] === u3[++r3] && u3[++s3] === u3[++r3] && u3[++s3] === u3[++r3] && u3[++s3] === u3[++r3] && u3[++s3] === u3[++r3] && u3[++s3] === u3[++r3] && s3 < c4);
              if (n3 = S2 - (c4 - s3), s3 = c4 - S2, a3 < n3) {
                if (e3.match_start = t3, o3 <= (a3 = n3))
                  break;
                d2 = u3[s3 + a3 - 1], p3 = u3[s3 + a3];
              }
            }
          } while ((t3 = f4[t3 & l3]) > h3 && 0 != --i3);
          return a3 <= e3.lookahead ? a3 : e3.lookahead;
        }
        function j(e3) {
          var t3, r3, n3, i3, s3, a3, o3, h3, u3, l3, f4 = e3.w_size;
          do {
            if (i3 = e3.window_size - e3.lookahead - e3.strstart, e3.strstart >= f4 + (f4 - z)) {
              for (c3.arraySet(e3.window, e3.window, f4, f4, 0), e3.match_start -= f4, e3.strstart -= f4, e3.block_start -= f4, t3 = r3 = e3.hash_size; n3 = e3.head[--t3], e3.head[t3] = f4 <= n3 ? n3 - f4 : 0, --r3; )
                ;
              for (t3 = r3 = f4; n3 = e3.prev[--t3], e3.prev[t3] = f4 <= n3 ? n3 - f4 : 0, --r3; )
                ;
              i3 += f4;
            }
            if (0 === e3.strm.avail_in)
              break;
            if (a3 = e3.strm, o3 = e3.window, h3 = e3.strstart + e3.lookahead, u3 = i3, l3 = void 0, l3 = a3.avail_in, u3 < l3 && (l3 = u3), r3 = 0 === l3 ? 0 : (a3.avail_in -= l3, c3.arraySet(o3, a3.input, a3.next_in, l3, h3), 1 === a3.state.wrap ? a3.adler = d(a3.adler, o3, l3, h3) : 2 === a3.state.wrap && (a3.adler = p2(a3.adler, o3, l3, h3)), a3.next_in += l3, a3.total_in += l3, l3), e3.lookahead += r3, e3.lookahead + e3.insert >= x2)
              for (s3 = e3.strstart - e3.insert, e3.ins_h = e3.window[s3], e3.ins_h = (e3.ins_h << e3.hash_shift ^ e3.window[s3 + 1]) & e3.hash_mask; e3.insert && (e3.ins_h = (e3.ins_h << e3.hash_shift ^ e3.window[s3 + x2 - 1]) & e3.hash_mask, e3.prev[s3 & e3.w_mask] = e3.head[e3.ins_h], e3.head[e3.ins_h] = s3, s3++, e3.insert--, !(e3.lookahead + e3.insert < x2)); )
                ;
          } while (e3.lookahead < z && 0 !== e3.strm.avail_in);
        }
        function Z(e3, t3) {
          for (var r3, n3; ; ) {
            if (e3.lookahead < z) {
              if (j(e3), e3.lookahead < z && t3 === l2)
                return A2;
              if (0 === e3.lookahead)
                break;
            }
            if (r3 = 0, e3.lookahead >= x2 && (e3.ins_h = (e3.ins_h << e3.hash_shift ^ e3.window[e3.strstart + x2 - 1]) & e3.hash_mask, r3 = e3.prev[e3.strstart & e3.w_mask] = e3.head[e3.ins_h], e3.head[e3.ins_h] = e3.strstart), 0 !== r3 && e3.strstart - r3 <= e3.w_size - z && (e3.match_length = L(e3, r3)), e3.match_length >= x2)
              if (n3 = u2._tr_tally(e3, e3.strstart - e3.match_start, e3.match_length - x2), e3.lookahead -= e3.match_length, e3.match_length <= e3.max_lazy_match && e3.lookahead >= x2) {
                for (e3.match_length--; e3.strstart++, e3.ins_h = (e3.ins_h << e3.hash_shift ^ e3.window[e3.strstart + x2 - 1]) & e3.hash_mask, r3 = e3.prev[e3.strstart & e3.w_mask] = e3.head[e3.ins_h], e3.head[e3.ins_h] = e3.strstart, 0 != --e3.match_length; )
                  ;
                e3.strstart++;
              } else
                e3.strstart += e3.match_length, e3.match_length = 0, e3.ins_h = e3.window[e3.strstart], e3.ins_h = (e3.ins_h << e3.hash_shift ^ e3.window[e3.strstart + 1]) & e3.hash_mask;
            else
              n3 = u2._tr_tally(e3, 0, e3.window[e3.strstart]), e3.lookahead--, e3.strstart++;
            if (n3 && (N2(e3, false), 0 === e3.strm.avail_out))
              return A2;
          }
          return e3.insert = e3.strstart < x2 - 1 ? e3.strstart : x2 - 1, t3 === f3 ? (N2(e3, true), 0 === e3.strm.avail_out ? O2 : B) : e3.last_lit && (N2(e3, false), 0 === e3.strm.avail_out) ? A2 : I;
        }
        function W(e3, t3) {
          for (var r3, n3, i3; ; ) {
            if (e3.lookahead < z) {
              if (j(e3), e3.lookahead < z && t3 === l2)
                return A2;
              if (0 === e3.lookahead)
                break;
            }
            if (r3 = 0, e3.lookahead >= x2 && (e3.ins_h = (e3.ins_h << e3.hash_shift ^ e3.window[e3.strstart + x2 - 1]) & e3.hash_mask, r3 = e3.prev[e3.strstart & e3.w_mask] = e3.head[e3.ins_h], e3.head[e3.ins_h] = e3.strstart), e3.prev_length = e3.match_length, e3.prev_match = e3.match_start, e3.match_length = x2 - 1, 0 !== r3 && e3.prev_length < e3.max_lazy_match && e3.strstart - r3 <= e3.w_size - z && (e3.match_length = L(e3, r3), e3.match_length <= 5 && (1 === e3.strategy || e3.match_length === x2 && 4096 < e3.strstart - e3.match_start) && (e3.match_length = x2 - 1)), e3.prev_length >= x2 && e3.match_length <= e3.prev_length) {
              for (i3 = e3.strstart + e3.lookahead - x2, n3 = u2._tr_tally(e3, e3.strstart - 1 - e3.prev_match, e3.prev_length - x2), e3.lookahead -= e3.prev_length - 1, e3.prev_length -= 2; ++e3.strstart <= i3 && (e3.ins_h = (e3.ins_h << e3.hash_shift ^ e3.window[e3.strstart + x2 - 1]) & e3.hash_mask, r3 = e3.prev[e3.strstart & e3.w_mask] = e3.head[e3.ins_h], e3.head[e3.ins_h] = e3.strstart), 0 != --e3.prev_length; )
                ;
              if (e3.match_available = 0, e3.match_length = x2 - 1, e3.strstart++, n3 && (N2(e3, false), 0 === e3.strm.avail_out))
                return A2;
            } else if (e3.match_available) {
              if ((n3 = u2._tr_tally(e3, 0, e3.window[e3.strstart - 1])) && N2(e3, false), e3.strstart++, e3.lookahead--, 0 === e3.strm.avail_out)
                return A2;
            } else
              e3.match_available = 1, e3.strstart++, e3.lookahead--;
          }
          return e3.match_available && (n3 = u2._tr_tally(e3, 0, e3.window[e3.strstart - 1]), e3.match_available = 0), e3.insert = e3.strstart < x2 - 1 ? e3.strstart : x2 - 1, t3 === f3 ? (N2(e3, true), 0 === e3.strm.avail_out ? O2 : B) : e3.last_lit && (N2(e3, false), 0 === e3.strm.avail_out) ? A2 : I;
        }
        function M(e3, t3, r3, n3, i3) {
          this.good_length = e3, this.max_lazy = t3, this.nice_length = r3, this.max_chain = n3, this.func = i3;
        }
        function H() {
          this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = v2, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new c3.Buf16(2 * w), this.dyn_dtree = new c3.Buf16(2 * (2 * a2 + 1)), this.bl_tree = new c3.Buf16(2 * (2 * o2 + 1)), D2(this.dyn_ltree), D2(this.dyn_dtree), D2(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new c3.Buf16(k + 1), this.heap = new c3.Buf16(2 * s2 + 1), D2(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new c3.Buf16(2 * s2 + 1), D2(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
        }
        function G2(e3) {
          var t3;
          return e3 && e3.state ? (e3.total_in = e3.total_out = 0, e3.data_type = i2, (t3 = e3.state).pending = 0, t3.pending_out = 0, t3.wrap < 0 && (t3.wrap = -t3.wrap), t3.status = t3.wrap ? C : E, e3.adler = 2 === t3.wrap ? 0 : 1, t3.last_flush = l2, u2._tr_init(t3), m3) : R(e3, _2);
        }
        function K(e3) {
          var t3 = G2(e3);
          return t3 === m3 && function(e4) {
            e4.window_size = 2 * e4.w_size, D2(e4.head), e4.max_lazy_match = h2[e4.level].max_lazy, e4.good_match = h2[e4.level].good_length, e4.nice_match = h2[e4.level].nice_length, e4.max_chain_length = h2[e4.level].max_chain, e4.strstart = 0, e4.block_start = 0, e4.lookahead = 0, e4.insert = 0, e4.match_length = e4.prev_length = x2 - 1, e4.match_available = 0, e4.ins_h = 0;
          }(e3.state), t3;
        }
        function Y(e3, t3, r3, n3, i3, s3) {
          if (!e3)
            return _2;
          var a3 = 1;
          if (t3 === g && (t3 = 6), n3 < 0 ? (a3 = 0, n3 = -n3) : 15 < n3 && (a3 = 2, n3 -= 16), i3 < 1 || y3 < i3 || r3 !== v2 || n3 < 8 || 15 < n3 || t3 < 0 || 9 < t3 || s3 < 0 || b < s3)
            return R(e3, _2);
          8 === n3 && (n3 = 9);
          var o3 = new H();
          return (e3.state = o3).strm = e3, o3.wrap = a3, o3.gzhead = null, o3.w_bits = n3, o3.w_size = 1 << o3.w_bits, o3.w_mask = o3.w_size - 1, o3.hash_bits = i3 + 7, o3.hash_size = 1 << o3.hash_bits, o3.hash_mask = o3.hash_size - 1, o3.hash_shift = ~~((o3.hash_bits + x2 - 1) / x2), o3.window = new c3.Buf8(2 * o3.w_size), o3.head = new c3.Buf16(o3.hash_size), o3.prev = new c3.Buf16(o3.w_size), o3.lit_bufsize = 1 << i3 + 6, o3.pending_buf_size = 4 * o3.lit_bufsize, o3.pending_buf = new c3.Buf8(o3.pending_buf_size), o3.d_buf = 1 * o3.lit_bufsize, o3.l_buf = 3 * o3.lit_bufsize, o3.level = t3, o3.strategy = s3, o3.method = r3, K(e3);
        }
        h2 = [new M(0, 0, 0, 0, function(e3, t3) {
          var r3 = 65535;
          for (r3 > e3.pending_buf_size - 5 && (r3 = e3.pending_buf_size - 5); ; ) {
            if (e3.lookahead <= 1) {
              if (j(e3), 0 === e3.lookahead && t3 === l2)
                return A2;
              if (0 === e3.lookahead)
                break;
            }
            e3.strstart += e3.lookahead, e3.lookahead = 0;
            var n3 = e3.block_start + r3;
            if ((0 === e3.strstart || e3.strstart >= n3) && (e3.lookahead = e3.strstart - n3, e3.strstart = n3, N2(e3, false), 0 === e3.strm.avail_out))
              return A2;
            if (e3.strstart - e3.block_start >= e3.w_size - z && (N2(e3, false), 0 === e3.strm.avail_out))
              return A2;
          }
          return e3.insert = 0, t3 === f3 ? (N2(e3, true), 0 === e3.strm.avail_out ? O2 : B) : (e3.strstart > e3.block_start && (N2(e3, false), e3.strm.avail_out), A2);
        }), new M(4, 4, 8, 4, Z), new M(4, 5, 16, 8, Z), new M(4, 6, 32, 32, Z), new M(4, 4, 16, 16, W), new M(8, 16, 32, 32, W), new M(8, 16, 128, 128, W), new M(8, 32, 128, 256, W), new M(32, 128, 258, 1024, W), new M(32, 258, 258, 4096, W)], r2.deflateInit = function(e3, t3) {
          return Y(e3, t3, v2, 15, 8, 0);
        }, r2.deflateInit2 = Y, r2.deflateReset = K, r2.deflateResetKeep = G2, r2.deflateSetHeader = function(e3, t3) {
          return e3 && e3.state ? 2 !== e3.state.wrap ? _2 : (e3.state.gzhead = t3, m3) : _2;
        }, r2.deflate = function(e3, t3) {
          var r3, n3, i3, s3;
          if (!e3 || !e3.state || 5 < t3 || t3 < 0)
            return e3 ? R(e3, _2) : _2;
          if (n3 = e3.state, !e3.output || !e3.input && 0 !== e3.avail_in || 666 === n3.status && t3 !== f3)
            return R(e3, 0 === e3.avail_out ? -5 : _2);
          if (n3.strm = e3, r3 = n3.last_flush, n3.last_flush = t3, n3.status === C)
            if (2 === n3.wrap)
              e3.adler = 0, U(n3, 31), U(n3, 139), U(n3, 8), n3.gzhead ? (U(n3, (n3.gzhead.text ? 1 : 0) + (n3.gzhead.hcrc ? 2 : 0) + (n3.gzhead.extra ? 4 : 0) + (n3.gzhead.name ? 8 : 0) + (n3.gzhead.comment ? 16 : 0)), U(n3, 255 & n3.gzhead.time), U(n3, n3.gzhead.time >> 8 & 255), U(n3, n3.gzhead.time >> 16 & 255), U(n3, n3.gzhead.time >> 24 & 255), U(n3, 9 === n3.level ? 2 : 2 <= n3.strategy || n3.level < 2 ? 4 : 0), U(n3, 255 & n3.gzhead.os), n3.gzhead.extra && n3.gzhead.extra.length && (U(n3, 255 & n3.gzhead.extra.length), U(n3, n3.gzhead.extra.length >> 8 & 255)), n3.gzhead.hcrc && (e3.adler = p2(e3.adler, n3.pending_buf, n3.pending, 0)), n3.gzindex = 0, n3.status = 69) : (U(n3, 0), U(n3, 0), U(n3, 0), U(n3, 0), U(n3, 0), U(n3, 9 === n3.level ? 2 : 2 <= n3.strategy || n3.level < 2 ? 4 : 0), U(n3, 3), n3.status = E);
            else {
              var a3 = v2 + (n3.w_bits - 8 << 4) << 8;
              a3 |= (2 <= n3.strategy || n3.level < 2 ? 0 : n3.level < 6 ? 1 : 6 === n3.level ? 2 : 3) << 6, 0 !== n3.strstart && (a3 |= 32), a3 += 31 - a3 % 31, n3.status = E, P(n3, a3), 0 !== n3.strstart && (P(n3, e3.adler >>> 16), P(n3, 65535 & e3.adler)), e3.adler = 1;
            }
          if (69 === n3.status)
            if (n3.gzhead.extra) {
              for (i3 = n3.pending; n3.gzindex < (65535 & n3.gzhead.extra.length) && (n3.pending !== n3.pending_buf_size || (n3.gzhead.hcrc && n3.pending > i3 && (e3.adler = p2(e3.adler, n3.pending_buf, n3.pending - i3, i3)), F(e3), i3 = n3.pending, n3.pending !== n3.pending_buf_size)); )
                U(n3, 255 & n3.gzhead.extra[n3.gzindex]), n3.gzindex++;
              n3.gzhead.hcrc && n3.pending > i3 && (e3.adler = p2(e3.adler, n3.pending_buf, n3.pending - i3, i3)), n3.gzindex === n3.gzhead.extra.length && (n3.gzindex = 0, n3.status = 73);
            } else
              n3.status = 73;
          if (73 === n3.status)
            if (n3.gzhead.name) {
              i3 = n3.pending;
              do {
                if (n3.pending === n3.pending_buf_size && (n3.gzhead.hcrc && n3.pending > i3 && (e3.adler = p2(e3.adler, n3.pending_buf, n3.pending - i3, i3)), F(e3), i3 = n3.pending, n3.pending === n3.pending_buf_size)) {
                  s3 = 1;
                  break;
                }
                s3 = n3.gzindex < n3.gzhead.name.length ? 255 & n3.gzhead.name.charCodeAt(n3.gzindex++) : 0, U(n3, s3);
              } while (0 !== s3);
              n3.gzhead.hcrc && n3.pending > i3 && (e3.adler = p2(e3.adler, n3.pending_buf, n3.pending - i3, i3)), 0 === s3 && (n3.gzindex = 0, n3.status = 91);
            } else
              n3.status = 91;
          if (91 === n3.status)
            if (n3.gzhead.comment) {
              i3 = n3.pending;
              do {
                if (n3.pending === n3.pending_buf_size && (n3.gzhead.hcrc && n3.pending > i3 && (e3.adler = p2(e3.adler, n3.pending_buf, n3.pending - i3, i3)), F(e3), i3 = n3.pending, n3.pending === n3.pending_buf_size)) {
                  s3 = 1;
                  break;
                }
                s3 = n3.gzindex < n3.gzhead.comment.length ? 255 & n3.gzhead.comment.charCodeAt(n3.gzindex++) : 0, U(n3, s3);
              } while (0 !== s3);
              n3.gzhead.hcrc && n3.pending > i3 && (e3.adler = p2(e3.adler, n3.pending_buf, n3.pending - i3, i3)), 0 === s3 && (n3.status = 103);
            } else
              n3.status = 103;
          if (103 === n3.status && (n3.gzhead.hcrc ? (n3.pending + 2 > n3.pending_buf_size && F(e3), n3.pending + 2 <= n3.pending_buf_size && (U(n3, 255 & e3.adler), U(n3, e3.adler >> 8 & 255), e3.adler = 0, n3.status = E)) : n3.status = E), 0 !== n3.pending) {
            if (F(e3), 0 === e3.avail_out)
              return n3.last_flush = -1, m3;
          } else if (0 === e3.avail_in && T3(t3) <= T3(r3) && t3 !== f3)
            return R(e3, -5);
          if (666 === n3.status && 0 !== e3.avail_in)
            return R(e3, -5);
          if (0 !== e3.avail_in || 0 !== n3.lookahead || t3 !== l2 && 666 !== n3.status) {
            var o3 = 2 === n3.strategy ? function(e4, t4) {
              for (var r4; ; ) {
                if (0 === e4.lookahead && (j(e4), 0 === e4.lookahead)) {
                  if (t4 === l2)
                    return A2;
                  break;
                }
                if (e4.match_length = 0, r4 = u2._tr_tally(e4, 0, e4.window[e4.strstart]), e4.lookahead--, e4.strstart++, r4 && (N2(e4, false), 0 === e4.strm.avail_out))
                  return A2;
              }
              return e4.insert = 0, t4 === f3 ? (N2(e4, true), 0 === e4.strm.avail_out ? O2 : B) : e4.last_lit && (N2(e4, false), 0 === e4.strm.avail_out) ? A2 : I;
            }(n3, t3) : 3 === n3.strategy ? function(e4, t4) {
              for (var r4, n4, i4, s4, a4 = e4.window; ; ) {
                if (e4.lookahead <= S2) {
                  if (j(e4), e4.lookahead <= S2 && t4 === l2)
                    return A2;
                  if (0 === e4.lookahead)
                    break;
                }
                if (e4.match_length = 0, e4.lookahead >= x2 && 0 < e4.strstart && (n4 = a4[i4 = e4.strstart - 1]) === a4[++i4] && n4 === a4[++i4] && n4 === a4[++i4]) {
                  s4 = e4.strstart + S2;
                  do {
                  } while (n4 === a4[++i4] && n4 === a4[++i4] && n4 === a4[++i4] && n4 === a4[++i4] && n4 === a4[++i4] && n4 === a4[++i4] && n4 === a4[++i4] && n4 === a4[++i4] && i4 < s4);
                  e4.match_length = S2 - (s4 - i4), e4.match_length > e4.lookahead && (e4.match_length = e4.lookahead);
                }
                if (e4.match_length >= x2 ? (r4 = u2._tr_tally(e4, 1, e4.match_length - x2), e4.lookahead -= e4.match_length, e4.strstart += e4.match_length, e4.match_length = 0) : (r4 = u2._tr_tally(e4, 0, e4.window[e4.strstart]), e4.lookahead--, e4.strstart++), r4 && (N2(e4, false), 0 === e4.strm.avail_out))
                  return A2;
              }
              return e4.insert = 0, t4 === f3 ? (N2(e4, true), 0 === e4.strm.avail_out ? O2 : B) : e4.last_lit && (N2(e4, false), 0 === e4.strm.avail_out) ? A2 : I;
            }(n3, t3) : h2[n3.level].func(n3, t3);
            if (o3 !== O2 && o3 !== B || (n3.status = 666), o3 === A2 || o3 === O2)
              return 0 === e3.avail_out && (n3.last_flush = -1), m3;
            if (o3 === I && (1 === t3 ? u2._tr_align(n3) : 5 !== t3 && (u2._tr_stored_block(n3, 0, 0, false), 3 === t3 && (D2(n3.head), 0 === n3.lookahead && (n3.strstart = 0, n3.block_start = 0, n3.insert = 0))), F(e3), 0 === e3.avail_out))
              return n3.last_flush = -1, m3;
          }
          return t3 !== f3 ? m3 : n3.wrap <= 0 ? 1 : (2 === n3.wrap ? (U(n3, 255 & e3.adler), U(n3, e3.adler >> 8 & 255), U(n3, e3.adler >> 16 & 255), U(n3, e3.adler >> 24 & 255), U(n3, 255 & e3.total_in), U(n3, e3.total_in >> 8 & 255), U(n3, e3.total_in >> 16 & 255), U(n3, e3.total_in >> 24 & 255)) : (P(n3, e3.adler >>> 16), P(n3, 65535 & e3.adler)), F(e3), 0 < n3.wrap && (n3.wrap = -n3.wrap), 0 !== n3.pending ? m3 : 1);
        }, r2.deflateEnd = function(e3) {
          var t3;
          return e3 && e3.state ? (t3 = e3.state.status) !== C && 69 !== t3 && 73 !== t3 && 91 !== t3 && 103 !== t3 && t3 !== E && 666 !== t3 ? R(e3, _2) : (e3.state = null, t3 === E ? R(e3, -3) : m3) : _2;
        }, r2.deflateSetDictionary = function(e3, t3) {
          var r3, n3, i3, s3, a3, o3, h3, u3, l3 = t3.length;
          if (!e3 || !e3.state)
            return _2;
          if (2 === (s3 = (r3 = e3.state).wrap) || 1 === s3 && r3.status !== C || r3.lookahead)
            return _2;
          for (1 === s3 && (e3.adler = d(e3.adler, t3, l3, 0)), r3.wrap = 0, l3 >= r3.w_size && (0 === s3 && (D2(r3.head), r3.strstart = 0, r3.block_start = 0, r3.insert = 0), u3 = new c3.Buf8(r3.w_size), c3.arraySet(u3, t3, l3 - r3.w_size, r3.w_size, 0), t3 = u3, l3 = r3.w_size), a3 = e3.avail_in, o3 = e3.next_in, h3 = e3.input, e3.avail_in = l3, e3.next_in = 0, e3.input = t3, j(r3); r3.lookahead >= x2; ) {
            for (n3 = r3.strstart, i3 = r3.lookahead - (x2 - 1); r3.ins_h = (r3.ins_h << r3.hash_shift ^ r3.window[n3 + x2 - 1]) & r3.hash_mask, r3.prev[n3 & r3.w_mask] = r3.head[r3.ins_h], r3.head[r3.ins_h] = n3, n3++, --i3; )
              ;
            r3.strstart = n3, r3.lookahead = x2 - 1, j(r3);
          }
          return r3.strstart += r3.lookahead, r3.block_start = r3.strstart, r3.insert = r3.lookahead, r3.lookahead = 0, r3.match_length = r3.prev_length = x2 - 1, r3.match_available = 0, e3.next_in = o3, e3.input = h3, e3.avail_in = a3, r3.wrap = s3, m3;
        }, r2.deflateInfo = "pako deflate (from Nodeca project)";
      }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./messages": 51, "./trees": 52 }], 47: [function(e2, t2, r2) {
        "use strict";
        t2.exports = function() {
          this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = false;
        };
      }, {}], 48: [function(e2, t2, r2) {
        "use strict";
        t2.exports = function(e3, t3) {
          var r3, n2, i2, s2, a2, o2, h2, u2, l2, f3, c3, d, p2, m3, _2, g, b, v2, y3, w, k, x2, S2, z, C;
          r3 = e3.state, n2 = e3.next_in, z = e3.input, i2 = n2 + (e3.avail_in - 5), s2 = e3.next_out, C = e3.output, a2 = s2 - (t3 - e3.avail_out), o2 = s2 + (e3.avail_out - 257), h2 = r3.dmax, u2 = r3.wsize, l2 = r3.whave, f3 = r3.wnext, c3 = r3.window, d = r3.hold, p2 = r3.bits, m3 = r3.lencode, _2 = r3.distcode, g = (1 << r3.lenbits) - 1, b = (1 << r3.distbits) - 1;
          e:
            do {
              p2 < 15 && (d += z[n2++] << p2, p2 += 8, d += z[n2++] << p2, p2 += 8), v2 = m3[d & g];
              t:
                for (; ; ) {
                  if (d >>>= y3 = v2 >>> 24, p2 -= y3, 0 === (y3 = v2 >>> 16 & 255))
                    C[s2++] = 65535 & v2;
                  else {
                    if (!(16 & y3)) {
                      if (0 == (64 & y3)) {
                        v2 = m3[(65535 & v2) + (d & (1 << y3) - 1)];
                        continue t;
                      }
                      if (32 & y3) {
                        r3.mode = 12;
                        break e;
                      }
                      e3.msg = "invalid literal/length code", r3.mode = 30;
                      break e;
                    }
                    w = 65535 & v2, (y3 &= 15) && (p2 < y3 && (d += z[n2++] << p2, p2 += 8), w += d & (1 << y3) - 1, d >>>= y3, p2 -= y3), p2 < 15 && (d += z[n2++] << p2, p2 += 8, d += z[n2++] << p2, p2 += 8), v2 = _2[d & b];
                    r:
                      for (; ; ) {
                        if (d >>>= y3 = v2 >>> 24, p2 -= y3, !(16 & (y3 = v2 >>> 16 & 255))) {
                          if (0 == (64 & y3)) {
                            v2 = _2[(65535 & v2) + (d & (1 << y3) - 1)];
                            continue r;
                          }
                          e3.msg = "invalid distance code", r3.mode = 30;
                          break e;
                        }
                        if (k = 65535 & v2, p2 < (y3 &= 15) && (d += z[n2++] << p2, (p2 += 8) < y3 && (d += z[n2++] << p2, p2 += 8)), h2 < (k += d & (1 << y3) - 1)) {
                          e3.msg = "invalid distance too far back", r3.mode = 30;
                          break e;
                        }
                        if (d >>>= y3, p2 -= y3, (y3 = s2 - a2) < k) {
                          if (l2 < (y3 = k - y3) && r3.sane) {
                            e3.msg = "invalid distance too far back", r3.mode = 30;
                            break e;
                          }
                          if (S2 = c3, (x2 = 0) === f3) {
                            if (x2 += u2 - y3, y3 < w) {
                              for (w -= y3; C[s2++] = c3[x2++], --y3; )
                                ;
                              x2 = s2 - k, S2 = C;
                            }
                          } else if (f3 < y3) {
                            if (x2 += u2 + f3 - y3, (y3 -= f3) < w) {
                              for (w -= y3; C[s2++] = c3[x2++], --y3; )
                                ;
                              if (x2 = 0, f3 < w) {
                                for (w -= y3 = f3; C[s2++] = c3[x2++], --y3; )
                                  ;
                                x2 = s2 - k, S2 = C;
                              }
                            }
                          } else if (x2 += f3 - y3, y3 < w) {
                            for (w -= y3; C[s2++] = c3[x2++], --y3; )
                              ;
                            x2 = s2 - k, S2 = C;
                          }
                          for (; 2 < w; )
                            C[s2++] = S2[x2++], C[s2++] = S2[x2++], C[s2++] = S2[x2++], w -= 3;
                          w && (C[s2++] = S2[x2++], 1 < w && (C[s2++] = S2[x2++]));
                        } else {
                          for (x2 = s2 - k; C[s2++] = C[x2++], C[s2++] = C[x2++], C[s2++] = C[x2++], 2 < (w -= 3); )
                            ;
                          w && (C[s2++] = C[x2++], 1 < w && (C[s2++] = C[x2++]));
                        }
                        break;
                      }
                  }
                  break;
                }
            } while (n2 < i2 && s2 < o2);
          n2 -= w = p2 >> 3, d &= (1 << (p2 -= w << 3)) - 1, e3.next_in = n2, e3.next_out = s2, e3.avail_in = n2 < i2 ? i2 - n2 + 5 : 5 - (n2 - i2), e3.avail_out = s2 < o2 ? o2 - s2 + 257 : 257 - (s2 - o2), r3.hold = d, r3.bits = p2;
        };
      }, {}], 49: [function(e2, t2, r2) {
        "use strict";
        var I = e2("../utils/common"), O2 = e2("./adler32"), B = e2("./crc32"), R = e2("./inffast"), T3 = e2("./inftrees"), D2 = 1, F = 2, N2 = 0, U = -2, P = 1, n2 = 852, i2 = 592;
        function L(e3) {
          return (e3 >>> 24 & 255) + (e3 >>> 8 & 65280) + ((65280 & e3) << 8) + ((255 & e3) << 24);
        }
        function s2() {
          this.mode = 0, this.last = false, this.wrap = 0, this.havedict = false, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new I.Buf16(320), this.work = new I.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
        }
        function a2(e3) {
          var t3;
          return e3 && e3.state ? (t3 = e3.state, e3.total_in = e3.total_out = t3.total = 0, e3.msg = "", t3.wrap && (e3.adler = 1 & t3.wrap), t3.mode = P, t3.last = 0, t3.havedict = 0, t3.dmax = 32768, t3.head = null, t3.hold = 0, t3.bits = 0, t3.lencode = t3.lendyn = new I.Buf32(n2), t3.distcode = t3.distdyn = new I.Buf32(i2), t3.sane = 1, t3.back = -1, N2) : U;
        }
        function o2(e3) {
          var t3;
          return e3 && e3.state ? ((t3 = e3.state).wsize = 0, t3.whave = 0, t3.wnext = 0, a2(e3)) : U;
        }
        function h2(e3, t3) {
          var r3, n3;
          return e3 && e3.state ? (n3 = e3.state, t3 < 0 ? (r3 = 0, t3 = -t3) : (r3 = 1 + (t3 >> 4), t3 < 48 && (t3 &= 15)), t3 && (t3 < 8 || 15 < t3) ? U : (null !== n3.window && n3.wbits !== t3 && (n3.window = null), n3.wrap = r3, n3.wbits = t3, o2(e3))) : U;
        }
        function u2(e3, t3) {
          var r3, n3;
          return e3 ? (n3 = new s2(), (e3.state = n3).window = null, (r3 = h2(e3, t3)) !== N2 && (e3.state = null), r3) : U;
        }
        var l2, f3, c3 = true;
        function j(e3) {
          if (c3) {
            var t3;
            for (l2 = new I.Buf32(512), f3 = new I.Buf32(32), t3 = 0; t3 < 144; )
              e3.lens[t3++] = 8;
            for (; t3 < 256; )
              e3.lens[t3++] = 9;
            for (; t3 < 280; )
              e3.lens[t3++] = 7;
            for (; t3 < 288; )
              e3.lens[t3++] = 8;
            for (T3(D2, e3.lens, 0, 288, l2, 0, e3.work, { bits: 9 }), t3 = 0; t3 < 32; )
              e3.lens[t3++] = 5;
            T3(F, e3.lens, 0, 32, f3, 0, e3.work, { bits: 5 }), c3 = false;
          }
          e3.lencode = l2, e3.lenbits = 9, e3.distcode = f3, e3.distbits = 5;
        }
        function Z(e3, t3, r3, n3) {
          var i3, s3 = e3.state;
          return null === s3.window && (s3.wsize = 1 << s3.wbits, s3.wnext = 0, s3.whave = 0, s3.window = new I.Buf8(s3.wsize)), n3 >= s3.wsize ? (I.arraySet(s3.window, t3, r3 - s3.wsize, s3.wsize, 0), s3.wnext = 0, s3.whave = s3.wsize) : (n3 < (i3 = s3.wsize - s3.wnext) && (i3 = n3), I.arraySet(s3.window, t3, r3 - n3, i3, s3.wnext), (n3 -= i3) ? (I.arraySet(s3.window, t3, r3 - n3, n3, 0), s3.wnext = n3, s3.whave = s3.wsize) : (s3.wnext += i3, s3.wnext === s3.wsize && (s3.wnext = 0), s3.whave < s3.wsize && (s3.whave += i3))), 0;
        }
        r2.inflateReset = o2, r2.inflateReset2 = h2, r2.inflateResetKeep = a2, r2.inflateInit = function(e3) {
          return u2(e3, 15);
        }, r2.inflateInit2 = u2, r2.inflate = function(e3, t3) {
          var r3, n3, i3, s3, a3, o3, h3, u3, l3, f4, c4, d, p2, m3, _2, g, b, v2, y3, w, k, x2, S2, z, C = 0, E = new I.Buf8(4), A2 = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
          if (!e3 || !e3.state || !e3.output || !e3.input && 0 !== e3.avail_in)
            return U;
          12 === (r3 = e3.state).mode && (r3.mode = 13), a3 = e3.next_out, i3 = e3.output, h3 = e3.avail_out, s3 = e3.next_in, n3 = e3.input, o3 = e3.avail_in, u3 = r3.hold, l3 = r3.bits, f4 = o3, c4 = h3, x2 = N2;
          e:
            for (; ; )
              switch (r3.mode) {
                case P:
                  if (0 === r3.wrap) {
                    r3.mode = 13;
                    break;
                  }
                  for (; l3 < 16; ) {
                    if (0 === o3)
                      break e;
                    o3--, u3 += n3[s3++] << l3, l3 += 8;
                  }
                  if (2 & r3.wrap && 35615 === u3) {
                    E[r3.check = 0] = 255 & u3, E[1] = u3 >>> 8 & 255, r3.check = B(r3.check, E, 2, 0), l3 = u3 = 0, r3.mode = 2;
                    break;
                  }
                  if (r3.flags = 0, r3.head && (r3.head.done = false), !(1 & r3.wrap) || (((255 & u3) << 8) + (u3 >> 8)) % 31) {
                    e3.msg = "incorrect header check", r3.mode = 30;
                    break;
                  }
                  if (8 != (15 & u3)) {
                    e3.msg = "unknown compression method", r3.mode = 30;
                    break;
                  }
                  if (l3 -= 4, k = 8 + (15 & (u3 >>>= 4)), 0 === r3.wbits)
                    r3.wbits = k;
                  else if (k > r3.wbits) {
                    e3.msg = "invalid window size", r3.mode = 30;
                    break;
                  }
                  r3.dmax = 1 << k, e3.adler = r3.check = 1, r3.mode = 512 & u3 ? 10 : 12, l3 = u3 = 0;
                  break;
                case 2:
                  for (; l3 < 16; ) {
                    if (0 === o3)
                      break e;
                    o3--, u3 += n3[s3++] << l3, l3 += 8;
                  }
                  if (r3.flags = u3, 8 != (255 & r3.flags)) {
                    e3.msg = "unknown compression method", r3.mode = 30;
                    break;
                  }
                  if (57344 & r3.flags) {
                    e3.msg = "unknown header flags set", r3.mode = 30;
                    break;
                  }
                  r3.head && (r3.head.text = u3 >> 8 & 1), 512 & r3.flags && (E[0] = 255 & u3, E[1] = u3 >>> 8 & 255, r3.check = B(r3.check, E, 2, 0)), l3 = u3 = 0, r3.mode = 3;
                case 3:
                  for (; l3 < 32; ) {
                    if (0 === o3)
                      break e;
                    o3--, u3 += n3[s3++] << l3, l3 += 8;
                  }
                  r3.head && (r3.head.time = u3), 512 & r3.flags && (E[0] = 255 & u3, E[1] = u3 >>> 8 & 255, E[2] = u3 >>> 16 & 255, E[3] = u3 >>> 24 & 255, r3.check = B(r3.check, E, 4, 0)), l3 = u3 = 0, r3.mode = 4;
                case 4:
                  for (; l3 < 16; ) {
                    if (0 === o3)
                      break e;
                    o3--, u3 += n3[s3++] << l3, l3 += 8;
                  }
                  r3.head && (r3.head.xflags = 255 & u3, r3.head.os = u3 >> 8), 512 & r3.flags && (E[0] = 255 & u3, E[1] = u3 >>> 8 & 255, r3.check = B(r3.check, E, 2, 0)), l3 = u3 = 0, r3.mode = 5;
                case 5:
                  if (1024 & r3.flags) {
                    for (; l3 < 16; ) {
                      if (0 === o3)
                        break e;
                      o3--, u3 += n3[s3++] << l3, l3 += 8;
                    }
                    r3.length = u3, r3.head && (r3.head.extra_len = u3), 512 & r3.flags && (E[0] = 255 & u3, E[1] = u3 >>> 8 & 255, r3.check = B(r3.check, E, 2, 0)), l3 = u3 = 0;
                  } else
                    r3.head && (r3.head.extra = null);
                  r3.mode = 6;
                case 6:
                  if (1024 & r3.flags && (o3 < (d = r3.length) && (d = o3), d && (r3.head && (k = r3.head.extra_len - r3.length, r3.head.extra || (r3.head.extra = new Array(r3.head.extra_len)), I.arraySet(r3.head.extra, n3, s3, d, k)), 512 & r3.flags && (r3.check = B(r3.check, n3, d, s3)), o3 -= d, s3 += d, r3.length -= d), r3.length))
                    break e;
                  r3.length = 0, r3.mode = 7;
                case 7:
                  if (2048 & r3.flags) {
                    if (0 === o3)
                      break e;
                    for (d = 0; k = n3[s3 + d++], r3.head && k && r3.length < 65536 && (r3.head.name += String.fromCharCode(k)), k && d < o3; )
                      ;
                    if (512 & r3.flags && (r3.check = B(r3.check, n3, d, s3)), o3 -= d, s3 += d, k)
                      break e;
                  } else
                    r3.head && (r3.head.name = null);
                  r3.length = 0, r3.mode = 8;
                case 8:
                  if (4096 & r3.flags) {
                    if (0 === o3)
                      break e;
                    for (d = 0; k = n3[s3 + d++], r3.head && k && r3.length < 65536 && (r3.head.comment += String.fromCharCode(k)), k && d < o3; )
                      ;
                    if (512 & r3.flags && (r3.check = B(r3.check, n3, d, s3)), o3 -= d, s3 += d, k)
                      break e;
                  } else
                    r3.head && (r3.head.comment = null);
                  r3.mode = 9;
                case 9:
                  if (512 & r3.flags) {
                    for (; l3 < 16; ) {
                      if (0 === o3)
                        break e;
                      o3--, u3 += n3[s3++] << l3, l3 += 8;
                    }
                    if (u3 !== (65535 & r3.check)) {
                      e3.msg = "header crc mismatch", r3.mode = 30;
                      break;
                    }
                    l3 = u3 = 0;
                  }
                  r3.head && (r3.head.hcrc = r3.flags >> 9 & 1, r3.head.done = true), e3.adler = r3.check = 0, r3.mode = 12;
                  break;
                case 10:
                  for (; l3 < 32; ) {
                    if (0 === o3)
                      break e;
                    o3--, u3 += n3[s3++] << l3, l3 += 8;
                  }
                  e3.adler = r3.check = L(u3), l3 = u3 = 0, r3.mode = 11;
                case 11:
                  if (0 === r3.havedict)
                    return e3.next_out = a3, e3.avail_out = h3, e3.next_in = s3, e3.avail_in = o3, r3.hold = u3, r3.bits = l3, 2;
                  e3.adler = r3.check = 1, r3.mode = 12;
                case 12:
                  if (5 === t3 || 6 === t3)
                    break e;
                case 13:
                  if (r3.last) {
                    u3 >>>= 7 & l3, l3 -= 7 & l3, r3.mode = 27;
                    break;
                  }
                  for (; l3 < 3; ) {
                    if (0 === o3)
                      break e;
                    o3--, u3 += n3[s3++] << l3, l3 += 8;
                  }
                  switch (r3.last = 1 & u3, l3 -= 1, 3 & (u3 >>>= 1)) {
                    case 0:
                      r3.mode = 14;
                      break;
                    case 1:
                      if (j(r3), r3.mode = 20, 6 !== t3)
                        break;
                      u3 >>>= 2, l3 -= 2;
                      break e;
                    case 2:
                      r3.mode = 17;
                      break;
                    case 3:
                      e3.msg = "invalid block type", r3.mode = 30;
                  }
                  u3 >>>= 2, l3 -= 2;
                  break;
                case 14:
                  for (u3 >>>= 7 & l3, l3 -= 7 & l3; l3 < 32; ) {
                    if (0 === o3)
                      break e;
                    o3--, u3 += n3[s3++] << l3, l3 += 8;
                  }
                  if ((65535 & u3) != (u3 >>> 16 ^ 65535)) {
                    e3.msg = "invalid stored block lengths", r3.mode = 30;
                    break;
                  }
                  if (r3.length = 65535 & u3, l3 = u3 = 0, r3.mode = 15, 6 === t3)
                    break e;
                case 15:
                  r3.mode = 16;
                case 16:
                  if (d = r3.length) {
                    if (o3 < d && (d = o3), h3 < d && (d = h3), 0 === d)
                      break e;
                    I.arraySet(i3, n3, s3, d, a3), o3 -= d, s3 += d, h3 -= d, a3 += d, r3.length -= d;
                    break;
                  }
                  r3.mode = 12;
                  break;
                case 17:
                  for (; l3 < 14; ) {
                    if (0 === o3)
                      break e;
                    o3--, u3 += n3[s3++] << l3, l3 += 8;
                  }
                  if (r3.nlen = 257 + (31 & u3), u3 >>>= 5, l3 -= 5, r3.ndist = 1 + (31 & u3), u3 >>>= 5, l3 -= 5, r3.ncode = 4 + (15 & u3), u3 >>>= 4, l3 -= 4, 286 < r3.nlen || 30 < r3.ndist) {
                    e3.msg = "too many length or distance symbols", r3.mode = 30;
                    break;
                  }
                  r3.have = 0, r3.mode = 18;
                case 18:
                  for (; r3.have < r3.ncode; ) {
                    for (; l3 < 3; ) {
                      if (0 === o3)
                        break e;
                      o3--, u3 += n3[s3++] << l3, l3 += 8;
                    }
                    r3.lens[A2[r3.have++]] = 7 & u3, u3 >>>= 3, l3 -= 3;
                  }
                  for (; r3.have < 19; )
                    r3.lens[A2[r3.have++]] = 0;
                  if (r3.lencode = r3.lendyn, r3.lenbits = 7, S2 = { bits: r3.lenbits }, x2 = T3(0, r3.lens, 0, 19, r3.lencode, 0, r3.work, S2), r3.lenbits = S2.bits, x2) {
                    e3.msg = "invalid code lengths set", r3.mode = 30;
                    break;
                  }
                  r3.have = 0, r3.mode = 19;
                case 19:
                  for (; r3.have < r3.nlen + r3.ndist; ) {
                    for (; g = (C = r3.lencode[u3 & (1 << r3.lenbits) - 1]) >>> 16 & 255, b = 65535 & C, !((_2 = C >>> 24) <= l3); ) {
                      if (0 === o3)
                        break e;
                      o3--, u3 += n3[s3++] << l3, l3 += 8;
                    }
                    if (b < 16)
                      u3 >>>= _2, l3 -= _2, r3.lens[r3.have++] = b;
                    else {
                      if (16 === b) {
                        for (z = _2 + 2; l3 < z; ) {
                          if (0 === o3)
                            break e;
                          o3--, u3 += n3[s3++] << l3, l3 += 8;
                        }
                        if (u3 >>>= _2, l3 -= _2, 0 === r3.have) {
                          e3.msg = "invalid bit length repeat", r3.mode = 30;
                          break;
                        }
                        k = r3.lens[r3.have - 1], d = 3 + (3 & u3), u3 >>>= 2, l3 -= 2;
                      } else if (17 === b) {
                        for (z = _2 + 3; l3 < z; ) {
                          if (0 === o3)
                            break e;
                          o3--, u3 += n3[s3++] << l3, l3 += 8;
                        }
                        l3 -= _2, k = 0, d = 3 + (7 & (u3 >>>= _2)), u3 >>>= 3, l3 -= 3;
                      } else {
                        for (z = _2 + 7; l3 < z; ) {
                          if (0 === o3)
                            break e;
                          o3--, u3 += n3[s3++] << l3, l3 += 8;
                        }
                        l3 -= _2, k = 0, d = 11 + (127 & (u3 >>>= _2)), u3 >>>= 7, l3 -= 7;
                      }
                      if (r3.have + d > r3.nlen + r3.ndist) {
                        e3.msg = "invalid bit length repeat", r3.mode = 30;
                        break;
                      }
                      for (; d--; )
                        r3.lens[r3.have++] = k;
                    }
                  }
                  if (30 === r3.mode)
                    break;
                  if (0 === r3.lens[256]) {
                    e3.msg = "invalid code -- missing end-of-block", r3.mode = 30;
                    break;
                  }
                  if (r3.lenbits = 9, S2 = { bits: r3.lenbits }, x2 = T3(D2, r3.lens, 0, r3.nlen, r3.lencode, 0, r3.work, S2), r3.lenbits = S2.bits, x2) {
                    e3.msg = "invalid literal/lengths set", r3.mode = 30;
                    break;
                  }
                  if (r3.distbits = 6, r3.distcode = r3.distdyn, S2 = { bits: r3.distbits }, x2 = T3(F, r3.lens, r3.nlen, r3.ndist, r3.distcode, 0, r3.work, S2), r3.distbits = S2.bits, x2) {
                    e3.msg = "invalid distances set", r3.mode = 30;
                    break;
                  }
                  if (r3.mode = 20, 6 === t3)
                    break e;
                case 20:
                  r3.mode = 21;
                case 21:
                  if (6 <= o3 && 258 <= h3) {
                    e3.next_out = a3, e3.avail_out = h3, e3.next_in = s3, e3.avail_in = o3, r3.hold = u3, r3.bits = l3, R(e3, c4), a3 = e3.next_out, i3 = e3.output, h3 = e3.avail_out, s3 = e3.next_in, n3 = e3.input, o3 = e3.avail_in, u3 = r3.hold, l3 = r3.bits, 12 === r3.mode && (r3.back = -1);
                    break;
                  }
                  for (r3.back = 0; g = (C = r3.lencode[u3 & (1 << r3.lenbits) - 1]) >>> 16 & 255, b = 65535 & C, !((_2 = C >>> 24) <= l3); ) {
                    if (0 === o3)
                      break e;
                    o3--, u3 += n3[s3++] << l3, l3 += 8;
                  }
                  if (g && 0 == (240 & g)) {
                    for (v2 = _2, y3 = g, w = b; g = (C = r3.lencode[w + ((u3 & (1 << v2 + y3) - 1) >> v2)]) >>> 16 & 255, b = 65535 & C, !(v2 + (_2 = C >>> 24) <= l3); ) {
                      if (0 === o3)
                        break e;
                      o3--, u3 += n3[s3++] << l3, l3 += 8;
                    }
                    u3 >>>= v2, l3 -= v2, r3.back += v2;
                  }
                  if (u3 >>>= _2, l3 -= _2, r3.back += _2, r3.length = b, 0 === g) {
                    r3.mode = 26;
                    break;
                  }
                  if (32 & g) {
                    r3.back = -1, r3.mode = 12;
                    break;
                  }
                  if (64 & g) {
                    e3.msg = "invalid literal/length code", r3.mode = 30;
                    break;
                  }
                  r3.extra = 15 & g, r3.mode = 22;
                case 22:
                  if (r3.extra) {
                    for (z = r3.extra; l3 < z; ) {
                      if (0 === o3)
                        break e;
                      o3--, u3 += n3[s3++] << l3, l3 += 8;
                    }
                    r3.length += u3 & (1 << r3.extra) - 1, u3 >>>= r3.extra, l3 -= r3.extra, r3.back += r3.extra;
                  }
                  r3.was = r3.length, r3.mode = 23;
                case 23:
                  for (; g = (C = r3.distcode[u3 & (1 << r3.distbits) - 1]) >>> 16 & 255, b = 65535 & C, !((_2 = C >>> 24) <= l3); ) {
                    if (0 === o3)
                      break e;
                    o3--, u3 += n3[s3++] << l3, l3 += 8;
                  }
                  if (0 == (240 & g)) {
                    for (v2 = _2, y3 = g, w = b; g = (C = r3.distcode[w + ((u3 & (1 << v2 + y3) - 1) >> v2)]) >>> 16 & 255, b = 65535 & C, !(v2 + (_2 = C >>> 24) <= l3); ) {
                      if (0 === o3)
                        break e;
                      o3--, u3 += n3[s3++] << l3, l3 += 8;
                    }
                    u3 >>>= v2, l3 -= v2, r3.back += v2;
                  }
                  if (u3 >>>= _2, l3 -= _2, r3.back += _2, 64 & g) {
                    e3.msg = "invalid distance code", r3.mode = 30;
                    break;
                  }
                  r3.offset = b, r3.extra = 15 & g, r3.mode = 24;
                case 24:
                  if (r3.extra) {
                    for (z = r3.extra; l3 < z; ) {
                      if (0 === o3)
                        break e;
                      o3--, u3 += n3[s3++] << l3, l3 += 8;
                    }
                    r3.offset += u3 & (1 << r3.extra) - 1, u3 >>>= r3.extra, l3 -= r3.extra, r3.back += r3.extra;
                  }
                  if (r3.offset > r3.dmax) {
                    e3.msg = "invalid distance too far back", r3.mode = 30;
                    break;
                  }
                  r3.mode = 25;
                case 25:
                  if (0 === h3)
                    break e;
                  if (d = c4 - h3, r3.offset > d) {
                    if ((d = r3.offset - d) > r3.whave && r3.sane) {
                      e3.msg = "invalid distance too far back", r3.mode = 30;
                      break;
                    }
                    p2 = d > r3.wnext ? (d -= r3.wnext, r3.wsize - d) : r3.wnext - d, d > r3.length && (d = r3.length), m3 = r3.window;
                  } else
                    m3 = i3, p2 = a3 - r3.offset, d = r3.length;
                  for (h3 < d && (d = h3), h3 -= d, r3.length -= d; i3[a3++] = m3[p2++], --d; )
                    ;
                  0 === r3.length && (r3.mode = 21);
                  break;
                case 26:
                  if (0 === h3)
                    break e;
                  i3[a3++] = r3.length, h3--, r3.mode = 21;
                  break;
                case 27:
                  if (r3.wrap) {
                    for (; l3 < 32; ) {
                      if (0 === o3)
                        break e;
                      o3--, u3 |= n3[s3++] << l3, l3 += 8;
                    }
                    if (c4 -= h3, e3.total_out += c4, r3.total += c4, c4 && (e3.adler = r3.check = r3.flags ? B(r3.check, i3, c4, a3 - c4) : O2(r3.check, i3, c4, a3 - c4)), c4 = h3, (r3.flags ? u3 : L(u3)) !== r3.check) {
                      e3.msg = "incorrect data check", r3.mode = 30;
                      break;
                    }
                    l3 = u3 = 0;
                  }
                  r3.mode = 28;
                case 28:
                  if (r3.wrap && r3.flags) {
                    for (; l3 < 32; ) {
                      if (0 === o3)
                        break e;
                      o3--, u3 += n3[s3++] << l3, l3 += 8;
                    }
                    if (u3 !== (4294967295 & r3.total)) {
                      e3.msg = "incorrect length check", r3.mode = 30;
                      break;
                    }
                    l3 = u3 = 0;
                  }
                  r3.mode = 29;
                case 29:
                  x2 = 1;
                  break e;
                case 30:
                  x2 = -3;
                  break e;
                case 31:
                  return -4;
                case 32:
                default:
                  return U;
              }
          return e3.next_out = a3, e3.avail_out = h3, e3.next_in = s3, e3.avail_in = o3, r3.hold = u3, r3.bits = l3, (r3.wsize || c4 !== e3.avail_out && r3.mode < 30 && (r3.mode < 27 || 4 !== t3)) && Z(e3, e3.output, e3.next_out, c4 - e3.avail_out) ? (r3.mode = 31, -4) : (f4 -= e3.avail_in, c4 -= e3.avail_out, e3.total_in += f4, e3.total_out += c4, r3.total += c4, r3.wrap && c4 && (e3.adler = r3.check = r3.flags ? B(r3.check, i3, c4, e3.next_out - c4) : O2(r3.check, i3, c4, e3.next_out - c4)), e3.data_type = r3.bits + (r3.last ? 64 : 0) + (12 === r3.mode ? 128 : 0) + (20 === r3.mode || 15 === r3.mode ? 256 : 0), (0 == f4 && 0 === c4 || 4 === t3) && x2 === N2 && (x2 = -5), x2);
        }, r2.inflateEnd = function(e3) {
          if (!e3 || !e3.state)
            return U;
          var t3 = e3.state;
          return t3.window && (t3.window = null), e3.state = null, N2;
        }, r2.inflateGetHeader = function(e3, t3) {
          var r3;
          return e3 && e3.state ? 0 == (2 & (r3 = e3.state).wrap) ? U : ((r3.head = t3).done = false, N2) : U;
        }, r2.inflateSetDictionary = function(e3, t3) {
          var r3, n3 = t3.length;
          return e3 && e3.state ? 0 !== (r3 = e3.state).wrap && 11 !== r3.mode ? U : 11 === r3.mode && O2(1, t3, n3, 0) !== r3.check ? -3 : Z(e3, t3, n3, n3) ? (r3.mode = 31, -4) : (r3.havedict = 1, N2) : U;
        }, r2.inflateInfo = "pako inflate (from Nodeca project)";
      }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./inffast": 48, "./inftrees": 50 }], 50: [function(e2, t2, r2) {
        "use strict";
        var D2 = e2("../utils/common"), F = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0], N2 = [16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78], U = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0], P = [16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64];
        t2.exports = function(e3, t3, r3, n2, i2, s2, a2, o2) {
          var h2, u2, l2, f3, c3, d, p2, m3, _2, g = o2.bits, b = 0, v2 = 0, y3 = 0, w = 0, k = 0, x2 = 0, S2 = 0, z = 0, C = 0, E = 0, A2 = null, I = 0, O2 = new D2.Buf16(16), B = new D2.Buf16(16), R = null, T3 = 0;
          for (b = 0; b <= 15; b++)
            O2[b] = 0;
          for (v2 = 0; v2 < n2; v2++)
            O2[t3[r3 + v2]]++;
          for (k = g, w = 15; 1 <= w && 0 === O2[w]; w--)
            ;
          if (w < k && (k = w), 0 === w)
            return i2[s2++] = 20971520, i2[s2++] = 20971520, o2.bits = 1, 0;
          for (y3 = 1; y3 < w && 0 === O2[y3]; y3++)
            ;
          for (k < y3 && (k = y3), b = z = 1; b <= 15; b++)
            if (z <<= 1, (z -= O2[b]) < 0)
              return -1;
          if (0 < z && (0 === e3 || 1 !== w))
            return -1;
          for (B[1] = 0, b = 1; b < 15; b++)
            B[b + 1] = B[b] + O2[b];
          for (v2 = 0; v2 < n2; v2++)
            0 !== t3[r3 + v2] && (a2[B[t3[r3 + v2]]++] = v2);
          if (d = 0 === e3 ? (A2 = R = a2, 19) : 1 === e3 ? (A2 = F, I -= 257, R = N2, T3 -= 257, 256) : (A2 = U, R = P, -1), b = y3, c3 = s2, S2 = v2 = E = 0, l2 = -1, f3 = (C = 1 << (x2 = k)) - 1, 1 === e3 && 852 < C || 2 === e3 && 592 < C)
            return 1;
          for (; ; ) {
            for (p2 = b - S2, _2 = a2[v2] < d ? (m3 = 0, a2[v2]) : a2[v2] > d ? (m3 = R[T3 + a2[v2]], A2[I + a2[v2]]) : (m3 = 96, 0), h2 = 1 << b - S2, y3 = u2 = 1 << x2; i2[c3 + (E >> S2) + (u2 -= h2)] = p2 << 24 | m3 << 16 | _2 | 0, 0 !== u2; )
              ;
            for (h2 = 1 << b - 1; E & h2; )
              h2 >>= 1;
            if (0 !== h2 ? (E &= h2 - 1, E += h2) : E = 0, v2++, 0 == --O2[b]) {
              if (b === w)
                break;
              b = t3[r3 + a2[v2]];
            }
            if (k < b && (E & f3) !== l2) {
              for (0 === S2 && (S2 = k), c3 += y3, z = 1 << (x2 = b - S2); x2 + S2 < w && !((z -= O2[x2 + S2]) <= 0); )
                x2++, z <<= 1;
              if (C += 1 << x2, 1 === e3 && 852 < C || 2 === e3 && 592 < C)
                return 1;
              i2[l2 = E & f3] = k << 24 | x2 << 16 | c3 - s2 | 0;
            }
          }
          return 0 !== E && (i2[c3 + E] = b - S2 << 24 | 64 << 16 | 0), o2.bits = k, 0;
        };
      }, { "../utils/common": 41 }], 51: [function(e2, t2, r2) {
        "use strict";
        t2.exports = { 2: "need dictionary", 1: "stream end", 0: "", "-1": "file error", "-2": "stream error", "-3": "data error", "-4": "insufficient memory", "-5": "buffer error", "-6": "incompatible version" };
      }, {}], 52: [function(e2, t2, r2) {
        "use strict";
        var i2 = e2("../utils/common"), o2 = 0, h2 = 1;
        function n2(e3) {
          for (var t3 = e3.length; 0 <= --t3; )
            e3[t3] = 0;
        }
        var s2 = 0, a2 = 29, u2 = 256, l2 = u2 + 1 + a2, f3 = 30, c3 = 19, _2 = 2 * l2 + 1, g = 15, d = 16, p2 = 7, m3 = 256, b = 16, v2 = 17, y3 = 18, w = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0], k = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13], x2 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7], S2 = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], z = new Array(2 * (l2 + 2));
        n2(z);
        var C = new Array(2 * f3);
        n2(C);
        var E = new Array(512);
        n2(E);
        var A2 = new Array(256);
        n2(A2);
        var I = new Array(a2);
        n2(I);
        var O2, B, R, T3 = new Array(f3);
        function D2(e3, t3, r3, n3, i3) {
          this.static_tree = e3, this.extra_bits = t3, this.extra_base = r3, this.elems = n3, this.max_length = i3, this.has_stree = e3 && e3.length;
        }
        function F(e3, t3) {
          this.dyn_tree = e3, this.max_code = 0, this.stat_desc = t3;
        }
        function N2(e3) {
          return e3 < 256 ? E[e3] : E[256 + (e3 >>> 7)];
        }
        function U(e3, t3) {
          e3.pending_buf[e3.pending++] = 255 & t3, e3.pending_buf[e3.pending++] = t3 >>> 8 & 255;
        }
        function P(e3, t3, r3) {
          e3.bi_valid > d - r3 ? (e3.bi_buf |= t3 << e3.bi_valid & 65535, U(e3, e3.bi_buf), e3.bi_buf = t3 >> d - e3.bi_valid, e3.bi_valid += r3 - d) : (e3.bi_buf |= t3 << e3.bi_valid & 65535, e3.bi_valid += r3);
        }
        function L(e3, t3, r3) {
          P(e3, r3[2 * t3], r3[2 * t3 + 1]);
        }
        function j(e3, t3) {
          for (var r3 = 0; r3 |= 1 & e3, e3 >>>= 1, r3 <<= 1, 0 < --t3; )
            ;
          return r3 >>> 1;
        }
        function Z(e3, t3, r3) {
          var n3, i3, s3 = new Array(g + 1), a3 = 0;
          for (n3 = 1; n3 <= g; n3++)
            s3[n3] = a3 = a3 + r3[n3 - 1] << 1;
          for (i3 = 0; i3 <= t3; i3++) {
            var o3 = e3[2 * i3 + 1];
            0 !== o3 && (e3[2 * i3] = j(s3[o3]++, o3));
          }
        }
        function W(e3) {
          var t3;
          for (t3 = 0; t3 < l2; t3++)
            e3.dyn_ltree[2 * t3] = 0;
          for (t3 = 0; t3 < f3; t3++)
            e3.dyn_dtree[2 * t3] = 0;
          for (t3 = 0; t3 < c3; t3++)
            e3.bl_tree[2 * t3] = 0;
          e3.dyn_ltree[2 * m3] = 1, e3.opt_len = e3.static_len = 0, e3.last_lit = e3.matches = 0;
        }
        function M(e3) {
          8 < e3.bi_valid ? U(e3, e3.bi_buf) : 0 < e3.bi_valid && (e3.pending_buf[e3.pending++] = e3.bi_buf), e3.bi_buf = 0, e3.bi_valid = 0;
        }
        function H(e3, t3, r3, n3) {
          var i3 = 2 * t3, s3 = 2 * r3;
          return e3[i3] < e3[s3] || e3[i3] === e3[s3] && n3[t3] <= n3[r3];
        }
        function G2(e3, t3, r3) {
          for (var n3 = e3.heap[r3], i3 = r3 << 1; i3 <= e3.heap_len && (i3 < e3.heap_len && H(t3, e3.heap[i3 + 1], e3.heap[i3], e3.depth) && i3++, !H(t3, n3, e3.heap[i3], e3.depth)); )
            e3.heap[r3] = e3.heap[i3], r3 = i3, i3 <<= 1;
          e3.heap[r3] = n3;
        }
        function K(e3, t3, r3) {
          var n3, i3, s3, a3, o3 = 0;
          if (0 !== e3.last_lit)
            for (; n3 = e3.pending_buf[e3.d_buf + 2 * o3] << 8 | e3.pending_buf[e3.d_buf + 2 * o3 + 1], i3 = e3.pending_buf[e3.l_buf + o3], o3++, 0 === n3 ? L(e3, i3, t3) : (L(e3, (s3 = A2[i3]) + u2 + 1, t3), 0 !== (a3 = w[s3]) && P(e3, i3 -= I[s3], a3), L(e3, s3 = N2(--n3), r3), 0 !== (a3 = k[s3]) && P(e3, n3 -= T3[s3], a3)), o3 < e3.last_lit; )
              ;
          L(e3, m3, t3);
        }
        function Y(e3, t3) {
          var r3, n3, i3, s3 = t3.dyn_tree, a3 = t3.stat_desc.static_tree, o3 = t3.stat_desc.has_stree, h3 = t3.stat_desc.elems, u3 = -1;
          for (e3.heap_len = 0, e3.heap_max = _2, r3 = 0; r3 < h3; r3++)
            0 !== s3[2 * r3] ? (e3.heap[++e3.heap_len] = u3 = r3, e3.depth[r3] = 0) : s3[2 * r3 + 1] = 0;
          for (; e3.heap_len < 2; )
            s3[2 * (i3 = e3.heap[++e3.heap_len] = u3 < 2 ? ++u3 : 0)] = 1, e3.depth[i3] = 0, e3.opt_len--, o3 && (e3.static_len -= a3[2 * i3 + 1]);
          for (t3.max_code = u3, r3 = e3.heap_len >> 1; 1 <= r3; r3--)
            G2(e3, s3, r3);
          for (i3 = h3; r3 = e3.heap[1], e3.heap[1] = e3.heap[e3.heap_len--], G2(e3, s3, 1), n3 = e3.heap[1], e3.heap[--e3.heap_max] = r3, e3.heap[--e3.heap_max] = n3, s3[2 * i3] = s3[2 * r3] + s3[2 * n3], e3.depth[i3] = (e3.depth[r3] >= e3.depth[n3] ? e3.depth[r3] : e3.depth[n3]) + 1, s3[2 * r3 + 1] = s3[2 * n3 + 1] = i3, e3.heap[1] = i3++, G2(e3, s3, 1), 2 <= e3.heap_len; )
            ;
          e3.heap[--e3.heap_max] = e3.heap[1], function(e4, t4) {
            var r4, n4, i4, s4, a4, o4, h4 = t4.dyn_tree, u4 = t4.max_code, l3 = t4.stat_desc.static_tree, f4 = t4.stat_desc.has_stree, c4 = t4.stat_desc.extra_bits, d2 = t4.stat_desc.extra_base, p3 = t4.stat_desc.max_length, m4 = 0;
            for (s4 = 0; s4 <= g; s4++)
              e4.bl_count[s4] = 0;
            for (h4[2 * e4.heap[e4.heap_max] + 1] = 0, r4 = e4.heap_max + 1; r4 < _2; r4++)
              p3 < (s4 = h4[2 * h4[2 * (n4 = e4.heap[r4]) + 1] + 1] + 1) && (s4 = p3, m4++), h4[2 * n4 + 1] = s4, u4 < n4 || (e4.bl_count[s4]++, a4 = 0, d2 <= n4 && (a4 = c4[n4 - d2]), o4 = h4[2 * n4], e4.opt_len += o4 * (s4 + a4), f4 && (e4.static_len += o4 * (l3[2 * n4 + 1] + a4)));
            if (0 !== m4) {
              do {
                for (s4 = p3 - 1; 0 === e4.bl_count[s4]; )
                  s4--;
                e4.bl_count[s4]--, e4.bl_count[s4 + 1] += 2, e4.bl_count[p3]--, m4 -= 2;
              } while (0 < m4);
              for (s4 = p3; 0 !== s4; s4--)
                for (n4 = e4.bl_count[s4]; 0 !== n4; )
                  u4 < (i4 = e4.heap[--r4]) || (h4[2 * i4 + 1] !== s4 && (e4.opt_len += (s4 - h4[2 * i4 + 1]) * h4[2 * i4], h4[2 * i4 + 1] = s4), n4--);
            }
          }(e3, t3), Z(s3, u3, e3.bl_count);
        }
        function X(e3, t3, r3) {
          var n3, i3, s3 = -1, a3 = t3[1], o3 = 0, h3 = 7, u3 = 4;
          for (0 === a3 && (h3 = 138, u3 = 3), t3[2 * (r3 + 1) + 1] = 65535, n3 = 0; n3 <= r3; n3++)
            i3 = a3, a3 = t3[2 * (n3 + 1) + 1], ++o3 < h3 && i3 === a3 || (o3 < u3 ? e3.bl_tree[2 * i3] += o3 : 0 !== i3 ? (i3 !== s3 && e3.bl_tree[2 * i3]++, e3.bl_tree[2 * b]++) : o3 <= 10 ? e3.bl_tree[2 * v2]++ : e3.bl_tree[2 * y3]++, s3 = i3, u3 = (o3 = 0) === a3 ? (h3 = 138, 3) : i3 === a3 ? (h3 = 6, 3) : (h3 = 7, 4));
        }
        function V(e3, t3, r3) {
          var n3, i3, s3 = -1, a3 = t3[1], o3 = 0, h3 = 7, u3 = 4;
          for (0 === a3 && (h3 = 138, u3 = 3), n3 = 0; n3 <= r3; n3++)
            if (i3 = a3, a3 = t3[2 * (n3 + 1) + 1], !(++o3 < h3 && i3 === a3)) {
              if (o3 < u3)
                for (; L(e3, i3, e3.bl_tree), 0 != --o3; )
                  ;
              else
                0 !== i3 ? (i3 !== s3 && (L(e3, i3, e3.bl_tree), o3--), L(e3, b, e3.bl_tree), P(e3, o3 - 3, 2)) : o3 <= 10 ? (L(e3, v2, e3.bl_tree), P(e3, o3 - 3, 3)) : (L(e3, y3, e3.bl_tree), P(e3, o3 - 11, 7));
              s3 = i3, u3 = (o3 = 0) === a3 ? (h3 = 138, 3) : i3 === a3 ? (h3 = 6, 3) : (h3 = 7, 4);
            }
        }
        n2(T3);
        var q = false;
        function J(e3, t3, r3, n3) {
          P(e3, (s2 << 1) + (n3 ? 1 : 0), 3), function(e4, t4, r4, n4) {
            M(e4), n4 && (U(e4, r4), U(e4, ~r4)), i2.arraySet(e4.pending_buf, e4.window, t4, r4, e4.pending), e4.pending += r4;
          }(e3, t3, r3, true);
        }
        r2._tr_init = function(e3) {
          q || (function() {
            var e4, t3, r3, n3, i3, s3 = new Array(g + 1);
            for (n3 = r3 = 0; n3 < a2 - 1; n3++)
              for (I[n3] = r3, e4 = 0; e4 < 1 << w[n3]; e4++)
                A2[r3++] = n3;
            for (A2[r3 - 1] = n3, n3 = i3 = 0; n3 < 16; n3++)
              for (T3[n3] = i3, e4 = 0; e4 < 1 << k[n3]; e4++)
                E[i3++] = n3;
            for (i3 >>= 7; n3 < f3; n3++)
              for (T3[n3] = i3 << 7, e4 = 0; e4 < 1 << k[n3] - 7; e4++)
                E[256 + i3++] = n3;
            for (t3 = 0; t3 <= g; t3++)
              s3[t3] = 0;
            for (e4 = 0; e4 <= 143; )
              z[2 * e4 + 1] = 8, e4++, s3[8]++;
            for (; e4 <= 255; )
              z[2 * e4 + 1] = 9, e4++, s3[9]++;
            for (; e4 <= 279; )
              z[2 * e4 + 1] = 7, e4++, s3[7]++;
            for (; e4 <= 287; )
              z[2 * e4 + 1] = 8, e4++, s3[8]++;
            for (Z(z, l2 + 1, s3), e4 = 0; e4 < f3; e4++)
              C[2 * e4 + 1] = 5, C[2 * e4] = j(e4, 5);
            O2 = new D2(z, w, u2 + 1, l2, g), B = new D2(C, k, 0, f3, g), R = new D2(new Array(0), x2, 0, c3, p2);
          }(), q = true), e3.l_desc = new F(e3.dyn_ltree, O2), e3.d_desc = new F(e3.dyn_dtree, B), e3.bl_desc = new F(e3.bl_tree, R), e3.bi_buf = 0, e3.bi_valid = 0, W(e3);
        }, r2._tr_stored_block = J, r2._tr_flush_block = function(e3, t3, r3, n3) {
          var i3, s3, a3 = 0;
          0 < e3.level ? (2 === e3.strm.data_type && (e3.strm.data_type = function(e4) {
            var t4, r4 = 4093624447;
            for (t4 = 0; t4 <= 31; t4++, r4 >>>= 1)
              if (1 & r4 && 0 !== e4.dyn_ltree[2 * t4])
                return o2;
            if (0 !== e4.dyn_ltree[18] || 0 !== e4.dyn_ltree[20] || 0 !== e4.dyn_ltree[26])
              return h2;
            for (t4 = 32; t4 < u2; t4++)
              if (0 !== e4.dyn_ltree[2 * t4])
                return h2;
            return o2;
          }(e3)), Y(e3, e3.l_desc), Y(e3, e3.d_desc), a3 = function(e4) {
            var t4;
            for (X(e4, e4.dyn_ltree, e4.l_desc.max_code), X(e4, e4.dyn_dtree, e4.d_desc.max_code), Y(e4, e4.bl_desc), t4 = c3 - 1; 3 <= t4 && 0 === e4.bl_tree[2 * S2[t4] + 1]; t4--)
              ;
            return e4.opt_len += 3 * (t4 + 1) + 5 + 5 + 4, t4;
          }(e3), i3 = e3.opt_len + 3 + 7 >>> 3, (s3 = e3.static_len + 3 + 7 >>> 3) <= i3 && (i3 = s3)) : i3 = s3 = r3 + 5, r3 + 4 <= i3 && -1 !== t3 ? J(e3, t3, r3, n3) : 4 === e3.strategy || s3 === i3 ? (P(e3, 2 + (n3 ? 1 : 0), 3), K(e3, z, C)) : (P(e3, 4 + (n3 ? 1 : 0), 3), function(e4, t4, r4, n4) {
            var i4;
            for (P(e4, t4 - 257, 5), P(e4, r4 - 1, 5), P(e4, n4 - 4, 4), i4 = 0; i4 < n4; i4++)
              P(e4, e4.bl_tree[2 * S2[i4] + 1], 3);
            V(e4, e4.dyn_ltree, t4 - 1), V(e4, e4.dyn_dtree, r4 - 1);
          }(e3, e3.l_desc.max_code + 1, e3.d_desc.max_code + 1, a3 + 1), K(e3, e3.dyn_ltree, e3.dyn_dtree)), W(e3), n3 && M(e3);
        }, r2._tr_tally = function(e3, t3, r3) {
          return e3.pending_buf[e3.d_buf + 2 * e3.last_lit] = t3 >>> 8 & 255, e3.pending_buf[e3.d_buf + 2 * e3.last_lit + 1] = 255 & t3, e3.pending_buf[e3.l_buf + e3.last_lit] = 255 & r3, e3.last_lit++, 0 === t3 ? e3.dyn_ltree[2 * r3]++ : (e3.matches++, t3--, e3.dyn_ltree[2 * (A2[r3] + u2 + 1)]++, e3.dyn_dtree[2 * N2(t3)]++), e3.last_lit === e3.lit_bufsize - 1;
        }, r2._tr_align = function(e3) {
          P(e3, 2, 3), L(e3, m3, z), function(e4) {
            16 === e4.bi_valid ? (U(e4, e4.bi_buf), e4.bi_buf = 0, e4.bi_valid = 0) : 8 <= e4.bi_valid && (e4.pending_buf[e4.pending++] = 255 & e4.bi_buf, e4.bi_buf >>= 8, e4.bi_valid -= 8);
          }(e3);
        };
      }, { "../utils/common": 41 }], 53: [function(e2, t2, r2) {
        "use strict";
        t2.exports = function() {
          this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
        };
      }, {}], 54: [function(e2, t2, r2) {
        (function(e3) {
          !function(r3, n2) {
            "use strict";
            if (!r3.setImmediate) {
              var i2, s2, t3, a2, o2 = 1, h2 = {}, u2 = false, l2 = r3.document, e4 = Object.getPrototypeOf && Object.getPrototypeOf(r3);
              e4 = e4 && e4.setTimeout ? e4 : r3, i2 = "[object process]" === {}.toString.call(r3.process) ? function(e5) {
                process.nextTick(function() {
                  c3(e5);
                });
              } : function() {
                if (r3.postMessage && !r3.importScripts) {
                  var e5 = true, t4 = r3.onmessage;
                  return r3.onmessage = function() {
                    e5 = false;
                  }, r3.postMessage("", "*"), r3.onmessage = t4, e5;
                }
              }() ? (a2 = "setImmediate$" + Math.random() + "$", r3.addEventListener ? r3.addEventListener("message", d, false) : r3.attachEvent("onmessage", d), function(e5) {
                r3.postMessage(a2 + e5, "*");
              }) : r3.MessageChannel ? ((t3 = new MessageChannel()).port1.onmessage = function(e5) {
                c3(e5.data);
              }, function(e5) {
                t3.port2.postMessage(e5);
              }) : l2 && "onreadystatechange" in l2.createElement("script") ? (s2 = l2.documentElement, function(e5) {
                var t4 = l2.createElement("script");
                t4.onreadystatechange = function() {
                  c3(e5), t4.onreadystatechange = null, s2.removeChild(t4), t4 = null;
                }, s2.appendChild(t4);
              }) : function(e5) {
                setTimeout(c3, 0, e5);
              }, e4.setImmediate = function(e5) {
                "function" != typeof e5 && (e5 = new Function("" + e5));
                for (var t4 = new Array(arguments.length - 1), r4 = 0; r4 < t4.length; r4++)
                  t4[r4] = arguments[r4 + 1];
                var n3 = { callback: e5, args: t4 };
                return h2[o2] = n3, i2(o2), o2++;
              }, e4.clearImmediate = f3;
            }
            function f3(e5) {
              delete h2[e5];
            }
            function c3(e5) {
              if (u2)
                setTimeout(c3, 0, e5);
              else {
                var t4 = h2[e5];
                if (t4) {
                  u2 = true;
                  try {
                    !function(e6) {
                      var t5 = e6.callback, r4 = e6.args;
                      switch (r4.length) {
                        case 0:
                          t5();
                          break;
                        case 1:
                          t5(r4[0]);
                          break;
                        case 2:
                          t5(r4[0], r4[1]);
                          break;
                        case 3:
                          t5(r4[0], r4[1], r4[2]);
                          break;
                        default:
                          t5.apply(n2, r4);
                      }
                    }(t4);
                  } finally {
                    f3(e5), u2 = false;
                  }
                }
              }
            }
            function d(e5) {
              e5.source === r3 && "string" == typeof e5.data && 0 === e5.data.indexOf(a2) && c3(+e5.data.slice(a2.length));
            }
          }("undefined" == typeof self ? void 0 === e3 ? this : e3 : self);
        }).call(this, "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
      }, {}] }, {}, [10])(10);
    });
  }
});

// ../simple-mind-map/node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS({
  "../simple-mind-map/node_modules/safe-buffer/index.js"(exports, module) {
    var buffer = __require("buffer");
    var Buffer2 = buffer.Buffer;
    function copyProps(src, dst) {
      for (var key in src) {
        dst[key] = src[key];
      }
    }
    if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
      module.exports = buffer;
    } else {
      copyProps(buffer, exports);
      exports.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length2) {
      return Buffer2(arg, encodingOrOffset, length2);
    }
    copyProps(Buffer2, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length2) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer2(arg, encodingOrOffset, length2);
    };
    SafeBuffer.alloc = function(size2, fill, encoding) {
      if (typeof size2 !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer2(size2);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size2) {
      if (typeof size2 !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer2(size2);
    };
    SafeBuffer.allocUnsafeSlow = function(size2) {
      if (typeof size2 !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer.SlowBuffer(size2);
    };
  }
});

// ../simple-mind-map/node_modules/string_decoder/lib/string_decoder.js
var require_string_decoder = __commonJS({
  "../simple-mind-map/node_modules/string_decoder/lib/string_decoder.js"(exports) {
    "use strict";
    var Buffer2 = require_safe_buffer().Buffer;
    var isEncoding = Buffer2.isEncoding || function(encoding) {
      encoding = "" + encoding;
      switch (encoding && encoding.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    function _normalizeEncoding(enc) {
      if (!enc)
        return "utf8";
      var retried;
      while (true) {
        switch (enc) {
          case "utf8":
          case "utf-8":
            return "utf8";
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return "utf16le";
          case "latin1":
          case "binary":
            return "latin1";
          case "base64":
          case "ascii":
          case "hex":
            return enc;
          default:
            if (retried)
              return;
            enc = ("" + enc).toLowerCase();
            retried = true;
        }
      }
    }
    function normalizeEncoding(enc) {
      var nenc = _normalizeEncoding(enc);
      if (typeof nenc !== "string" && (Buffer2.isEncoding === isEncoding || !isEncoding(enc)))
        throw new Error("Unknown encoding: " + enc);
      return nenc || enc;
    }
    exports.StringDecoder = StringDecoder;
    function StringDecoder(encoding) {
      this.encoding = normalizeEncoding(encoding);
      var nb;
      switch (this.encoding) {
        case "utf16le":
          this.text = utf16Text;
          this.end = utf16End;
          nb = 4;
          break;
        case "utf8":
          this.fillLast = utf8FillLast;
          nb = 4;
          break;
        case "base64":
          this.text = base64Text;
          this.end = base64End;
          nb = 3;
          break;
        default:
          this.write = simpleWrite;
          this.end = simpleEnd;
          return;
      }
      this.lastNeed = 0;
      this.lastTotal = 0;
      this.lastChar = Buffer2.allocUnsafe(nb);
    }
    StringDecoder.prototype.write = function(buf) {
      if (buf.length === 0)
        return "";
      var r2;
      var i2;
      if (this.lastNeed) {
        r2 = this.fillLast(buf);
        if (r2 === void 0)
          return "";
        i2 = this.lastNeed;
        this.lastNeed = 0;
      } else {
        i2 = 0;
      }
      if (i2 < buf.length)
        return r2 ? r2 + this.text(buf, i2) : this.text(buf, i2);
      return r2 || "";
    };
    StringDecoder.prototype.end = utf8End;
    StringDecoder.prototype.text = utf8Text;
    StringDecoder.prototype.fillLast = function(buf) {
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
      this.lastNeed -= buf.length;
    };
    function utf8CheckByte(byte) {
      if (byte <= 127)
        return 0;
      else if (byte >> 5 === 6)
        return 2;
      else if (byte >> 4 === 14)
        return 3;
      else if (byte >> 3 === 30)
        return 4;
      return byte >> 6 === 2 ? -1 : -2;
    }
    function utf8CheckIncomplete(self2, buf, i2) {
      var j = buf.length - 1;
      if (j < i2)
        return 0;
      var nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0)
          self2.lastNeed = nb - 1;
        return nb;
      }
      if (--j < i2 || nb === -2)
        return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0)
          self2.lastNeed = nb - 2;
        return nb;
      }
      if (--j < i2 || nb === -2)
        return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0) {
          if (nb === 2)
            nb = 0;
          else
            self2.lastNeed = nb - 3;
        }
        return nb;
      }
      return 0;
    }
    function utf8CheckExtraBytes(self2, buf, p2) {
      if ((buf[0] & 192) !== 128) {
        self2.lastNeed = 0;
        return "\uFFFD";
      }
      if (self2.lastNeed > 1 && buf.length > 1) {
        if ((buf[1] & 192) !== 128) {
          self2.lastNeed = 1;
          return "\uFFFD";
        }
        if (self2.lastNeed > 2 && buf.length > 2) {
          if ((buf[2] & 192) !== 128) {
            self2.lastNeed = 2;
            return "\uFFFD";
          }
        }
      }
    }
    function utf8FillLast(buf) {
      var p2 = this.lastTotal - this.lastNeed;
      var r2 = utf8CheckExtraBytes(this, buf, p2);
      if (r2 !== void 0)
        return r2;
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, p2, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, p2, 0, buf.length);
      this.lastNeed -= buf.length;
    }
    function utf8Text(buf, i2) {
      var total = utf8CheckIncomplete(this, buf, i2);
      if (!this.lastNeed)
        return buf.toString("utf8", i2);
      this.lastTotal = total;
      var end = buf.length - (total - this.lastNeed);
      buf.copy(this.lastChar, 0, end);
      return buf.toString("utf8", i2, end);
    }
    function utf8End(buf) {
      var r2 = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed)
        return r2 + "\uFFFD";
      return r2;
    }
    function utf16Text(buf, i2) {
      if ((buf.length - i2) % 2 === 0) {
        var r2 = buf.toString("utf16le", i2);
        if (r2) {
          var c3 = r2.charCodeAt(r2.length - 1);
          if (c3 >= 55296 && c3 <= 56319) {
            this.lastNeed = 2;
            this.lastTotal = 4;
            this.lastChar[0] = buf[buf.length - 2];
            this.lastChar[1] = buf[buf.length - 1];
            return r2.slice(0, -1);
          }
        }
        return r2;
      }
      this.lastNeed = 1;
      this.lastTotal = 2;
      this.lastChar[0] = buf[buf.length - 1];
      return buf.toString("utf16le", i2, buf.length - 1);
    }
    function utf16End(buf) {
      var r2 = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed) {
        var end = this.lastTotal - this.lastNeed;
        return r2 + this.lastChar.toString("utf16le", 0, end);
      }
      return r2;
    }
    function base64Text(buf, i2) {
      var n2 = (buf.length - i2) % 3;
      if (n2 === 0)
        return buf.toString("base64", i2);
      this.lastNeed = 3 - n2;
      this.lastTotal = 3;
      if (n2 === 1) {
        this.lastChar[0] = buf[buf.length - 1];
      } else {
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
      }
      return buf.toString("base64", i2, buf.length - n2);
    }
    function base64End(buf) {
      var r2 = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed)
        return r2 + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
      return r2;
    }
    function simpleWrite(buf) {
      return buf.toString(this.encoding);
    }
    function simpleEnd(buf) {
      return buf && buf.length ? this.write(buf) : "";
    }
  }
});

// ../simple-mind-map/node_modules/sax/lib/sax.js
var require_sax = __commonJS({
  "../simple-mind-map/node_modules/sax/lib/sax.js"(exports) {
    (function(sax) {
      sax.parser = function(strict, opt) {
        return new SAXParser(strict, opt);
      };
      sax.SAXParser = SAXParser;
      sax.SAXStream = SAXStream;
      sax.createStream = createStream;
      sax.MAX_BUFFER_LENGTH = 64 * 1024;
      var buffers = [
        "comment",
        "sgmlDecl",
        "textNode",
        "tagName",
        "doctype",
        "procInstName",
        "procInstBody",
        "entity",
        "attribName",
        "attribValue",
        "cdata",
        "script"
      ];
      sax.EVENTS = [
        "text",
        "processinginstruction",
        "sgmldeclaration",
        "doctype",
        "comment",
        "opentagstart",
        "attribute",
        "opentag",
        "closetag",
        "opencdata",
        "cdata",
        "closecdata",
        "error",
        "end",
        "ready",
        "script",
        "opennamespace",
        "closenamespace"
      ];
      function SAXParser(strict, opt) {
        if (!(this instanceof SAXParser)) {
          return new SAXParser(strict, opt);
        }
        var parser2 = this;
        clearBuffers(parser2);
        parser2.q = parser2.c = "";
        parser2.bufferCheckPosition = sax.MAX_BUFFER_LENGTH;
        parser2.opt = opt || {};
        parser2.opt.lowercase = parser2.opt.lowercase || parser2.opt.lowercasetags;
        parser2.looseCase = parser2.opt.lowercase ? "toLowerCase" : "toUpperCase";
        parser2.tags = [];
        parser2.closed = parser2.closedRoot = parser2.sawRoot = false;
        parser2.tag = parser2.error = null;
        parser2.strict = !!strict;
        parser2.noscript = !!(strict || parser2.opt.noscript);
        parser2.state = S2.BEGIN;
        parser2.strictEntities = parser2.opt.strictEntities;
        parser2.ENTITIES = parser2.strictEntities ? Object.create(sax.XML_ENTITIES) : Object.create(sax.ENTITIES);
        parser2.attribList = [];
        if (parser2.opt.xmlns) {
          parser2.ns = Object.create(rootNS);
        }
        parser2.trackPosition = parser2.opt.position !== false;
        if (parser2.trackPosition) {
          parser2.position = parser2.line = parser2.column = 0;
        }
        emit(parser2, "onready");
      }
      if (!Object.create) {
        Object.create = function(o2) {
          function F() {
          }
          F.prototype = o2;
          var newf = new F();
          return newf;
        };
      }
      if (!Object.keys) {
        Object.keys = function(o2) {
          var a2 = [];
          for (var i2 in o2)
            if (o2.hasOwnProperty(i2))
              a2.push(i2);
          return a2;
        };
      }
      function checkBufferLength(parser2) {
        var maxAllowed = Math.max(sax.MAX_BUFFER_LENGTH, 10);
        var maxActual = 0;
        for (var i2 = 0, l2 = buffers.length; i2 < l2; i2++) {
          var len = parser2[buffers[i2]].length;
          if (len > maxAllowed) {
            switch (buffers[i2]) {
              case "textNode":
                closeText(parser2);
                break;
              case "cdata":
                emitNode(parser2, "oncdata", parser2.cdata);
                parser2.cdata = "";
                break;
              case "script":
                emitNode(parser2, "onscript", parser2.script);
                parser2.script = "";
                break;
              default:
                error(parser2, "Max buffer length exceeded: " + buffers[i2]);
            }
          }
          maxActual = Math.max(maxActual, len);
        }
        var m3 = sax.MAX_BUFFER_LENGTH - maxActual;
        parser2.bufferCheckPosition = m3 + parser2.position;
      }
      function clearBuffers(parser2) {
        for (var i2 = 0, l2 = buffers.length; i2 < l2; i2++) {
          parser2[buffers[i2]] = "";
        }
      }
      function flushBuffers(parser2) {
        closeText(parser2);
        if (parser2.cdata !== "") {
          emitNode(parser2, "oncdata", parser2.cdata);
          parser2.cdata = "";
        }
        if (parser2.script !== "") {
          emitNode(parser2, "onscript", parser2.script);
          parser2.script = "";
        }
      }
      SAXParser.prototype = {
        end: function() {
          end(this);
        },
        write,
        resume: function() {
          this.error = null;
          return this;
        },
        close: function() {
          return this.write(null);
        },
        flush: function() {
          flushBuffers(this);
        }
      };
      var Stream;
      try {
        Stream = __require("stream").Stream;
      } catch (ex) {
        Stream = function() {
        };
      }
      var streamWraps = sax.EVENTS.filter(function(ev) {
        return ev !== "error" && ev !== "end";
      });
      function createStream(strict, opt) {
        return new SAXStream(strict, opt);
      }
      function SAXStream(strict, opt) {
        if (!(this instanceof SAXStream)) {
          return new SAXStream(strict, opt);
        }
        Stream.apply(this);
        this._parser = new SAXParser(strict, opt);
        this.writable = true;
        this.readable = true;
        var me = this;
        this._parser.onend = function() {
          me.emit("end");
        };
        this._parser.onerror = function(er) {
          me.emit("error", er);
          me._parser.error = null;
        };
        this._decoder = null;
        streamWraps.forEach(function(ev) {
          Object.defineProperty(me, "on" + ev, {
            get: function() {
              return me._parser["on" + ev];
            },
            set: function(h2) {
              if (!h2) {
                me.removeAllListeners(ev);
                me._parser["on" + ev] = h2;
                return h2;
              }
              me.on(ev, h2);
            },
            enumerable: true,
            configurable: false
          });
        });
      }
      SAXStream.prototype = Object.create(Stream.prototype, {
        constructor: {
          value: SAXStream
        }
      });
      SAXStream.prototype.write = function(data2) {
        if (typeof Buffer === "function" && typeof Buffer.isBuffer === "function" && Buffer.isBuffer(data2)) {
          if (!this._decoder) {
            var SD = require_string_decoder().StringDecoder;
            this._decoder = new SD("utf8");
          }
          data2 = this._decoder.write(data2);
        }
        this._parser.write(data2.toString());
        this.emit("data", data2);
        return true;
      };
      SAXStream.prototype.end = function(chunk) {
        if (chunk && chunk.length) {
          this.write(chunk);
        }
        this._parser.end();
        return true;
      };
      SAXStream.prototype.on = function(ev, handler) {
        var me = this;
        if (!me._parser["on" + ev] && streamWraps.indexOf(ev) !== -1) {
          me._parser["on" + ev] = function() {
            var args = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments);
            args.splice(0, 0, ev);
            me.emit.apply(me, args);
          };
        }
        return Stream.prototype.on.call(me, ev, handler);
      };
      var CDATA = "[CDATA[";
      var DOCTYPE = "DOCTYPE";
      var XML_NAMESPACE = "http://www.w3.org/XML/1998/namespace";
      var XMLNS_NAMESPACE = "http://www.w3.org/2000/xmlns/";
      var rootNS = { xml: XML_NAMESPACE, xmlns: XMLNS_NAMESPACE };
      var nameStart = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
      var nameBody = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
      var entityStart = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
      var entityBody = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
      function isWhitespace(c3) {
        return c3 === " " || c3 === "\n" || c3 === "\r" || c3 === "	";
      }
      function isQuote(c3) {
        return c3 === '"' || c3 === "'";
      }
      function isAttribEnd(c3) {
        return c3 === ">" || isWhitespace(c3);
      }
      function isMatch(regex, c3) {
        return regex.test(c3);
      }
      function notMatch(regex, c3) {
        return !isMatch(regex, c3);
      }
      var S2 = 0;
      sax.STATE = {
        BEGIN: S2++,
        // leading byte order mark or whitespace
        BEGIN_WHITESPACE: S2++,
        // leading whitespace
        TEXT: S2++,
        // general stuff
        TEXT_ENTITY: S2++,
        // &amp and such.
        OPEN_WAKA: S2++,
        // <
        SGML_DECL: S2++,
        // <!BLARG
        SGML_DECL_QUOTED: S2++,
        // <!BLARG foo "bar
        DOCTYPE: S2++,
        // <!DOCTYPE
        DOCTYPE_QUOTED: S2++,
        // <!DOCTYPE "//blah
        DOCTYPE_DTD: S2++,
        // <!DOCTYPE "//blah" [ ...
        DOCTYPE_DTD_QUOTED: S2++,
        // <!DOCTYPE "//blah" [ "foo
        COMMENT_STARTING: S2++,
        // <!-
        COMMENT: S2++,
        // <!--
        COMMENT_ENDING: S2++,
        // <!-- blah -
        COMMENT_ENDED: S2++,
        // <!-- blah --
        CDATA: S2++,
        // <![CDATA[ something
        CDATA_ENDING: S2++,
        // ]
        CDATA_ENDING_2: S2++,
        // ]]
        PROC_INST: S2++,
        // <?hi
        PROC_INST_BODY: S2++,
        // <?hi there
        PROC_INST_ENDING: S2++,
        // <?hi "there" ?
        OPEN_TAG: S2++,
        // <strong
        OPEN_TAG_SLASH: S2++,
        // <strong /
        ATTRIB: S2++,
        // <a
        ATTRIB_NAME: S2++,
        // <a foo
        ATTRIB_NAME_SAW_WHITE: S2++,
        // <a foo _
        ATTRIB_VALUE: S2++,
        // <a foo=
        ATTRIB_VALUE_QUOTED: S2++,
        // <a foo="bar
        ATTRIB_VALUE_CLOSED: S2++,
        // <a foo="bar"
        ATTRIB_VALUE_UNQUOTED: S2++,
        // <a foo=bar
        ATTRIB_VALUE_ENTITY_Q: S2++,
        // <foo bar="&quot;"
        ATTRIB_VALUE_ENTITY_U: S2++,
        // <foo bar=&quot
        CLOSE_TAG: S2++,
        // </a
        CLOSE_TAG_SAW_WHITE: S2++,
        // </a   >
        SCRIPT: S2++,
        // <script> ...
        SCRIPT_ENDING: S2++
        // <script> ... <
      };
      sax.XML_ENTITIES = {
        "amp": "&",
        "gt": ">",
        "lt": "<",
        "quot": '"',
        "apos": "'"
      };
      sax.ENTITIES = {
        "amp": "&",
        "gt": ">",
        "lt": "<",
        "quot": '"',
        "apos": "'",
        "AElig": 198,
        "Aacute": 193,
        "Acirc": 194,
        "Agrave": 192,
        "Aring": 197,
        "Atilde": 195,
        "Auml": 196,
        "Ccedil": 199,
        "ETH": 208,
        "Eacute": 201,
        "Ecirc": 202,
        "Egrave": 200,
        "Euml": 203,
        "Iacute": 205,
        "Icirc": 206,
        "Igrave": 204,
        "Iuml": 207,
        "Ntilde": 209,
        "Oacute": 211,
        "Ocirc": 212,
        "Ograve": 210,
        "Oslash": 216,
        "Otilde": 213,
        "Ouml": 214,
        "THORN": 222,
        "Uacute": 218,
        "Ucirc": 219,
        "Ugrave": 217,
        "Uuml": 220,
        "Yacute": 221,
        "aacute": 225,
        "acirc": 226,
        "aelig": 230,
        "agrave": 224,
        "aring": 229,
        "atilde": 227,
        "auml": 228,
        "ccedil": 231,
        "eacute": 233,
        "ecirc": 234,
        "egrave": 232,
        "eth": 240,
        "euml": 235,
        "iacute": 237,
        "icirc": 238,
        "igrave": 236,
        "iuml": 239,
        "ntilde": 241,
        "oacute": 243,
        "ocirc": 244,
        "ograve": 242,
        "oslash": 248,
        "otilde": 245,
        "ouml": 246,
        "szlig": 223,
        "thorn": 254,
        "uacute": 250,
        "ucirc": 251,
        "ugrave": 249,
        "uuml": 252,
        "yacute": 253,
        "yuml": 255,
        "copy": 169,
        "reg": 174,
        "nbsp": 160,
        "iexcl": 161,
        "cent": 162,
        "pound": 163,
        "curren": 164,
        "yen": 165,
        "brvbar": 166,
        "sect": 167,
        "uml": 168,
        "ordf": 170,
        "laquo": 171,
        "not": 172,
        "shy": 173,
        "macr": 175,
        "deg": 176,
        "plusmn": 177,
        "sup1": 185,
        "sup2": 178,
        "sup3": 179,
        "acute": 180,
        "micro": 181,
        "para": 182,
        "middot": 183,
        "cedil": 184,
        "ordm": 186,
        "raquo": 187,
        "frac14": 188,
        "frac12": 189,
        "frac34": 190,
        "iquest": 191,
        "times": 215,
        "divide": 247,
        "OElig": 338,
        "oelig": 339,
        "Scaron": 352,
        "scaron": 353,
        "Yuml": 376,
        "fnof": 402,
        "circ": 710,
        "tilde": 732,
        "Alpha": 913,
        "Beta": 914,
        "Gamma": 915,
        "Delta": 916,
        "Epsilon": 917,
        "Zeta": 918,
        "Eta": 919,
        "Theta": 920,
        "Iota": 921,
        "Kappa": 922,
        "Lambda": 923,
        "Mu": 924,
        "Nu": 925,
        "Xi": 926,
        "Omicron": 927,
        "Pi": 928,
        "Rho": 929,
        "Sigma": 931,
        "Tau": 932,
        "Upsilon": 933,
        "Phi": 934,
        "Chi": 935,
        "Psi": 936,
        "Omega": 937,
        "alpha": 945,
        "beta": 946,
        "gamma": 947,
        "delta": 948,
        "epsilon": 949,
        "zeta": 950,
        "eta": 951,
        "theta": 952,
        "iota": 953,
        "kappa": 954,
        "lambda": 955,
        "mu": 956,
        "nu": 957,
        "xi": 958,
        "omicron": 959,
        "pi": 960,
        "rho": 961,
        "sigmaf": 962,
        "sigma": 963,
        "tau": 964,
        "upsilon": 965,
        "phi": 966,
        "chi": 967,
        "psi": 968,
        "omega": 969,
        "thetasym": 977,
        "upsih": 978,
        "piv": 982,
        "ensp": 8194,
        "emsp": 8195,
        "thinsp": 8201,
        "zwnj": 8204,
        "zwj": 8205,
        "lrm": 8206,
        "rlm": 8207,
        "ndash": 8211,
        "mdash": 8212,
        "lsquo": 8216,
        "rsquo": 8217,
        "sbquo": 8218,
        "ldquo": 8220,
        "rdquo": 8221,
        "bdquo": 8222,
        "dagger": 8224,
        "Dagger": 8225,
        "bull": 8226,
        "hellip": 8230,
        "permil": 8240,
        "prime": 8242,
        "Prime": 8243,
        "lsaquo": 8249,
        "rsaquo": 8250,
        "oline": 8254,
        "frasl": 8260,
        "euro": 8364,
        "image": 8465,
        "weierp": 8472,
        "real": 8476,
        "trade": 8482,
        "alefsym": 8501,
        "larr": 8592,
        "uarr": 8593,
        "rarr": 8594,
        "darr": 8595,
        "harr": 8596,
        "crarr": 8629,
        "lArr": 8656,
        "uArr": 8657,
        "rArr": 8658,
        "dArr": 8659,
        "hArr": 8660,
        "forall": 8704,
        "part": 8706,
        "exist": 8707,
        "empty": 8709,
        "nabla": 8711,
        "isin": 8712,
        "notin": 8713,
        "ni": 8715,
        "prod": 8719,
        "sum": 8721,
        "minus": 8722,
        "lowast": 8727,
        "radic": 8730,
        "prop": 8733,
        "infin": 8734,
        "ang": 8736,
        "and": 8743,
        "or": 8744,
        "cap": 8745,
        "cup": 8746,
        "int": 8747,
        "there4": 8756,
        "sim": 8764,
        "cong": 8773,
        "asymp": 8776,
        "ne": 8800,
        "equiv": 8801,
        "le": 8804,
        "ge": 8805,
        "sub": 8834,
        "sup": 8835,
        "nsub": 8836,
        "sube": 8838,
        "supe": 8839,
        "oplus": 8853,
        "otimes": 8855,
        "perp": 8869,
        "sdot": 8901,
        "lceil": 8968,
        "rceil": 8969,
        "lfloor": 8970,
        "rfloor": 8971,
        "lang": 9001,
        "rang": 9002,
        "loz": 9674,
        "spades": 9824,
        "clubs": 9827,
        "hearts": 9829,
        "diams": 9830
      };
      Object.keys(sax.ENTITIES).forEach(function(key) {
        var e2 = sax.ENTITIES[key];
        var s3 = typeof e2 === "number" ? String.fromCharCode(e2) : e2;
        sax.ENTITIES[key] = s3;
      });
      for (var s2 in sax.STATE) {
        sax.STATE[sax.STATE[s2]] = s2;
      }
      S2 = sax.STATE;
      function emit(parser2, event, data2) {
        parser2[event] && parser2[event](data2);
      }
      function emitNode(parser2, nodeType, data2) {
        if (parser2.textNode)
          closeText(parser2);
        emit(parser2, nodeType, data2);
      }
      function closeText(parser2) {
        parser2.textNode = textopts(parser2.opt, parser2.textNode);
        if (parser2.textNode)
          emit(parser2, "ontext", parser2.textNode);
        parser2.textNode = "";
      }
      function textopts(opt, text4) {
        if (opt.trim)
          text4 = text4.trim();
        if (opt.normalize)
          text4 = text4.replace(/\s+/g, " ");
        return text4;
      }
      function error(parser2, er) {
        closeText(parser2);
        if (parser2.trackPosition) {
          er += "\nLine: " + parser2.line + "\nColumn: " + parser2.column + "\nChar: " + parser2.c;
        }
        er = new Error(er);
        parser2.error = er;
        emit(parser2, "onerror", er);
        return parser2;
      }
      function end(parser2) {
        if (parser2.sawRoot && !parser2.closedRoot)
          strictFail(parser2, "Unclosed root tag");
        if (parser2.state !== S2.BEGIN && parser2.state !== S2.BEGIN_WHITESPACE && parser2.state !== S2.TEXT) {
          error(parser2, "Unexpected end");
        }
        closeText(parser2);
        parser2.c = "";
        parser2.closed = true;
        emit(parser2, "onend");
        SAXParser.call(parser2, parser2.strict, parser2.opt);
        return parser2;
      }
      function strictFail(parser2, message) {
        if (typeof parser2 !== "object" || !(parser2 instanceof SAXParser)) {
          throw new Error("bad call to strictFail");
        }
        if (parser2.strict) {
          error(parser2, message);
        }
      }
      function newTag(parser2) {
        if (!parser2.strict)
          parser2.tagName = parser2.tagName[parser2.looseCase]();
        var parent = parser2.tags[parser2.tags.length - 1] || parser2;
        var tag = parser2.tag = { name: parser2.tagName, attributes: {} };
        if (parser2.opt.xmlns) {
          tag.ns = parent.ns;
        }
        parser2.attribList.length = 0;
        emitNode(parser2, "onopentagstart", tag);
      }
      function qname(name, attribute) {
        var i2 = name.indexOf(":");
        var qualName = i2 < 0 ? ["", name] : name.split(":");
        var prefix = qualName[0];
        var local = qualName[1];
        if (attribute && name === "xmlns") {
          prefix = "xmlns";
          local = "";
        }
        return { prefix, local };
      }
      function attrib(parser2) {
        if (!parser2.strict) {
          parser2.attribName = parser2.attribName[parser2.looseCase]();
        }
        if (parser2.attribList.indexOf(parser2.attribName) !== -1 || parser2.tag.attributes.hasOwnProperty(parser2.attribName)) {
          parser2.attribName = parser2.attribValue = "";
          return;
        }
        if (parser2.opt.xmlns) {
          var qn = qname(parser2.attribName, true);
          var prefix = qn.prefix;
          var local = qn.local;
          if (prefix === "xmlns") {
            if (local === "xml" && parser2.attribValue !== XML_NAMESPACE) {
              strictFail(
                parser2,
                "xml: prefix must be bound to " + XML_NAMESPACE + "\nActual: " + parser2.attribValue
              );
            } else if (local === "xmlns" && parser2.attribValue !== XMLNS_NAMESPACE) {
              strictFail(
                parser2,
                "xmlns: prefix must be bound to " + XMLNS_NAMESPACE + "\nActual: " + parser2.attribValue
              );
            } else {
              var tag = parser2.tag;
              var parent = parser2.tags[parser2.tags.length - 1] || parser2;
              if (tag.ns === parent.ns) {
                tag.ns = Object.create(parent.ns);
              }
              tag.ns[local] = parser2.attribValue;
            }
          }
          parser2.attribList.push([parser2.attribName, parser2.attribValue]);
        } else {
          parser2.tag.attributes[parser2.attribName] = parser2.attribValue;
          emitNode(parser2, "onattribute", {
            name: parser2.attribName,
            value: parser2.attribValue
          });
        }
        parser2.attribName = parser2.attribValue = "";
      }
      function openTag(parser2, selfClosing) {
        if (parser2.opt.xmlns) {
          var tag = parser2.tag;
          var qn = qname(parser2.tagName);
          tag.prefix = qn.prefix;
          tag.local = qn.local;
          tag.uri = tag.ns[qn.prefix] || "";
          if (tag.prefix && !tag.uri) {
            strictFail(parser2, "Unbound namespace prefix: " + JSON.stringify(parser2.tagName));
            tag.uri = qn.prefix;
          }
          var parent = parser2.tags[parser2.tags.length - 1] || parser2;
          if (tag.ns && parent.ns !== tag.ns) {
            Object.keys(tag.ns).forEach(function(p2) {
              emitNode(parser2, "onopennamespace", {
                prefix: p2,
                uri: tag.ns[p2]
              });
            });
          }
          for (var i2 = 0, l2 = parser2.attribList.length; i2 < l2; i2++) {
            var nv = parser2.attribList[i2];
            var name = nv[0];
            var value = nv[1];
            var qualName = qname(name, true);
            var prefix = qualName.prefix;
            var local = qualName.local;
            var uri = prefix === "" ? "" : tag.ns[prefix] || "";
            var a2 = {
              name,
              value,
              prefix,
              local,
              uri
            };
            if (prefix && prefix !== "xmlns" && !uri) {
              strictFail(parser2, "Unbound namespace prefix: " + JSON.stringify(prefix));
              a2.uri = prefix;
            }
            parser2.tag.attributes[name] = a2;
            emitNode(parser2, "onattribute", a2);
          }
          parser2.attribList.length = 0;
        }
        parser2.tag.isSelfClosing = !!selfClosing;
        parser2.sawRoot = true;
        parser2.tags.push(parser2.tag);
        emitNode(parser2, "onopentag", parser2.tag);
        if (!selfClosing) {
          if (!parser2.noscript && parser2.tagName.toLowerCase() === "script") {
            parser2.state = S2.SCRIPT;
          } else {
            parser2.state = S2.TEXT;
          }
          parser2.tag = null;
          parser2.tagName = "";
        }
        parser2.attribName = parser2.attribValue = "";
        parser2.attribList.length = 0;
      }
      function closeTag(parser2) {
        if (!parser2.tagName) {
          strictFail(parser2, "Weird empty close tag.");
          parser2.textNode += "</>";
          parser2.state = S2.TEXT;
          return;
        }
        if (parser2.script) {
          if (parser2.tagName !== "script") {
            parser2.script += "</" + parser2.tagName + ">";
            parser2.tagName = "";
            parser2.state = S2.SCRIPT;
            return;
          }
          emitNode(parser2, "onscript", parser2.script);
          parser2.script = "";
        }
        var t2 = parser2.tags.length;
        var tagName = parser2.tagName;
        if (!parser2.strict) {
          tagName = tagName[parser2.looseCase]();
        }
        var closeTo = tagName;
        while (t2--) {
          var close3 = parser2.tags[t2];
          if (close3.name !== closeTo) {
            strictFail(parser2, "Unexpected close tag");
          } else {
            break;
          }
        }
        if (t2 < 0) {
          strictFail(parser2, "Unmatched closing tag: " + parser2.tagName);
          parser2.textNode += "</" + parser2.tagName + ">";
          parser2.state = S2.TEXT;
          return;
        }
        parser2.tagName = tagName;
        var s3 = parser2.tags.length;
        while (s3-- > t2) {
          var tag = parser2.tag = parser2.tags.pop();
          parser2.tagName = parser2.tag.name;
          emitNode(parser2, "onclosetag", parser2.tagName);
          var x2 = {};
          for (var i2 in tag.ns) {
            x2[i2] = tag.ns[i2];
          }
          var parent = parser2.tags[parser2.tags.length - 1] || parser2;
          if (parser2.opt.xmlns && tag.ns !== parent.ns) {
            Object.keys(tag.ns).forEach(function(p2) {
              var n2 = tag.ns[p2];
              emitNode(parser2, "onclosenamespace", { prefix: p2, uri: n2 });
            });
          }
        }
        if (t2 === 0)
          parser2.closedRoot = true;
        parser2.tagName = parser2.attribValue = parser2.attribName = "";
        parser2.attribList.length = 0;
        parser2.state = S2.TEXT;
      }
      function parseEntity(parser2) {
        var entity = parser2.entity;
        var entityLC = entity.toLowerCase();
        var num;
        var numStr = "";
        if (parser2.ENTITIES[entity]) {
          return parser2.ENTITIES[entity];
        }
        if (parser2.ENTITIES[entityLC]) {
          return parser2.ENTITIES[entityLC];
        }
        entity = entityLC;
        if (entity.charAt(0) === "#") {
          if (entity.charAt(1) === "x") {
            entity = entity.slice(2);
            num = parseInt(entity, 16);
            numStr = num.toString(16);
          } else {
            entity = entity.slice(1);
            num = parseInt(entity, 10);
            numStr = num.toString(10);
          }
        }
        entity = entity.replace(/^0+/, "");
        if (isNaN(num) || numStr.toLowerCase() !== entity) {
          strictFail(parser2, "Invalid character entity");
          return "&" + parser2.entity + ";";
        }
        return String.fromCodePoint(num);
      }
      function beginWhiteSpace(parser2, c3) {
        if (c3 === "<") {
          parser2.state = S2.OPEN_WAKA;
          parser2.startTagPosition = parser2.position;
        } else if (!isWhitespace(c3)) {
          strictFail(parser2, "Non-whitespace before first tag.");
          parser2.textNode = c3;
          parser2.state = S2.TEXT;
        }
      }
      function charAt(chunk, i2) {
        var result = "";
        if (i2 < chunk.length) {
          result = chunk.charAt(i2);
        }
        return result;
      }
      function write(chunk) {
        var parser2 = this;
        if (this.error) {
          throw this.error;
        }
        if (parser2.closed) {
          return error(
            parser2,
            "Cannot write after close. Assign an onready handler."
          );
        }
        if (chunk === null) {
          return end(parser2);
        }
        if (typeof chunk === "object") {
          chunk = chunk.toString();
        }
        var i2 = 0;
        var c3 = "";
        while (true) {
          c3 = charAt(chunk, i2++);
          parser2.c = c3;
          if (!c3) {
            break;
          }
          if (parser2.trackPosition) {
            parser2.position++;
            if (c3 === "\n") {
              parser2.line++;
              parser2.column = 0;
            } else {
              parser2.column++;
            }
          }
          switch (parser2.state) {
            case S2.BEGIN:
              parser2.state = S2.BEGIN_WHITESPACE;
              if (c3 === "\uFEFF") {
                continue;
              }
              beginWhiteSpace(parser2, c3);
              continue;
            case S2.BEGIN_WHITESPACE:
              beginWhiteSpace(parser2, c3);
              continue;
            case S2.TEXT:
              if (parser2.sawRoot && !parser2.closedRoot) {
                var starti = i2 - 1;
                while (c3 && c3 !== "<" && c3 !== "&") {
                  c3 = charAt(chunk, i2++);
                  if (c3 && parser2.trackPosition) {
                    parser2.position++;
                    if (c3 === "\n") {
                      parser2.line++;
                      parser2.column = 0;
                    } else {
                      parser2.column++;
                    }
                  }
                }
                parser2.textNode += chunk.substring(starti, i2 - 1);
              }
              if (c3 === "<" && !(parser2.sawRoot && parser2.closedRoot && !parser2.strict)) {
                parser2.state = S2.OPEN_WAKA;
                parser2.startTagPosition = parser2.position;
              } else {
                if (!isWhitespace(c3) && (!parser2.sawRoot || parser2.closedRoot)) {
                  strictFail(parser2, "Text data outside of root node.");
                }
                if (c3 === "&") {
                  parser2.state = S2.TEXT_ENTITY;
                } else {
                  parser2.textNode += c3;
                }
              }
              continue;
            case S2.SCRIPT:
              if (c3 === "<") {
                parser2.state = S2.SCRIPT_ENDING;
              } else {
                parser2.script += c3;
              }
              continue;
            case S2.SCRIPT_ENDING:
              if (c3 === "/") {
                parser2.state = S2.CLOSE_TAG;
              } else {
                parser2.script += "<" + c3;
                parser2.state = S2.SCRIPT;
              }
              continue;
            case S2.OPEN_WAKA:
              if (c3 === "!") {
                parser2.state = S2.SGML_DECL;
                parser2.sgmlDecl = "";
              } else if (isWhitespace(c3)) {
              } else if (isMatch(nameStart, c3)) {
                parser2.state = S2.OPEN_TAG;
                parser2.tagName = c3;
              } else if (c3 === "/") {
                parser2.state = S2.CLOSE_TAG;
                parser2.tagName = "";
              } else if (c3 === "?") {
                parser2.state = S2.PROC_INST;
                parser2.procInstName = parser2.procInstBody = "";
              } else {
                strictFail(parser2, "Unencoded <");
                if (parser2.startTagPosition + 1 < parser2.position) {
                  var pad2 = parser2.position - parser2.startTagPosition;
                  c3 = new Array(pad2).join(" ") + c3;
                }
                parser2.textNode += "<" + c3;
                parser2.state = S2.TEXT;
              }
              continue;
            case S2.SGML_DECL:
              if ((parser2.sgmlDecl + c3).toUpperCase() === CDATA) {
                emitNode(parser2, "onopencdata");
                parser2.state = S2.CDATA;
                parser2.sgmlDecl = "";
                parser2.cdata = "";
              } else if (parser2.sgmlDecl + c3 === "--") {
                parser2.state = S2.COMMENT;
                parser2.comment = "";
                parser2.sgmlDecl = "";
              } else if ((parser2.sgmlDecl + c3).toUpperCase() === DOCTYPE) {
                parser2.state = S2.DOCTYPE;
                if (parser2.doctype || parser2.sawRoot) {
                  strictFail(
                    parser2,
                    "Inappropriately located doctype declaration"
                  );
                }
                parser2.doctype = "";
                parser2.sgmlDecl = "";
              } else if (c3 === ">") {
                emitNode(parser2, "onsgmldeclaration", parser2.sgmlDecl);
                parser2.sgmlDecl = "";
                parser2.state = S2.TEXT;
              } else if (isQuote(c3)) {
                parser2.state = S2.SGML_DECL_QUOTED;
                parser2.sgmlDecl += c3;
              } else {
                parser2.sgmlDecl += c3;
              }
              continue;
            case S2.SGML_DECL_QUOTED:
              if (c3 === parser2.q) {
                parser2.state = S2.SGML_DECL;
                parser2.q = "";
              }
              parser2.sgmlDecl += c3;
              continue;
            case S2.DOCTYPE:
              if (c3 === ">") {
                parser2.state = S2.TEXT;
                emitNode(parser2, "ondoctype", parser2.doctype);
                parser2.doctype = true;
              } else {
                parser2.doctype += c3;
                if (c3 === "[") {
                  parser2.state = S2.DOCTYPE_DTD;
                } else if (isQuote(c3)) {
                  parser2.state = S2.DOCTYPE_QUOTED;
                  parser2.q = c3;
                }
              }
              continue;
            case S2.DOCTYPE_QUOTED:
              parser2.doctype += c3;
              if (c3 === parser2.q) {
                parser2.q = "";
                parser2.state = S2.DOCTYPE;
              }
              continue;
            case S2.DOCTYPE_DTD:
              parser2.doctype += c3;
              if (c3 === "]") {
                parser2.state = S2.DOCTYPE;
              } else if (isQuote(c3)) {
                parser2.state = S2.DOCTYPE_DTD_QUOTED;
                parser2.q = c3;
              }
              continue;
            case S2.DOCTYPE_DTD_QUOTED:
              parser2.doctype += c3;
              if (c3 === parser2.q) {
                parser2.state = S2.DOCTYPE_DTD;
                parser2.q = "";
              }
              continue;
            case S2.COMMENT:
              if (c3 === "-") {
                parser2.state = S2.COMMENT_ENDING;
              } else {
                parser2.comment += c3;
              }
              continue;
            case S2.COMMENT_ENDING:
              if (c3 === "-") {
                parser2.state = S2.COMMENT_ENDED;
                parser2.comment = textopts(parser2.opt, parser2.comment);
                if (parser2.comment) {
                  emitNode(parser2, "oncomment", parser2.comment);
                }
                parser2.comment = "";
              } else {
                parser2.comment += "-" + c3;
                parser2.state = S2.COMMENT;
              }
              continue;
            case S2.COMMENT_ENDED:
              if (c3 !== ">") {
                strictFail(parser2, "Malformed comment");
                parser2.comment += "--" + c3;
                parser2.state = S2.COMMENT;
              } else {
                parser2.state = S2.TEXT;
              }
              continue;
            case S2.CDATA:
              if (c3 === "]") {
                parser2.state = S2.CDATA_ENDING;
              } else {
                parser2.cdata += c3;
              }
              continue;
            case S2.CDATA_ENDING:
              if (c3 === "]") {
                parser2.state = S2.CDATA_ENDING_2;
              } else {
                parser2.cdata += "]" + c3;
                parser2.state = S2.CDATA;
              }
              continue;
            case S2.CDATA_ENDING_2:
              if (c3 === ">") {
                if (parser2.cdata) {
                  emitNode(parser2, "oncdata", parser2.cdata);
                }
                emitNode(parser2, "onclosecdata");
                parser2.cdata = "";
                parser2.state = S2.TEXT;
              } else if (c3 === "]") {
                parser2.cdata += "]";
              } else {
                parser2.cdata += "]]" + c3;
                parser2.state = S2.CDATA;
              }
              continue;
            case S2.PROC_INST:
              if (c3 === "?") {
                parser2.state = S2.PROC_INST_ENDING;
              } else if (isWhitespace(c3)) {
                parser2.state = S2.PROC_INST_BODY;
              } else {
                parser2.procInstName += c3;
              }
              continue;
            case S2.PROC_INST_BODY:
              if (!parser2.procInstBody && isWhitespace(c3)) {
                continue;
              } else if (c3 === "?") {
                parser2.state = S2.PROC_INST_ENDING;
              } else {
                parser2.procInstBody += c3;
              }
              continue;
            case S2.PROC_INST_ENDING:
              if (c3 === ">") {
                emitNode(parser2, "onprocessinginstruction", {
                  name: parser2.procInstName,
                  body: parser2.procInstBody
                });
                parser2.procInstName = parser2.procInstBody = "";
                parser2.state = S2.TEXT;
              } else {
                parser2.procInstBody += "?" + c3;
                parser2.state = S2.PROC_INST_BODY;
              }
              continue;
            case S2.OPEN_TAG:
              if (isMatch(nameBody, c3)) {
                parser2.tagName += c3;
              } else {
                newTag(parser2);
                if (c3 === ">") {
                  openTag(parser2);
                } else if (c3 === "/") {
                  parser2.state = S2.OPEN_TAG_SLASH;
                } else {
                  if (!isWhitespace(c3)) {
                    strictFail(parser2, "Invalid character in tag name");
                  }
                  parser2.state = S2.ATTRIB;
                }
              }
              continue;
            case S2.OPEN_TAG_SLASH:
              if (c3 === ">") {
                openTag(parser2, true);
                closeTag(parser2);
              } else {
                strictFail(parser2, "Forward-slash in opening tag not followed by >");
                parser2.state = S2.ATTRIB;
              }
              continue;
            case S2.ATTRIB:
              if (isWhitespace(c3)) {
                continue;
              } else if (c3 === ">") {
                openTag(parser2);
              } else if (c3 === "/") {
                parser2.state = S2.OPEN_TAG_SLASH;
              } else if (isMatch(nameStart, c3)) {
                parser2.attribName = c3;
                parser2.attribValue = "";
                parser2.state = S2.ATTRIB_NAME;
              } else {
                strictFail(parser2, "Invalid attribute name");
              }
              continue;
            case S2.ATTRIB_NAME:
              if (c3 === "=") {
                parser2.state = S2.ATTRIB_VALUE;
              } else if (c3 === ">") {
                strictFail(parser2, "Attribute without value");
                parser2.attribValue = parser2.attribName;
                attrib(parser2);
                openTag(parser2);
              } else if (isWhitespace(c3)) {
                parser2.state = S2.ATTRIB_NAME_SAW_WHITE;
              } else if (isMatch(nameBody, c3)) {
                parser2.attribName += c3;
              } else {
                strictFail(parser2, "Invalid attribute name");
              }
              continue;
            case S2.ATTRIB_NAME_SAW_WHITE:
              if (c3 === "=") {
                parser2.state = S2.ATTRIB_VALUE;
              } else if (isWhitespace(c3)) {
                continue;
              } else {
                strictFail(parser2, "Attribute without value");
                parser2.tag.attributes[parser2.attribName] = "";
                parser2.attribValue = "";
                emitNode(parser2, "onattribute", {
                  name: parser2.attribName,
                  value: ""
                });
                parser2.attribName = "";
                if (c3 === ">") {
                  openTag(parser2);
                } else if (isMatch(nameStart, c3)) {
                  parser2.attribName = c3;
                  parser2.state = S2.ATTRIB_NAME;
                } else {
                  strictFail(parser2, "Invalid attribute name");
                  parser2.state = S2.ATTRIB;
                }
              }
              continue;
            case S2.ATTRIB_VALUE:
              if (isWhitespace(c3)) {
                continue;
              } else if (isQuote(c3)) {
                parser2.q = c3;
                parser2.state = S2.ATTRIB_VALUE_QUOTED;
              } else {
                strictFail(parser2, "Unquoted attribute value");
                parser2.state = S2.ATTRIB_VALUE_UNQUOTED;
                parser2.attribValue = c3;
              }
              continue;
            case S2.ATTRIB_VALUE_QUOTED:
              if (c3 !== parser2.q) {
                if (c3 === "&") {
                  parser2.state = S2.ATTRIB_VALUE_ENTITY_Q;
                } else {
                  parser2.attribValue += c3;
                }
                continue;
              }
              attrib(parser2);
              parser2.q = "";
              parser2.state = S2.ATTRIB_VALUE_CLOSED;
              continue;
            case S2.ATTRIB_VALUE_CLOSED:
              if (isWhitespace(c3)) {
                parser2.state = S2.ATTRIB;
              } else if (c3 === ">") {
                openTag(parser2);
              } else if (c3 === "/") {
                parser2.state = S2.OPEN_TAG_SLASH;
              } else if (isMatch(nameStart, c3)) {
                strictFail(parser2, "No whitespace between attributes");
                parser2.attribName = c3;
                parser2.attribValue = "";
                parser2.state = S2.ATTRIB_NAME;
              } else {
                strictFail(parser2, "Invalid attribute name");
              }
              continue;
            case S2.ATTRIB_VALUE_UNQUOTED:
              if (!isAttribEnd(c3)) {
                if (c3 === "&") {
                  parser2.state = S2.ATTRIB_VALUE_ENTITY_U;
                } else {
                  parser2.attribValue += c3;
                }
                continue;
              }
              attrib(parser2);
              if (c3 === ">") {
                openTag(parser2);
              } else {
                parser2.state = S2.ATTRIB;
              }
              continue;
            case S2.CLOSE_TAG:
              if (!parser2.tagName) {
                if (isWhitespace(c3)) {
                  continue;
                } else if (notMatch(nameStart, c3)) {
                  if (parser2.script) {
                    parser2.script += "</" + c3;
                    parser2.state = S2.SCRIPT;
                  } else {
                    strictFail(parser2, "Invalid tagname in closing tag.");
                  }
                } else {
                  parser2.tagName = c3;
                }
              } else if (c3 === ">") {
                closeTag(parser2);
              } else if (isMatch(nameBody, c3)) {
                parser2.tagName += c3;
              } else if (parser2.script) {
                parser2.script += "</" + parser2.tagName;
                parser2.tagName = "";
                parser2.state = S2.SCRIPT;
              } else {
                if (!isWhitespace(c3)) {
                  strictFail(parser2, "Invalid tagname in closing tag");
                }
                parser2.state = S2.CLOSE_TAG_SAW_WHITE;
              }
              continue;
            case S2.CLOSE_TAG_SAW_WHITE:
              if (isWhitespace(c3)) {
                continue;
              }
              if (c3 === ">") {
                closeTag(parser2);
              } else {
                strictFail(parser2, "Invalid characters in closing tag");
              }
              continue;
            case S2.TEXT_ENTITY:
            case S2.ATTRIB_VALUE_ENTITY_Q:
            case S2.ATTRIB_VALUE_ENTITY_U:
              var returnState;
              var buffer;
              switch (parser2.state) {
                case S2.TEXT_ENTITY:
                  returnState = S2.TEXT;
                  buffer = "textNode";
                  break;
                case S2.ATTRIB_VALUE_ENTITY_Q:
                  returnState = S2.ATTRIB_VALUE_QUOTED;
                  buffer = "attribValue";
                  break;
                case S2.ATTRIB_VALUE_ENTITY_U:
                  returnState = S2.ATTRIB_VALUE_UNQUOTED;
                  buffer = "attribValue";
                  break;
              }
              if (c3 === ";") {
                parser2[buffer] += parseEntity(parser2);
                parser2.entity = "";
                parser2.state = returnState;
              } else if (isMatch(parser2.entity.length ? entityBody : entityStart, c3)) {
                parser2.entity += c3;
              } else {
                strictFail(parser2, "Invalid character in entity name");
                parser2[buffer] += "&" + parser2.entity + c3;
                parser2.entity = "";
                parser2.state = returnState;
              }
              continue;
            default:
              throw new Error(parser2, "Unknown state: " + parser2.state);
          }
        }
        if (parser2.position >= parser2.bufferCheckPosition) {
          checkBufferLength(parser2);
        }
        return parser2;
      }
      if (!String.fromCodePoint) {
        (function() {
          var stringFromCharCode = String.fromCharCode;
          var floor = Math.floor;
          var fromCodePoint = function() {
            var MAX_SIZE = 16384;
            var codeUnits = [];
            var highSurrogate;
            var lowSurrogate;
            var index3 = -1;
            var length2 = arguments.length;
            if (!length2) {
              return "";
            }
            var result = "";
            while (++index3 < length2) {
              var codePoint = Number(arguments[index3]);
              if (!isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`
              codePoint < 0 || // not a valid Unicode code point
              codePoint > 1114111 || // not a valid Unicode code point
              floor(codePoint) !== codePoint) {
                throw RangeError("Invalid code point: " + codePoint);
              }
              if (codePoint <= 65535) {
                codeUnits.push(codePoint);
              } else {
                codePoint -= 65536;
                highSurrogate = (codePoint >> 10) + 55296;
                lowSurrogate = codePoint % 1024 + 56320;
                codeUnits.push(highSurrogate, lowSurrogate);
              }
              if (index3 + 1 === length2 || codeUnits.length > MAX_SIZE) {
                result += stringFromCharCode.apply(null, codeUnits);
                codeUnits.length = 0;
              }
            }
            return result;
          };
          if (Object.defineProperty) {
            Object.defineProperty(String, "fromCodePoint", {
              value: fromCodePoint,
              configurable: true,
              writable: true
            });
          } else {
            String.fromCodePoint = fromCodePoint;
          }
        })();
      }
    })(typeof exports === "undefined" ? exports.sax = {} : exports);
  }
});

// ../simple-mind-map/node_modules/xml-js/lib/array-helper.js
var require_array_helper = __commonJS({
  "../simple-mind-map/node_modules/xml-js/lib/array-helper.js"(exports, module) {
    module.exports = {
      isArray: function(value) {
        if (Array.isArray) {
          return Array.isArray(value);
        }
        return Object.prototype.toString.call(value) === "[object Array]";
      }
    };
  }
});

// ../simple-mind-map/node_modules/xml-js/lib/options-helper.js
var require_options_helper = __commonJS({
  "../simple-mind-map/node_modules/xml-js/lib/options-helper.js"(exports, module) {
    var isArray = require_array_helper().isArray;
    module.exports = {
      copyOptions: function(options) {
        var key, copy = {};
        for (key in options) {
          if (options.hasOwnProperty(key)) {
            copy[key] = options[key];
          }
        }
        return copy;
      },
      ensureFlagExists: function(item, options) {
        if (!(item in options) || typeof options[item] !== "boolean") {
          options[item] = false;
        }
      },
      ensureSpacesExists: function(options) {
        if (!("spaces" in options) || typeof options.spaces !== "number" && typeof options.spaces !== "string") {
          options.spaces = 0;
        }
      },
      ensureAlwaysArrayExists: function(options) {
        if (!("alwaysArray" in options) || typeof options.alwaysArray !== "boolean" && !isArray(options.alwaysArray)) {
          options.alwaysArray = false;
        }
      },
      ensureKeyExists: function(key, options) {
        if (!(key + "Key" in options) || typeof options[key + "Key"] !== "string") {
          options[key + "Key"] = options.compact ? "_" + key : key;
        }
      },
      checkFnExists: function(key, options) {
        return key + "Fn" in options;
      }
    };
  }
});

// ../simple-mind-map/node_modules/xml-js/lib/xml2js.js
var require_xml2js = __commonJS({
  "../simple-mind-map/node_modules/xml-js/lib/xml2js.js"(exports, module) {
    var sax = require_sax();
    var expat = { on: function() {
    }, parse: function() {
    } };
    var helper = require_options_helper();
    var isArray = require_array_helper().isArray;
    var options;
    var pureJsParser = true;
    var currentElement;
    function validateOptions(userOptions) {
      options = helper.copyOptions(userOptions);
      helper.ensureFlagExists("ignoreDeclaration", options);
      helper.ensureFlagExists("ignoreInstruction", options);
      helper.ensureFlagExists("ignoreAttributes", options);
      helper.ensureFlagExists("ignoreText", options);
      helper.ensureFlagExists("ignoreComment", options);
      helper.ensureFlagExists("ignoreCdata", options);
      helper.ensureFlagExists("ignoreDoctype", options);
      helper.ensureFlagExists("compact", options);
      helper.ensureFlagExists("alwaysChildren", options);
      helper.ensureFlagExists("addParent", options);
      helper.ensureFlagExists("trim", options);
      helper.ensureFlagExists("nativeType", options);
      helper.ensureFlagExists("nativeTypeAttributes", options);
      helper.ensureFlagExists("sanitize", options);
      helper.ensureFlagExists("instructionHasAttributes", options);
      helper.ensureFlagExists("captureSpacesBetweenElements", options);
      helper.ensureAlwaysArrayExists(options);
      helper.ensureKeyExists("declaration", options);
      helper.ensureKeyExists("instruction", options);
      helper.ensureKeyExists("attributes", options);
      helper.ensureKeyExists("text", options);
      helper.ensureKeyExists("comment", options);
      helper.ensureKeyExists("cdata", options);
      helper.ensureKeyExists("doctype", options);
      helper.ensureKeyExists("type", options);
      helper.ensureKeyExists("name", options);
      helper.ensureKeyExists("elements", options);
      helper.ensureKeyExists("parent", options);
      helper.checkFnExists("doctype", options);
      helper.checkFnExists("instruction", options);
      helper.checkFnExists("cdata", options);
      helper.checkFnExists("comment", options);
      helper.checkFnExists("text", options);
      helper.checkFnExists("instructionName", options);
      helper.checkFnExists("elementName", options);
      helper.checkFnExists("attributeName", options);
      helper.checkFnExists("attributeValue", options);
      helper.checkFnExists("attributes", options);
      return options;
    }
    function nativeType(value) {
      var nValue = Number(value);
      if (!isNaN(nValue)) {
        return nValue;
      }
      var bValue = value.toLowerCase();
      if (bValue === "true") {
        return true;
      } else if (bValue === "false") {
        return false;
      }
      return value;
    }
    function addField2(type, value) {
      var key;
      if (options.compact) {
        if (!currentElement[options[type + "Key"]] && (isArray(options.alwaysArray) ? options.alwaysArray.indexOf(options[type + "Key"]) !== -1 : options.alwaysArray)) {
          currentElement[options[type + "Key"]] = [];
        }
        if (currentElement[options[type + "Key"]] && !isArray(currentElement[options[type + "Key"]])) {
          currentElement[options[type + "Key"]] = [currentElement[options[type + "Key"]]];
        }
        if (type + "Fn" in options && typeof value === "string") {
          value = options[type + "Fn"](value, currentElement);
        }
        if (type === "instruction" && ("instructionFn" in options || "instructionNameFn" in options)) {
          for (key in value) {
            if (value.hasOwnProperty(key)) {
              if ("instructionFn" in options) {
                value[key] = options.instructionFn(value[key], key, currentElement);
              } else {
                var temp = value[key];
                delete value[key];
                value[options.instructionNameFn(key, temp, currentElement)] = temp;
              }
            }
          }
        }
        if (isArray(currentElement[options[type + "Key"]])) {
          currentElement[options[type + "Key"]].push(value);
        } else {
          currentElement[options[type + "Key"]] = value;
        }
      } else {
        if (!currentElement[options.elementsKey]) {
          currentElement[options.elementsKey] = [];
        }
        var element2 = {};
        element2[options.typeKey] = type;
        if (type === "instruction") {
          for (key in value) {
            if (value.hasOwnProperty(key)) {
              break;
            }
          }
          element2[options.nameKey] = "instructionNameFn" in options ? options.instructionNameFn(key, value, currentElement) : key;
          if (options.instructionHasAttributes) {
            element2[options.attributesKey] = value[key][options.attributesKey];
            if ("instructionFn" in options) {
              element2[options.attributesKey] = options.instructionFn(element2[options.attributesKey], key, currentElement);
            }
          } else {
            if ("instructionFn" in options) {
              value[key] = options.instructionFn(value[key], key, currentElement);
            }
            element2[options.instructionKey] = value[key];
          }
        } else {
          if (type + "Fn" in options) {
            value = options[type + "Fn"](value, currentElement);
          }
          element2[options[type + "Key"]] = value;
        }
        if (options.addParent) {
          element2[options.parentKey] = currentElement;
        }
        currentElement[options.elementsKey].push(element2);
      }
    }
    function manipulateAttributes(attributes) {
      if ("attributesFn" in options && attributes) {
        attributes = options.attributesFn(attributes, currentElement);
      }
      if ((options.trim || "attributeValueFn" in options || "attributeNameFn" in options || options.nativeTypeAttributes) && attributes) {
        var key;
        for (key in attributes) {
          if (attributes.hasOwnProperty(key)) {
            if (options.trim)
              attributes[key] = attributes[key].trim();
            if (options.nativeTypeAttributes) {
              attributes[key] = nativeType(attributes[key]);
            }
            if ("attributeValueFn" in options)
              attributes[key] = options.attributeValueFn(attributes[key], key, currentElement);
            if ("attributeNameFn" in options) {
              var temp = attributes[key];
              delete attributes[key];
              attributes[options.attributeNameFn(key, attributes[key], currentElement)] = temp;
            }
          }
        }
      }
      return attributes;
    }
    function onInstruction(instruction) {
      var attributes = {};
      if (instruction.body && (instruction.name.toLowerCase() === "xml" || options.instructionHasAttributes)) {
        var attrsRegExp = /([\w:-]+)\s*=\s*(?:"([^"]*)"|'([^']*)'|(\w+))\s*/g;
        var match;
        while ((match = attrsRegExp.exec(instruction.body)) !== null) {
          attributes[match[1]] = match[2] || match[3] || match[4];
        }
        attributes = manipulateAttributes(attributes);
      }
      if (instruction.name.toLowerCase() === "xml") {
        if (options.ignoreDeclaration) {
          return;
        }
        currentElement[options.declarationKey] = {};
        if (Object.keys(attributes).length) {
          currentElement[options.declarationKey][options.attributesKey] = attributes;
        }
        if (options.addParent) {
          currentElement[options.declarationKey][options.parentKey] = currentElement;
        }
      } else {
        if (options.ignoreInstruction) {
          return;
        }
        if (options.trim) {
          instruction.body = instruction.body.trim();
        }
        var value = {};
        if (options.instructionHasAttributes && Object.keys(attributes).length) {
          value[instruction.name] = {};
          value[instruction.name][options.attributesKey] = attributes;
        } else {
          value[instruction.name] = instruction.body;
        }
        addField2("instruction", value);
      }
    }
    function onStartElement(name, attributes) {
      var element2;
      if (typeof name === "object") {
        attributes = name.attributes;
        name = name.name;
      }
      attributes = manipulateAttributes(attributes);
      if ("elementNameFn" in options) {
        name = options.elementNameFn(name, currentElement);
      }
      if (options.compact) {
        element2 = {};
        if (!options.ignoreAttributes && attributes && Object.keys(attributes).length) {
          element2[options.attributesKey] = {};
          var key;
          for (key in attributes) {
            if (attributes.hasOwnProperty(key)) {
              element2[options.attributesKey][key] = attributes[key];
            }
          }
        }
        if (!(name in currentElement) && (isArray(options.alwaysArray) ? options.alwaysArray.indexOf(name) !== -1 : options.alwaysArray)) {
          currentElement[name] = [];
        }
        if (currentElement[name] && !isArray(currentElement[name])) {
          currentElement[name] = [currentElement[name]];
        }
        if (isArray(currentElement[name])) {
          currentElement[name].push(element2);
        } else {
          currentElement[name] = element2;
        }
      } else {
        if (!currentElement[options.elementsKey]) {
          currentElement[options.elementsKey] = [];
        }
        element2 = {};
        element2[options.typeKey] = "element";
        element2[options.nameKey] = name;
        if (!options.ignoreAttributes && attributes && Object.keys(attributes).length) {
          element2[options.attributesKey] = attributes;
        }
        if (options.alwaysChildren) {
          element2[options.elementsKey] = [];
        }
        currentElement[options.elementsKey].push(element2);
      }
      element2[options.parentKey] = currentElement;
      currentElement = element2;
    }
    function onText(text4) {
      if (options.ignoreText) {
        return;
      }
      if (!text4.trim() && !options.captureSpacesBetweenElements) {
        return;
      }
      if (options.trim) {
        text4 = text4.trim();
      }
      if (options.nativeType) {
        text4 = nativeType(text4);
      }
      if (options.sanitize) {
        text4 = text4.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
      }
      addField2("text", text4);
    }
    function onComment(comment) {
      if (options.ignoreComment) {
        return;
      }
      if (options.trim) {
        comment = comment.trim();
      }
      addField2("comment", comment);
    }
    function onEndElement(name) {
      var parentElement = currentElement[options.parentKey];
      if (!options.addParent) {
        delete currentElement[options.parentKey];
      }
      currentElement = parentElement;
    }
    function onCdata(cdata) {
      if (options.ignoreCdata) {
        return;
      }
      if (options.trim) {
        cdata = cdata.trim();
      }
      addField2("cdata", cdata);
    }
    function onDoctype(doctype) {
      if (options.ignoreDoctype) {
        return;
      }
      doctype = doctype.replace(/^ /, "");
      if (options.trim) {
        doctype = doctype.trim();
      }
      addField2("doctype", doctype);
    }
    function onError(error) {
      error.note = error;
    }
    module.exports = function(xml, userOptions) {
      var parser2 = pureJsParser ? sax.parser(true, {}) : parser2 = new expat.Parser("UTF-8");
      var result = {};
      currentElement = result;
      options = validateOptions(userOptions);
      if (pureJsParser) {
        parser2.opt = { strictEntities: true };
        parser2.onopentag = onStartElement;
        parser2.ontext = onText;
        parser2.oncomment = onComment;
        parser2.onclosetag = onEndElement;
        parser2.onerror = onError;
        parser2.oncdata = onCdata;
        parser2.ondoctype = onDoctype;
        parser2.onprocessinginstruction = onInstruction;
      } else {
        parser2.on("startElement", onStartElement);
        parser2.on("text", onText);
        parser2.on("comment", onComment);
        parser2.on("endElement", onEndElement);
        parser2.on("error", onError);
      }
      if (pureJsParser) {
        parser2.write(xml).close();
      } else {
        if (!parser2.parse(xml)) {
          throw new Error("XML parsing error: " + parser2.getError());
        }
      }
      if (result[options.elementsKey]) {
        var temp = result[options.elementsKey];
        delete result[options.elementsKey];
        result[options.elementsKey] = temp;
        delete result.text;
      }
      return result;
    };
  }
});

// ../simple-mind-map/node_modules/xml-js/lib/xml2json.js
var require_xml2json = __commonJS({
  "../simple-mind-map/node_modules/xml-js/lib/xml2json.js"(exports, module) {
    var helper = require_options_helper();
    var xml2js = require_xml2js();
    function validateOptions(userOptions) {
      var options = helper.copyOptions(userOptions);
      helper.ensureSpacesExists(options);
      return options;
    }
    module.exports = function(xml, userOptions) {
      var options, js, json, parentKey;
      options = validateOptions(userOptions);
      js = xml2js(xml, options);
      parentKey = "compact" in options && options.compact ? "_parent" : "parent";
      if ("addParent" in options && options.addParent) {
        json = JSON.stringify(js, function(k, v2) {
          return k === parentKey ? "_" : v2;
        }, options.spaces);
      } else {
        json = JSON.stringify(js, null, options.spaces);
      }
      return json.replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
    };
  }
});

// ../simple-mind-map/node_modules/xml-js/lib/js2xml.js
var require_js2xml = __commonJS({
  "../simple-mind-map/node_modules/xml-js/lib/js2xml.js"(exports, module) {
    var helper = require_options_helper();
    var isArray = require_array_helper().isArray;
    var currentElement;
    var currentElementName;
    function validateOptions(userOptions) {
      var options = helper.copyOptions(userOptions);
      helper.ensureFlagExists("ignoreDeclaration", options);
      helper.ensureFlagExists("ignoreInstruction", options);
      helper.ensureFlagExists("ignoreAttributes", options);
      helper.ensureFlagExists("ignoreText", options);
      helper.ensureFlagExists("ignoreComment", options);
      helper.ensureFlagExists("ignoreCdata", options);
      helper.ensureFlagExists("ignoreDoctype", options);
      helper.ensureFlagExists("compact", options);
      helper.ensureFlagExists("indentText", options);
      helper.ensureFlagExists("indentCdata", options);
      helper.ensureFlagExists("indentAttributes", options);
      helper.ensureFlagExists("indentInstruction", options);
      helper.ensureFlagExists("fullTagEmptyElement", options);
      helper.ensureFlagExists("noQuotesForNativeAttributes", options);
      helper.ensureSpacesExists(options);
      if (typeof options.spaces === "number") {
        options.spaces = Array(options.spaces + 1).join(" ");
      }
      helper.ensureKeyExists("declaration", options);
      helper.ensureKeyExists("instruction", options);
      helper.ensureKeyExists("attributes", options);
      helper.ensureKeyExists("text", options);
      helper.ensureKeyExists("comment", options);
      helper.ensureKeyExists("cdata", options);
      helper.ensureKeyExists("doctype", options);
      helper.ensureKeyExists("type", options);
      helper.ensureKeyExists("name", options);
      helper.ensureKeyExists("elements", options);
      helper.checkFnExists("doctype", options);
      helper.checkFnExists("instruction", options);
      helper.checkFnExists("cdata", options);
      helper.checkFnExists("comment", options);
      helper.checkFnExists("text", options);
      helper.checkFnExists("instructionName", options);
      helper.checkFnExists("elementName", options);
      helper.checkFnExists("attributeName", options);
      helper.checkFnExists("attributeValue", options);
      helper.checkFnExists("attributes", options);
      helper.checkFnExists("fullTagEmptyElement", options);
      return options;
    }
    function writeIndentation(options, depth, firstLine) {
      return (!firstLine && options.spaces ? "\n" : "") + Array(depth + 1).join(options.spaces);
    }
    function writeAttributes(attributes, options, depth) {
      if (options.ignoreAttributes) {
        return "";
      }
      if ("attributesFn" in options) {
        attributes = options.attributesFn(attributes, currentElementName, currentElement);
      }
      var key, attr2, attrName, quote, result = [];
      for (key in attributes) {
        if (attributes.hasOwnProperty(key) && attributes[key] !== null && attributes[key] !== void 0) {
          quote = options.noQuotesForNativeAttributes && typeof attributes[key] !== "string" ? "" : '"';
          attr2 = "" + attributes[key];
          attr2 = attr2.replace(/"/g, "&quot;");
          attrName = "attributeNameFn" in options ? options.attributeNameFn(key, attr2, currentElementName, currentElement) : key;
          result.push(options.spaces && options.indentAttributes ? writeIndentation(options, depth + 1, false) : " ");
          result.push(attrName + "=" + quote + ("attributeValueFn" in options ? options.attributeValueFn(attr2, key, currentElementName, currentElement) : attr2) + quote);
        }
      }
      if (attributes && Object.keys(attributes).length && options.spaces && options.indentAttributes) {
        result.push(writeIndentation(options, depth, false));
      }
      return result.join("");
    }
    function writeDeclaration(declaration, options, depth) {
      currentElement = declaration;
      currentElementName = "xml";
      return options.ignoreDeclaration ? "" : "<?xml" + writeAttributes(declaration[options.attributesKey], options, depth) + "?>";
    }
    function writeInstruction(instruction, options, depth) {
      if (options.ignoreInstruction) {
        return "";
      }
      var key;
      for (key in instruction) {
        if (instruction.hasOwnProperty(key)) {
          break;
        }
      }
      var instructionName = "instructionNameFn" in options ? options.instructionNameFn(key, instruction[key], currentElementName, currentElement) : key;
      if (typeof instruction[key] === "object") {
        currentElement = instruction;
        currentElementName = instructionName;
        return "<?" + instructionName + writeAttributes(instruction[key][options.attributesKey], options, depth) + "?>";
      } else {
        var instructionValue = instruction[key] ? instruction[key] : "";
        if ("instructionFn" in options)
          instructionValue = options.instructionFn(instructionValue, key, currentElementName, currentElement);
        return "<?" + instructionName + (instructionValue ? " " + instructionValue : "") + "?>";
      }
    }
    function writeComment(comment, options) {
      return options.ignoreComment ? "" : "<!--" + ("commentFn" in options ? options.commentFn(comment, currentElementName, currentElement) : comment) + "-->";
    }
    function writeCdata(cdata, options) {
      return options.ignoreCdata ? "" : "<![CDATA[" + ("cdataFn" in options ? options.cdataFn(cdata, currentElementName, currentElement) : cdata.replace("]]>", "]]]]><![CDATA[>")) + "]]>";
    }
    function writeDoctype(doctype, options) {
      return options.ignoreDoctype ? "" : "<!DOCTYPE " + ("doctypeFn" in options ? options.doctypeFn(doctype, currentElementName, currentElement) : doctype) + ">";
    }
    function writeText(text4, options) {
      if (options.ignoreText)
        return "";
      text4 = "" + text4;
      text4 = text4.replace(/&amp;/g, "&");
      text4 = text4.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
      return "textFn" in options ? options.textFn(text4, currentElementName, currentElement) : text4;
    }
    function hasContent(element2, options) {
      var i2;
      if (element2.elements && element2.elements.length) {
        for (i2 = 0; i2 < element2.elements.length; ++i2) {
          switch (element2.elements[i2][options.typeKey]) {
            case "text":
              if (options.indentText) {
                return true;
              }
              break;
            case "cdata":
              if (options.indentCdata) {
                return true;
              }
              break;
            case "instruction":
              if (options.indentInstruction) {
                return true;
              }
              break;
            case "doctype":
            case "comment":
            case "element":
              return true;
            default:
              return true;
          }
        }
      }
      return false;
    }
    function writeElement(element2, options, depth) {
      currentElement = element2;
      currentElementName = element2.name;
      var xml = [], elementName = "elementNameFn" in options ? options.elementNameFn(element2.name, element2) : element2.name;
      xml.push("<" + elementName);
      if (element2[options.attributesKey]) {
        xml.push(writeAttributes(element2[options.attributesKey], options, depth));
      }
      var withClosingTag = element2[options.elementsKey] && element2[options.elementsKey].length || element2[options.attributesKey] && element2[options.attributesKey]["xml:space"] === "preserve";
      if (!withClosingTag) {
        if ("fullTagEmptyElementFn" in options) {
          withClosingTag = options.fullTagEmptyElementFn(element2.name, element2);
        } else {
          withClosingTag = options.fullTagEmptyElement;
        }
      }
      if (withClosingTag) {
        xml.push(">");
        if (element2[options.elementsKey] && element2[options.elementsKey].length) {
          xml.push(writeElements(element2[options.elementsKey], options, depth + 1));
          currentElement = element2;
          currentElementName = element2.name;
        }
        xml.push(options.spaces && hasContent(element2, options) ? "\n" + Array(depth + 1).join(options.spaces) : "");
        xml.push("</" + elementName + ">");
      } else {
        xml.push("/>");
      }
      return xml.join("");
    }
    function writeElements(elements3, options, depth, firstLine) {
      return elements3.reduce(function(xml, element2) {
        var indent = writeIndentation(options, depth, firstLine && !xml);
        switch (element2.type) {
          case "element":
            return xml + indent + writeElement(element2, options, depth);
          case "comment":
            return xml + indent + writeComment(element2[options.commentKey], options);
          case "doctype":
            return xml + indent + writeDoctype(element2[options.doctypeKey], options);
          case "cdata":
            return xml + (options.indentCdata ? indent : "") + writeCdata(element2[options.cdataKey], options);
          case "text":
            return xml + (options.indentText ? indent : "") + writeText(element2[options.textKey], options);
          case "instruction":
            var instruction = {};
            instruction[element2[options.nameKey]] = element2[options.attributesKey] ? element2 : element2[options.instructionKey];
            return xml + (options.indentInstruction ? indent : "") + writeInstruction(instruction, options, depth);
        }
      }, "");
    }
    function hasContentCompact(element2, options, anyContent) {
      var key;
      for (key in element2) {
        if (element2.hasOwnProperty(key)) {
          switch (key) {
            case options.parentKey:
            case options.attributesKey:
              break;
            case options.textKey:
              if (options.indentText || anyContent) {
                return true;
              }
              break;
            case options.cdataKey:
              if (options.indentCdata || anyContent) {
                return true;
              }
              break;
            case options.instructionKey:
              if (options.indentInstruction || anyContent) {
                return true;
              }
              break;
            case options.doctypeKey:
            case options.commentKey:
              return true;
            default:
              return true;
          }
        }
      }
      return false;
    }
    function writeElementCompact(element2, name, options, depth, indent) {
      currentElement = element2;
      currentElementName = name;
      var elementName = "elementNameFn" in options ? options.elementNameFn(name, element2) : name;
      if (typeof element2 === "undefined" || element2 === null || element2 === "") {
        return "fullTagEmptyElementFn" in options && options.fullTagEmptyElementFn(name, element2) || options.fullTagEmptyElement ? "<" + elementName + "></" + elementName + ">" : "<" + elementName + "/>";
      }
      var xml = [];
      if (name) {
        xml.push("<" + elementName);
        if (typeof element2 !== "object") {
          xml.push(">" + writeText(element2, options) + "</" + elementName + ">");
          return xml.join("");
        }
        if (element2[options.attributesKey]) {
          xml.push(writeAttributes(element2[options.attributesKey], options, depth));
        }
        var withClosingTag = hasContentCompact(element2, options, true) || element2[options.attributesKey] && element2[options.attributesKey]["xml:space"] === "preserve";
        if (!withClosingTag) {
          if ("fullTagEmptyElementFn" in options) {
            withClosingTag = options.fullTagEmptyElementFn(name, element2);
          } else {
            withClosingTag = options.fullTagEmptyElement;
          }
        }
        if (withClosingTag) {
          xml.push(">");
        } else {
          xml.push("/>");
          return xml.join("");
        }
      }
      xml.push(writeElementsCompact(element2, options, depth + 1, false));
      currentElement = element2;
      currentElementName = name;
      if (name) {
        xml.push((indent ? writeIndentation(options, depth, false) : "") + "</" + elementName + ">");
      }
      return xml.join("");
    }
    function writeElementsCompact(element2, options, depth, firstLine) {
      var i2, key, nodes, xml = [];
      for (key in element2) {
        if (element2.hasOwnProperty(key)) {
          nodes = isArray(element2[key]) ? element2[key] : [element2[key]];
          for (i2 = 0; i2 < nodes.length; ++i2) {
            switch (key) {
              case options.declarationKey:
                xml.push(writeDeclaration(nodes[i2], options, depth));
                break;
              case options.instructionKey:
                xml.push((options.indentInstruction ? writeIndentation(options, depth, firstLine) : "") + writeInstruction(nodes[i2], options, depth));
                break;
              case options.attributesKey:
              case options.parentKey:
                break;
              case options.textKey:
                xml.push((options.indentText ? writeIndentation(options, depth, firstLine) : "") + writeText(nodes[i2], options));
                break;
              case options.cdataKey:
                xml.push((options.indentCdata ? writeIndentation(options, depth, firstLine) : "") + writeCdata(nodes[i2], options));
                break;
              case options.doctypeKey:
                xml.push(writeIndentation(options, depth, firstLine) + writeDoctype(nodes[i2], options));
                break;
              case options.commentKey:
                xml.push(writeIndentation(options, depth, firstLine) + writeComment(nodes[i2], options));
                break;
              default:
                xml.push(writeIndentation(options, depth, firstLine) + writeElementCompact(nodes[i2], key, options, depth, hasContentCompact(nodes[i2], options)));
            }
            firstLine = firstLine && !xml.length;
          }
        }
      }
      return xml.join("");
    }
    module.exports = function(js, options) {
      options = validateOptions(options);
      var xml = [];
      currentElement = js;
      currentElementName = "_root_";
      if (options.compact) {
        xml.push(writeElementsCompact(js, options, 0, true));
      } else {
        if (js[options.declarationKey]) {
          xml.push(writeDeclaration(js[options.declarationKey], options, 0));
        }
        if (js[options.elementsKey] && js[options.elementsKey].length) {
          xml.push(writeElements(js[options.elementsKey], options, 0, !xml.length));
        }
      }
      return xml.join("");
    };
  }
});

// ../simple-mind-map/node_modules/xml-js/lib/json2xml.js
var require_json2xml = __commonJS({
  "../simple-mind-map/node_modules/xml-js/lib/json2xml.js"(exports, module) {
    var js2xml = require_js2xml();
    module.exports = function(json, options) {
      if (json instanceof Buffer) {
        json = json.toString();
      }
      var js = null;
      if (typeof json === "string") {
        try {
          js = JSON.parse(json);
        } catch (e2) {
          throw new Error("The JSON structure is invalid");
        }
      } else {
        js = json;
      }
      return js2xml(js, options);
    };
  }
});

// ../simple-mind-map/node_modules/xml-js/lib/index.js
var require_lib = __commonJS({
  "../simple-mind-map/node_modules/xml-js/lib/index.js"(exports, module) {
    var xml2js = require_xml2js();
    var xml2json = require_xml2json();
    var js2xml = require_js2xml();
    var json2xml = require_json2xml();
    module.exports = {
      xml2js,
      xml2json,
      js2xml,
      json2xml
    };
  }
});

// ../simple-mind-map/node_modules/@babel/runtime/helpers/esm/typeof.js
function _typeof(o2) {
  "@babel/helpers - typeof";
  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o3) {
    return typeof o3;
  } : function(o3) {
    return o3 && "function" == typeof Symbol && o3.constructor === Symbol && o3 !== Symbol.prototype ? "symbol" : typeof o3;
  }, _typeof(o2);
}
var init_typeof = __esm({
  "../simple-mind-map/node_modules/@babel/runtime/helpers/esm/typeof.js"() {
  }
});

// ../simple-mind-map/node_modules/html2canvas/dist/html2canvas.js
var require_html2canvas = __commonJS({
  "../simple-mind-map/node_modules/html2canvas/dist/html2canvas.js"(exports, module) {
    (function(global2, factory) {
      typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, global2.html2canvas = factory());
    })(exports, function() {
      "use strict";
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p2 in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p2))
              d2[p2] = b2[p2];
        };
        return extendStatics(d, b);
      };
      function __extends3(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      }
      var __assign = function() {
        __assign = Object.assign || function __assign2(t2) {
          for (var s2, i3 = 1, n2 = arguments.length; i3 < n2; i3++) {
            s2 = arguments[i3];
            for (var p2 in s2)
              if (Object.prototype.hasOwnProperty.call(s2, p2))
                t2[p2] = s2[p2];
          }
          return t2;
        };
        return __assign.apply(this, arguments);
      };
      function __awaiter(thisArg, _arguments, P, generator) {
        function adopt2(value) {
          return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
          });
        }
        return new (P || (P = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e3) {
              reject(e3);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e3) {
              reject(e3);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt2(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      }
      function __generator(thisArg, body) {
        var _2 = { label: 0, sent: function() {
          if (t2[0] & 1)
            throw t2[1];
          return t2[1];
        }, trys: [], ops: [] }, f4, y3, t2, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
          return this;
        }), g;
        function verb(n2) {
          return function(v2) {
            return step([n2, v2]);
          };
        }
        function step(op2) {
          if (f4)
            throw new TypeError("Generator is already executing.");
          while (_2)
            try {
              if (f4 = 1, y3 && (t2 = op2[0] & 2 ? y3["return"] : op2[0] ? y3["throw"] || ((t2 = y3["return"]) && t2.call(y3), 0) : y3.next) && !(t2 = t2.call(y3, op2[1])).done)
                return t2;
              if (y3 = 0, t2)
                op2 = [op2[0] & 2, t2.value];
              switch (op2[0]) {
                case 0:
                case 1:
                  t2 = op2;
                  break;
                case 4:
                  _2.label++;
                  return { value: op2[1], done: false };
                case 5:
                  _2.label++;
                  y3 = op2[1];
                  op2 = [0];
                  continue;
                case 7:
                  op2 = _2.ops.pop();
                  _2.trys.pop();
                  continue;
                default:
                  if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op2[0] === 6 || op2[0] === 2)) {
                    _2 = 0;
                    continue;
                  }
                  if (op2[0] === 3 && (!t2 || op2[1] > t2[0] && op2[1] < t2[3])) {
                    _2.label = op2[1];
                    break;
                  }
                  if (op2[0] === 6 && _2.label < t2[1]) {
                    _2.label = t2[1];
                    t2 = op2;
                    break;
                  }
                  if (t2 && _2.label < t2[2]) {
                    _2.label = t2[2];
                    _2.ops.push(op2);
                    break;
                  }
                  if (t2[2])
                    _2.ops.pop();
                  _2.trys.pop();
                  continue;
              }
              op2 = body.call(thisArg, _2);
            } catch (e3) {
              op2 = [6, e3];
              y3 = 0;
            } finally {
              f4 = t2 = 0;
            }
          if (op2[0] & 5)
            throw op2[1];
          return { value: op2[0] ? op2[1] : void 0, done: true };
        }
      }
      function __spreadArray(to2, from2, pack2) {
        if (pack2 || arguments.length === 2)
          for (var i3 = 0, l2 = from2.length, ar; i3 < l2; i3++) {
            if (ar || !(i3 in from2)) {
              if (!ar)
                ar = Array.prototype.slice.call(from2, 0, i3);
              ar[i3] = from2[i3];
            }
          }
        return to2.concat(ar || from2);
      }
      var Bounds = (
        /** @class */
        function() {
          function Bounds2(left, top, width2, height2) {
            this.left = left;
            this.top = top;
            this.width = width2;
            this.height = height2;
          }
          Bounds2.prototype.add = function(x2, y3, w, h2) {
            return new Bounds2(this.left + x2, this.top + y3, this.width + w, this.height + h2);
          };
          Bounds2.fromClientRect = function(context, clientRect) {
            return new Bounds2(clientRect.left + context.windowBounds.left, clientRect.top + context.windowBounds.top, clientRect.width, clientRect.height);
          };
          Bounds2.fromDOMRectList = function(context, domRectList) {
            var domRect = Array.from(domRectList).find(function(rect) {
              return rect.width !== 0;
            });
            return domRect ? new Bounds2(domRect.left + context.windowBounds.left, domRect.top + context.windowBounds.top, domRect.width, domRect.height) : Bounds2.EMPTY;
          };
          Bounds2.EMPTY = new Bounds2(0, 0, 0, 0);
          return Bounds2;
        }()
      );
      var parseBounds = function(context, node3) {
        return Bounds.fromClientRect(context, node3.getBoundingClientRect());
      };
      var parseDocumentSize = function(document4) {
        var body = document4.body;
        var documentElement = document4.documentElement;
        if (!body || !documentElement) {
          throw new Error("Unable to get document size");
        }
        var width2 = Math.max(Math.max(body.scrollWidth, documentElement.scrollWidth), Math.max(body.offsetWidth, documentElement.offsetWidth), Math.max(body.clientWidth, documentElement.clientWidth));
        var height2 = Math.max(Math.max(body.scrollHeight, documentElement.scrollHeight), Math.max(body.offsetHeight, documentElement.offsetHeight), Math.max(body.clientHeight, documentElement.clientHeight));
        return new Bounds(0, 0, width2, height2);
      };
      var toCodePoints$1 = function(str) {
        var codePoints = [];
        var i3 = 0;
        var length2 = str.length;
        while (i3 < length2) {
          var value = str.charCodeAt(i3++);
          if (value >= 55296 && value <= 56319 && i3 < length2) {
            var extra = str.charCodeAt(i3++);
            if ((extra & 64512) === 56320) {
              codePoints.push(((value & 1023) << 10) + (extra & 1023) + 65536);
            } else {
              codePoints.push(value);
              i3--;
            }
          } else {
            codePoints.push(value);
          }
        }
        return codePoints;
      };
      var fromCodePoint$1 = function() {
        var codePoints = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          codePoints[_i] = arguments[_i];
        }
        if (String.fromCodePoint) {
          return String.fromCodePoint.apply(String, codePoints);
        }
        var length2 = codePoints.length;
        if (!length2) {
          return "";
        }
        var codeUnits = [];
        var index3 = -1;
        var result = "";
        while (++index3 < length2) {
          var codePoint = codePoints[index3];
          if (codePoint <= 65535) {
            codeUnits.push(codePoint);
          } else {
            codePoint -= 65536;
            codeUnits.push((codePoint >> 10) + 55296, codePoint % 1024 + 56320);
          }
          if (index3 + 1 === length2 || codeUnits.length > 16384) {
            result += String.fromCharCode.apply(String, codeUnits);
            codeUnits.length = 0;
          }
        }
        return result;
      };
      var chars$2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
      var lookup$2 = typeof Uint8Array === "undefined" ? [] : new Uint8Array(256);
      for (var i$2 = 0; i$2 < chars$2.length; i$2++) {
        lookup$2[chars$2.charCodeAt(i$2)] = i$2;
      }
      var chars$1$1 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
      var lookup$1$1 = typeof Uint8Array === "undefined" ? [] : new Uint8Array(256);
      for (var i$1$1 = 0; i$1$1 < chars$1$1.length; i$1$1++) {
        lookup$1$1[chars$1$1.charCodeAt(i$1$1)] = i$1$1;
      }
      var decode$1 = function(base642) {
        var bufferLength = base642.length * 0.75, len = base642.length, i3, p2 = 0, encoded1, encoded2, encoded3, encoded4;
        if (base642[base642.length - 1] === "=") {
          bufferLength--;
          if (base642[base642.length - 2] === "=") {
            bufferLength--;
          }
        }
        var buffer = typeof ArrayBuffer !== "undefined" && typeof Uint8Array !== "undefined" && typeof Uint8Array.prototype.slice !== "undefined" ? new ArrayBuffer(bufferLength) : new Array(bufferLength);
        var bytes = Array.isArray(buffer) ? buffer : new Uint8Array(buffer);
        for (i3 = 0; i3 < len; i3 += 4) {
          encoded1 = lookup$1$1[base642.charCodeAt(i3)];
          encoded2 = lookup$1$1[base642.charCodeAt(i3 + 1)];
          encoded3 = lookup$1$1[base642.charCodeAt(i3 + 2)];
          encoded4 = lookup$1$1[base642.charCodeAt(i3 + 3)];
          bytes[p2++] = encoded1 << 2 | encoded2 >> 4;
          bytes[p2++] = (encoded2 & 15) << 4 | encoded3 >> 2;
          bytes[p2++] = (encoded3 & 3) << 6 | encoded4 & 63;
        }
        return buffer;
      };
      var polyUint16Array$1 = function(buffer) {
        var length2 = buffer.length;
        var bytes = [];
        for (var i3 = 0; i3 < length2; i3 += 2) {
          bytes.push(buffer[i3 + 1] << 8 | buffer[i3]);
        }
        return bytes;
      };
      var polyUint32Array$1 = function(buffer) {
        var length2 = buffer.length;
        var bytes = [];
        for (var i3 = 0; i3 < length2; i3 += 4) {
          bytes.push(buffer[i3 + 3] << 24 | buffer[i3 + 2] << 16 | buffer[i3 + 1] << 8 | buffer[i3]);
        }
        return bytes;
      };
      var UTRIE2_SHIFT_2$1 = 5;
      var UTRIE2_SHIFT_1$1 = 6 + 5;
      var UTRIE2_INDEX_SHIFT$1 = 2;
      var UTRIE2_SHIFT_1_2$1 = UTRIE2_SHIFT_1$1 - UTRIE2_SHIFT_2$1;
      var UTRIE2_LSCP_INDEX_2_OFFSET$1 = 65536 >> UTRIE2_SHIFT_2$1;
      var UTRIE2_DATA_BLOCK_LENGTH$1 = 1 << UTRIE2_SHIFT_2$1;
      var UTRIE2_DATA_MASK$1 = UTRIE2_DATA_BLOCK_LENGTH$1 - 1;
      var UTRIE2_LSCP_INDEX_2_LENGTH$1 = 1024 >> UTRIE2_SHIFT_2$1;
      var UTRIE2_INDEX_2_BMP_LENGTH$1 = UTRIE2_LSCP_INDEX_2_OFFSET$1 + UTRIE2_LSCP_INDEX_2_LENGTH$1;
      var UTRIE2_UTF8_2B_INDEX_2_OFFSET$1 = UTRIE2_INDEX_2_BMP_LENGTH$1;
      var UTRIE2_UTF8_2B_INDEX_2_LENGTH$1 = 2048 >> 6;
      var UTRIE2_INDEX_1_OFFSET$1 = UTRIE2_UTF8_2B_INDEX_2_OFFSET$1 + UTRIE2_UTF8_2B_INDEX_2_LENGTH$1;
      var UTRIE2_OMITTED_BMP_INDEX_1_LENGTH$1 = 65536 >> UTRIE2_SHIFT_1$1;
      var UTRIE2_INDEX_2_BLOCK_LENGTH$1 = 1 << UTRIE2_SHIFT_1_2$1;
      var UTRIE2_INDEX_2_MASK$1 = UTRIE2_INDEX_2_BLOCK_LENGTH$1 - 1;
      var slice16$1 = function(view, start, end) {
        if (view.slice) {
          return view.slice(start, end);
        }
        return new Uint16Array(Array.prototype.slice.call(view, start, end));
      };
      var slice32$1 = function(view, start, end) {
        if (view.slice) {
          return view.slice(start, end);
        }
        return new Uint32Array(Array.prototype.slice.call(view, start, end));
      };
      var createTrieFromBase64$1 = function(base642, _byteLength) {
        var buffer = decode$1(base642);
        var view32 = Array.isArray(buffer) ? polyUint32Array$1(buffer) : new Uint32Array(buffer);
        var view16 = Array.isArray(buffer) ? polyUint16Array$1(buffer) : new Uint16Array(buffer);
        var headerLength = 24;
        var index3 = slice16$1(view16, headerLength / 2, view32[4] / 2);
        var data2 = view32[5] === 2 ? slice16$1(view16, (headerLength + view32[4]) / 2) : slice32$1(view32, Math.ceil((headerLength + view32[4]) / 4));
        return new Trie$1(view32[0], view32[1], view32[2], view32[3], index3, data2);
      };
      var Trie$1 = (
        /** @class */
        function() {
          function Trie2(initialValue, errorValue, highStart, highValueIndex, index3, data2) {
            this.initialValue = initialValue;
            this.errorValue = errorValue;
            this.highStart = highStart;
            this.highValueIndex = highValueIndex;
            this.index = index3;
            this.data = data2;
          }
          Trie2.prototype.get = function(codePoint) {
            var ix;
            if (codePoint >= 0) {
              if (codePoint < 55296 || codePoint > 56319 && codePoint <= 65535) {
                ix = this.index[codePoint >> UTRIE2_SHIFT_2$1];
                ix = (ix << UTRIE2_INDEX_SHIFT$1) + (codePoint & UTRIE2_DATA_MASK$1);
                return this.data[ix];
              }
              if (codePoint <= 65535) {
                ix = this.index[UTRIE2_LSCP_INDEX_2_OFFSET$1 + (codePoint - 55296 >> UTRIE2_SHIFT_2$1)];
                ix = (ix << UTRIE2_INDEX_SHIFT$1) + (codePoint & UTRIE2_DATA_MASK$1);
                return this.data[ix];
              }
              if (codePoint < this.highStart) {
                ix = UTRIE2_INDEX_1_OFFSET$1 - UTRIE2_OMITTED_BMP_INDEX_1_LENGTH$1 + (codePoint >> UTRIE2_SHIFT_1$1);
                ix = this.index[ix];
                ix += codePoint >> UTRIE2_SHIFT_2$1 & UTRIE2_INDEX_2_MASK$1;
                ix = this.index[ix];
                ix = (ix << UTRIE2_INDEX_SHIFT$1) + (codePoint & UTRIE2_DATA_MASK$1);
                return this.data[ix];
              }
              if (codePoint <= 1114111) {
                return this.data[this.highValueIndex];
              }
            }
            return this.errorValue;
          };
          return Trie2;
        }()
      );
      var chars$3 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
      var lookup$3 = typeof Uint8Array === "undefined" ? [] : new Uint8Array(256);
      for (var i$3 = 0; i$3 < chars$3.length; i$3++) {
        lookup$3[chars$3.charCodeAt(i$3)] = i$3;
      }
      var base64$1 = "KwAAAAAAAAAACA4AUD0AADAgAAACAAAAAAAIABAAGABAAEgAUABYAGAAaABgAGgAYgBqAF8AZwBgAGgAcQB5AHUAfQCFAI0AlQCdAKIAqgCyALoAYABoAGAAaABgAGgAwgDKAGAAaADGAM4A0wDbAOEA6QDxAPkAAQEJAQ8BFwF1AH0AHAEkASwBNAE6AUIBQQFJAVEBWQFhAWgBcAF4ATAAgAGGAY4BlQGXAZ8BpwGvAbUBvQHFAc0B0wHbAeMB6wHxAfkBAQIJAvEBEQIZAiECKQIxAjgCQAJGAk4CVgJeAmQCbAJ0AnwCgQKJApECmQKgAqgCsAK4ArwCxAIwAMwC0wLbAjAA4wLrAvMC+AIAAwcDDwMwABcDHQMlAy0DNQN1AD0DQQNJA0kDSQNRA1EDVwNZA1kDdQB1AGEDdQBpA20DdQN1AHsDdQCBA4kDkQN1AHUAmQOhA3UAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AKYDrgN1AHUAtgO+A8YDzgPWAxcD3gPjA+sD8wN1AHUA+wMDBAkEdQANBBUEHQQlBCoEFwMyBDgEYABABBcDSARQBFgEYARoBDAAcAQzAXgEgASIBJAEdQCXBHUAnwSnBK4EtgS6BMIEyAR1AHUAdQB1AHUAdQCVANAEYABgAGAAYABgAGAAYABgANgEYADcBOQEYADsBPQE/AQEBQwFFAUcBSQFLAU0BWQEPAVEBUsFUwVbBWAAYgVgAGoFcgV6BYIFigWRBWAAmQWfBaYFYABgAGAAYABgAKoFYACxBbAFuQW6BcEFwQXHBcEFwQXPBdMF2wXjBeoF8gX6BQIGCgYSBhoGIgYqBjIGOgZgAD4GRgZMBmAAUwZaBmAAYABgAGAAYABgAGAAYABgAGAAYABgAGIGYABpBnAGYABgAGAAYABgAGAAYABgAGAAYAB4Bn8GhQZgAGAAYAB1AHcDFQSLBmAAYABgAJMGdQA9A3UAmwajBqsGqwaVALMGuwbDBjAAywbSBtIG1QbSBtIG0gbSBtIG0gbdBuMG6wbzBvsGAwcLBxMHAwcbByMHJwcsBywHMQcsB9IGOAdAB0gHTgfSBkgHVgfSBtIG0gbSBtIG0gbSBtIG0gbSBiwHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAdgAGAALAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAdbB2MHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsB2kH0gZwB64EdQB1AHUAdQB1AHUAdQB1AHUHfQdgAIUHjQd1AHUAlQedB2AAYAClB6sHYACzB7YHvgfGB3UAzgfWBzMB3gfmB1EB7gf1B/0HlQENAQUIDQh1ABUIHQglCBcDLQg1CD0IRQhNCEEDUwh1AHUAdQBbCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIcAh3CHoIMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIgggwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAALAcsBywHLAcsBywHLAcsBywHLAcsB4oILAcsB44I0gaWCJ4Ipgh1AHUAqgiyCHUAdQB1AHUAdQB1AHUAdQB1AHUAtwh8AXUAvwh1AMUIyQjRCNkI4AjoCHUAdQB1AO4I9gj+CAYJDgkTCS0HGwkjCYIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiAAIAAAAFAAYABgAGIAXwBgAHEAdQBFAJUAogCyAKAAYABgAEIA4ABGANMA4QDxAMEBDwE1AFwBLAE6AQEBUQF4QkhCmEKoQrhCgAHIQsAB0MLAAcABwAHAAeDC6ABoAHDCwMMAAcABwAHAAdDDGMMAAcAB6MM4wwjDWMNow3jDaABoAGgAaABoAGgAaABoAGgAaABoAGgAaABoAGgAaABoAGgAaABoAEjDqABWw6bDqABpg6gAaABoAHcDvwOPA+gAaABfA/8DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DpcPAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcAB9cPKwkyCToJMAB1AHUAdQBCCUoJTQl1AFUJXAljCWcJawkwADAAMAAwAHMJdQB2CX4JdQCECYoJjgmWCXUAngkwAGAAYABxAHUApgn3A64JtAl1ALkJdQDACTAAMAAwADAAdQB1AHUAdQB1AHUAdQB1AHUAowYNBMUIMAAwADAAMADICcsJ0wnZCRUE4QkwAOkJ8An4CTAAMAB1AAAKvwh1AAgKDwoXCh8KdQAwACcKLgp1ADYKqAmICT4KRgowADAAdQB1AE4KMAB1AFYKdQBeCnUAZQowADAAMAAwADAAMAAwADAAMAAVBHUAbQowADAAdQC5CXUKMAAwAHwBxAijBogEMgF9CoQKiASMCpQKmgqIBKIKqgquCogEDQG2Cr4KxgrLCjAAMADTCtsKCgHjCusK8Qr5CgELMAAwADAAMAB1AIsECQsRC3UANAEZCzAAMAAwADAAMAB1ACELKQswAHUANAExCzkLdQBBC0kLMABRC1kLMAAwADAAMAAwADAAdQBhCzAAMAAwAGAAYABpC3ELdwt/CzAAMACHC4sLkwubC58Lpwt1AK4Ltgt1APsDMAAwADAAMAAwADAAMAAwAL4LwwvLC9IL1wvdCzAAMADlC+kL8Qv5C/8LSQswADAAMAAwADAAMAAwADAAMAAHDDAAMAAwADAAMAAODBYMHgx1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1ACYMMAAwADAAdQB1AHUALgx1AHUAdQB1AHUAdQA2DDAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AD4MdQBGDHUAdQB1AHUAdQB1AEkMdQB1AHUAdQB1AFAMMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQBYDHUAdQB1AF8MMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUA+wMVBGcMMAAwAHwBbwx1AHcMfwyHDI8MMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAYABgAJcMMAAwADAAdQB1AJ8MlQClDDAAMACtDCwHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsB7UMLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AA0EMAC9DDAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAsBywHLAcsBywHLAcsBywHLQcwAMEMyAwsBywHLAcsBywHLAcsBywHLAcsBywHzAwwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAHUAdQB1ANQM2QzhDDAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMABgAGAAYABgAGAAYABgAOkMYADxDGAA+AwADQYNYABhCWAAYAAODTAAMAAwADAAFg1gAGAAHg37AzAAMAAwADAAYABgACYNYAAsDTQNPA1gAEMNPg1LDWAAYABgAGAAYABgAGAAYABgAGAAUg1aDYsGVglhDV0NcQBnDW0NdQ15DWAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAlQCBDZUAiA2PDZcNMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAnw2nDTAAMAAwADAAMAAwAHUArw23DTAAMAAwADAAMAAwADAAMAAwADAAMAB1AL8NMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAB1AHUAdQB1AHUAdQDHDTAAYABgAM8NMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAA1w11ANwNMAAwAD0B5A0wADAAMAAwADAAMADsDfQN/A0EDgwOFA4wABsOMAAwADAAMAAwADAAMAAwANIG0gbSBtIG0gbSBtIG0gYjDigOwQUuDsEFMw7SBjoO0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIGQg5KDlIOVg7SBtIGXg5lDm0OdQ7SBtIGfQ6EDooOjQ6UDtIGmg6hDtIG0gaoDqwO0ga0DrwO0gZgAGAAYADEDmAAYAAkBtIGzA5gANIOYADaDokO0gbSBt8O5w7SBu8O0gb1DvwO0gZgAGAAxA7SBtIG0gbSBtIGYABgAGAAYAAED2AAsAUMD9IG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIGFA8sBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAccD9IGLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHJA8sBywHLAcsBywHLAccDywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywPLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAc0D9IG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIGLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAccD9IG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIGFA8sBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHPA/SBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gYUD0QPlQCVAJUAMAAwADAAMACVAJUAlQCVAJUAlQCVAEwPMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAA//8EAAQABAAEAAQABAAEAAQABAANAAMAAQABAAIABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQACgATABcAHgAbABoAHgAXABYAEgAeABsAGAAPABgAHABLAEsASwBLAEsASwBLAEsASwBLABgAGAAeAB4AHgATAB4AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQABYAGwASAB4AHgAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAWAA0AEQAeAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAAQABAAEAAQABAAFAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAJABYAGgAbABsAGwAeAB0AHQAeAE8AFwAeAA0AHgAeABoAGwBPAE8ADgBQAB0AHQAdAE8ATwAXAE8ATwBPABYAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAFAAUABQAFAAUABQAFAAUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAB4AHgAeAFAATwBAAE8ATwBPAEAATwBQAFAATwBQAB4AHgAeAB4AHgAeAB0AHQAdAB0AHgAdAB4ADgBQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgBQAB4AUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAJAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAkACQAJAAkACQAJAAkABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAeAB4AHgAeAFAAHgAeAB4AKwArAFAAUABQAFAAGABQACsAKwArACsAHgAeAFAAHgBQAFAAUAArAFAAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAEAAQABAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAUAAeAB4AHgAeAB4AHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAYAA0AKwArAB4AHgAbACsABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQADQAEAB4ABAAEAB4ABAAEABMABAArACsAKwArACsAKwArACsAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAKwArACsAKwBWAFYAVgBWAB4AHgArACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AGgAaABoAGAAYAB4AHgAEAAQABAAEAAQABAAEAAQABAAEAAQAEwAEACsAEwATAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABLAEsASwBLAEsASwBLAEsASwBLABoAGQAZAB4AUABQAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQABMAUAAEAAQABAAEAAQABAAEAB4AHgAEAAQABAAEAAQABABQAFAABAAEAB4ABAAEAAQABABQAFAASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUAAeAB4AUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAFAABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQAUABQAB4AHgAYABMAUAArACsABAAbABsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAFAABAAEAAQABAAEAFAABAAEAAQAUAAEAAQABAAEAAQAKwArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAArACsAHgArAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAB4ABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAUAAEAAQABAAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQAFAABAAEAA0ADQBLAEsASwBLAEsASwBLAEsASwBLAB4AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAArAFAAUABQAFAAUABQAFAAUAArACsAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUAArACsAKwBQAFAAUABQACsAKwAEAFAABAAEAAQABAAEAAQABAArACsABAAEACsAKwAEAAQABABQACsAKwArACsAKwArACsAKwAEACsAKwArACsAUABQACsAUABQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLAFAAUAAaABoAUABQAFAAUABQAEwAHgAbAFAAHgAEACsAKwAEAAQABAArAFAAUABQAFAAUABQACsAKwArACsAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQACsAUABQACsAUABQACsAKwAEACsABAAEAAQABAAEACsAKwArACsABAAEACsAKwAEAAQABAArACsAKwAEACsAKwArACsAKwArACsAUABQAFAAUAArAFAAKwArACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLAAQABABQAFAAUAAEAB4AKwArACsAKwArACsAKwArACsAKwAEAAQABAArAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQACsAUABQAFAAUABQACsAKwAEAFAABAAEAAQABAAEAAQABAAEACsABAAEAAQAKwAEAAQABAArACsAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLAB4AGwArACsAKwArACsAKwArAFAABAAEAAQABAAEAAQAKwAEAAQABAArAFAAUABQAFAAUABQAFAAUAArACsAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAArACsABAAEACsAKwAEAAQABAArACsAKwArACsAKwArAAQABAAEACsAKwArACsAUABQACsAUABQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLAB4AUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArAAQAUAArAFAAUABQAFAAUABQACsAKwArAFAAUABQACsAUABQAFAAUAArACsAKwBQAFAAKwBQACsAUABQACsAKwArAFAAUAArACsAKwBQAFAAUAArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArAAQABAAEAAQABAArACsAKwAEAAQABAArAAQABAAEAAQAKwArAFAAKwArACsAKwArACsABAArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAUABQAFAAHgAeAB4AHgAeAB4AGwAeACsAKwArACsAKwAEAAQABAAEAAQAUABQAFAAUABQAFAAUABQACsAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAUAAEAAQABAAEAAQABAAEACsABAAEAAQAKwAEAAQABAAEACsAKwArACsAKwArACsABAAEACsAUABQAFAAKwArACsAKwArAFAAUAAEAAQAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAKwAOAFAAUABQAFAAUABQAFAAHgBQAAQABAAEAA4AUABQAFAAUABQAFAAUABQACsAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAKwArAAQAUAAEAAQABAAEAAQABAAEACsABAAEAAQAKwAEAAQABAAEACsAKwArACsAKwArACsABAAEACsAKwArACsAKwArACsAUAArAFAAUAAEAAQAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwBQAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAFAABAAEAAQABAAEAAQABAArAAQABAAEACsABAAEAAQABABQAB4AKwArACsAKwBQAFAAUAAEAFAAUABQAFAAUABQAFAAUABQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLAFAAUABQAFAAUABQAFAAUABQABoAUABQAFAAUABQAFAAKwAEAAQABAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQACsAUAArACsAUABQAFAAUABQAFAAUAArACsAKwAEACsAKwArACsABAAEAAQABAAEAAQAKwAEACsABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArAAQABAAeACsAKwArACsAKwArACsAKwArACsAKwArAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAAqAFwAXAAqACoAKgAqACoAKgAqACsAKwArACsAGwBcAFwAXABcAFwAXABcACoAKgAqACoAKgAqACoAKgAeAEsASwBLAEsASwBLAEsASwBLAEsADQANACsAKwArACsAKwBcAFwAKwBcACsAXABcAFwAXABcACsAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACsAXAArAFwAXABcAFwAXABcAFwAXABcAFwAKgBcAFwAKgAqACoAKgAqACoAKgAqACoAXAArACsAXABcAFwAXABcACsAXAArACoAKgAqACoAKgAqACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwBcAFwAXABcAFAADgAOAA4ADgAeAA4ADgAJAA4ADgANAAkAEwATABMAEwATAAkAHgATAB4AHgAeAAQABAAeAB4AHgAeAB4AHgBLAEsASwBLAEsASwBLAEsASwBLAFAAUABQAFAAUABQAFAAUABQAFAADQAEAB4ABAAeAAQAFgARABYAEQAEAAQAUABQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQADQAEAAQABAAEAAQADQAEAAQAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABAArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArAA0ADQAeAB4AHgAeAB4AHgAEAB4AHgAeAB4AHgAeACsAHgAeAA4ADgANAA4AHgAeAB4AHgAeAAkACQArACsAKwArACsAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgBcAEsASwBLAEsASwBLAEsASwBLAEsADQANAB4AHgAeAB4AXABcAFwAXABcAFwAKgAqACoAKgBcAFwAXABcACoAKgAqAFwAKgAqACoAXABcACoAKgAqACoAKgAqACoAXABcAFwAKgAqACoAKgBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACoAKgAqACoAKgAqACoAKgAqACoAKgAqAFwAKgBLAEsASwBLAEsASwBLAEsASwBLACoAKgAqACoAKgAqAFAAUABQAFAAUABQACsAUAArACsAKwArACsAUAArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgBQAFAAUABQAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUAArACsAUABQAFAAUABQAFAAUAArAFAAKwBQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAKwArAFAAUABQAFAAUABQAFAAKwBQACsAUABQAFAAUAArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsABAAEAAQAHgANAB4AHgAeAB4AHgAeAB4AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUAArACsADQBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAANAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAWABEAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAA0ADQANAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAAQABAAEACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAANAA0AKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUAArAAQABAArACsAKwArACsAKwArACsAKwArACsAKwBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqAA0ADQAVAFwADQAeAA0AGwBcACoAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwAeAB4AEwATAA0ADQAOAB4AEwATAB4ABAAEAAQACQArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUAAEAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQAUAArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAArACsAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAHgArACsAKwATABMASwBLAEsASwBLAEsASwBLAEsASwBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAArACsAXABcAFwAXABcACsAKwArACsAKwArACsAKwArACsAKwBcAFwAXABcAFwAXABcAFwAXABcAFwAXAArACsAKwArAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAXAArACsAKwAqACoAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAArACsAHgAeAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACoAKgAqACoAKgAqACoAKgAqACoAKwAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKwArAAQASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwArACsAKwArACoAKgAqACoAKgAqACoAXAAqACoAKgAqACoAKgArACsABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsABAAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABABQAFAAUABQAFAAUABQACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwANAA0AHgANAA0ADQANAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAEAAQABAAEAAQAHgAeAB4AHgAeAB4AHgAeAB4AKwArACsABAAEAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABQAFAASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwAeAB4AHgAeAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArAA0ADQANAA0ADQBLAEsASwBLAEsASwBLAEsASwBLACsAKwArAFAAUABQAEsASwBLAEsASwBLAEsASwBLAEsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAA0ADQBQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUAAeAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArAAQABAAEAB4ABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAAQAUABQAFAAUABQAFAABABQAFAABAAEAAQAUAArACsAKwArACsABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsABAAEAAQABAAEAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAKwBQACsAUAArAFAAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArAB4AHgAeAB4AHgAeAB4AHgBQAB4AHgAeAFAAUABQACsAHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAUABQACsAKwAeAB4AHgAeAB4AHgArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArAFAAUABQACsAHgAeAB4AHgAeAB4AHgAOAB4AKwANAA0ADQANAA0ADQANAAkADQANAA0ACAAEAAsABAAEAA0ACQANAA0ADAAdAB0AHgAXABcAFgAXABcAFwAWABcAHQAdAB4AHgAUABQAFAANAAEAAQAEAAQABAAEAAQACQAaABoAGgAaABoAGgAaABoAHgAXABcAHQAVABUAHgAeAB4AHgAeAB4AGAAWABEAFQAVABUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ADQAeAA0ADQANAA0AHgANAA0ADQAHAB4AHgAeAB4AKwAEAAQABAAEAAQABAAEAAQABAAEAFAAUAArACsATwBQAFAAUABQAFAAHgAeAB4AFgARAE8AUABPAE8ATwBPAFAAUABQAFAAUAAeAB4AHgAWABEAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArABsAGwAbABsAGwAbABsAGgAbABsAGwAbABsAGwAbABsAGwAbABsAGwAbABsAGgAbABsAGwAbABoAGwAbABoAGwAbABsAGwAbABsAGwAbABsAGwAbABsAGwAbABsAGwAbAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAHgAeAFAAGgAeAB0AHgBQAB4AGgAeAB4AHgAeAB4AHgAeAB4AHgBPAB4AUAAbAB4AHgBQAFAAUABQAFAAHgAeAB4AHQAdAB4AUAAeAFAAHgBQAB4AUABPAFAAUAAeAB4AHgAeAB4AHgAeAFAAUABQAFAAUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAAHgBQAFAAUABQAE8ATwBQAFAAUABQAFAATwBQAFAATwBQAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAFAAUABQAFAATwBPAE8ATwBPAE8ATwBPAE8ATwBQAFAAUABQAFAAUABQAFAAUAAeAB4AUABQAFAAUABPAB4AHgArACsAKwArAB0AHQAdAB0AHQAdAB0AHQAdAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHgAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB4AHQAdAB4AHgAeAB0AHQAeAB4AHQAeAB4AHgAdAB4AHQAbABsAHgAdAB4AHgAeAB4AHQAeAB4AHQAdAB0AHQAeAB4AHQAeAB0AHgAdAB0AHQAdAB0AHQAeAB0AHgAeAB4AHgAeAB0AHQAdAB0AHgAeAB4AHgAdAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB4AHgAeAB0AHgAeAB4AHgAeAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB0AHgAeAB0AHQAdAB0AHgAeAB0AHQAeAB4AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHQAeAB4AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHQAeAB4AHgAdAB4AHgAeAB4AHgAeAB4AHQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AFAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeABYAEQAWABEAHgAeAB4AHgAeAB4AHQAeAB4AHgAeAB4AHgAeACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAWABEAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAFAAHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHgAeAB4AHgAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAeAB4AHQAdAB0AHQAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHQAeAB0AHQAdAB0AHQAdAB0AHgAeAB4AHgAeAB4AHgAeAB0AHQAeAB4AHQAdAB4AHgAeAB4AHQAdAB4AHgAeAB4AHQAdAB0AHgAeAB0AHgAeAB0AHQAdAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB0AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAlAB4AHQAdAB4AHgAdAB4AHgAeAB4AHQAdAB4AHgAeAB4AJQAlAB0AHQAlAB4AJQAlACUAIAAlACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAeAB4AHgAeAB0AHgAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB0AHgAdAB0AHQAeAB0AJQAdAB0AHgAdAB0AHgAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAlACUAJQAlACUAJQAlACUAJQAdAB0AHQAdACUAHgAlACUAJQAdACUAJQAdAB0AHQAlACUAHQAdACUAHQAdACUAJQAlAB4AHQAeAB4AHgAeAB0AHQAlAB0AHQAdAB0AHQAdACUAJQAlACUAJQAdACUAJQAgACUAHQAdACUAJQAlACUAJQAlACUAJQAeAB4AHgAlACUAIAAgACAAIAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHgAeAB4AFwAXABcAFwAXABcAHgATABMAJQAeAB4AHgAWABEAFgARABYAEQAWABEAFgARABYAEQAWABEATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeABYAEQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAWABEAFgARABYAEQAWABEAFgARAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AFgARABYAEQAWABEAFgARABYAEQAWABEAFgARABYAEQAWABEAFgARABYAEQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAWABEAFgARAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AFgARAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB0AHQAdAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AUABQAFAAUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAEAAQABAAeAB4AKwArACsAKwArABMADQANAA0AUAATAA0AUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAUAANACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAA0ADQANAA0ADQANAA0ADQAeAA0AFgANAB4AHgAXABcAHgAeABcAFwAWABEAFgARABYAEQAWABEADQANAA0ADQATAFAADQANAB4ADQANAB4AHgAeAB4AHgAMAAwADQANAA0AHgANAA0AFgANAA0ADQANAA0ADQANAA0AHgANAB4ADQANAB4AHgAeACsAKwArACsAKwArACsAKwArACsAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAKwArACsAKwArACsAKwArACsAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAlACUAJQAlACUAJQAlACUAJQAlACUAJQArACsAKwArAA0AEQARACUAJQBHAFcAVwAWABEAFgARABYAEQAWABEAFgARACUAJQAWABEAFgARABYAEQAWABEAFQAWABEAEQAlAFcAVwBXAFcAVwBXAFcAVwBXAAQABAAEAAQABAAEACUAVwBXAFcAVwA2ACUAJQBXAFcAVwBHAEcAJQAlACUAKwBRAFcAUQBXAFEAVwBRAFcAUQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFEAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBRAFcAUQBXAFEAVwBXAFcAVwBXAFcAUQBXAFcAVwBXAFcAVwBRAFEAKwArAAQABAAVABUARwBHAFcAFQBRAFcAUQBXAFEAVwBRAFcAUQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFEAVwBRAFcAUQBXAFcAVwBXAFcAVwBRAFcAVwBXAFcAVwBXAFEAUQBXAFcAVwBXABUAUQBHAEcAVwArACsAKwArACsAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAKwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAKwAlACUAVwBXAFcAVwAlACUAJQAlACUAJQAlACUAJQAlACsAKwArACsAKwArACsAKwArACsAKwArAFEAUQBRAFEAUQBRAFEAUQBRAFEAUQBRAFEAUQBRAFEAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQArAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQBPAE8ATwBPAE8ATwBPAE8AJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACUAJQAlAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAEcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAADQATAA0AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABLAEsASwBLAEsASwBLAEsASwBLAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAABAAEAAQABAAeAAQABAAEAAQABAAEAAQABAAEAAQAHgBQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AUABQAAQABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAeAA0ADQANAA0ADQArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAB4AHgAeAB4AHgAeAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAHgAeAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAeAB4AUABQAFAAUABQAFAAUABQAFAAUABQAAQAUABQAFAABABQAFAAUABQAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAeAB4AHgAeAAQAKwArACsAUABQAFAAUABQAFAAHgAeABoAHgArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAADgAOABMAEwArACsAKwArACsAKwArACsABAAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwANAA0ASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArACsAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAFAAUAAeAB4AHgBQAA4AUABQAAQAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAA0ADQBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwArACsAKwArACsAKwArAB4AWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYACsAKwArAAQAHgAeAB4AHgAeAB4ADQANAA0AHgAeAB4AHgArAFAASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArAB4AHgBcAFwAXABcAFwAKgBcAFwAXABcAFwAXABcAFwAXABcAEsASwBLAEsASwBLAEsASwBLAEsAXABcAFwAXABcACsAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwArAFAAUABQAAQAUABQAFAAUABQAFAAUABQAAQABAArACsASwBLAEsASwBLAEsASwBLAEsASwArACsAHgANAA0ADQBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAKgAqACoAXAAqACoAKgBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAAqAFwAKgAqACoAXABcACoAKgBcAFwAXABcAFwAKgAqAFwAKgBcACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFwAXABcACoAKgBQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAA0ADQBQAFAAUAAEAAQAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUAArACsAUABQAFAAUABQAFAAKwArAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQADQAEAAQAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAVABVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBUAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVACsAKwArACsAKwArACsAKwArACsAKwArAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAKwArACsAKwBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAKwArACsAKwAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAKwArACsAKwArAFYABABWAFYAVgBWAFYAVgBWAFYAVgBWAB4AVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgArAFYAVgBWAFYAVgArAFYAKwBWAFYAKwBWAFYAKwBWAFYAVgBWAFYAVgBWAFYAVgBWAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAEQAWAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUAAaAB4AKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAGAARABEAGAAYABMAEwAWABEAFAArACsAKwArACsAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACUAJQAlACUAJQAWABEAFgARABYAEQAWABEAFgARABYAEQAlACUAFgARACUAJQAlACUAJQAlACUAEQAlABEAKwAVABUAEwATACUAFgARABYAEQAWABEAJQAlACUAJQAlACUAJQAlACsAJQAbABoAJQArACsAKwArAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAcAKwATACUAJQAbABoAJQAlABYAEQAlACUAEQAlABEAJQBXAFcAVwBXAFcAVwBXAFcAVwBXABUAFQAlACUAJQATACUAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXABYAJQARACUAJQAlAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwAWACUAEQAlABYAEQARABYAEQARABUAVwBRAFEAUQBRAFEAUQBRAFEAUQBRAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAEcARwArACsAVwBXAFcAVwBXAFcAKwArAFcAVwBXAFcAVwBXACsAKwBXAFcAVwBXAFcAVwArACsAVwBXAFcAKwArACsAGgAbACUAJQAlABsAGwArAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwAEAAQABAAQAB0AKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsADQANAA0AKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAB4AHgAeAB4AHgAeAB4AHgAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAAQAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAA0AUABQAFAAUAArACsAKwArAFAAUABQAFAAUABQAFAAUAANAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwAeACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAKwArAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUAArACsAKwBQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwANAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAB4AUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUAArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAA0AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAUABQAFAAUABQAAQABAAEACsABAAEACsAKwArACsAKwAEAAQABAAEAFAAUABQAFAAKwBQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAQABAAEACsAKwArACsABABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAA0ADQANAA0ADQANAA0ADQAeACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAFAAUABQAFAAUABQAFAAUAAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAArACsAKwArAFAAUABQAFAAUAANAA0ADQANAA0ADQAUACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsADQANAA0ADQANAA0ADQBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAAQABAAEAAQAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUAArAAQABAANACsAKwBQAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAB4AHgAeAB4AHgArACsAKwArACsAKwAEAAQABAAEAAQABAAEAA0ADQAeAB4AHgAeAB4AKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABAAeAB4AHgANAA0ADQANACsAKwArACsAKwArACsAKwArACsAKwAeACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwArACsAKwArAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsASwBLAEsASwBLAEsASwBLAEsASwANAA0ADQANAFAABAAEAFAAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAeAA4AUAArACsAKwArACsAKwArACsAKwAEAFAAUABQAFAADQANAB4ADQAEAAQABAAEAB4ABAAEAEsASwBLAEsASwBLAEsASwBLAEsAUAAOAFAADQANAA0AKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAANAA0AHgANAA0AHgAEACsAUABQAFAAUABQAFAAUAArAFAAKwBQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAA0AKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsABAAEAAQABAArAFAAUABQAFAAUABQAFAAUAArACsAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQACsAUABQAFAAUABQACsABAAEAFAABAAEAAQABAAEAAQABAArACsABAAEACsAKwAEAAQABAArACsAUAArACsAKwArACsAKwAEACsAKwArACsAKwBQAFAAUABQAFAABAAEACsAKwAEAAQABAAEAAQABAAEACsAKwArAAQABAAEAAQABAArACsAKwArACsAKwArACsAKwArACsABAAEAAQABAAEAAQABABQAFAAUABQAA0ADQANAA0AHgBLAEsASwBLAEsASwBLAEsASwBLAA0ADQArAB4ABABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAAQABAAEAFAAUAAeAFAAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAArACsABAAEAAQABAAEAAQABAAEAAQADgANAA0AEwATAB4AHgAeAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAFAAUABQAFAABAAEACsAKwAEAA0ADQAeAFAAKwArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAFAAKwArACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAKwArACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwBcAFwADQANAA0AKgBQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAeACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAKwArAFAAKwArAFAAUABQAFAAUABQAFAAUAArAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQAKwAEAAQAKwArAAQABAAEAAQAUAAEAFAABAAEAA0ADQANACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAArACsABAAEAAQABAAEAAQABABQAA4AUAAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAFAABAAEAAQABAAOAB4ADQANAA0ADQAOAB4ABAArACsAKwArACsAKwArACsAUAAEAAQABAAEAAQABAAEAAQABAAEAAQAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAA0ADQANAFAADgAOAA4ADQANACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEACsABAAEAAQABAAEAAQABAAEAFAADQANAA0ADQANACsAKwArACsAKwArACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwAOABMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQACsAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAArACsAKwAEACsABAAEACsABAAEAAQABAAEAAQABABQAAQAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAKwBQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQAKwAEAAQAKwAEAAQABAAEAAQAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAaABoAGgAaAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwArACsAKwArAA0AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsADQANAA0ADQANACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAASABIAEgAQwBDAEMAUABQAFAAUABDAFAAUABQAEgAQwBIAEMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAASABDAEMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwAJAAkACQAJAAkACQAJABYAEQArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABIAEMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwANAA0AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAQABAAEAAQABAANACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAA0ADQANAB4AHgAeAB4AHgAeAFAAUABQAFAADQAeACsAKwArACsAKwArACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwArAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAANAA0AHgAeACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwAEAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwArACsAKwAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAARwBHABUARwAJACsAKwArACsAKwArACsAKwArACsAKwAEAAQAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACsAKwArACsAKwArACsAKwBXAFcAVwBXAFcAVwBXAFcAVwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUQBRAFEAKwArACsAKwArACsAKwArACsAKwArACsAKwBRAFEAUQBRACsAKwArACsAKwArACsAKwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUAArACsAHgAEAAQADQAEAAQABAAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwArAB4AHgAeAB4AHgAeAB4AKwArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAAQABAAEAAQABAAeAB4AHgAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAB4AHgAEAAQABAAEAAQABAAEAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQAHgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwBQAFAAKwArAFAAKwArAFAAUAArACsAUABQAFAAUAArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAUAArAFAAUABQAFAAUABQAFAAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwBQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAHgAeAFAAUABQAFAAUAArAFAAKwArACsAUABQAFAAUABQAFAAUAArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAeACsAKwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAeAB4AHgAeAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAeAB4AHgAeAB4AHgAeAB4ABAAeAB4AHgAeAB4AHgAeAB4AHgAeAAQAHgAeAA0ADQANAA0AHgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAAQABAAEAAQAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAAQABAAEAAQABAAEAAQAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArAAQABAAEAAQABAAEAAQAKwAEAAQAKwAEAAQABAAEAAQAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwAEAAQABAAEAAQABAAEAFAAUABQAFAAUABQAFAAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwBQAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArABsAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwArAB4AHgAeAB4ABAAEAAQABAAEAAQABABQACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArABYAFgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAGgBQAFAAUAAaAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAKwBQACsAKwBQACsAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAKwBQACsAUAArACsAKwArACsAKwBQACsAKwArACsAUAArAFAAKwBQACsAUABQAFAAKwBQAFAAKwBQACsAKwBQACsAUAArAFAAKwBQACsAUAArAFAAUAArAFAAKwArAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQAFAAUAArAFAAUABQAFAAKwBQACsAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAUABQAFAAKwBQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8AJQAlACUAHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHgAeAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB4AHgAeACUAJQAlAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAJQAlACUAJQAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlAB4AHgAlACUAJQAlACUAHgAlACUAJQAlACUAIAAgACAAJQAlACAAJQAlACAAIAAgACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACEAIQAhACEAIQAlACUAIAAgACUAJQAgACAAIAAgACAAIAAgACAAIAAgACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAJQAlACUAIAAlACUAJQAlACAAIAAgACUAIAAgACAAJQAlACUAJQAlACUAJQAgACUAIAAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAHgAlAB4AJQAeACUAJQAlACUAJQAgACUAJQAlACUAHgAlAB4AHgAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAIAAlACUAJQAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAJQAlACUAJQAgACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAlACUAJQAlACUAJQAlACAAIAAgACUAJQAlACAAIAAgACAAIAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeABcAFwAXABUAFQAVAB4AHgAeAB4AJQAlACUAIAAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAIAAgACUAJQAlACUAJQAlACUAJQAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAlACUAJQAlACUAJQAlACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAlACUAJQAlACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAgACUAJQAgACUAJQAlACUAJQAlACUAJQAgACAAIAAgACAAIAAgACAAJQAlACUAJQAlACUAIAAlACUAJQAlACUAJQAlACUAJQAgACAAIAAgACAAIAAgACAAIAAgACUAJQAgACAAIAAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAgACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAIAAlACAAIAAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAgACAAIAAlACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAJQAlAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAKwArAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwAlACUAJQAlACUAJQAlACUAJQAlACUAVwBXACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAKwAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAA==";
      var LETTER_NUMBER_MODIFIER = 50;
      var BK = 1;
      var CR$1 = 2;
      var LF$1 = 3;
      var CM = 4;
      var NL = 5;
      var WJ = 7;
      var ZW = 8;
      var GL = 9;
      var SP = 10;
      var ZWJ$1 = 11;
      var B2 = 12;
      var BA = 13;
      var BB = 14;
      var HY = 15;
      var CB = 16;
      var CL = 17;
      var CP = 18;
      var EX = 19;
      var IN = 20;
      var NS = 21;
      var OP = 22;
      var QU = 23;
      var IS = 24;
      var NU = 25;
      var PO = 26;
      var PR = 27;
      var SY = 28;
      var AI = 29;
      var AL = 30;
      var CJ = 31;
      var EB = 32;
      var EM = 33;
      var H2 = 34;
      var H3 = 35;
      var HL = 36;
      var ID = 37;
      var JL = 38;
      var JV = 39;
      var JT = 40;
      var RI$1 = 41;
      var SA = 42;
      var XX = 43;
      var ea_OP = [9001, 65288];
      var BREAK_MANDATORY = "!";
      var BREAK_NOT_ALLOWED$1 = "\xD7";
      var BREAK_ALLOWED$1 = "\xF7";
      var UnicodeTrie$1 = createTrieFromBase64$1(base64$1);
      var ALPHABETICS = [AL, HL];
      var HARD_LINE_BREAKS = [BK, CR$1, LF$1, NL];
      var SPACE$1 = [SP, ZW];
      var PREFIX_POSTFIX = [PR, PO];
      var LINE_BREAKS = HARD_LINE_BREAKS.concat(SPACE$1);
      var KOREAN_SYLLABLE_BLOCK = [JL, JV, JT, H2, H3];
      var HYPHEN = [HY, BA];
      var codePointsToCharacterClasses = function(codePoints, lineBreak2) {
        if (lineBreak2 === void 0) {
          lineBreak2 = "strict";
        }
        var types = [];
        var indices = [];
        var categories = [];
        codePoints.forEach(function(codePoint, index3) {
          var classType = UnicodeTrie$1.get(codePoint);
          if (classType > LETTER_NUMBER_MODIFIER) {
            categories.push(true);
            classType -= LETTER_NUMBER_MODIFIER;
          } else {
            categories.push(false);
          }
          if (["normal", "auto", "loose"].indexOf(lineBreak2) !== -1) {
            if ([8208, 8211, 12316, 12448].indexOf(codePoint) !== -1) {
              indices.push(index3);
              return types.push(CB);
            }
          }
          if (classType === CM || classType === ZWJ$1) {
            if (index3 === 0) {
              indices.push(index3);
              return types.push(AL);
            }
            var prev2 = types[index3 - 1];
            if (LINE_BREAKS.indexOf(prev2) === -1) {
              indices.push(indices[index3 - 1]);
              return types.push(prev2);
            }
            indices.push(index3);
            return types.push(AL);
          }
          indices.push(index3);
          if (classType === CJ) {
            return types.push(lineBreak2 === "strict" ? NS : ID);
          }
          if (classType === SA) {
            return types.push(AL);
          }
          if (classType === AI) {
            return types.push(AL);
          }
          if (classType === XX) {
            if (codePoint >= 131072 && codePoint <= 196605 || codePoint >= 196608 && codePoint <= 262141) {
              return types.push(ID);
            } else {
              return types.push(AL);
            }
          }
          types.push(classType);
        });
        return [indices, types, categories];
      };
      var isAdjacentWithSpaceIgnored = function(a3, b, currentIndex, classTypes) {
        var current = classTypes[currentIndex];
        if (Array.isArray(a3) ? a3.indexOf(current) !== -1 : a3 === current) {
          var i3 = currentIndex;
          while (i3 <= classTypes.length) {
            i3++;
            var next2 = classTypes[i3];
            if (next2 === b) {
              return true;
            }
            if (next2 !== SP) {
              break;
            }
          }
        }
        if (current === SP) {
          var i3 = currentIndex;
          while (i3 > 0) {
            i3--;
            var prev2 = classTypes[i3];
            if (Array.isArray(a3) ? a3.indexOf(prev2) !== -1 : a3 === prev2) {
              var n2 = currentIndex;
              while (n2 <= classTypes.length) {
                n2++;
                var next2 = classTypes[n2];
                if (next2 === b) {
                  return true;
                }
                if (next2 !== SP) {
                  break;
                }
              }
            }
            if (prev2 !== SP) {
              break;
            }
          }
        }
        return false;
      };
      var previousNonSpaceClassType = function(currentIndex, classTypes) {
        var i3 = currentIndex;
        while (i3 >= 0) {
          var type = classTypes[i3];
          if (type === SP) {
            i3--;
          } else {
            return type;
          }
        }
        return 0;
      };
      var _lineBreakAtIndex = function(codePoints, classTypes, indicies, index3, forbiddenBreaks) {
        if (indicies[index3] === 0) {
          return BREAK_NOT_ALLOWED$1;
        }
        var currentIndex = index3 - 1;
        if (Array.isArray(forbiddenBreaks) && forbiddenBreaks[currentIndex] === true) {
          return BREAK_NOT_ALLOWED$1;
        }
        var beforeIndex = currentIndex - 1;
        var afterIndex = currentIndex + 1;
        var current = classTypes[currentIndex];
        var before2 = beforeIndex >= 0 ? classTypes[beforeIndex] : 0;
        var next2 = classTypes[afterIndex];
        if (current === CR$1 && next2 === LF$1) {
          return BREAK_NOT_ALLOWED$1;
        }
        if (HARD_LINE_BREAKS.indexOf(current) !== -1) {
          return BREAK_MANDATORY;
        }
        if (HARD_LINE_BREAKS.indexOf(next2) !== -1) {
          return BREAK_NOT_ALLOWED$1;
        }
        if (SPACE$1.indexOf(next2) !== -1) {
          return BREAK_NOT_ALLOWED$1;
        }
        if (previousNonSpaceClassType(currentIndex, classTypes) === ZW) {
          return BREAK_ALLOWED$1;
        }
        if (UnicodeTrie$1.get(codePoints[currentIndex]) === ZWJ$1) {
          return BREAK_NOT_ALLOWED$1;
        }
        if ((current === EB || current === EM) && UnicodeTrie$1.get(codePoints[afterIndex]) === ZWJ$1) {
          return BREAK_NOT_ALLOWED$1;
        }
        if (current === WJ || next2 === WJ) {
          return BREAK_NOT_ALLOWED$1;
        }
        if (current === GL) {
          return BREAK_NOT_ALLOWED$1;
        }
        if ([SP, BA, HY].indexOf(current) === -1 && next2 === GL) {
          return BREAK_NOT_ALLOWED$1;
        }
        if ([CL, CP, EX, IS, SY].indexOf(next2) !== -1) {
          return BREAK_NOT_ALLOWED$1;
        }
        if (previousNonSpaceClassType(currentIndex, classTypes) === OP) {
          return BREAK_NOT_ALLOWED$1;
        }
        if (isAdjacentWithSpaceIgnored(QU, OP, currentIndex, classTypes)) {
          return BREAK_NOT_ALLOWED$1;
        }
        if (isAdjacentWithSpaceIgnored([CL, CP], NS, currentIndex, classTypes)) {
          return BREAK_NOT_ALLOWED$1;
        }
        if (isAdjacentWithSpaceIgnored(B2, B2, currentIndex, classTypes)) {
          return BREAK_NOT_ALLOWED$1;
        }
        if (current === SP) {
          return BREAK_ALLOWED$1;
        }
        if (current === QU || next2 === QU) {
          return BREAK_NOT_ALLOWED$1;
        }
        if (next2 === CB || current === CB) {
          return BREAK_ALLOWED$1;
        }
        if ([BA, HY, NS].indexOf(next2) !== -1 || current === BB) {
          return BREAK_NOT_ALLOWED$1;
        }
        if (before2 === HL && HYPHEN.indexOf(current) !== -1) {
          return BREAK_NOT_ALLOWED$1;
        }
        if (current === SY && next2 === HL) {
          return BREAK_NOT_ALLOWED$1;
        }
        if (next2 === IN) {
          return BREAK_NOT_ALLOWED$1;
        }
        if (ALPHABETICS.indexOf(next2) !== -1 && current === NU || ALPHABETICS.indexOf(current) !== -1 && next2 === NU) {
          return BREAK_NOT_ALLOWED$1;
        }
        if (current === PR && [ID, EB, EM].indexOf(next2) !== -1 || [ID, EB, EM].indexOf(current) !== -1 && next2 === PO) {
          return BREAK_NOT_ALLOWED$1;
        }
        if (ALPHABETICS.indexOf(current) !== -1 && PREFIX_POSTFIX.indexOf(next2) !== -1 || PREFIX_POSTFIX.indexOf(current) !== -1 && ALPHABETICS.indexOf(next2) !== -1) {
          return BREAK_NOT_ALLOWED$1;
        }
        if (
          // (PR | PO) × ( OP | HY )? NU
          [PR, PO].indexOf(current) !== -1 && (next2 === NU || [OP, HY].indexOf(next2) !== -1 && classTypes[afterIndex + 1] === NU) || // ( OP | HY ) × NU
          [OP, HY].indexOf(current) !== -1 && next2 === NU || // NU ×	(NU | SY | IS)
          current === NU && [NU, SY, IS].indexOf(next2) !== -1
        ) {
          return BREAK_NOT_ALLOWED$1;
        }
        if ([NU, SY, IS, CL, CP].indexOf(next2) !== -1) {
          var prevIndex = currentIndex;
          while (prevIndex >= 0) {
            var type = classTypes[prevIndex];
            if (type === NU) {
              return BREAK_NOT_ALLOWED$1;
            } else if ([SY, IS].indexOf(type) !== -1) {
              prevIndex--;
            } else {
              break;
            }
          }
        }
        if ([PR, PO].indexOf(next2) !== -1) {
          var prevIndex = [CL, CP].indexOf(current) !== -1 ? beforeIndex : currentIndex;
          while (prevIndex >= 0) {
            var type = classTypes[prevIndex];
            if (type === NU) {
              return BREAK_NOT_ALLOWED$1;
            } else if ([SY, IS].indexOf(type) !== -1) {
              prevIndex--;
            } else {
              break;
            }
          }
        }
        if (JL === current && [JL, JV, H2, H3].indexOf(next2) !== -1 || [JV, H2].indexOf(current) !== -1 && [JV, JT].indexOf(next2) !== -1 || [JT, H3].indexOf(current) !== -1 && next2 === JT) {
          return BREAK_NOT_ALLOWED$1;
        }
        if (KOREAN_SYLLABLE_BLOCK.indexOf(current) !== -1 && [IN, PO].indexOf(next2) !== -1 || KOREAN_SYLLABLE_BLOCK.indexOf(next2) !== -1 && current === PR) {
          return BREAK_NOT_ALLOWED$1;
        }
        if (ALPHABETICS.indexOf(current) !== -1 && ALPHABETICS.indexOf(next2) !== -1) {
          return BREAK_NOT_ALLOWED$1;
        }
        if (current === IS && ALPHABETICS.indexOf(next2) !== -1) {
          return BREAK_NOT_ALLOWED$1;
        }
        if (ALPHABETICS.concat(NU).indexOf(current) !== -1 && next2 === OP && ea_OP.indexOf(codePoints[afterIndex]) === -1 || ALPHABETICS.concat(NU).indexOf(next2) !== -1 && current === CP) {
          return BREAK_NOT_ALLOWED$1;
        }
        if (current === RI$1 && next2 === RI$1) {
          var i3 = indicies[currentIndex];
          var count = 1;
          while (i3 > 0) {
            i3--;
            if (classTypes[i3] === RI$1) {
              count++;
            } else {
              break;
            }
          }
          if (count % 2 !== 0) {
            return BREAK_NOT_ALLOWED$1;
          }
        }
        if (current === EB && next2 === EM) {
          return BREAK_NOT_ALLOWED$1;
        }
        return BREAK_ALLOWED$1;
      };
      var cssFormattedClasses = function(codePoints, options) {
        if (!options) {
          options = { lineBreak: "normal", wordBreak: "normal" };
        }
        var _a2 = codePointsToCharacterClasses(codePoints, options.lineBreak), indicies = _a2[0], classTypes = _a2[1], isLetterNumber = _a2[2];
        if (options.wordBreak === "break-all" || options.wordBreak === "break-word") {
          classTypes = classTypes.map(function(type) {
            return [NU, AL, SA].indexOf(type) !== -1 ? ID : type;
          });
        }
        var forbiddenBreakpoints = options.wordBreak === "keep-all" ? isLetterNumber.map(function(letterNumber, i3) {
          return letterNumber && codePoints[i3] >= 19968 && codePoints[i3] <= 40959;
        }) : void 0;
        return [indicies, classTypes, forbiddenBreakpoints];
      };
      var Break = (
        /** @class */
        function() {
          function Break2(codePoints, lineBreak2, start, end) {
            this.codePoints = codePoints;
            this.required = lineBreak2 === BREAK_MANDATORY;
            this.start = start;
            this.end = end;
          }
          Break2.prototype.slice = function() {
            return fromCodePoint$1.apply(void 0, this.codePoints.slice(this.start, this.end));
          };
          return Break2;
        }()
      );
      var LineBreaker = function(str, options) {
        var codePoints = toCodePoints$1(str);
        var _a2 = cssFormattedClasses(codePoints, options), indicies = _a2[0], classTypes = _a2[1], forbiddenBreakpoints = _a2[2];
        var length2 = codePoints.length;
        var lastEnd = 0;
        var nextIndex = 0;
        return {
          next: function() {
            if (nextIndex >= length2) {
              return { done: true, value: null };
            }
            var lineBreak2 = BREAK_NOT_ALLOWED$1;
            while (nextIndex < length2 && (lineBreak2 = _lineBreakAtIndex(codePoints, classTypes, indicies, ++nextIndex, forbiddenBreakpoints)) === BREAK_NOT_ALLOWED$1) {
            }
            if (lineBreak2 !== BREAK_NOT_ALLOWED$1 || nextIndex === length2) {
              var value = new Break(codePoints, lineBreak2, lastEnd, nextIndex);
              lastEnd = nextIndex;
              return { value, done: false };
            }
            return { done: true, value: null };
          }
        };
      };
      var FLAG_UNRESTRICTED = 1 << 0;
      var FLAG_ID = 1 << 1;
      var FLAG_INTEGER = 1 << 2;
      var FLAG_NUMBER = 1 << 3;
      var LINE_FEED = 10;
      var SOLIDUS = 47;
      var REVERSE_SOLIDUS = 92;
      var CHARACTER_TABULATION = 9;
      var SPACE = 32;
      var QUOTATION_MARK = 34;
      var EQUALS_SIGN = 61;
      var NUMBER_SIGN = 35;
      var DOLLAR_SIGN = 36;
      var PERCENTAGE_SIGN = 37;
      var APOSTROPHE = 39;
      var LEFT_PARENTHESIS = 40;
      var RIGHT_PARENTHESIS = 41;
      var LOW_LINE = 95;
      var HYPHEN_MINUS = 45;
      var EXCLAMATION_MARK = 33;
      var LESS_THAN_SIGN = 60;
      var GREATER_THAN_SIGN = 62;
      var COMMERCIAL_AT = 64;
      var LEFT_SQUARE_BRACKET = 91;
      var RIGHT_SQUARE_BRACKET = 93;
      var CIRCUMFLEX_ACCENT = 61;
      var LEFT_CURLY_BRACKET = 123;
      var QUESTION_MARK = 63;
      var RIGHT_CURLY_BRACKET = 125;
      var VERTICAL_LINE = 124;
      var TILDE = 126;
      var CONTROL = 128;
      var REPLACEMENT_CHARACTER = 65533;
      var ASTERISK = 42;
      var PLUS_SIGN = 43;
      var COMMA = 44;
      var COLON = 58;
      var SEMICOLON = 59;
      var FULL_STOP = 46;
      var NULL = 0;
      var BACKSPACE = 8;
      var LINE_TABULATION = 11;
      var SHIFT_OUT = 14;
      var INFORMATION_SEPARATOR_ONE = 31;
      var DELETE = 127;
      var EOF = -1;
      var ZERO = 48;
      var a2 = 97;
      var e2 = 101;
      var f3 = 102;
      var u2 = 117;
      var z = 122;
      var A2 = 65;
      var E = 69;
      var F = 70;
      var U = 85;
      var Z = 90;
      var isDigit = function(codePoint) {
        return codePoint >= ZERO && codePoint <= 57;
      };
      var isSurrogateCodePoint = function(codePoint) {
        return codePoint >= 55296 && codePoint <= 57343;
      };
      var isHex2 = function(codePoint) {
        return isDigit(codePoint) || codePoint >= A2 && codePoint <= F || codePoint >= a2 && codePoint <= f3;
      };
      var isLowerCaseLetter = function(codePoint) {
        return codePoint >= a2 && codePoint <= z;
      };
      var isUpperCaseLetter = function(codePoint) {
        return codePoint >= A2 && codePoint <= Z;
      };
      var isLetter = function(codePoint) {
        return isLowerCaseLetter(codePoint) || isUpperCaseLetter(codePoint);
      };
      var isNonASCIICodePoint = function(codePoint) {
        return codePoint >= CONTROL;
      };
      var isWhiteSpace = function(codePoint) {
        return codePoint === LINE_FEED || codePoint === CHARACTER_TABULATION || codePoint === SPACE;
      };
      var isNameStartCodePoint = function(codePoint) {
        return isLetter(codePoint) || isNonASCIICodePoint(codePoint) || codePoint === LOW_LINE;
      };
      var isNameCodePoint = function(codePoint) {
        return isNameStartCodePoint(codePoint) || isDigit(codePoint) || codePoint === HYPHEN_MINUS;
      };
      var isNonPrintableCodePoint = function(codePoint) {
        return codePoint >= NULL && codePoint <= BACKSPACE || codePoint === LINE_TABULATION || codePoint >= SHIFT_OUT && codePoint <= INFORMATION_SEPARATOR_ONE || codePoint === DELETE;
      };
      var isValidEscape = function(c1, c22) {
        if (c1 !== REVERSE_SOLIDUS) {
          return false;
        }
        return c22 !== LINE_FEED;
      };
      var isIdentifierStart = function(c1, c22, c3) {
        if (c1 === HYPHEN_MINUS) {
          return isNameStartCodePoint(c22) || isValidEscape(c22, c3);
        } else if (isNameStartCodePoint(c1)) {
          return true;
        } else if (c1 === REVERSE_SOLIDUS && isValidEscape(c1, c22)) {
          return true;
        }
        return false;
      };
      var isNumberStart = function(c1, c22, c3) {
        if (c1 === PLUS_SIGN || c1 === HYPHEN_MINUS) {
          if (isDigit(c22)) {
            return true;
          }
          return c22 === FULL_STOP && isDigit(c3);
        }
        if (c1 === FULL_STOP) {
          return isDigit(c22);
        }
        return isDigit(c1);
      };
      var stringToNumber = function(codePoints) {
        var c3 = 0;
        var sign = 1;
        if (codePoints[c3] === PLUS_SIGN || codePoints[c3] === HYPHEN_MINUS) {
          if (codePoints[c3] === HYPHEN_MINUS) {
            sign = -1;
          }
          c3++;
        }
        var integers = [];
        while (isDigit(codePoints[c3])) {
          integers.push(codePoints[c3++]);
        }
        var int = integers.length ? parseInt(fromCodePoint$1.apply(void 0, integers), 10) : 0;
        if (codePoints[c3] === FULL_STOP) {
          c3++;
        }
        var fraction = [];
        while (isDigit(codePoints[c3])) {
          fraction.push(codePoints[c3++]);
        }
        var fracd = fraction.length;
        var frac = fracd ? parseInt(fromCodePoint$1.apply(void 0, fraction), 10) : 0;
        if (codePoints[c3] === E || codePoints[c3] === e2) {
          c3++;
        }
        var expsign = 1;
        if (codePoints[c3] === PLUS_SIGN || codePoints[c3] === HYPHEN_MINUS) {
          if (codePoints[c3] === HYPHEN_MINUS) {
            expsign = -1;
          }
          c3++;
        }
        var exponent = [];
        while (isDigit(codePoints[c3])) {
          exponent.push(codePoints[c3++]);
        }
        var exp = exponent.length ? parseInt(fromCodePoint$1.apply(void 0, exponent), 10) : 0;
        return sign * (int + frac * Math.pow(10, -fracd)) * Math.pow(10, expsign * exp);
      };
      var LEFT_PARENTHESIS_TOKEN = {
        type: 2
        /* LEFT_PARENTHESIS_TOKEN */
      };
      var RIGHT_PARENTHESIS_TOKEN = {
        type: 3
        /* RIGHT_PARENTHESIS_TOKEN */
      };
      var COMMA_TOKEN = {
        type: 4
        /* COMMA_TOKEN */
      };
      var SUFFIX_MATCH_TOKEN = {
        type: 13
        /* SUFFIX_MATCH_TOKEN */
      };
      var PREFIX_MATCH_TOKEN = {
        type: 8
        /* PREFIX_MATCH_TOKEN */
      };
      var COLUMN_TOKEN = {
        type: 21
        /* COLUMN_TOKEN */
      };
      var DASH_MATCH_TOKEN = {
        type: 9
        /* DASH_MATCH_TOKEN */
      };
      var INCLUDE_MATCH_TOKEN = {
        type: 10
        /* INCLUDE_MATCH_TOKEN */
      };
      var LEFT_CURLY_BRACKET_TOKEN = {
        type: 11
        /* LEFT_CURLY_BRACKET_TOKEN */
      };
      var RIGHT_CURLY_BRACKET_TOKEN = {
        type: 12
        /* RIGHT_CURLY_BRACKET_TOKEN */
      };
      var SUBSTRING_MATCH_TOKEN = {
        type: 14
        /* SUBSTRING_MATCH_TOKEN */
      };
      var BAD_URL_TOKEN = {
        type: 23
        /* BAD_URL_TOKEN */
      };
      var BAD_STRING_TOKEN = {
        type: 1
        /* BAD_STRING_TOKEN */
      };
      var CDO_TOKEN = {
        type: 25
        /* CDO_TOKEN */
      };
      var CDC_TOKEN = {
        type: 24
        /* CDC_TOKEN */
      };
      var COLON_TOKEN = {
        type: 26
        /* COLON_TOKEN */
      };
      var SEMICOLON_TOKEN = {
        type: 27
        /* SEMICOLON_TOKEN */
      };
      var LEFT_SQUARE_BRACKET_TOKEN = {
        type: 28
        /* LEFT_SQUARE_BRACKET_TOKEN */
      };
      var RIGHT_SQUARE_BRACKET_TOKEN = {
        type: 29
        /* RIGHT_SQUARE_BRACKET_TOKEN */
      };
      var WHITESPACE_TOKEN = {
        type: 31
        /* WHITESPACE_TOKEN */
      };
      var EOF_TOKEN = {
        type: 32
        /* EOF_TOKEN */
      };
      var Tokenizer = (
        /** @class */
        function() {
          function Tokenizer2() {
            this._value = [];
          }
          Tokenizer2.prototype.write = function(chunk) {
            this._value = this._value.concat(toCodePoints$1(chunk));
          };
          Tokenizer2.prototype.read = function() {
            var tokens = [];
            var token = this.consumeToken();
            while (token !== EOF_TOKEN) {
              tokens.push(token);
              token = this.consumeToken();
            }
            return tokens;
          };
          Tokenizer2.prototype.consumeToken = function() {
            var codePoint = this.consumeCodePoint();
            switch (codePoint) {
              case QUOTATION_MARK:
                return this.consumeStringToken(QUOTATION_MARK);
              case NUMBER_SIGN:
                var c1 = this.peekCodePoint(0);
                var c22 = this.peekCodePoint(1);
                var c3 = this.peekCodePoint(2);
                if (isNameCodePoint(c1) || isValidEscape(c22, c3)) {
                  var flags = isIdentifierStart(c1, c22, c3) ? FLAG_ID : FLAG_UNRESTRICTED;
                  var value = this.consumeName();
                  return { type: 5, value, flags };
                }
                break;
              case DOLLAR_SIGN:
                if (this.peekCodePoint(0) === EQUALS_SIGN) {
                  this.consumeCodePoint();
                  return SUFFIX_MATCH_TOKEN;
                }
                break;
              case APOSTROPHE:
                return this.consumeStringToken(APOSTROPHE);
              case LEFT_PARENTHESIS:
                return LEFT_PARENTHESIS_TOKEN;
              case RIGHT_PARENTHESIS:
                return RIGHT_PARENTHESIS_TOKEN;
              case ASTERISK:
                if (this.peekCodePoint(0) === EQUALS_SIGN) {
                  this.consumeCodePoint();
                  return SUBSTRING_MATCH_TOKEN;
                }
                break;
              case PLUS_SIGN:
                if (isNumberStart(codePoint, this.peekCodePoint(0), this.peekCodePoint(1))) {
                  this.reconsumeCodePoint(codePoint);
                  return this.consumeNumericToken();
                }
                break;
              case COMMA:
                return COMMA_TOKEN;
              case HYPHEN_MINUS:
                var e1 = codePoint;
                var e22 = this.peekCodePoint(0);
                var e3 = this.peekCodePoint(1);
                if (isNumberStart(e1, e22, e3)) {
                  this.reconsumeCodePoint(codePoint);
                  return this.consumeNumericToken();
                }
                if (isIdentifierStart(e1, e22, e3)) {
                  this.reconsumeCodePoint(codePoint);
                  return this.consumeIdentLikeToken();
                }
                if (e22 === HYPHEN_MINUS && e3 === GREATER_THAN_SIGN) {
                  this.consumeCodePoint();
                  this.consumeCodePoint();
                  return CDC_TOKEN;
                }
                break;
              case FULL_STOP:
                if (isNumberStart(codePoint, this.peekCodePoint(0), this.peekCodePoint(1))) {
                  this.reconsumeCodePoint(codePoint);
                  return this.consumeNumericToken();
                }
                break;
              case SOLIDUS:
                if (this.peekCodePoint(0) === ASTERISK) {
                  this.consumeCodePoint();
                  while (true) {
                    var c4 = this.consumeCodePoint();
                    if (c4 === ASTERISK) {
                      c4 = this.consumeCodePoint();
                      if (c4 === SOLIDUS) {
                        return this.consumeToken();
                      }
                    }
                    if (c4 === EOF) {
                      return this.consumeToken();
                    }
                  }
                }
                break;
              case COLON:
                return COLON_TOKEN;
              case SEMICOLON:
                return SEMICOLON_TOKEN;
              case LESS_THAN_SIGN:
                if (this.peekCodePoint(0) === EXCLAMATION_MARK && this.peekCodePoint(1) === HYPHEN_MINUS && this.peekCodePoint(2) === HYPHEN_MINUS) {
                  this.consumeCodePoint();
                  this.consumeCodePoint();
                  return CDO_TOKEN;
                }
                break;
              case COMMERCIAL_AT:
                var a1 = this.peekCodePoint(0);
                var a22 = this.peekCodePoint(1);
                var a3 = this.peekCodePoint(2);
                if (isIdentifierStart(a1, a22, a3)) {
                  var value = this.consumeName();
                  return { type: 7, value };
                }
                break;
              case LEFT_SQUARE_BRACKET:
                return LEFT_SQUARE_BRACKET_TOKEN;
              case REVERSE_SOLIDUS:
                if (isValidEscape(codePoint, this.peekCodePoint(0))) {
                  this.reconsumeCodePoint(codePoint);
                  return this.consumeIdentLikeToken();
                }
                break;
              case RIGHT_SQUARE_BRACKET:
                return RIGHT_SQUARE_BRACKET_TOKEN;
              case CIRCUMFLEX_ACCENT:
                if (this.peekCodePoint(0) === EQUALS_SIGN) {
                  this.consumeCodePoint();
                  return PREFIX_MATCH_TOKEN;
                }
                break;
              case LEFT_CURLY_BRACKET:
                return LEFT_CURLY_BRACKET_TOKEN;
              case RIGHT_CURLY_BRACKET:
                return RIGHT_CURLY_BRACKET_TOKEN;
              case u2:
              case U:
                var u1 = this.peekCodePoint(0);
                var u22 = this.peekCodePoint(1);
                if (u1 === PLUS_SIGN && (isHex2(u22) || u22 === QUESTION_MARK)) {
                  this.consumeCodePoint();
                  this.consumeUnicodeRangeToken();
                }
                this.reconsumeCodePoint(codePoint);
                return this.consumeIdentLikeToken();
              case VERTICAL_LINE:
                if (this.peekCodePoint(0) === EQUALS_SIGN) {
                  this.consumeCodePoint();
                  return DASH_MATCH_TOKEN;
                }
                if (this.peekCodePoint(0) === VERTICAL_LINE) {
                  this.consumeCodePoint();
                  return COLUMN_TOKEN;
                }
                break;
              case TILDE:
                if (this.peekCodePoint(0) === EQUALS_SIGN) {
                  this.consumeCodePoint();
                  return INCLUDE_MATCH_TOKEN;
                }
                break;
              case EOF:
                return EOF_TOKEN;
            }
            if (isWhiteSpace(codePoint)) {
              this.consumeWhiteSpace();
              return WHITESPACE_TOKEN;
            }
            if (isDigit(codePoint)) {
              this.reconsumeCodePoint(codePoint);
              return this.consumeNumericToken();
            }
            if (isNameStartCodePoint(codePoint)) {
              this.reconsumeCodePoint(codePoint);
              return this.consumeIdentLikeToken();
            }
            return { type: 6, value: fromCodePoint$1(codePoint) };
          };
          Tokenizer2.prototype.consumeCodePoint = function() {
            var value = this._value.shift();
            return typeof value === "undefined" ? -1 : value;
          };
          Tokenizer2.prototype.reconsumeCodePoint = function(codePoint) {
            this._value.unshift(codePoint);
          };
          Tokenizer2.prototype.peekCodePoint = function(delta) {
            if (delta >= this._value.length) {
              return -1;
            }
            return this._value[delta];
          };
          Tokenizer2.prototype.consumeUnicodeRangeToken = function() {
            var digits = [];
            var codePoint = this.consumeCodePoint();
            while (isHex2(codePoint) && digits.length < 6) {
              digits.push(codePoint);
              codePoint = this.consumeCodePoint();
            }
            var questionMarks = false;
            while (codePoint === QUESTION_MARK && digits.length < 6) {
              digits.push(codePoint);
              codePoint = this.consumeCodePoint();
              questionMarks = true;
            }
            if (questionMarks) {
              var start_1 = parseInt(fromCodePoint$1.apply(void 0, digits.map(function(digit) {
                return digit === QUESTION_MARK ? ZERO : digit;
              })), 16);
              var end = parseInt(fromCodePoint$1.apply(void 0, digits.map(function(digit) {
                return digit === QUESTION_MARK ? F : digit;
              })), 16);
              return { type: 30, start: start_1, end };
            }
            var start = parseInt(fromCodePoint$1.apply(void 0, digits), 16);
            if (this.peekCodePoint(0) === HYPHEN_MINUS && isHex2(this.peekCodePoint(1))) {
              this.consumeCodePoint();
              codePoint = this.consumeCodePoint();
              var endDigits = [];
              while (isHex2(codePoint) && endDigits.length < 6) {
                endDigits.push(codePoint);
                codePoint = this.consumeCodePoint();
              }
              var end = parseInt(fromCodePoint$1.apply(void 0, endDigits), 16);
              return { type: 30, start, end };
            } else {
              return { type: 30, start, end: start };
            }
          };
          Tokenizer2.prototype.consumeIdentLikeToken = function() {
            var value = this.consumeName();
            if (value.toLowerCase() === "url" && this.peekCodePoint(0) === LEFT_PARENTHESIS) {
              this.consumeCodePoint();
              return this.consumeUrlToken();
            } else if (this.peekCodePoint(0) === LEFT_PARENTHESIS) {
              this.consumeCodePoint();
              return { type: 19, value };
            }
            return { type: 20, value };
          };
          Tokenizer2.prototype.consumeUrlToken = function() {
            var value = [];
            this.consumeWhiteSpace();
            if (this.peekCodePoint(0) === EOF) {
              return { type: 22, value: "" };
            }
            var next2 = this.peekCodePoint(0);
            if (next2 === APOSTROPHE || next2 === QUOTATION_MARK) {
              var stringToken = this.consumeStringToken(this.consumeCodePoint());
              if (stringToken.type === 0) {
                this.consumeWhiteSpace();
                if (this.peekCodePoint(0) === EOF || this.peekCodePoint(0) === RIGHT_PARENTHESIS) {
                  this.consumeCodePoint();
                  return { type: 22, value: stringToken.value };
                }
              }
              this.consumeBadUrlRemnants();
              return BAD_URL_TOKEN;
            }
            while (true) {
              var codePoint = this.consumeCodePoint();
              if (codePoint === EOF || codePoint === RIGHT_PARENTHESIS) {
                return { type: 22, value: fromCodePoint$1.apply(void 0, value) };
              } else if (isWhiteSpace(codePoint)) {
                this.consumeWhiteSpace();
                if (this.peekCodePoint(0) === EOF || this.peekCodePoint(0) === RIGHT_PARENTHESIS) {
                  this.consumeCodePoint();
                  return { type: 22, value: fromCodePoint$1.apply(void 0, value) };
                }
                this.consumeBadUrlRemnants();
                return BAD_URL_TOKEN;
              } else if (codePoint === QUOTATION_MARK || codePoint === APOSTROPHE || codePoint === LEFT_PARENTHESIS || isNonPrintableCodePoint(codePoint)) {
                this.consumeBadUrlRemnants();
                return BAD_URL_TOKEN;
              } else if (codePoint === REVERSE_SOLIDUS) {
                if (isValidEscape(codePoint, this.peekCodePoint(0))) {
                  value.push(this.consumeEscapedCodePoint());
                } else {
                  this.consumeBadUrlRemnants();
                  return BAD_URL_TOKEN;
                }
              } else {
                value.push(codePoint);
              }
            }
          };
          Tokenizer2.prototype.consumeWhiteSpace = function() {
            while (isWhiteSpace(this.peekCodePoint(0))) {
              this.consumeCodePoint();
            }
          };
          Tokenizer2.prototype.consumeBadUrlRemnants = function() {
            while (true) {
              var codePoint = this.consumeCodePoint();
              if (codePoint === RIGHT_PARENTHESIS || codePoint === EOF) {
                return;
              }
              if (isValidEscape(codePoint, this.peekCodePoint(0))) {
                this.consumeEscapedCodePoint();
              }
            }
          };
          Tokenizer2.prototype.consumeStringSlice = function(count) {
            var SLICE_STACK_SIZE = 5e4;
            var value = "";
            while (count > 0) {
              var amount = Math.min(SLICE_STACK_SIZE, count);
              value += fromCodePoint$1.apply(void 0, this._value.splice(0, amount));
              count -= amount;
            }
            this._value.shift();
            return value;
          };
          Tokenizer2.prototype.consumeStringToken = function(endingCodePoint) {
            var value = "";
            var i3 = 0;
            do {
              var codePoint = this._value[i3];
              if (codePoint === EOF || codePoint === void 0 || codePoint === endingCodePoint) {
                value += this.consumeStringSlice(i3);
                return { type: 0, value };
              }
              if (codePoint === LINE_FEED) {
                this._value.splice(0, i3);
                return BAD_STRING_TOKEN;
              }
              if (codePoint === REVERSE_SOLIDUS) {
                var next2 = this._value[i3 + 1];
                if (next2 !== EOF && next2 !== void 0) {
                  if (next2 === LINE_FEED) {
                    value += this.consumeStringSlice(i3);
                    i3 = -1;
                    this._value.shift();
                  } else if (isValidEscape(codePoint, next2)) {
                    value += this.consumeStringSlice(i3);
                    value += fromCodePoint$1(this.consumeEscapedCodePoint());
                    i3 = -1;
                  }
                }
              }
              i3++;
            } while (true);
          };
          Tokenizer2.prototype.consumeNumber = function() {
            var repr = [];
            var type = FLAG_INTEGER;
            var c1 = this.peekCodePoint(0);
            if (c1 === PLUS_SIGN || c1 === HYPHEN_MINUS) {
              repr.push(this.consumeCodePoint());
            }
            while (isDigit(this.peekCodePoint(0))) {
              repr.push(this.consumeCodePoint());
            }
            c1 = this.peekCodePoint(0);
            var c22 = this.peekCodePoint(1);
            if (c1 === FULL_STOP && isDigit(c22)) {
              repr.push(this.consumeCodePoint(), this.consumeCodePoint());
              type = FLAG_NUMBER;
              while (isDigit(this.peekCodePoint(0))) {
                repr.push(this.consumeCodePoint());
              }
            }
            c1 = this.peekCodePoint(0);
            c22 = this.peekCodePoint(1);
            var c3 = this.peekCodePoint(2);
            if ((c1 === E || c1 === e2) && ((c22 === PLUS_SIGN || c22 === HYPHEN_MINUS) && isDigit(c3) || isDigit(c22))) {
              repr.push(this.consumeCodePoint(), this.consumeCodePoint());
              type = FLAG_NUMBER;
              while (isDigit(this.peekCodePoint(0))) {
                repr.push(this.consumeCodePoint());
              }
            }
            return [stringToNumber(repr), type];
          };
          Tokenizer2.prototype.consumeNumericToken = function() {
            var _a2 = this.consumeNumber(), number = _a2[0], flags = _a2[1];
            var c1 = this.peekCodePoint(0);
            var c22 = this.peekCodePoint(1);
            var c3 = this.peekCodePoint(2);
            if (isIdentifierStart(c1, c22, c3)) {
              var unit = this.consumeName();
              return { type: 15, number, flags, unit };
            }
            if (c1 === PERCENTAGE_SIGN) {
              this.consumeCodePoint();
              return { type: 16, number, flags };
            }
            return { type: 17, number, flags };
          };
          Tokenizer2.prototype.consumeEscapedCodePoint = function() {
            var codePoint = this.consumeCodePoint();
            if (isHex2(codePoint)) {
              var hex3 = fromCodePoint$1(codePoint);
              while (isHex2(this.peekCodePoint(0)) && hex3.length < 6) {
                hex3 += fromCodePoint$1(this.consumeCodePoint());
              }
              if (isWhiteSpace(this.peekCodePoint(0))) {
                this.consumeCodePoint();
              }
              var hexCodePoint = parseInt(hex3, 16);
              if (hexCodePoint === 0 || isSurrogateCodePoint(hexCodePoint) || hexCodePoint > 1114111) {
                return REPLACEMENT_CHARACTER;
              }
              return hexCodePoint;
            }
            if (codePoint === EOF) {
              return REPLACEMENT_CHARACTER;
            }
            return codePoint;
          };
          Tokenizer2.prototype.consumeName = function() {
            var result = "";
            while (true) {
              var codePoint = this.consumeCodePoint();
              if (isNameCodePoint(codePoint)) {
                result += fromCodePoint$1(codePoint);
              } else if (isValidEscape(codePoint, this.peekCodePoint(0))) {
                result += fromCodePoint$1(this.consumeEscapedCodePoint());
              } else {
                this.reconsumeCodePoint(codePoint);
                return result;
              }
            }
          };
          return Tokenizer2;
        }()
      );
      var Parser3 = (
        /** @class */
        function() {
          function Parser4(tokens) {
            this._tokens = tokens;
          }
          Parser4.create = function(value) {
            var tokenizer = new Tokenizer();
            tokenizer.write(value);
            return new Parser4(tokenizer.read());
          };
          Parser4.parseValue = function(value) {
            return Parser4.create(value).parseComponentValue();
          };
          Parser4.parseValues = function(value) {
            return Parser4.create(value).parseComponentValues();
          };
          Parser4.prototype.parseComponentValue = function() {
            var token = this.consumeToken();
            while (token.type === 31) {
              token = this.consumeToken();
            }
            if (token.type === 32) {
              throw new SyntaxError("Error parsing CSS component value, unexpected EOF");
            }
            this.reconsumeToken(token);
            var value = this.consumeComponentValue();
            do {
              token = this.consumeToken();
            } while (token.type === 31);
            if (token.type === 32) {
              return value;
            }
            throw new SyntaxError("Error parsing CSS component value, multiple values found when expecting only one");
          };
          Parser4.prototype.parseComponentValues = function() {
            var values = [];
            while (true) {
              var value = this.consumeComponentValue();
              if (value.type === 32) {
                return values;
              }
              values.push(value);
              values.push();
            }
          };
          Parser4.prototype.consumeComponentValue = function() {
            var token = this.consumeToken();
            switch (token.type) {
              case 11:
              case 28:
              case 2:
                return this.consumeSimpleBlock(token.type);
              case 19:
                return this.consumeFunction(token);
            }
            return token;
          };
          Parser4.prototype.consumeSimpleBlock = function(type) {
            var block = { type, values: [] };
            var token = this.consumeToken();
            while (true) {
              if (token.type === 32 || isEndingTokenFor(token, type)) {
                return block;
              }
              this.reconsumeToken(token);
              block.values.push(this.consumeComponentValue());
              token = this.consumeToken();
            }
          };
          Parser4.prototype.consumeFunction = function(functionToken) {
            var cssFunction = {
              name: functionToken.value,
              values: [],
              type: 18
              /* FUNCTION */
            };
            while (true) {
              var token = this.consumeToken();
              if (token.type === 32 || token.type === 3) {
                return cssFunction;
              }
              this.reconsumeToken(token);
              cssFunction.values.push(this.consumeComponentValue());
            }
          };
          Parser4.prototype.consumeToken = function() {
            var token = this._tokens.shift();
            return typeof token === "undefined" ? EOF_TOKEN : token;
          };
          Parser4.prototype.reconsumeToken = function(token) {
            this._tokens.unshift(token);
          };
          return Parser4;
        }()
      );
      var isDimensionToken = function(token) {
        return token.type === 15;
      };
      var isNumberToken = function(token) {
        return token.type === 17;
      };
      var isIdentToken = function(token) {
        return token.type === 20;
      };
      var isStringToken = function(token) {
        return token.type === 0;
      };
      var isIdentWithValue = function(token, value) {
        return isIdentToken(token) && token.value === value;
      };
      var nonWhiteSpace = function(token) {
        return token.type !== 31;
      };
      var nonFunctionArgSeparator = function(token) {
        return token.type !== 31 && token.type !== 4;
      };
      var parseFunctionArgs = function(tokens) {
        var args = [];
        var arg = [];
        tokens.forEach(function(token) {
          if (token.type === 4) {
            if (arg.length === 0) {
              throw new Error("Error parsing function args, zero tokens for arg");
            }
            args.push(arg);
            arg = [];
            return;
          }
          if (token.type !== 31) {
            arg.push(token);
          }
        });
        if (arg.length) {
          args.push(arg);
        }
        return args;
      };
      var isEndingTokenFor = function(token, type) {
        if (type === 11 && token.type === 12) {
          return true;
        }
        if (type === 28 && token.type === 29) {
          return true;
        }
        return type === 2 && token.type === 3;
      };
      var isLength = function(token) {
        return token.type === 17 || token.type === 15;
      };
      var isLengthPercentage = function(token) {
        return token.type === 16 || isLength(token);
      };
      var parseLengthPercentageTuple = function(tokens) {
        return tokens.length > 1 ? [tokens[0], tokens[1]] : [tokens[0]];
      };
      var ZERO_LENGTH = {
        type: 17,
        number: 0,
        flags: FLAG_INTEGER
      };
      var FIFTY_PERCENT = {
        type: 16,
        number: 50,
        flags: FLAG_INTEGER
      };
      var HUNDRED_PERCENT = {
        type: 16,
        number: 100,
        flags: FLAG_INTEGER
      };
      var getAbsoluteValueForTuple = function(tuple, width2, height2) {
        var x2 = tuple[0], y3 = tuple[1];
        return [getAbsoluteValue(x2, width2), getAbsoluteValue(typeof y3 !== "undefined" ? y3 : x2, height2)];
      };
      var getAbsoluteValue = function(token, parent) {
        if (token.type === 16) {
          return token.number / 100 * parent;
        }
        if (isDimensionToken(token)) {
          switch (token.unit) {
            case "rem":
            case "em":
              return 16 * token.number;
            case "px":
            default:
              return token.number;
          }
        }
        return token.number;
      };
      var DEG = "deg";
      var GRAD = "grad";
      var RAD = "rad";
      var TURN = "turn";
      var angle = {
        name: "angle",
        parse: function(_context, value) {
          if (value.type === 15) {
            switch (value.unit) {
              case DEG:
                return Math.PI * value.number / 180;
              case GRAD:
                return Math.PI / 200 * value.number;
              case RAD:
                return value.number;
              case TURN:
                return Math.PI * 2 * value.number;
            }
          }
          throw new Error("Unsupported angle type");
        }
      };
      var isAngle = function(value) {
        if (value.type === 15) {
          if (value.unit === DEG || value.unit === GRAD || value.unit === RAD || value.unit === TURN) {
            return true;
          }
        }
        return false;
      };
      var parseNamedSide = function(tokens) {
        var sideOrCorner = tokens.filter(isIdentToken).map(function(ident) {
          return ident.value;
        }).join(" ");
        switch (sideOrCorner) {
          case "to bottom right":
          case "to right bottom":
          case "left top":
          case "top left":
            return [ZERO_LENGTH, ZERO_LENGTH];
          case "to top":
          case "bottom":
            return deg(0);
          case "to bottom left":
          case "to left bottom":
          case "right top":
          case "top right":
            return [ZERO_LENGTH, HUNDRED_PERCENT];
          case "to right":
          case "left":
            return deg(90);
          case "to top left":
          case "to left top":
          case "right bottom":
          case "bottom right":
            return [HUNDRED_PERCENT, HUNDRED_PERCENT];
          case "to bottom":
          case "top":
            return deg(180);
          case "to top right":
          case "to right top":
          case "left bottom":
          case "bottom left":
            return [HUNDRED_PERCENT, ZERO_LENGTH];
          case "to left":
          case "right":
            return deg(270);
        }
        return 0;
      };
      var deg = function(deg2) {
        return Math.PI * deg2 / 180;
      };
      var color$1 = {
        name: "color",
        parse: function(context, value) {
          if (value.type === 18) {
            var colorFunction = SUPPORTED_COLOR_FUNCTIONS[value.name];
            if (typeof colorFunction === "undefined") {
              throw new Error('Attempting to parse an unsupported color function "' + value.name + '"');
            }
            return colorFunction(context, value.values);
          }
          if (value.type === 5) {
            if (value.value.length === 3) {
              var r2 = value.value.substring(0, 1);
              var g = value.value.substring(1, 2);
              var b = value.value.substring(2, 3);
              return pack(parseInt(r2 + r2, 16), parseInt(g + g, 16), parseInt(b + b, 16), 1);
            }
            if (value.value.length === 4) {
              var r2 = value.value.substring(0, 1);
              var g = value.value.substring(1, 2);
              var b = value.value.substring(2, 3);
              var a3 = value.value.substring(3, 4);
              return pack(parseInt(r2 + r2, 16), parseInt(g + g, 16), parseInt(b + b, 16), parseInt(a3 + a3, 16) / 255);
            }
            if (value.value.length === 6) {
              var r2 = value.value.substring(0, 2);
              var g = value.value.substring(2, 4);
              var b = value.value.substring(4, 6);
              return pack(parseInt(r2, 16), parseInt(g, 16), parseInt(b, 16), 1);
            }
            if (value.value.length === 8) {
              var r2 = value.value.substring(0, 2);
              var g = value.value.substring(2, 4);
              var b = value.value.substring(4, 6);
              var a3 = value.value.substring(6, 8);
              return pack(parseInt(r2, 16), parseInt(g, 16), parseInt(b, 16), parseInt(a3, 16) / 255);
            }
          }
          if (value.type === 20) {
            var namedColor = COLORS[value.value.toUpperCase()];
            if (typeof namedColor !== "undefined") {
              return namedColor;
            }
          }
          return COLORS.TRANSPARENT;
        }
      };
      var isTransparent2 = function(color2) {
        return (255 & color2) === 0;
      };
      var asString = function(color2) {
        var alpha = 255 & color2;
        var blue = 255 & color2 >> 8;
        var green = 255 & color2 >> 16;
        var red = 255 & color2 >> 24;
        return alpha < 255 ? "rgba(" + red + "," + green + "," + blue + "," + alpha / 255 + ")" : "rgb(" + red + "," + green + "," + blue + ")";
      };
      var pack = function(r2, g, b, a3) {
        return (r2 << 24 | g << 16 | b << 8 | Math.round(a3 * 255) << 0) >>> 0;
      };
      var getTokenColorValue = function(token, i3) {
        if (token.type === 17) {
          return token.number;
        }
        if (token.type === 16) {
          var max2 = i3 === 3 ? 1 : 255;
          return i3 === 3 ? token.number / 100 * max2 : Math.round(token.number / 100 * max2);
        }
        return 0;
      };
      var rgb2 = function(_context, args) {
        var tokens = args.filter(nonFunctionArgSeparator);
        if (tokens.length === 3) {
          var _a2 = tokens.map(getTokenColorValue), r2 = _a2[0], g = _a2[1], b = _a2[2];
          return pack(r2, g, b, 1);
        }
        if (tokens.length === 4) {
          var _b2 = tokens.map(getTokenColorValue), r2 = _b2[0], g = _b2[1], b = _b2[2], a3 = _b2[3];
          return pack(r2, g, b, a3);
        }
        return 0;
      };
      function hue2rgb(t1, t2, hue) {
        if (hue < 0) {
          hue += 1;
        }
        if (hue >= 1) {
          hue -= 1;
        }
        if (hue < 1 / 6) {
          return (t2 - t1) * hue * 6 + t1;
        } else if (hue < 1 / 2) {
          return t2;
        } else if (hue < 2 / 3) {
          return (t2 - t1) * 6 * (2 / 3 - hue) + t1;
        } else {
          return t1;
        }
      }
      var hsl = function(context, args) {
        var tokens = args.filter(nonFunctionArgSeparator);
        var hue = tokens[0], saturation = tokens[1], lightness = tokens[2], alpha = tokens[3];
        var h2 = (hue.type === 17 ? deg(hue.number) : angle.parse(context, hue)) / (Math.PI * 2);
        var s2 = isLengthPercentage(saturation) ? saturation.number / 100 : 0;
        var l2 = isLengthPercentage(lightness) ? lightness.number / 100 : 0;
        var a3 = typeof alpha !== "undefined" && isLengthPercentage(alpha) ? getAbsoluteValue(alpha, 1) : 1;
        if (s2 === 0) {
          return pack(l2 * 255, l2 * 255, l2 * 255, 1);
        }
        var t2 = l2 <= 0.5 ? l2 * (s2 + 1) : l2 + s2 - l2 * s2;
        var t1 = l2 * 2 - t2;
        var r2 = hue2rgb(t1, t2, h2 + 1 / 3);
        var g = hue2rgb(t1, t2, h2);
        var b = hue2rgb(t1, t2, h2 - 1 / 3);
        return pack(r2 * 255, g * 255, b * 255, a3);
      };
      var SUPPORTED_COLOR_FUNCTIONS = {
        hsl,
        hsla: hsl,
        rgb: rgb2,
        rgba: rgb2
      };
      var parseColor = function(context, value) {
        return color$1.parse(context, Parser3.create(value).parseComponentValue());
      };
      var COLORS = {
        ALICEBLUE: 4042850303,
        ANTIQUEWHITE: 4209760255,
        AQUA: 16777215,
        AQUAMARINE: 2147472639,
        AZURE: 4043309055,
        BEIGE: 4126530815,
        BISQUE: 4293182719,
        BLACK: 255,
        BLANCHEDALMOND: 4293643775,
        BLUE: 65535,
        BLUEVIOLET: 2318131967,
        BROWN: 2771004159,
        BURLYWOOD: 3736635391,
        CADETBLUE: 1604231423,
        CHARTREUSE: 2147418367,
        CHOCOLATE: 3530104575,
        CORAL: 4286533887,
        CORNFLOWERBLUE: 1687547391,
        CORNSILK: 4294499583,
        CRIMSON: 3692313855,
        CYAN: 16777215,
        DARKBLUE: 35839,
        DARKCYAN: 9145343,
        DARKGOLDENROD: 3095837695,
        DARKGRAY: 2846468607,
        DARKGREEN: 6553855,
        DARKGREY: 2846468607,
        DARKKHAKI: 3182914559,
        DARKMAGENTA: 2332068863,
        DARKOLIVEGREEN: 1433087999,
        DARKORANGE: 4287365375,
        DARKORCHID: 2570243327,
        DARKRED: 2332033279,
        DARKSALMON: 3918953215,
        DARKSEAGREEN: 2411499519,
        DARKSLATEBLUE: 1211993087,
        DARKSLATEGRAY: 793726975,
        DARKSLATEGREY: 793726975,
        DARKTURQUOISE: 13554175,
        DARKVIOLET: 2483082239,
        DEEPPINK: 4279538687,
        DEEPSKYBLUE: 12582911,
        DIMGRAY: 1768516095,
        DIMGREY: 1768516095,
        DODGERBLUE: 512819199,
        FIREBRICK: 2988581631,
        FLORALWHITE: 4294635775,
        FORESTGREEN: 579543807,
        FUCHSIA: 4278255615,
        GAINSBORO: 3705462015,
        GHOSTWHITE: 4177068031,
        GOLD: 4292280575,
        GOLDENROD: 3668254975,
        GRAY: 2155905279,
        GREEN: 8388863,
        GREENYELLOW: 2919182335,
        GREY: 2155905279,
        HONEYDEW: 4043305215,
        HOTPINK: 4285117695,
        INDIANRED: 3445382399,
        INDIGO: 1258324735,
        IVORY: 4294963455,
        KHAKI: 4041641215,
        LAVENDER: 3873897215,
        LAVENDERBLUSH: 4293981695,
        LAWNGREEN: 2096890111,
        LEMONCHIFFON: 4294626815,
        LIGHTBLUE: 2916673279,
        LIGHTCORAL: 4034953471,
        LIGHTCYAN: 3774873599,
        LIGHTGOLDENRODYELLOW: 4210742015,
        LIGHTGRAY: 3553874943,
        LIGHTGREEN: 2431553791,
        LIGHTGREY: 3553874943,
        LIGHTPINK: 4290167295,
        LIGHTSALMON: 4288707327,
        LIGHTSEAGREEN: 548580095,
        LIGHTSKYBLUE: 2278488831,
        LIGHTSLATEGRAY: 2005441023,
        LIGHTSLATEGREY: 2005441023,
        LIGHTSTEELBLUE: 2965692159,
        LIGHTYELLOW: 4294959359,
        LIME: 16711935,
        LIMEGREEN: 852308735,
        LINEN: 4210091775,
        MAGENTA: 4278255615,
        MAROON: 2147483903,
        MEDIUMAQUAMARINE: 1724754687,
        MEDIUMBLUE: 52735,
        MEDIUMORCHID: 3126187007,
        MEDIUMPURPLE: 2473647103,
        MEDIUMSEAGREEN: 1018393087,
        MEDIUMSLATEBLUE: 2070474495,
        MEDIUMSPRINGGREEN: 16423679,
        MEDIUMTURQUOISE: 1221709055,
        MEDIUMVIOLETRED: 3340076543,
        MIDNIGHTBLUE: 421097727,
        MINTCREAM: 4127193855,
        MISTYROSE: 4293190143,
        MOCCASIN: 4293178879,
        NAVAJOWHITE: 4292783615,
        NAVY: 33023,
        OLDLACE: 4260751103,
        OLIVE: 2155872511,
        OLIVEDRAB: 1804477439,
        ORANGE: 4289003775,
        ORANGERED: 4282712319,
        ORCHID: 3664828159,
        PALEGOLDENROD: 4008225535,
        PALEGREEN: 2566625535,
        PALETURQUOISE: 2951671551,
        PALEVIOLETRED: 3681588223,
        PAPAYAWHIP: 4293907967,
        PEACHPUFF: 4292524543,
        PERU: 3448061951,
        PINK: 4290825215,
        PLUM: 3718307327,
        POWDERBLUE: 2967529215,
        PURPLE: 2147516671,
        REBECCAPURPLE: 1714657791,
        RED: 4278190335,
        ROSYBROWN: 3163525119,
        ROYALBLUE: 1097458175,
        SADDLEBROWN: 2336560127,
        SALMON: 4202722047,
        SANDYBROWN: 4104413439,
        SEAGREEN: 780883967,
        SEASHELL: 4294307583,
        SIENNA: 2689740287,
        SILVER: 3233857791,
        SKYBLUE: 2278484991,
        SLATEBLUE: 1784335871,
        SLATEGRAY: 1887473919,
        SLATEGREY: 1887473919,
        SNOW: 4294638335,
        SPRINGGREEN: 16744447,
        STEELBLUE: 1182971135,
        TAN: 3535047935,
        TEAL: 8421631,
        THISTLE: 3636451583,
        TOMATO: 4284696575,
        TRANSPARENT: 0,
        TURQUOISE: 1088475391,
        VIOLET: 4001558271,
        WHEAT: 4125012991,
        WHITE: 4294967295,
        WHITESMOKE: 4126537215,
        YELLOW: 4294902015,
        YELLOWGREEN: 2597139199
      };
      var backgroundClip = {
        name: "background-clip",
        initialValue: "border-box",
        prefix: false,
        type: 1,
        parse: function(_context, tokens) {
          return tokens.map(function(token) {
            if (isIdentToken(token)) {
              switch (token.value) {
                case "padding-box":
                  return 1;
                case "content-box":
                  return 2;
              }
            }
            return 0;
          });
        }
      };
      var backgroundColor = {
        name: "background-color",
        initialValue: "transparent",
        prefix: false,
        type: 3,
        format: "color"
      };
      var parseColorStop = function(context, args) {
        var color2 = color$1.parse(context, args[0]);
        var stop = args[1];
        return stop && isLengthPercentage(stop) ? { color: color2, stop } : { color: color2, stop: null };
      };
      var processColorStops = function(stops, lineLength) {
        var first = stops[0];
        var last = stops[stops.length - 1];
        if (first.stop === null) {
          first.stop = ZERO_LENGTH;
        }
        if (last.stop === null) {
          last.stop = HUNDRED_PERCENT;
        }
        var processStops = [];
        var previous2 = 0;
        for (var i3 = 0; i3 < stops.length; i3++) {
          var stop_1 = stops[i3].stop;
          if (stop_1 !== null) {
            var absoluteValue = getAbsoluteValue(stop_1, lineLength);
            if (absoluteValue > previous2) {
              processStops.push(absoluteValue);
            } else {
              processStops.push(previous2);
            }
            previous2 = absoluteValue;
          } else {
            processStops.push(null);
          }
        }
        var gapBegin = null;
        for (var i3 = 0; i3 < processStops.length; i3++) {
          var stop_2 = processStops[i3];
          if (stop_2 === null) {
            if (gapBegin === null) {
              gapBegin = i3;
            }
          } else if (gapBegin !== null) {
            var gapLength = i3 - gapBegin;
            var beforeGap = processStops[gapBegin - 1];
            var gapValue = (stop_2 - beforeGap) / (gapLength + 1);
            for (var g = 1; g <= gapLength; g++) {
              processStops[gapBegin + g - 1] = gapValue * g;
            }
            gapBegin = null;
          }
        }
        return stops.map(function(_a2, i4) {
          var color2 = _a2.color;
          return { color: color2, stop: Math.max(Math.min(1, processStops[i4] / lineLength), 0) };
        });
      };
      var getAngleFromCorner = function(corner, width2, height2) {
        var centerX = width2 / 2;
        var centerY = height2 / 2;
        var x2 = getAbsoluteValue(corner[0], width2) - centerX;
        var y3 = centerY - getAbsoluteValue(corner[1], height2);
        return (Math.atan2(y3, x2) + Math.PI * 2) % (Math.PI * 2);
      };
      var calculateGradientDirection = function(angle2, width2, height2) {
        var radian = typeof angle2 === "number" ? angle2 : getAngleFromCorner(angle2, width2, height2);
        var lineLength = Math.abs(width2 * Math.sin(radian)) + Math.abs(height2 * Math.cos(radian));
        var halfWidth = width2 / 2;
        var halfHeight = height2 / 2;
        var halfLineLength = lineLength / 2;
        var yDiff = Math.sin(radian - Math.PI / 2) * halfLineLength;
        var xDiff = Math.cos(radian - Math.PI / 2) * halfLineLength;
        return [lineLength, halfWidth - xDiff, halfWidth + xDiff, halfHeight - yDiff, halfHeight + yDiff];
      };
      var distance = function(a3, b) {
        return Math.sqrt(a3 * a3 + b * b);
      };
      var findCorner = function(width2, height2, x2, y3, closest) {
        var corners = [
          [0, 0],
          [0, height2],
          [width2, 0],
          [width2, height2]
        ];
        return corners.reduce(function(stat, corner) {
          var cx2 = corner[0], cy2 = corner[1];
          var d = distance(x2 - cx2, y3 - cy2);
          if (closest ? d < stat.optimumDistance : d > stat.optimumDistance) {
            return {
              optimumCorner: corner,
              optimumDistance: d
            };
          }
          return stat;
        }, {
          optimumDistance: closest ? Infinity : -Infinity,
          optimumCorner: null
        }).optimumCorner;
      };
      var calculateRadius = function(gradient, x2, y3, width2, height2) {
        var rx2 = 0;
        var ry2 = 0;
        switch (gradient.size) {
          case 0:
            if (gradient.shape === 0) {
              rx2 = ry2 = Math.min(Math.abs(x2), Math.abs(x2 - width2), Math.abs(y3), Math.abs(y3 - height2));
            } else if (gradient.shape === 1) {
              rx2 = Math.min(Math.abs(x2), Math.abs(x2 - width2));
              ry2 = Math.min(Math.abs(y3), Math.abs(y3 - height2));
            }
            break;
          case 2:
            if (gradient.shape === 0) {
              rx2 = ry2 = Math.min(distance(x2, y3), distance(x2, y3 - height2), distance(x2 - width2, y3), distance(x2 - width2, y3 - height2));
            } else if (gradient.shape === 1) {
              var c3 = Math.min(Math.abs(y3), Math.abs(y3 - height2)) / Math.min(Math.abs(x2), Math.abs(x2 - width2));
              var _a2 = findCorner(width2, height2, x2, y3, true), cx2 = _a2[0], cy2 = _a2[1];
              rx2 = distance(cx2 - x2, (cy2 - y3) / c3);
              ry2 = c3 * rx2;
            }
            break;
          case 1:
            if (gradient.shape === 0) {
              rx2 = ry2 = Math.max(Math.abs(x2), Math.abs(x2 - width2), Math.abs(y3), Math.abs(y3 - height2));
            } else if (gradient.shape === 1) {
              rx2 = Math.max(Math.abs(x2), Math.abs(x2 - width2));
              ry2 = Math.max(Math.abs(y3), Math.abs(y3 - height2));
            }
            break;
          case 3:
            if (gradient.shape === 0) {
              rx2 = ry2 = Math.max(distance(x2, y3), distance(x2, y3 - height2), distance(x2 - width2, y3), distance(x2 - width2, y3 - height2));
            } else if (gradient.shape === 1) {
              var c3 = Math.max(Math.abs(y3), Math.abs(y3 - height2)) / Math.max(Math.abs(x2), Math.abs(x2 - width2));
              var _b2 = findCorner(width2, height2, x2, y3, false), cx2 = _b2[0], cy2 = _b2[1];
              rx2 = distance(cx2 - x2, (cy2 - y3) / c3);
              ry2 = c3 * rx2;
            }
            break;
        }
        if (Array.isArray(gradient.size)) {
          rx2 = getAbsoluteValue(gradient.size[0], width2);
          ry2 = gradient.size.length === 2 ? getAbsoluteValue(gradient.size[1], height2) : rx2;
        }
        return [rx2, ry2];
      };
      var linearGradient = function(context, tokens) {
        var angle$1 = deg(180);
        var stops = [];
        parseFunctionArgs(tokens).forEach(function(arg, i3) {
          if (i3 === 0) {
            var firstToken = arg[0];
            if (firstToken.type === 20 && firstToken.value === "to") {
              angle$1 = parseNamedSide(arg);
              return;
            } else if (isAngle(firstToken)) {
              angle$1 = angle.parse(context, firstToken);
              return;
            }
          }
          var colorStop = parseColorStop(context, arg);
          stops.push(colorStop);
        });
        return {
          angle: angle$1,
          stops,
          type: 1
          /* LINEAR_GRADIENT */
        };
      };
      var prefixLinearGradient = function(context, tokens) {
        var angle$1 = deg(180);
        var stops = [];
        parseFunctionArgs(tokens).forEach(function(arg, i3) {
          if (i3 === 0) {
            var firstToken = arg[0];
            if (firstToken.type === 20 && ["top", "left", "right", "bottom"].indexOf(firstToken.value) !== -1) {
              angle$1 = parseNamedSide(arg);
              return;
            } else if (isAngle(firstToken)) {
              angle$1 = (angle.parse(context, firstToken) + deg(270)) % deg(360);
              return;
            }
          }
          var colorStop = parseColorStop(context, arg);
          stops.push(colorStop);
        });
        return {
          angle: angle$1,
          stops,
          type: 1
          /* LINEAR_GRADIENT */
        };
      };
      var webkitGradient = function(context, tokens) {
        var angle2 = deg(180);
        var stops = [];
        var type = 1;
        var shape = 0;
        var size2 = 3;
        var position4 = [];
        parseFunctionArgs(tokens).forEach(function(arg, i3) {
          var firstToken = arg[0];
          if (i3 === 0) {
            if (isIdentToken(firstToken) && firstToken.value === "linear") {
              type = 1;
              return;
            } else if (isIdentToken(firstToken) && firstToken.value === "radial") {
              type = 2;
              return;
            }
          }
          if (firstToken.type === 18) {
            if (firstToken.name === "from") {
              var color2 = color$1.parse(context, firstToken.values[0]);
              stops.push({ stop: ZERO_LENGTH, color: color2 });
            } else if (firstToken.name === "to") {
              var color2 = color$1.parse(context, firstToken.values[0]);
              stops.push({ stop: HUNDRED_PERCENT, color: color2 });
            } else if (firstToken.name === "color-stop") {
              var values = firstToken.values.filter(nonFunctionArgSeparator);
              if (values.length === 2) {
                var color2 = color$1.parse(context, values[1]);
                var stop_1 = values[0];
                if (isNumberToken(stop_1)) {
                  stops.push({
                    stop: { type: 16, number: stop_1.number * 100, flags: stop_1.flags },
                    color: color2
                  });
                }
              }
            }
          }
        });
        return type === 1 ? {
          angle: (angle2 + deg(180)) % deg(360),
          stops,
          type
        } : { size: size2, shape, stops, position: position4, type };
      };
      var CLOSEST_SIDE = "closest-side";
      var FARTHEST_SIDE = "farthest-side";
      var CLOSEST_CORNER = "closest-corner";
      var FARTHEST_CORNER = "farthest-corner";
      var CIRCLE = "circle";
      var ELLIPSE = "ellipse";
      var COVER = "cover";
      var CONTAIN = "contain";
      var radialGradient = function(context, tokens) {
        var shape = 0;
        var size2 = 3;
        var stops = [];
        var position4 = [];
        parseFunctionArgs(tokens).forEach(function(arg, i3) {
          var isColorStop = true;
          if (i3 === 0) {
            var isAtPosition_1 = false;
            isColorStop = arg.reduce(function(acc, token) {
              if (isAtPosition_1) {
                if (isIdentToken(token)) {
                  switch (token.value) {
                    case "center":
                      position4.push(FIFTY_PERCENT);
                      return acc;
                    case "top":
                    case "left":
                      position4.push(ZERO_LENGTH);
                      return acc;
                    case "right":
                    case "bottom":
                      position4.push(HUNDRED_PERCENT);
                      return acc;
                  }
                } else if (isLengthPercentage(token) || isLength(token)) {
                  position4.push(token);
                }
              } else if (isIdentToken(token)) {
                switch (token.value) {
                  case CIRCLE:
                    shape = 0;
                    return false;
                  case ELLIPSE:
                    shape = 1;
                    return false;
                  case "at":
                    isAtPosition_1 = true;
                    return false;
                  case CLOSEST_SIDE:
                    size2 = 0;
                    return false;
                  case COVER:
                  case FARTHEST_SIDE:
                    size2 = 1;
                    return false;
                  case CONTAIN:
                  case CLOSEST_CORNER:
                    size2 = 2;
                    return false;
                  case FARTHEST_CORNER:
                    size2 = 3;
                    return false;
                }
              } else if (isLength(token) || isLengthPercentage(token)) {
                if (!Array.isArray(size2)) {
                  size2 = [];
                }
                size2.push(token);
                return false;
              }
              return acc;
            }, isColorStop);
          }
          if (isColorStop) {
            var colorStop = parseColorStop(context, arg);
            stops.push(colorStop);
          }
        });
        return {
          size: size2,
          shape,
          stops,
          position: position4,
          type: 2
          /* RADIAL_GRADIENT */
        };
      };
      var prefixRadialGradient = function(context, tokens) {
        var shape = 0;
        var size2 = 3;
        var stops = [];
        var position4 = [];
        parseFunctionArgs(tokens).forEach(function(arg, i3) {
          var isColorStop = true;
          if (i3 === 0) {
            isColorStop = arg.reduce(function(acc, token) {
              if (isIdentToken(token)) {
                switch (token.value) {
                  case "center":
                    position4.push(FIFTY_PERCENT);
                    return false;
                  case "top":
                  case "left":
                    position4.push(ZERO_LENGTH);
                    return false;
                  case "right":
                  case "bottom":
                    position4.push(HUNDRED_PERCENT);
                    return false;
                }
              } else if (isLengthPercentage(token) || isLength(token)) {
                position4.push(token);
                return false;
              }
              return acc;
            }, isColorStop);
          } else if (i3 === 1) {
            isColorStop = arg.reduce(function(acc, token) {
              if (isIdentToken(token)) {
                switch (token.value) {
                  case CIRCLE:
                    shape = 0;
                    return false;
                  case ELLIPSE:
                    shape = 1;
                    return false;
                  case CONTAIN:
                  case CLOSEST_SIDE:
                    size2 = 0;
                    return false;
                  case FARTHEST_SIDE:
                    size2 = 1;
                    return false;
                  case CLOSEST_CORNER:
                    size2 = 2;
                    return false;
                  case COVER:
                  case FARTHEST_CORNER:
                    size2 = 3;
                    return false;
                }
              } else if (isLength(token) || isLengthPercentage(token)) {
                if (!Array.isArray(size2)) {
                  size2 = [];
                }
                size2.push(token);
                return false;
              }
              return acc;
            }, isColorStop);
          }
          if (isColorStop) {
            var colorStop = parseColorStop(context, arg);
            stops.push(colorStop);
          }
        });
        return {
          size: size2,
          shape,
          stops,
          position: position4,
          type: 2
          /* RADIAL_GRADIENT */
        };
      };
      var isLinearGradient = function(background) {
        return background.type === 1;
      };
      var isRadialGradient = function(background) {
        return background.type === 2;
      };
      var image = {
        name: "image",
        parse: function(context, value) {
          if (value.type === 22) {
            var image_1 = {
              url: value.value,
              type: 0
              /* URL */
            };
            context.cache.addImage(value.value);
            return image_1;
          }
          if (value.type === 18) {
            var imageFunction = SUPPORTED_IMAGE_FUNCTIONS[value.name];
            if (typeof imageFunction === "undefined") {
              throw new Error('Attempting to parse an unsupported image function "' + value.name + '"');
            }
            return imageFunction(context, value.values);
          }
          throw new Error("Unsupported image type " + value.type);
        }
      };
      function isSupportedImage(value) {
        return !(value.type === 20 && value.value === "none") && (value.type !== 18 || !!SUPPORTED_IMAGE_FUNCTIONS[value.name]);
      }
      var SUPPORTED_IMAGE_FUNCTIONS = {
        "linear-gradient": linearGradient,
        "-moz-linear-gradient": prefixLinearGradient,
        "-ms-linear-gradient": prefixLinearGradient,
        "-o-linear-gradient": prefixLinearGradient,
        "-webkit-linear-gradient": prefixLinearGradient,
        "radial-gradient": radialGradient,
        "-moz-radial-gradient": prefixRadialGradient,
        "-ms-radial-gradient": prefixRadialGradient,
        "-o-radial-gradient": prefixRadialGradient,
        "-webkit-radial-gradient": prefixRadialGradient,
        "-webkit-gradient": webkitGradient
      };
      var backgroundImage = {
        name: "background-image",
        initialValue: "none",
        type: 1,
        prefix: false,
        parse: function(context, tokens) {
          if (tokens.length === 0) {
            return [];
          }
          var first = tokens[0];
          if (first.type === 20 && first.value === "none") {
            return [];
          }
          return tokens.filter(function(value) {
            return nonFunctionArgSeparator(value) && isSupportedImage(value);
          }).map(function(value) {
            return image.parse(context, value);
          });
        }
      };
      var backgroundOrigin = {
        name: "background-origin",
        initialValue: "border-box",
        prefix: false,
        type: 1,
        parse: function(_context, tokens) {
          return tokens.map(function(token) {
            if (isIdentToken(token)) {
              switch (token.value) {
                case "padding-box":
                  return 1;
                case "content-box":
                  return 2;
              }
            }
            return 0;
          });
        }
      };
      var backgroundPosition = {
        name: "background-position",
        initialValue: "0% 0%",
        type: 1,
        prefix: false,
        parse: function(_context, tokens) {
          return parseFunctionArgs(tokens).map(function(values) {
            return values.filter(isLengthPercentage);
          }).map(parseLengthPercentageTuple);
        }
      };
      var backgroundRepeat = {
        name: "background-repeat",
        initialValue: "repeat",
        prefix: false,
        type: 1,
        parse: function(_context, tokens) {
          return parseFunctionArgs(tokens).map(function(values) {
            return values.filter(isIdentToken).map(function(token) {
              return token.value;
            }).join(" ");
          }).map(parseBackgroundRepeat);
        }
      };
      var parseBackgroundRepeat = function(value) {
        switch (value) {
          case "no-repeat":
            return 1;
          case "repeat-x":
          case "repeat no-repeat":
            return 2;
          case "repeat-y":
          case "no-repeat repeat":
            return 3;
          case "repeat":
          default:
            return 0;
        }
      };
      var BACKGROUND_SIZE;
      (function(BACKGROUND_SIZE2) {
        BACKGROUND_SIZE2["AUTO"] = "auto";
        BACKGROUND_SIZE2["CONTAIN"] = "contain";
        BACKGROUND_SIZE2["COVER"] = "cover";
      })(BACKGROUND_SIZE || (BACKGROUND_SIZE = {}));
      var backgroundSize = {
        name: "background-size",
        initialValue: "0",
        prefix: false,
        type: 1,
        parse: function(_context, tokens) {
          return parseFunctionArgs(tokens).map(function(values) {
            return values.filter(isBackgroundSizeInfoToken);
          });
        }
      };
      var isBackgroundSizeInfoToken = function(value) {
        return isIdentToken(value) || isLengthPercentage(value);
      };
      var borderColorForSide = function(side) {
        return {
          name: "border-" + side + "-color",
          initialValue: "transparent",
          prefix: false,
          type: 3,
          format: "color"
        };
      };
      var borderTopColor = borderColorForSide("top");
      var borderRightColor = borderColorForSide("right");
      var borderBottomColor = borderColorForSide("bottom");
      var borderLeftColor = borderColorForSide("left");
      var borderRadiusForSide = function(side) {
        return {
          name: "border-radius-" + side,
          initialValue: "0 0",
          prefix: false,
          type: 1,
          parse: function(_context, tokens) {
            return parseLengthPercentageTuple(tokens.filter(isLengthPercentage));
          }
        };
      };
      var borderTopLeftRadius = borderRadiusForSide("top-left");
      var borderTopRightRadius = borderRadiusForSide("top-right");
      var borderBottomRightRadius = borderRadiusForSide("bottom-right");
      var borderBottomLeftRadius = borderRadiusForSide("bottom-left");
      var borderStyleForSide = function(side) {
        return {
          name: "border-" + side + "-style",
          initialValue: "solid",
          prefix: false,
          type: 2,
          parse: function(_context, style) {
            switch (style) {
              case "none":
                return 0;
              case "dashed":
                return 2;
              case "dotted":
                return 3;
              case "double":
                return 4;
            }
            return 1;
          }
        };
      };
      var borderTopStyle = borderStyleForSide("top");
      var borderRightStyle = borderStyleForSide("right");
      var borderBottomStyle = borderStyleForSide("bottom");
      var borderLeftStyle = borderStyleForSide("left");
      var borderWidthForSide = function(side) {
        return {
          name: "border-" + side + "-width",
          initialValue: "0",
          type: 0,
          prefix: false,
          parse: function(_context, token) {
            if (isDimensionToken(token)) {
              return token.number;
            }
            return 0;
          }
        };
      };
      var borderTopWidth = borderWidthForSide("top");
      var borderRightWidth = borderWidthForSide("right");
      var borderBottomWidth = borderWidthForSide("bottom");
      var borderLeftWidth = borderWidthForSide("left");
      var color = {
        name: "color",
        initialValue: "transparent",
        prefix: false,
        type: 3,
        format: "color"
      };
      var direction = {
        name: "direction",
        initialValue: "ltr",
        prefix: false,
        type: 2,
        parse: function(_context, direction2) {
          switch (direction2) {
            case "rtl":
              return 1;
            case "ltr":
            default:
              return 0;
          }
        }
      };
      var display = {
        name: "display",
        initialValue: "inline-block",
        prefix: false,
        type: 1,
        parse: function(_context, tokens) {
          return tokens.filter(isIdentToken).reduce(
            function(bit, token) {
              return bit | parseDisplayValue(token.value);
            },
            0
            /* NONE */
          );
        }
      };
      var parseDisplayValue = function(display2) {
        switch (display2) {
          case "block":
          case "-webkit-box":
            return 2;
          case "inline":
            return 4;
          case "run-in":
            return 8;
          case "flow":
            return 16;
          case "flow-root":
            return 32;
          case "table":
            return 64;
          case "flex":
          case "-webkit-flex":
            return 128;
          case "grid":
          case "-ms-grid":
            return 256;
          case "ruby":
            return 512;
          case "subgrid":
            return 1024;
          case "list-item":
            return 2048;
          case "table-row-group":
            return 4096;
          case "table-header-group":
            return 8192;
          case "table-footer-group":
            return 16384;
          case "table-row":
            return 32768;
          case "table-cell":
            return 65536;
          case "table-column-group":
            return 131072;
          case "table-column":
            return 262144;
          case "table-caption":
            return 524288;
          case "ruby-base":
            return 1048576;
          case "ruby-text":
            return 2097152;
          case "ruby-base-container":
            return 4194304;
          case "ruby-text-container":
            return 8388608;
          case "contents":
            return 16777216;
          case "inline-block":
            return 33554432;
          case "inline-list-item":
            return 67108864;
          case "inline-table":
            return 134217728;
          case "inline-flex":
            return 268435456;
          case "inline-grid":
            return 536870912;
        }
        return 0;
      };
      var float = {
        name: "float",
        initialValue: "none",
        prefix: false,
        type: 2,
        parse: function(_context, float2) {
          switch (float2) {
            case "left":
              return 1;
            case "right":
              return 2;
            case "inline-start":
              return 3;
            case "inline-end":
              return 4;
          }
          return 0;
        }
      };
      var letterSpacing = {
        name: "letter-spacing",
        initialValue: "0",
        prefix: false,
        type: 0,
        parse: function(_context, token) {
          if (token.type === 20 && token.value === "normal") {
            return 0;
          }
          if (token.type === 17) {
            return token.number;
          }
          if (token.type === 15) {
            return token.number;
          }
          return 0;
        }
      };
      var LINE_BREAK;
      (function(LINE_BREAK2) {
        LINE_BREAK2["NORMAL"] = "normal";
        LINE_BREAK2["STRICT"] = "strict";
      })(LINE_BREAK || (LINE_BREAK = {}));
      var lineBreak = {
        name: "line-break",
        initialValue: "normal",
        prefix: false,
        type: 2,
        parse: function(_context, lineBreak2) {
          switch (lineBreak2) {
            case "strict":
              return LINE_BREAK.STRICT;
            case "normal":
            default:
              return LINE_BREAK.NORMAL;
          }
        }
      };
      var lineHeight = {
        name: "line-height",
        initialValue: "normal",
        prefix: false,
        type: 4
        /* TOKEN_VALUE */
      };
      var computeLineHeight = function(token, fontSize2) {
        if (isIdentToken(token) && token.value === "normal") {
          return 1.2 * fontSize2;
        } else if (token.type === 17) {
          return fontSize2 * token.number;
        } else if (isLengthPercentage(token)) {
          return getAbsoluteValue(token, fontSize2);
        }
        return fontSize2;
      };
      var listStyleImage = {
        name: "list-style-image",
        initialValue: "none",
        type: 0,
        prefix: false,
        parse: function(context, token) {
          if (token.type === 20 && token.value === "none") {
            return null;
          }
          return image.parse(context, token);
        }
      };
      var listStylePosition = {
        name: "list-style-position",
        initialValue: "outside",
        prefix: false,
        type: 2,
        parse: function(_context, position4) {
          switch (position4) {
            case "inside":
              return 0;
            case "outside":
            default:
              return 1;
          }
        }
      };
      var listStyleType = {
        name: "list-style-type",
        initialValue: "none",
        prefix: false,
        type: 2,
        parse: function(_context, type) {
          switch (type) {
            case "disc":
              return 0;
            case "circle":
              return 1;
            case "square":
              return 2;
            case "decimal":
              return 3;
            case "cjk-decimal":
              return 4;
            case "decimal-leading-zero":
              return 5;
            case "lower-roman":
              return 6;
            case "upper-roman":
              return 7;
            case "lower-greek":
              return 8;
            case "lower-alpha":
              return 9;
            case "upper-alpha":
              return 10;
            case "arabic-indic":
              return 11;
            case "armenian":
              return 12;
            case "bengali":
              return 13;
            case "cambodian":
              return 14;
            case "cjk-earthly-branch":
              return 15;
            case "cjk-heavenly-stem":
              return 16;
            case "cjk-ideographic":
              return 17;
            case "devanagari":
              return 18;
            case "ethiopic-numeric":
              return 19;
            case "georgian":
              return 20;
            case "gujarati":
              return 21;
            case "gurmukhi":
              return 22;
            case "hebrew":
              return 22;
            case "hiragana":
              return 23;
            case "hiragana-iroha":
              return 24;
            case "japanese-formal":
              return 25;
            case "japanese-informal":
              return 26;
            case "kannada":
              return 27;
            case "katakana":
              return 28;
            case "katakana-iroha":
              return 29;
            case "khmer":
              return 30;
            case "korean-hangul-formal":
              return 31;
            case "korean-hanja-formal":
              return 32;
            case "korean-hanja-informal":
              return 33;
            case "lao":
              return 34;
            case "lower-armenian":
              return 35;
            case "malayalam":
              return 36;
            case "mongolian":
              return 37;
            case "myanmar":
              return 38;
            case "oriya":
              return 39;
            case "persian":
              return 40;
            case "simp-chinese-formal":
              return 41;
            case "simp-chinese-informal":
              return 42;
            case "tamil":
              return 43;
            case "telugu":
              return 44;
            case "thai":
              return 45;
            case "tibetan":
              return 46;
            case "trad-chinese-formal":
              return 47;
            case "trad-chinese-informal":
              return 48;
            case "upper-armenian":
              return 49;
            case "disclosure-open":
              return 50;
            case "disclosure-closed":
              return 51;
            case "none":
            default:
              return -1;
          }
        }
      };
      var marginForSide = function(side) {
        return {
          name: "margin-" + side,
          initialValue: "0",
          prefix: false,
          type: 4
          /* TOKEN_VALUE */
        };
      };
      var marginTop = marginForSide("top");
      var marginRight = marginForSide("right");
      var marginBottom = marginForSide("bottom");
      var marginLeft = marginForSide("left");
      var overflow = {
        name: "overflow",
        initialValue: "visible",
        prefix: false,
        type: 1,
        parse: function(_context, tokens) {
          return tokens.filter(isIdentToken).map(function(overflow2) {
            switch (overflow2.value) {
              case "hidden":
                return 1;
              case "scroll":
                return 2;
              case "clip":
                return 3;
              case "auto":
                return 4;
              case "visible":
              default:
                return 0;
            }
          });
        }
      };
      var overflowWrap = {
        name: "overflow-wrap",
        initialValue: "normal",
        prefix: false,
        type: 2,
        parse: function(_context, overflow2) {
          switch (overflow2) {
            case "break-word":
              return "break-word";
            case "normal":
            default:
              return "normal";
          }
        }
      };
      var paddingForSide = function(side) {
        return {
          name: "padding-" + side,
          initialValue: "0",
          prefix: false,
          type: 3,
          format: "length-percentage"
        };
      };
      var paddingTop = paddingForSide("top");
      var paddingRight = paddingForSide("right");
      var paddingBottom = paddingForSide("bottom");
      var paddingLeft = paddingForSide("left");
      var textAlign = {
        name: "text-align",
        initialValue: "left",
        prefix: false,
        type: 2,
        parse: function(_context, textAlign2) {
          switch (textAlign2) {
            case "right":
              return 2;
            case "center":
            case "justify":
              return 1;
            case "left":
            default:
              return 0;
          }
        }
      };
      var position3 = {
        name: "position",
        initialValue: "static",
        prefix: false,
        type: 2,
        parse: function(_context, position4) {
          switch (position4) {
            case "relative":
              return 1;
            case "absolute":
              return 2;
            case "fixed":
              return 3;
            case "sticky":
              return 4;
          }
          return 0;
        }
      };
      var textShadow = {
        name: "text-shadow",
        initialValue: "none",
        type: 1,
        prefix: false,
        parse: function(context, tokens) {
          if (tokens.length === 1 && isIdentWithValue(tokens[0], "none")) {
            return [];
          }
          return parseFunctionArgs(tokens).map(function(values) {
            var shadow = {
              color: COLORS.TRANSPARENT,
              offsetX: ZERO_LENGTH,
              offsetY: ZERO_LENGTH,
              blur: ZERO_LENGTH
            };
            var c3 = 0;
            for (var i3 = 0; i3 < values.length; i3++) {
              var token = values[i3];
              if (isLength(token)) {
                if (c3 === 0) {
                  shadow.offsetX = token;
                } else if (c3 === 1) {
                  shadow.offsetY = token;
                } else {
                  shadow.blur = token;
                }
                c3++;
              } else {
                shadow.color = color$1.parse(context, token);
              }
            }
            return shadow;
          });
        }
      };
      var textTransform = {
        name: "text-transform",
        initialValue: "none",
        prefix: false,
        type: 2,
        parse: function(_context, textTransform2) {
          switch (textTransform2) {
            case "uppercase":
              return 2;
            case "lowercase":
              return 1;
            case "capitalize":
              return 3;
          }
          return 0;
        }
      };
      var transform$1 = {
        name: "transform",
        initialValue: "none",
        prefix: true,
        type: 0,
        parse: function(_context, token) {
          if (token.type === 20 && token.value === "none") {
            return null;
          }
          if (token.type === 18) {
            var transformFunction = SUPPORTED_TRANSFORM_FUNCTIONS[token.name];
            if (typeof transformFunction === "undefined") {
              throw new Error('Attempting to parse an unsupported transform function "' + token.name + '"');
            }
            return transformFunction(token.values);
          }
          return null;
        }
      };
      var matrix = function(args) {
        var values = args.filter(function(arg) {
          return arg.type === 17;
        }).map(function(arg) {
          return arg.number;
        });
        return values.length === 6 ? values : null;
      };
      var matrix3d = function(args) {
        var values = args.filter(function(arg) {
          return arg.type === 17;
        }).map(function(arg) {
          return arg.number;
        });
        var a1 = values[0], b1 = values[1];
        values[2];
        values[3];
        var a22 = values[4], b2 = values[5];
        values[6];
        values[7];
        values[8];
        values[9];
        values[10];
        values[11];
        var a4 = values[12], b4 = values[13];
        values[14];
        values[15];
        return values.length === 16 ? [a1, b1, a22, b2, a4, b4] : null;
      };
      var SUPPORTED_TRANSFORM_FUNCTIONS = {
        matrix,
        matrix3d
      };
      var DEFAULT_VALUE = {
        type: 16,
        number: 50,
        flags: FLAG_INTEGER
      };
      var DEFAULT = [DEFAULT_VALUE, DEFAULT_VALUE];
      var transformOrigin = {
        name: "transform-origin",
        initialValue: "50% 50%",
        prefix: true,
        type: 1,
        parse: function(_context, tokens) {
          var origins = tokens.filter(isLengthPercentage);
          if (origins.length !== 2) {
            return DEFAULT;
          }
          return [origins[0], origins[1]];
        }
      };
      var visibility = {
        name: "visible",
        initialValue: "none",
        prefix: false,
        type: 2,
        parse: function(_context, visibility2) {
          switch (visibility2) {
            case "hidden":
              return 1;
            case "collapse":
              return 2;
            case "visible":
            default:
              return 0;
          }
        }
      };
      var WORD_BREAK;
      (function(WORD_BREAK2) {
        WORD_BREAK2["NORMAL"] = "normal";
        WORD_BREAK2["BREAK_ALL"] = "break-all";
        WORD_BREAK2["KEEP_ALL"] = "keep-all";
      })(WORD_BREAK || (WORD_BREAK = {}));
      var wordBreak = {
        name: "word-break",
        initialValue: "normal",
        prefix: false,
        type: 2,
        parse: function(_context, wordBreak2) {
          switch (wordBreak2) {
            case "break-all":
              return WORD_BREAK.BREAK_ALL;
            case "keep-all":
              return WORD_BREAK.KEEP_ALL;
            case "normal":
            default:
              return WORD_BREAK.NORMAL;
          }
        }
      };
      var zIndex = {
        name: "z-index",
        initialValue: "auto",
        prefix: false,
        type: 0,
        parse: function(_context, token) {
          if (token.type === 20) {
            return { auto: true, order: 0 };
          }
          if (isNumberToken(token)) {
            return { auto: false, order: token.number };
          }
          throw new Error("Invalid z-index number parsed");
        }
      };
      var time = {
        name: "time",
        parse: function(_context, value) {
          if (value.type === 15) {
            switch (value.unit.toLowerCase()) {
              case "s":
                return 1e3 * value.number;
              case "ms":
                return value.number;
            }
          }
          throw new Error("Unsupported time type");
        }
      };
      var opacity = {
        name: "opacity",
        initialValue: "1",
        type: 0,
        prefix: false,
        parse: function(_context, token) {
          if (isNumberToken(token)) {
            return token.number;
          }
          return 1;
        }
      };
      var textDecorationColor = {
        name: "text-decoration-color",
        initialValue: "transparent",
        prefix: false,
        type: 3,
        format: "color"
      };
      var textDecorationLine = {
        name: "text-decoration-line",
        initialValue: "none",
        prefix: false,
        type: 1,
        parse: function(_context, tokens) {
          return tokens.filter(isIdentToken).map(function(token) {
            switch (token.value) {
              case "underline":
                return 1;
              case "overline":
                return 2;
              case "line-through":
                return 3;
              case "none":
                return 4;
            }
            return 0;
          }).filter(function(line) {
            return line !== 0;
          });
        }
      };
      var fontFamily = {
        name: "font-family",
        initialValue: "",
        prefix: false,
        type: 1,
        parse: function(_context, tokens) {
          var accumulator = [];
          var results = [];
          tokens.forEach(function(token) {
            switch (token.type) {
              case 20:
              case 0:
                accumulator.push(token.value);
                break;
              case 17:
                accumulator.push(token.number.toString());
                break;
              case 4:
                results.push(accumulator.join(" "));
                accumulator.length = 0;
                break;
            }
          });
          if (accumulator.length) {
            results.push(accumulator.join(" "));
          }
          return results.map(function(result) {
            return result.indexOf(" ") === -1 ? result : "'" + result + "'";
          });
        }
      };
      var fontSize = {
        name: "font-size",
        initialValue: "0",
        prefix: false,
        type: 3,
        format: "length"
      };
      var fontWeight = {
        name: "font-weight",
        initialValue: "normal",
        type: 0,
        prefix: false,
        parse: function(_context, token) {
          if (isNumberToken(token)) {
            return token.number;
          }
          if (isIdentToken(token)) {
            switch (token.value) {
              case "bold":
                return 700;
              case "normal":
              default:
                return 400;
            }
          }
          return 400;
        }
      };
      var fontVariant = {
        name: "font-variant",
        initialValue: "none",
        type: 1,
        prefix: false,
        parse: function(_context, tokens) {
          return tokens.filter(isIdentToken).map(function(token) {
            return token.value;
          });
        }
      };
      var fontStyle = {
        name: "font-style",
        initialValue: "normal",
        prefix: false,
        type: 2,
        parse: function(_context, overflow2) {
          switch (overflow2) {
            case "oblique":
              return "oblique";
            case "italic":
              return "italic";
            case "normal":
            default:
              return "normal";
          }
        }
      };
      var contains3 = function(bit, value) {
        return (bit & value) !== 0;
      };
      var content3 = {
        name: "content",
        initialValue: "none",
        type: 1,
        prefix: false,
        parse: function(_context, tokens) {
          if (tokens.length === 0) {
            return [];
          }
          var first = tokens[0];
          if (first.type === 20 && first.value === "none") {
            return [];
          }
          return tokens;
        }
      };
      var counterIncrement = {
        name: "counter-increment",
        initialValue: "none",
        prefix: true,
        type: 1,
        parse: function(_context, tokens) {
          if (tokens.length === 0) {
            return null;
          }
          var first = tokens[0];
          if (first.type === 20 && first.value === "none") {
            return null;
          }
          var increments = [];
          var filtered = tokens.filter(nonWhiteSpace);
          for (var i3 = 0; i3 < filtered.length; i3++) {
            var counter = filtered[i3];
            var next2 = filtered[i3 + 1];
            if (counter.type === 20) {
              var increment = next2 && isNumberToken(next2) ? next2.number : 1;
              increments.push({ counter: counter.value, increment });
            }
          }
          return increments;
        }
      };
      var counterReset = {
        name: "counter-reset",
        initialValue: "none",
        prefix: true,
        type: 1,
        parse: function(_context, tokens) {
          if (tokens.length === 0) {
            return [];
          }
          var resets = [];
          var filtered = tokens.filter(nonWhiteSpace);
          for (var i3 = 0; i3 < filtered.length; i3++) {
            var counter = filtered[i3];
            var next2 = filtered[i3 + 1];
            if (isIdentToken(counter) && counter.value !== "none") {
              var reset = next2 && isNumberToken(next2) ? next2.number : 0;
              resets.push({ counter: counter.value, reset });
            }
          }
          return resets;
        }
      };
      var duration = {
        name: "duration",
        initialValue: "0s",
        prefix: false,
        type: 1,
        parse: function(context, tokens) {
          return tokens.filter(isDimensionToken).map(function(token) {
            return time.parse(context, token);
          });
        }
      };
      var quotes = {
        name: "quotes",
        initialValue: "none",
        prefix: true,
        type: 1,
        parse: function(_context, tokens) {
          if (tokens.length === 0) {
            return null;
          }
          var first = tokens[0];
          if (first.type === 20 && first.value === "none") {
            return null;
          }
          var quotes2 = [];
          var filtered = tokens.filter(isStringToken);
          if (filtered.length % 2 !== 0) {
            return null;
          }
          for (var i3 = 0; i3 < filtered.length; i3 += 2) {
            var open_1 = filtered[i3].value;
            var close_1 = filtered[i3 + 1].value;
            quotes2.push({ open: open_1, close: close_1 });
          }
          return quotes2;
        }
      };
      var getQuote = function(quotes2, depth, open4) {
        if (!quotes2) {
          return "";
        }
        var quote = quotes2[Math.min(depth, quotes2.length - 1)];
        if (!quote) {
          return "";
        }
        return open4 ? quote.open : quote.close;
      };
      var boxShadow = {
        name: "box-shadow",
        initialValue: "none",
        type: 1,
        prefix: false,
        parse: function(context, tokens) {
          if (tokens.length === 1 && isIdentWithValue(tokens[0], "none")) {
            return [];
          }
          return parseFunctionArgs(tokens).map(function(values) {
            var shadow = {
              color: 255,
              offsetX: ZERO_LENGTH,
              offsetY: ZERO_LENGTH,
              blur: ZERO_LENGTH,
              spread: ZERO_LENGTH,
              inset: false
            };
            var c3 = 0;
            for (var i3 = 0; i3 < values.length; i3++) {
              var token = values[i3];
              if (isIdentWithValue(token, "inset")) {
                shadow.inset = true;
              } else if (isLength(token)) {
                if (c3 === 0) {
                  shadow.offsetX = token;
                } else if (c3 === 1) {
                  shadow.offsetY = token;
                } else if (c3 === 2) {
                  shadow.blur = token;
                } else {
                  shadow.spread = token;
                }
                c3++;
              } else {
                shadow.color = color$1.parse(context, token);
              }
            }
            return shadow;
          });
        }
      };
      var paintOrder = {
        name: "paint-order",
        initialValue: "normal",
        prefix: false,
        type: 1,
        parse: function(_context, tokens) {
          var DEFAULT_VALUE2 = [
            0,
            1,
            2
            /* MARKERS */
          ];
          var layers = [];
          tokens.filter(isIdentToken).forEach(function(token) {
            switch (token.value) {
              case "stroke":
                layers.push(
                  1
                  /* STROKE */
                );
                break;
              case "fill":
                layers.push(
                  0
                  /* FILL */
                );
                break;
              case "markers":
                layers.push(
                  2
                  /* MARKERS */
                );
                break;
            }
          });
          DEFAULT_VALUE2.forEach(function(value) {
            if (layers.indexOf(value) === -1) {
              layers.push(value);
            }
          });
          return layers;
        }
      };
      var webkitTextStrokeColor = {
        name: "-webkit-text-stroke-color",
        initialValue: "currentcolor",
        prefix: false,
        type: 3,
        format: "color"
      };
      var webkitTextStrokeWidth = {
        name: "-webkit-text-stroke-width",
        initialValue: "0",
        type: 0,
        prefix: false,
        parse: function(_context, token) {
          if (isDimensionToken(token)) {
            return token.number;
          }
          return 0;
        }
      };
      var CSSParsedDeclaration = (
        /** @class */
        function() {
          function CSSParsedDeclaration2(context, declaration) {
            var _a2, _b2;
            this.animationDuration = parse2(context, duration, declaration.animationDuration);
            this.backgroundClip = parse2(context, backgroundClip, declaration.backgroundClip);
            this.backgroundColor = parse2(context, backgroundColor, declaration.backgroundColor);
            this.backgroundImage = parse2(context, backgroundImage, declaration.backgroundImage);
            this.backgroundOrigin = parse2(context, backgroundOrigin, declaration.backgroundOrigin);
            this.backgroundPosition = parse2(context, backgroundPosition, declaration.backgroundPosition);
            this.backgroundRepeat = parse2(context, backgroundRepeat, declaration.backgroundRepeat);
            this.backgroundSize = parse2(context, backgroundSize, declaration.backgroundSize);
            this.borderTopColor = parse2(context, borderTopColor, declaration.borderTopColor);
            this.borderRightColor = parse2(context, borderRightColor, declaration.borderRightColor);
            this.borderBottomColor = parse2(context, borderBottomColor, declaration.borderBottomColor);
            this.borderLeftColor = parse2(context, borderLeftColor, declaration.borderLeftColor);
            this.borderTopLeftRadius = parse2(context, borderTopLeftRadius, declaration.borderTopLeftRadius);
            this.borderTopRightRadius = parse2(context, borderTopRightRadius, declaration.borderTopRightRadius);
            this.borderBottomRightRadius = parse2(context, borderBottomRightRadius, declaration.borderBottomRightRadius);
            this.borderBottomLeftRadius = parse2(context, borderBottomLeftRadius, declaration.borderBottomLeftRadius);
            this.borderTopStyle = parse2(context, borderTopStyle, declaration.borderTopStyle);
            this.borderRightStyle = parse2(context, borderRightStyle, declaration.borderRightStyle);
            this.borderBottomStyle = parse2(context, borderBottomStyle, declaration.borderBottomStyle);
            this.borderLeftStyle = parse2(context, borderLeftStyle, declaration.borderLeftStyle);
            this.borderTopWidth = parse2(context, borderTopWidth, declaration.borderTopWidth);
            this.borderRightWidth = parse2(context, borderRightWidth, declaration.borderRightWidth);
            this.borderBottomWidth = parse2(context, borderBottomWidth, declaration.borderBottomWidth);
            this.borderLeftWidth = parse2(context, borderLeftWidth, declaration.borderLeftWidth);
            this.boxShadow = parse2(context, boxShadow, declaration.boxShadow);
            this.color = parse2(context, color, declaration.color);
            this.direction = parse2(context, direction, declaration.direction);
            this.display = parse2(context, display, declaration.display);
            this.float = parse2(context, float, declaration.cssFloat);
            this.fontFamily = parse2(context, fontFamily, declaration.fontFamily);
            this.fontSize = parse2(context, fontSize, declaration.fontSize);
            this.fontStyle = parse2(context, fontStyle, declaration.fontStyle);
            this.fontVariant = parse2(context, fontVariant, declaration.fontVariant);
            this.fontWeight = parse2(context, fontWeight, declaration.fontWeight);
            this.letterSpacing = parse2(context, letterSpacing, declaration.letterSpacing);
            this.lineBreak = parse2(context, lineBreak, declaration.lineBreak);
            this.lineHeight = parse2(context, lineHeight, declaration.lineHeight);
            this.listStyleImage = parse2(context, listStyleImage, declaration.listStyleImage);
            this.listStylePosition = parse2(context, listStylePosition, declaration.listStylePosition);
            this.listStyleType = parse2(context, listStyleType, declaration.listStyleType);
            this.marginTop = parse2(context, marginTop, declaration.marginTop);
            this.marginRight = parse2(context, marginRight, declaration.marginRight);
            this.marginBottom = parse2(context, marginBottom, declaration.marginBottom);
            this.marginLeft = parse2(context, marginLeft, declaration.marginLeft);
            this.opacity = parse2(context, opacity, declaration.opacity);
            var overflowTuple = parse2(context, overflow, declaration.overflow);
            this.overflowX = overflowTuple[0];
            this.overflowY = overflowTuple[overflowTuple.length > 1 ? 1 : 0];
            this.overflowWrap = parse2(context, overflowWrap, declaration.overflowWrap);
            this.paddingTop = parse2(context, paddingTop, declaration.paddingTop);
            this.paddingRight = parse2(context, paddingRight, declaration.paddingRight);
            this.paddingBottom = parse2(context, paddingBottom, declaration.paddingBottom);
            this.paddingLeft = parse2(context, paddingLeft, declaration.paddingLeft);
            this.paintOrder = parse2(context, paintOrder, declaration.paintOrder);
            this.position = parse2(context, position3, declaration.position);
            this.textAlign = parse2(context, textAlign, declaration.textAlign);
            this.textDecorationColor = parse2(context, textDecorationColor, (_a2 = declaration.textDecorationColor) !== null && _a2 !== void 0 ? _a2 : declaration.color);
            this.textDecorationLine = parse2(context, textDecorationLine, (_b2 = declaration.textDecorationLine) !== null && _b2 !== void 0 ? _b2 : declaration.textDecoration);
            this.textShadow = parse2(context, textShadow, declaration.textShadow);
            this.textTransform = parse2(context, textTransform, declaration.textTransform);
            this.transform = parse2(context, transform$1, declaration.transform);
            this.transformOrigin = parse2(context, transformOrigin, declaration.transformOrigin);
            this.visibility = parse2(context, visibility, declaration.visibility);
            this.webkitTextStrokeColor = parse2(context, webkitTextStrokeColor, declaration.webkitTextStrokeColor);
            this.webkitTextStrokeWidth = parse2(context, webkitTextStrokeWidth, declaration.webkitTextStrokeWidth);
            this.wordBreak = parse2(context, wordBreak, declaration.wordBreak);
            this.zIndex = parse2(context, zIndex, declaration.zIndex);
          }
          CSSParsedDeclaration2.prototype.isVisible = function() {
            return this.display > 0 && this.opacity > 0 && this.visibility === 0;
          };
          CSSParsedDeclaration2.prototype.isTransparent = function() {
            return isTransparent2(this.backgroundColor);
          };
          CSSParsedDeclaration2.prototype.isTransformed = function() {
            return this.transform !== null;
          };
          CSSParsedDeclaration2.prototype.isPositioned = function() {
            return this.position !== 0;
          };
          CSSParsedDeclaration2.prototype.isPositionedWithZIndex = function() {
            return this.isPositioned() && !this.zIndex.auto;
          };
          CSSParsedDeclaration2.prototype.isFloating = function() {
            return this.float !== 0;
          };
          CSSParsedDeclaration2.prototype.isInlineLevel = function() {
            return contains3(
              this.display,
              4
              /* INLINE */
            ) || contains3(
              this.display,
              33554432
              /* INLINE_BLOCK */
            ) || contains3(
              this.display,
              268435456
              /* INLINE_FLEX */
            ) || contains3(
              this.display,
              536870912
              /* INLINE_GRID */
            ) || contains3(
              this.display,
              67108864
              /* INLINE_LIST_ITEM */
            ) || contains3(
              this.display,
              134217728
              /* INLINE_TABLE */
            );
          };
          return CSSParsedDeclaration2;
        }()
      );
      var CSSParsedPseudoDeclaration = (
        /** @class */
        function() {
          function CSSParsedPseudoDeclaration2(context, declaration) {
            this.content = parse2(context, content3, declaration.content);
            this.quotes = parse2(context, quotes, declaration.quotes);
          }
          return CSSParsedPseudoDeclaration2;
        }()
      );
      var CSSParsedCounterDeclaration = (
        /** @class */
        function() {
          function CSSParsedCounterDeclaration2(context, declaration) {
            this.counterIncrement = parse2(context, counterIncrement, declaration.counterIncrement);
            this.counterReset = parse2(context, counterReset, declaration.counterReset);
          }
          return CSSParsedCounterDeclaration2;
        }()
      );
      var parse2 = function(context, descriptor, style) {
        var tokenizer = new Tokenizer();
        var value = style !== null && typeof style !== "undefined" ? style.toString() : descriptor.initialValue;
        tokenizer.write(value);
        var parser2 = new Parser3(tokenizer.read());
        switch (descriptor.type) {
          case 2:
            var token = parser2.parseComponentValue();
            return descriptor.parse(context, isIdentToken(token) ? token.value : descriptor.initialValue);
          case 0:
            return descriptor.parse(context, parser2.parseComponentValue());
          case 1:
            return descriptor.parse(context, parser2.parseComponentValues());
          case 4:
            return parser2.parseComponentValue();
          case 3:
            switch (descriptor.format) {
              case "angle":
                return angle.parse(context, parser2.parseComponentValue());
              case "color":
                return color$1.parse(context, parser2.parseComponentValue());
              case "image":
                return image.parse(context, parser2.parseComponentValue());
              case "length":
                var length_1 = parser2.parseComponentValue();
                return isLength(length_1) ? length_1 : ZERO_LENGTH;
              case "length-percentage":
                var value_1 = parser2.parseComponentValue();
                return isLengthPercentage(value_1) ? value_1 : ZERO_LENGTH;
              case "time":
                return time.parse(context, parser2.parseComponentValue());
            }
            break;
        }
      };
      var elementDebuggerAttribute = "data-html2canvas-debug";
      var getElementDebugType = function(element2) {
        var attribute = element2.getAttribute(elementDebuggerAttribute);
        switch (attribute) {
          case "all":
            return 1;
          case "clone":
            return 2;
          case "parse":
            return 3;
          case "render":
            return 4;
          default:
            return 0;
        }
      };
      var isDebugging = function(element2, type) {
        var elementType = getElementDebugType(element2);
        return elementType === 1 || type === elementType;
      };
      var ElementContainer = (
        /** @class */
        function() {
          function ElementContainer2(context, element2) {
            this.context = context;
            this.textNodes = [];
            this.elements = [];
            this.flags = 0;
            if (isDebugging(
              element2,
              3
              /* PARSE */
            )) {
              debugger;
            }
            this.styles = new CSSParsedDeclaration(context, window.getComputedStyle(element2, null));
            if (isHTMLElementNode(element2)) {
              if (this.styles.animationDuration.some(function(duration2) {
                return duration2 > 0;
              })) {
                element2.style.animationDuration = "0s";
              }
              if (this.styles.transform !== null) {
                element2.style.transform = "none";
              }
            }
            this.bounds = parseBounds(this.context, element2);
            if (isDebugging(
              element2,
              4
              /* RENDER */
            )) {
              this.flags |= 16;
            }
          }
          return ElementContainer2;
        }()
      );
      var base64 = "AAAAAAAAAAAAEA4AGBkAAFAaAAACAAAAAAAIABAAGAAwADgACAAQAAgAEAAIABAACAAQAAgAEAAIABAACAAQAAgAEAAIABAAQABIAEQATAAIABAACAAQAAgAEAAIABAAVABcAAgAEAAIABAACAAQAGAAaABwAHgAgACIAI4AlgAIABAAmwCjAKgAsAC2AL4AvQDFAMoA0gBPAVYBWgEIAAgACACMANoAYgFkAWwBdAF8AX0BhQGNAZUBlgGeAaMBlQGWAasBswF8AbsBwwF0AcsBYwHTAQgA2wG/AOMBdAF8AekB8QF0AfkB+wHiAHQBfAEIAAMC5gQIAAsCEgIIAAgAFgIeAggAIgIpAggAMQI5AkACygEIAAgASAJQAlgCYAIIAAgACAAKBQoFCgUTBRMFGQUrBSsFCAAIAAgACAAIAAgACAAIAAgACABdAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABoAmgCrwGvAQgAbgJ2AggAHgEIAAgACADnAXsCCAAIAAgAgwIIAAgACAAIAAgACACKAggAkQKZAggAPADJAAgAoQKkAqwCsgK6AsICCADJAggA0AIIAAgACAAIANYC3gIIAAgACAAIAAgACABAAOYCCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAkASoB+QIEAAgACAA8AEMCCABCBQgACABJBVAFCAAIAAgACAAIAAgACAAIAAgACABTBVoFCAAIAFoFCABfBWUFCAAIAAgACAAIAAgAbQUIAAgACAAIAAgACABzBXsFfQWFBYoFigWKBZEFigWKBYoFmAWfBaYFrgWxBbkFCAAIAAgACAAIAAgACAAIAAgACAAIAMEFCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAMgFCADQBQgACAAIAAgACAAIAAgACAAIAAgACAAIAO4CCAAIAAgAiQAIAAgACABAAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAD0AggACAD8AggACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIANYFCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAMDvwAIAAgAJAIIAAgACAAIAAgACAAIAAgACwMTAwgACAB9BOsEGwMjAwgAKwMyAwsFYgE3A/MEPwMIAEUDTQNRAwgAWQOsAGEDCAAIAAgACAAIAAgACABpAzQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFIQUoBSwFCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABtAwgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABMAEwACAAIAAgACAAIABgACAAIAAgACAC/AAgACAAyAQgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACACAAIAAwAAgACAAIAAgACAAIAAgACAAIAAAARABIAAgACAAIABQASAAIAAgAIABwAEAAjgCIABsAqAC2AL0AigDQAtwC+IJIQqVAZUBWQqVAZUBlQGVAZUBlQGrC5UBlQGVAZUBlQGVAZUBlQGVAXsKlQGVAbAK6wsrDGUMpQzlDJUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAfAKAAuZA64AtwCJALoC6ADwAAgAuACgA/oEpgO6AqsD+AAIAAgAswMIAAgACAAIAIkAuwP5AfsBwwPLAwgACAAIAAgACADRA9kDCAAIAOED6QMIAAgACAAIAAgACADuA/YDCAAIAP4DyQAIAAgABgQIAAgAXQAOBAgACAAIAAgACAAIABMECAAIAAgACAAIAAgACAD8AAQBCAAIAAgAGgQiBCoECAExBAgAEAEIAAgACAAIAAgACAAIAAgACAAIAAgACAA4BAgACABABEYECAAIAAgATAQYAQgAVAQIAAgACAAIAAgACAAIAAgACAAIAFoECAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAOQEIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAB+BAcACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAEABhgSMBAgACAAIAAgAlAQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAwAEAAQABAADAAMAAwADAAQABAAEAAQABAAEAAQABHATAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAdQMIAAgACAAIAAgACAAIAMkACAAIAAgAfQMIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACACFA4kDCAAIAAgACAAIAOcBCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAIcDCAAIAAgACAAIAAgACAAIAAgACAAIAJEDCAAIAAgACADFAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABgBAgAZgQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAbAQCBXIECAAIAHkECAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABAAJwEQACjBKoEsgQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAC6BMIECAAIAAgACAAIAAgACABmBAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAxwQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAGYECAAIAAgAzgQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAigWKBYoFigWKBYoFigWKBd0FXwUIAOIF6gXxBYoF3gT5BQAGCAaKBYoFigWKBYoFigWKBYoFigWKBYoFigXWBIoFigWKBYoFigWKBYoFigWKBYsFEAaKBYoFigWKBYoFigWKBRQGCACKBYoFigWKBQgACAAIANEECAAIABgGigUgBggAJgYIAC4GMwaKBYoF0wQ3Bj4GigWKBYoFigWKBYoFigWKBYoFigWKBYoFigUIAAgACAAIAAgACAAIAAgAigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWLBf///////wQABAAEAAQABAAEAAQABAAEAAQAAwAEAAQAAgAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAQADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAUAAAAFAAUAAAAFAAUAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAEAAQABAAEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUAAQAAAAUABQAFAAUABQAFAAAAAAAFAAUAAAAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAFAAUAAQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABwAFAAUABQAFAAAABwAHAAcAAAAHAAcABwAFAAEAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAFAAcABwAFAAUAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAAAAQABAAAAAAAAAAAAAAAFAAUABQAFAAAABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAHAAcABwAHAAcAAAAHAAcAAAAAAAUABQAHAAUAAQAHAAEABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABwABAAUABQAFAAUAAAAAAAAAAAAAAAEAAQABAAEAAQABAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABwAFAAUAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUAAQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQABQANAAQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQABAAEAAQABAAEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAEAAQABAAEAAQABAAEAAQABAAEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAQABAAEAAQABAAEAAQABAAAAAAAAAAAAAAAAAAAAAAABQAHAAUABQAFAAAAAAAAAAcABQAFAAUABQAFAAQABAAEAAQABAAEAAQABAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUAAAAFAAUABQAFAAUAAAAFAAUABQAAAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAAAAAAAAAAAAUABQAFAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAHAAUAAAAHAAcABwAFAAUABQAFAAUABQAFAAUABwAHAAcABwAFAAcABwAAAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABwAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAUABwAHAAUABQAFAAUAAAAAAAcABwAAAAAABwAHAAUAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAABQAFAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAABwAHAAcABQAFAAAAAAAAAAAABQAFAAAAAAAFAAUABQAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAFAAUABQAFAAUAAAAFAAUABwAAAAcABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAFAAUABwAFAAUABQAFAAAAAAAHAAcAAAAAAAcABwAFAAAAAAAAAAAAAAAAAAAABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAcABwAAAAAAAAAHAAcABwAAAAcABwAHAAUAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAABQAHAAcABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABwAHAAcABwAAAAUABQAFAAAABQAFAAUABQAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAcABQAHAAcABQAHAAcAAAAFAAcABwAAAAcABwAFAAUAAAAAAAAAAAAAAAAAAAAFAAUAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAUABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAFAAcABwAFAAUABQAAAAUAAAAHAAcABwAHAAcABwAHAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAHAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAABwAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAUAAAAFAAAAAAAAAAAABwAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABwAFAAUABQAFAAUAAAAFAAUAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABwAFAAUABQAFAAUABQAAAAUABQAHAAcABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABQAFAAAAAAAAAAAABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAcABQAFAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAHAAUABQAFAAUABQAFAAUABwAHAAcABwAHAAcABwAHAAUABwAHAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABwAHAAcABwAFAAUABwAHAAcAAAAAAAAAAAAHAAcABQAHAAcABwAHAAcABwAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAcABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABQAHAAUABQAFAAUABQAFAAUAAAAFAAAABQAAAAAABQAFAAUABQAFAAUABQAFAAcABwAHAAcABwAHAAUABQAFAAUABQAFAAUABQAFAAUAAAAAAAUABQAFAAUABQAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABwAFAAcABwAHAAcABwAFAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAUABQAFAAUABwAHAAUABQAHAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAcABQAFAAcABwAHAAUABwAFAAUABQAHAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAcABwAHAAcABwAHAAUABQAFAAUABQAFAAUABQAHAAcABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAcABQAFAAUABQAFAAUABQAAAAAAAAAAAAUAAAAAAAAAAAAAAAAABQAAAAAABwAFAAUAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUAAAAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAABQAAAAAAAAAFAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAUABQAHAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAHAAcABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAHAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAcABwAFAAUABQAFAAcABwAFAAUABwAHAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAcABwAFAAUABwAHAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAFAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAFAAUABQAAAAAABQAFAAAAAAAAAAAAAAAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABQAFAAcABwAAAAAAAAAAAAAABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAFAAcABwAFAAcABwAAAAcABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAAAAAAAAAAAAAAAAAFAAUABQAAAAUABQAAAAAAAAAAAAAABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABQAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABwAFAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAcABQAFAAUABQAFAAUABQAFAAUABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAHAAcABQAHAAUABQAAAAAAAAAAAAAAAAAFAAAABwAHAAcABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABwAHAAcABwAAAAAABwAHAAAAAAAHAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAAAAAAFAAUABQAFAAUABQAFAAAAAAAAAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAFAAUABQAFAAUABwAHAAUABQAFAAcABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAHAAcABQAFAAUABQAFAAUABwAFAAcABwAFAAcABQAFAAcABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAHAAcABQAFAAUABQAAAAAABwAHAAcABwAFAAUABwAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAHAAUABQAFAAUABQAFAAUABQAHAAcABQAHAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABwAFAAcABwAFAAUABQAFAAUABQAHAAUAAAAAAAAAAAAAAAAAAAAAAAcABwAFAAUABQAFAAcABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAFAAUABQAFAAUABQAHAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAFAAAAAAAFAAUABwAHAAcABwAFAAAAAAAAAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABwAHAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABQAFAAUABQAFAAUABQAAAAUABQAFAAUABQAFAAcABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAAAHAAUABQAFAAUABQAFAAUABwAFAAUABwAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUAAAAAAAAABQAAAAUABQAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAHAAcAAAAFAAUAAAAHAAcABQAHAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABwAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAAAAAAAAAAAAAAAAAAABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAUABQAFAAAAAAAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAABQAFAAUABQAFAAUABQAAAAUABQAAAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAFAAUABQAFAAUADgAOAA4ADgAOAA4ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAAAAAAAAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAMAAwADAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAAAAAAAAAAAAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAAAAAAAAAAAAsADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwACwAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAADgAOAA4AAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAAAA4ADgAOAA4ADgAOAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAAAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAAAA4AAAAOAAAAAAAAAAAAAAAAAA4AAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAADgAAAAAAAAAAAA4AAAAOAAAAAAAAAAAADgAOAA4AAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAAAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4AAAAAAA4ADgAOAA4ADgAOAA4ADgAOAAAADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4AAAAAAAAAAAAAAAAAAAAAAA4ADgAOAA4ADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAOAA4ADgAOAA4ADgAAAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAAAAAAAAA=";
      var chars$1 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
      var lookup$1 = typeof Uint8Array === "undefined" ? [] : new Uint8Array(256);
      for (var i$1 = 0; i$1 < chars$1.length; i$1++) {
        lookup$1[chars$1.charCodeAt(i$1)] = i$1;
      }
      var decode2 = function(base642) {
        var bufferLength = base642.length * 0.75, len = base642.length, i3, p2 = 0, encoded1, encoded2, encoded3, encoded4;
        if (base642[base642.length - 1] === "=") {
          bufferLength--;
          if (base642[base642.length - 2] === "=") {
            bufferLength--;
          }
        }
        var buffer = typeof ArrayBuffer !== "undefined" && typeof Uint8Array !== "undefined" && typeof Uint8Array.prototype.slice !== "undefined" ? new ArrayBuffer(bufferLength) : new Array(bufferLength);
        var bytes = Array.isArray(buffer) ? buffer : new Uint8Array(buffer);
        for (i3 = 0; i3 < len; i3 += 4) {
          encoded1 = lookup$1[base642.charCodeAt(i3)];
          encoded2 = lookup$1[base642.charCodeAt(i3 + 1)];
          encoded3 = lookup$1[base642.charCodeAt(i3 + 2)];
          encoded4 = lookup$1[base642.charCodeAt(i3 + 3)];
          bytes[p2++] = encoded1 << 2 | encoded2 >> 4;
          bytes[p2++] = (encoded2 & 15) << 4 | encoded3 >> 2;
          bytes[p2++] = (encoded3 & 3) << 6 | encoded4 & 63;
        }
        return buffer;
      };
      var polyUint16Array = function(buffer) {
        var length2 = buffer.length;
        var bytes = [];
        for (var i3 = 0; i3 < length2; i3 += 2) {
          bytes.push(buffer[i3 + 1] << 8 | buffer[i3]);
        }
        return bytes;
      };
      var polyUint32Array = function(buffer) {
        var length2 = buffer.length;
        var bytes = [];
        for (var i3 = 0; i3 < length2; i3 += 4) {
          bytes.push(buffer[i3 + 3] << 24 | buffer[i3 + 2] << 16 | buffer[i3 + 1] << 8 | buffer[i3]);
        }
        return bytes;
      };
      var UTRIE2_SHIFT_2 = 5;
      var UTRIE2_SHIFT_1 = 6 + 5;
      var UTRIE2_INDEX_SHIFT = 2;
      var UTRIE2_SHIFT_1_2 = UTRIE2_SHIFT_1 - UTRIE2_SHIFT_2;
      var UTRIE2_LSCP_INDEX_2_OFFSET = 65536 >> UTRIE2_SHIFT_2;
      var UTRIE2_DATA_BLOCK_LENGTH = 1 << UTRIE2_SHIFT_2;
      var UTRIE2_DATA_MASK = UTRIE2_DATA_BLOCK_LENGTH - 1;
      var UTRIE2_LSCP_INDEX_2_LENGTH = 1024 >> UTRIE2_SHIFT_2;
      var UTRIE2_INDEX_2_BMP_LENGTH = UTRIE2_LSCP_INDEX_2_OFFSET + UTRIE2_LSCP_INDEX_2_LENGTH;
      var UTRIE2_UTF8_2B_INDEX_2_OFFSET = UTRIE2_INDEX_2_BMP_LENGTH;
      var UTRIE2_UTF8_2B_INDEX_2_LENGTH = 2048 >> 6;
      var UTRIE2_INDEX_1_OFFSET = UTRIE2_UTF8_2B_INDEX_2_OFFSET + UTRIE2_UTF8_2B_INDEX_2_LENGTH;
      var UTRIE2_OMITTED_BMP_INDEX_1_LENGTH = 65536 >> UTRIE2_SHIFT_1;
      var UTRIE2_INDEX_2_BLOCK_LENGTH = 1 << UTRIE2_SHIFT_1_2;
      var UTRIE2_INDEX_2_MASK = UTRIE2_INDEX_2_BLOCK_LENGTH - 1;
      var slice16 = function(view, start, end) {
        if (view.slice) {
          return view.slice(start, end);
        }
        return new Uint16Array(Array.prototype.slice.call(view, start, end));
      };
      var slice32 = function(view, start, end) {
        if (view.slice) {
          return view.slice(start, end);
        }
        return new Uint32Array(Array.prototype.slice.call(view, start, end));
      };
      var createTrieFromBase64 = function(base642, _byteLength) {
        var buffer = decode2(base642);
        var view32 = Array.isArray(buffer) ? polyUint32Array(buffer) : new Uint32Array(buffer);
        var view16 = Array.isArray(buffer) ? polyUint16Array(buffer) : new Uint16Array(buffer);
        var headerLength = 24;
        var index3 = slice16(view16, headerLength / 2, view32[4] / 2);
        var data2 = view32[5] === 2 ? slice16(view16, (headerLength + view32[4]) / 2) : slice32(view32, Math.ceil((headerLength + view32[4]) / 4));
        return new Trie(view32[0], view32[1], view32[2], view32[3], index3, data2);
      };
      var Trie = (
        /** @class */
        function() {
          function Trie2(initialValue, errorValue, highStart, highValueIndex, index3, data2) {
            this.initialValue = initialValue;
            this.errorValue = errorValue;
            this.highStart = highStart;
            this.highValueIndex = highValueIndex;
            this.index = index3;
            this.data = data2;
          }
          Trie2.prototype.get = function(codePoint) {
            var ix;
            if (codePoint >= 0) {
              if (codePoint < 55296 || codePoint > 56319 && codePoint <= 65535) {
                ix = this.index[codePoint >> UTRIE2_SHIFT_2];
                ix = (ix << UTRIE2_INDEX_SHIFT) + (codePoint & UTRIE2_DATA_MASK);
                return this.data[ix];
              }
              if (codePoint <= 65535) {
                ix = this.index[UTRIE2_LSCP_INDEX_2_OFFSET + (codePoint - 55296 >> UTRIE2_SHIFT_2)];
                ix = (ix << UTRIE2_INDEX_SHIFT) + (codePoint & UTRIE2_DATA_MASK);
                return this.data[ix];
              }
              if (codePoint < this.highStart) {
                ix = UTRIE2_INDEX_1_OFFSET - UTRIE2_OMITTED_BMP_INDEX_1_LENGTH + (codePoint >> UTRIE2_SHIFT_1);
                ix = this.index[ix];
                ix += codePoint >> UTRIE2_SHIFT_2 & UTRIE2_INDEX_2_MASK;
                ix = this.index[ix];
                ix = (ix << UTRIE2_INDEX_SHIFT) + (codePoint & UTRIE2_DATA_MASK);
                return this.data[ix];
              }
              if (codePoint <= 1114111) {
                return this.data[this.highValueIndex];
              }
            }
            return this.errorValue;
          };
          return Trie2;
        }()
      );
      var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
      var lookup = typeof Uint8Array === "undefined" ? [] : new Uint8Array(256);
      for (var i2 = 0; i2 < chars.length; i2++) {
        lookup[chars.charCodeAt(i2)] = i2;
      }
      var Prepend = 1;
      var CR = 2;
      var LF = 3;
      var Control = 4;
      var Extend = 5;
      var SpacingMark = 7;
      var L = 8;
      var V = 9;
      var T3 = 10;
      var LV = 11;
      var LVT = 12;
      var ZWJ = 13;
      var Extended_Pictographic = 14;
      var RI = 15;
      var toCodePoints = function(str) {
        var codePoints = [];
        var i3 = 0;
        var length2 = str.length;
        while (i3 < length2) {
          var value = str.charCodeAt(i3++);
          if (value >= 55296 && value <= 56319 && i3 < length2) {
            var extra = str.charCodeAt(i3++);
            if ((extra & 64512) === 56320) {
              codePoints.push(((value & 1023) << 10) + (extra & 1023) + 65536);
            } else {
              codePoints.push(value);
              i3--;
            }
          } else {
            codePoints.push(value);
          }
        }
        return codePoints;
      };
      var fromCodePoint = function() {
        var codePoints = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          codePoints[_i] = arguments[_i];
        }
        if (String.fromCodePoint) {
          return String.fromCodePoint.apply(String, codePoints);
        }
        var length2 = codePoints.length;
        if (!length2) {
          return "";
        }
        var codeUnits = [];
        var index3 = -1;
        var result = "";
        while (++index3 < length2) {
          var codePoint = codePoints[index3];
          if (codePoint <= 65535) {
            codeUnits.push(codePoint);
          } else {
            codePoint -= 65536;
            codeUnits.push((codePoint >> 10) + 55296, codePoint % 1024 + 56320);
          }
          if (index3 + 1 === length2 || codeUnits.length > 16384) {
            result += String.fromCharCode.apply(String, codeUnits);
            codeUnits.length = 0;
          }
        }
        return result;
      };
      var UnicodeTrie = createTrieFromBase64(base64);
      var BREAK_NOT_ALLOWED = "\xD7";
      var BREAK_ALLOWED = "\xF7";
      var codePointToClass = function(codePoint) {
        return UnicodeTrie.get(codePoint);
      };
      var _graphemeBreakAtIndex = function(_codePoints, classTypes, index3) {
        var prevIndex = index3 - 2;
        var prev2 = classTypes[prevIndex];
        var current = classTypes[index3 - 1];
        var next2 = classTypes[index3];
        if (current === CR && next2 === LF) {
          return BREAK_NOT_ALLOWED;
        }
        if (current === CR || current === LF || current === Control) {
          return BREAK_ALLOWED;
        }
        if (next2 === CR || next2 === LF || next2 === Control) {
          return BREAK_ALLOWED;
        }
        if (current === L && [L, V, LV, LVT].indexOf(next2) !== -1) {
          return BREAK_NOT_ALLOWED;
        }
        if ((current === LV || current === V) && (next2 === V || next2 === T3)) {
          return BREAK_NOT_ALLOWED;
        }
        if ((current === LVT || current === T3) && next2 === T3) {
          return BREAK_NOT_ALLOWED;
        }
        if (next2 === ZWJ || next2 === Extend) {
          return BREAK_NOT_ALLOWED;
        }
        if (next2 === SpacingMark) {
          return BREAK_NOT_ALLOWED;
        }
        if (current === Prepend) {
          return BREAK_NOT_ALLOWED;
        }
        if (current === ZWJ && next2 === Extended_Pictographic) {
          while (prev2 === Extend) {
            prev2 = classTypes[--prevIndex];
          }
          if (prev2 === Extended_Pictographic) {
            return BREAK_NOT_ALLOWED;
          }
        }
        if (current === RI && next2 === RI) {
          var countRI = 0;
          while (prev2 === RI) {
            countRI++;
            prev2 = classTypes[--prevIndex];
          }
          if (countRI % 2 === 0) {
            return BREAK_NOT_ALLOWED;
          }
        }
        return BREAK_ALLOWED;
      };
      var GraphemeBreaker = function(str) {
        var codePoints = toCodePoints(str);
        var length2 = codePoints.length;
        var index3 = 0;
        var lastEnd = 0;
        var classTypes = codePoints.map(codePointToClass);
        return {
          next: function() {
            if (index3 >= length2) {
              return { done: true, value: null };
            }
            var graphemeBreak = BREAK_NOT_ALLOWED;
            while (index3 < length2 && (graphemeBreak = _graphemeBreakAtIndex(codePoints, classTypes, ++index3)) === BREAK_NOT_ALLOWED) {
            }
            if (graphemeBreak !== BREAK_NOT_ALLOWED || index3 === length2) {
              var value = fromCodePoint.apply(null, codePoints.slice(lastEnd, index3));
              lastEnd = index3;
              return { value, done: false };
            }
            return { done: true, value: null };
          }
        };
      };
      var splitGraphemes = function(str) {
        var breaker = GraphemeBreaker(str);
        var graphemes = [];
        var bk;
        while (!(bk = breaker.next()).done) {
          if (bk.value) {
            graphemes.push(bk.value.slice());
          }
        }
        return graphemes;
      };
      var testRangeBounds = function(document4) {
        var TEST_HEIGHT = 123;
        if (document4.createRange) {
          var range = document4.createRange();
          if (range.getBoundingClientRect) {
            var testElement = document4.createElement("boundtest");
            testElement.style.height = TEST_HEIGHT + "px";
            testElement.style.display = "block";
            document4.body.appendChild(testElement);
            range.selectNode(testElement);
            var rangeBounds = range.getBoundingClientRect();
            var rangeHeight = Math.round(rangeBounds.height);
            document4.body.removeChild(testElement);
            if (rangeHeight === TEST_HEIGHT) {
              return true;
            }
          }
        }
        return false;
      };
      var testIOSLineBreak = function(document4) {
        var testElement = document4.createElement("boundtest");
        testElement.style.width = "50px";
        testElement.style.display = "block";
        testElement.style.fontSize = "12px";
        testElement.style.letterSpacing = "0px";
        testElement.style.wordSpacing = "0px";
        document4.body.appendChild(testElement);
        var range = document4.createRange();
        testElement.innerHTML = typeof "".repeat === "function" ? "&#128104;".repeat(10) : "";
        var node3 = testElement.firstChild;
        var textList = toCodePoints$1(node3.data).map(function(i3) {
          return fromCodePoint$1(i3);
        });
        var offset = 0;
        var prev2 = {};
        var supports = textList.every(function(text4, i3) {
          range.setStart(node3, offset);
          range.setEnd(node3, offset + text4.length);
          var rect = range.getBoundingClientRect();
          offset += text4.length;
          var boundAhead = rect.x > prev2.x || rect.y > prev2.y;
          prev2 = rect;
          if (i3 === 0) {
            return true;
          }
          return boundAhead;
        });
        document4.body.removeChild(testElement);
        return supports;
      };
      var testCORS = function() {
        return typeof new Image().crossOrigin !== "undefined";
      };
      var testResponseType = function() {
        return typeof new XMLHttpRequest().responseType === "string";
      };
      var testSVG = function(document4) {
        var img = new Image();
        var canvas = document4.createElement("canvas");
        var ctx = canvas.getContext("2d");
        if (!ctx) {
          return false;
        }
        img.src = "data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg'></svg>";
        try {
          ctx.drawImage(img, 0, 0);
          canvas.toDataURL();
        } catch (e3) {
          return false;
        }
        return true;
      };
      var isGreenPixel = function(data2) {
        return data2[0] === 0 && data2[1] === 255 && data2[2] === 0 && data2[3] === 255;
      };
      var testForeignObject = function(document4) {
        var canvas = document4.createElement("canvas");
        var size2 = 100;
        canvas.width = size2;
        canvas.height = size2;
        var ctx = canvas.getContext("2d");
        if (!ctx) {
          return Promise.reject(false);
        }
        ctx.fillStyle = "rgb(0, 255, 0)";
        ctx.fillRect(0, 0, size2, size2);
        var img = new Image();
        var greenImageSrc = canvas.toDataURL();
        img.src = greenImageSrc;
        var svg2 = createForeignObjectSVG(size2, size2, 0, 0, img);
        ctx.fillStyle = "red";
        ctx.fillRect(0, 0, size2, size2);
        return loadSerializedSVG$1(svg2).then(function(img2) {
          ctx.drawImage(img2, 0, 0);
          var data2 = ctx.getImageData(0, 0, size2, size2).data;
          ctx.fillStyle = "red";
          ctx.fillRect(0, 0, size2, size2);
          var node3 = document4.createElement("div");
          node3.style.backgroundImage = "url(" + greenImageSrc + ")";
          node3.style.height = size2 + "px";
          return isGreenPixel(data2) ? loadSerializedSVG$1(createForeignObjectSVG(size2, size2, 0, 0, node3)) : Promise.reject(false);
        }).then(function(img2) {
          ctx.drawImage(img2, 0, 0);
          return isGreenPixel(ctx.getImageData(0, 0, size2, size2).data);
        }).catch(function() {
          return false;
        });
      };
      var createForeignObjectSVG = function(width2, height2, x2, y3, node3) {
        var xmlns2 = "http://www.w3.org/2000/svg";
        var svg2 = document.createElementNS(xmlns2, "svg");
        var foreignObject = document.createElementNS(xmlns2, "foreignObject");
        svg2.setAttributeNS(null, "width", width2.toString());
        svg2.setAttributeNS(null, "height", height2.toString());
        foreignObject.setAttributeNS(null, "width", "100%");
        foreignObject.setAttributeNS(null, "height", "100%");
        foreignObject.setAttributeNS(null, "x", x2.toString());
        foreignObject.setAttributeNS(null, "y", y3.toString());
        foreignObject.setAttributeNS(null, "externalResourcesRequired", "true");
        svg2.appendChild(foreignObject);
        foreignObject.appendChild(node3);
        return svg2;
      };
      var loadSerializedSVG$1 = function(svg2) {
        return new Promise(function(resolve, reject) {
          var img = new Image();
          img.onload = function() {
            return resolve(img);
          };
          img.onerror = reject;
          img.src = "data:image/svg+xml;charset=utf-8," + encodeURIComponent(new XMLSerializer().serializeToString(svg2));
        });
      };
      var FEATURES = {
        get SUPPORT_RANGE_BOUNDS() {
          var value = testRangeBounds(document);
          Object.defineProperty(FEATURES, "SUPPORT_RANGE_BOUNDS", { value });
          return value;
        },
        get SUPPORT_WORD_BREAKING() {
          var value = FEATURES.SUPPORT_RANGE_BOUNDS && testIOSLineBreak(document);
          Object.defineProperty(FEATURES, "SUPPORT_WORD_BREAKING", { value });
          return value;
        },
        get SUPPORT_SVG_DRAWING() {
          var value = testSVG(document);
          Object.defineProperty(FEATURES, "SUPPORT_SVG_DRAWING", { value });
          return value;
        },
        get SUPPORT_FOREIGNOBJECT_DRAWING() {
          var value = typeof Array.from === "function" && typeof window.fetch === "function" ? testForeignObject(document) : Promise.resolve(false);
          Object.defineProperty(FEATURES, "SUPPORT_FOREIGNOBJECT_DRAWING", { value });
          return value;
        },
        get SUPPORT_CORS_IMAGES() {
          var value = testCORS();
          Object.defineProperty(FEATURES, "SUPPORT_CORS_IMAGES", { value });
          return value;
        },
        get SUPPORT_RESPONSE_TYPE() {
          var value = testResponseType();
          Object.defineProperty(FEATURES, "SUPPORT_RESPONSE_TYPE", { value });
          return value;
        },
        get SUPPORT_CORS_XHR() {
          var value = "withCredentials" in new XMLHttpRequest();
          Object.defineProperty(FEATURES, "SUPPORT_CORS_XHR", { value });
          return value;
        },
        get SUPPORT_NATIVE_TEXT_SEGMENTATION() {
          var value = !!(typeof Intl !== "undefined" && Intl.Segmenter);
          Object.defineProperty(FEATURES, "SUPPORT_NATIVE_TEXT_SEGMENTATION", { value });
          return value;
        }
      };
      var TextBounds = (
        /** @class */
        function() {
          function TextBounds2(text4, bounds) {
            this.text = text4;
            this.bounds = bounds;
          }
          return TextBounds2;
        }()
      );
      var parseTextBounds = function(context, value, styles2, node3) {
        var textList = breakText(value, styles2);
        var textBounds = [];
        var offset = 0;
        textList.forEach(function(text4) {
          if (styles2.textDecorationLine.length || text4.trim().length > 0) {
            if (FEATURES.SUPPORT_RANGE_BOUNDS) {
              var clientRects = createRange(node3, offset, text4.length).getClientRects();
              if (clientRects.length > 1) {
                var subSegments = segmentGraphemes(text4);
                var subOffset_1 = 0;
                subSegments.forEach(function(subSegment) {
                  textBounds.push(new TextBounds(subSegment, Bounds.fromDOMRectList(context, createRange(node3, subOffset_1 + offset, subSegment.length).getClientRects())));
                  subOffset_1 += subSegment.length;
                });
              } else {
                textBounds.push(new TextBounds(text4, Bounds.fromDOMRectList(context, clientRects)));
              }
            } else {
              var replacementNode = node3.splitText(text4.length);
              textBounds.push(new TextBounds(text4, getWrapperBounds(context, node3)));
              node3 = replacementNode;
            }
          } else if (!FEATURES.SUPPORT_RANGE_BOUNDS) {
            node3 = node3.splitText(text4.length);
          }
          offset += text4.length;
        });
        return textBounds;
      };
      var getWrapperBounds = function(context, node3) {
        var ownerDocument = node3.ownerDocument;
        if (ownerDocument) {
          var wrapper = ownerDocument.createElement("html2canvaswrapper");
          wrapper.appendChild(node3.cloneNode(true));
          var parentNode = node3.parentNode;
          if (parentNode) {
            parentNode.replaceChild(wrapper, node3);
            var bounds = parseBounds(context, wrapper);
            if (wrapper.firstChild) {
              parentNode.replaceChild(wrapper.firstChild, wrapper);
            }
            return bounds;
          }
        }
        return Bounds.EMPTY;
      };
      var createRange = function(node3, offset, length2) {
        var ownerDocument = node3.ownerDocument;
        if (!ownerDocument) {
          throw new Error("Node has no owner document");
        }
        var range = ownerDocument.createRange();
        range.setStart(node3, offset);
        range.setEnd(node3, offset + length2);
        return range;
      };
      var segmentGraphemes = function(value) {
        if (FEATURES.SUPPORT_NATIVE_TEXT_SEGMENTATION) {
          var segmenter = new Intl.Segmenter(void 0, { granularity: "grapheme" });
          return Array.from(segmenter.segment(value)).map(function(segment) {
            return segment.segment;
          });
        }
        return splitGraphemes(value);
      };
      var segmentWords = function(value, styles2) {
        if (FEATURES.SUPPORT_NATIVE_TEXT_SEGMENTATION) {
          var segmenter = new Intl.Segmenter(void 0, {
            granularity: "word"
          });
          return Array.from(segmenter.segment(value)).map(function(segment) {
            return segment.segment;
          });
        }
        return breakWords(value, styles2);
      };
      var breakText = function(value, styles2) {
        return styles2.letterSpacing !== 0 ? segmentGraphemes(value) : segmentWords(value, styles2);
      };
      var wordSeparators = [32, 160, 4961, 65792, 65793, 4153, 4241];
      var breakWords = function(str, styles2) {
        var breaker = LineBreaker(str, {
          lineBreak: styles2.lineBreak,
          wordBreak: styles2.overflowWrap === "break-word" ? "break-word" : styles2.wordBreak
        });
        var words = [];
        var bk;
        var _loop_1 = function() {
          if (bk.value) {
            var value = bk.value.slice();
            var codePoints = toCodePoints$1(value);
            var word_1 = "";
            codePoints.forEach(function(codePoint) {
              if (wordSeparators.indexOf(codePoint) === -1) {
                word_1 += fromCodePoint$1(codePoint);
              } else {
                if (word_1.length) {
                  words.push(word_1);
                }
                words.push(fromCodePoint$1(codePoint));
                word_1 = "";
              }
            });
            if (word_1.length) {
              words.push(word_1);
            }
          }
        };
        while (!(bk = breaker.next()).done) {
          _loop_1();
        }
        return words;
      };
      var TextContainer = (
        /** @class */
        function() {
          function TextContainer2(context, node3, styles2) {
            this.text = transform2(node3.data, styles2.textTransform);
            this.textBounds = parseTextBounds(context, this.text, styles2, node3);
          }
          return TextContainer2;
        }()
      );
      var transform2 = function(text4, transform3) {
        switch (transform3) {
          case 1:
            return text4.toLowerCase();
          case 3:
            return text4.replace(CAPITALIZE, capitalize2);
          case 2:
            return text4.toUpperCase();
          default:
            return text4;
        }
      };
      var CAPITALIZE = /(^|\s|:|-|\(|\))([a-z])/g;
      var capitalize2 = function(m3, p1, p2) {
        if (m3.length > 0) {
          return p1 + p2.toUpperCase();
        }
        return m3;
      };
      var ImageElementContainer = (
        /** @class */
        function(_super) {
          __extends3(ImageElementContainer2, _super);
          function ImageElementContainer2(context, img) {
            var _this = _super.call(this, context, img) || this;
            _this.src = img.currentSrc || img.src;
            _this.intrinsicWidth = img.naturalWidth;
            _this.intrinsicHeight = img.naturalHeight;
            _this.context.cache.addImage(_this.src);
            return _this;
          }
          return ImageElementContainer2;
        }(ElementContainer)
      );
      var CanvasElementContainer = (
        /** @class */
        function(_super) {
          __extends3(CanvasElementContainer2, _super);
          function CanvasElementContainer2(context, canvas) {
            var _this = _super.call(this, context, canvas) || this;
            _this.canvas = canvas;
            _this.intrinsicWidth = canvas.width;
            _this.intrinsicHeight = canvas.height;
            return _this;
          }
          return CanvasElementContainer2;
        }(ElementContainer)
      );
      var SVGElementContainer = (
        /** @class */
        function(_super) {
          __extends3(SVGElementContainer2, _super);
          function SVGElementContainer2(context, img) {
            var _this = _super.call(this, context, img) || this;
            var s2 = new XMLSerializer();
            var bounds = parseBounds(context, img);
            img.setAttribute("width", bounds.width + "px");
            img.setAttribute("height", bounds.height + "px");
            _this.svg = "data:image/svg+xml," + encodeURIComponent(s2.serializeToString(img));
            _this.intrinsicWidth = img.width.baseVal.value;
            _this.intrinsicHeight = img.height.baseVal.value;
            _this.context.cache.addImage(_this.svg);
            return _this;
          }
          return SVGElementContainer2;
        }(ElementContainer)
      );
      var LIElementContainer = (
        /** @class */
        function(_super) {
          __extends3(LIElementContainer2, _super);
          function LIElementContainer2(context, element2) {
            var _this = _super.call(this, context, element2) || this;
            _this.value = element2.value;
            return _this;
          }
          return LIElementContainer2;
        }(ElementContainer)
      );
      var OLElementContainer = (
        /** @class */
        function(_super) {
          __extends3(OLElementContainer2, _super);
          function OLElementContainer2(context, element2) {
            var _this = _super.call(this, context, element2) || this;
            _this.start = element2.start;
            _this.reversed = typeof element2.reversed === "boolean" && element2.reversed === true;
            return _this;
          }
          return OLElementContainer2;
        }(ElementContainer)
      );
      var CHECKBOX_BORDER_RADIUS = [
        {
          type: 15,
          flags: 0,
          unit: "px",
          number: 3
        }
      ];
      var RADIO_BORDER_RADIUS = [
        {
          type: 16,
          flags: 0,
          number: 50
        }
      ];
      var reformatInputBounds = function(bounds) {
        if (bounds.width > bounds.height) {
          return new Bounds(bounds.left + (bounds.width - bounds.height) / 2, bounds.top, bounds.height, bounds.height);
        } else if (bounds.width < bounds.height) {
          return new Bounds(bounds.left, bounds.top + (bounds.height - bounds.width) / 2, bounds.width, bounds.width);
        }
        return bounds;
      };
      var getInputValue = function(node3) {
        var value = node3.type === PASSWORD ? new Array(node3.value.length + 1).join("\u2022") : node3.value;
        return value.length === 0 ? node3.placeholder || "" : value;
      };
      var CHECKBOX = "checkbox";
      var RADIO = "radio";
      var PASSWORD = "password";
      var INPUT_COLOR = 707406591;
      var InputElementContainer = (
        /** @class */
        function(_super) {
          __extends3(InputElementContainer2, _super);
          function InputElementContainer2(context, input) {
            var _this = _super.call(this, context, input) || this;
            _this.type = input.type.toLowerCase();
            _this.checked = input.checked;
            _this.value = getInputValue(input);
            if (_this.type === CHECKBOX || _this.type === RADIO) {
              _this.styles.backgroundColor = 3739148031;
              _this.styles.borderTopColor = _this.styles.borderRightColor = _this.styles.borderBottomColor = _this.styles.borderLeftColor = 2779096575;
              _this.styles.borderTopWidth = _this.styles.borderRightWidth = _this.styles.borderBottomWidth = _this.styles.borderLeftWidth = 1;
              _this.styles.borderTopStyle = _this.styles.borderRightStyle = _this.styles.borderBottomStyle = _this.styles.borderLeftStyle = 1;
              _this.styles.backgroundClip = [
                0
                /* BORDER_BOX */
              ];
              _this.styles.backgroundOrigin = [
                0
                /* BORDER_BOX */
              ];
              _this.bounds = reformatInputBounds(_this.bounds);
            }
            switch (_this.type) {
              case CHECKBOX:
                _this.styles.borderTopRightRadius = _this.styles.borderTopLeftRadius = _this.styles.borderBottomRightRadius = _this.styles.borderBottomLeftRadius = CHECKBOX_BORDER_RADIUS;
                break;
              case RADIO:
                _this.styles.borderTopRightRadius = _this.styles.borderTopLeftRadius = _this.styles.borderBottomRightRadius = _this.styles.borderBottomLeftRadius = RADIO_BORDER_RADIUS;
                break;
            }
            return _this;
          }
          return InputElementContainer2;
        }(ElementContainer)
      );
      var SelectElementContainer = (
        /** @class */
        function(_super) {
          __extends3(SelectElementContainer2, _super);
          function SelectElementContainer2(context, element2) {
            var _this = _super.call(this, context, element2) || this;
            var option = element2.options[element2.selectedIndex || 0];
            _this.value = option ? option.text || "" : "";
            return _this;
          }
          return SelectElementContainer2;
        }(ElementContainer)
      );
      var TextareaElementContainer = (
        /** @class */
        function(_super) {
          __extends3(TextareaElementContainer2, _super);
          function TextareaElementContainer2(context, element2) {
            var _this = _super.call(this, context, element2) || this;
            _this.value = element2.value;
            return _this;
          }
          return TextareaElementContainer2;
        }(ElementContainer)
      );
      var IFrameElementContainer = (
        /** @class */
        function(_super) {
          __extends3(IFrameElementContainer2, _super);
          function IFrameElementContainer2(context, iframe) {
            var _this = _super.call(this, context, iframe) || this;
            _this.src = iframe.src;
            _this.width = parseInt(iframe.width, 10) || 0;
            _this.height = parseInt(iframe.height, 10) || 0;
            _this.backgroundColor = _this.styles.backgroundColor;
            try {
              if (iframe.contentWindow && iframe.contentWindow.document && iframe.contentWindow.document.documentElement) {
                _this.tree = parseTree3(context, iframe.contentWindow.document.documentElement);
                var documentBackgroundColor = iframe.contentWindow.document.documentElement ? parseColor(context, getComputedStyle(iframe.contentWindow.document.documentElement).backgroundColor) : COLORS.TRANSPARENT;
                var bodyBackgroundColor = iframe.contentWindow.document.body ? parseColor(context, getComputedStyle(iframe.contentWindow.document.body).backgroundColor) : COLORS.TRANSPARENT;
                _this.backgroundColor = isTransparent2(documentBackgroundColor) ? isTransparent2(bodyBackgroundColor) ? _this.styles.backgroundColor : bodyBackgroundColor : documentBackgroundColor;
              }
            } catch (e3) {
            }
            return _this;
          }
          return IFrameElementContainer2;
        }(ElementContainer)
      );
      var LIST_OWNERS = ["OL", "UL", "MENU"];
      var parseNodeTree = function(context, node3, parent, root2) {
        for (var childNode = node3.firstChild, nextNode = void 0; childNode; childNode = nextNode) {
          nextNode = childNode.nextSibling;
          if (isTextNode(childNode) && childNode.data.trim().length > 0) {
            parent.textNodes.push(new TextContainer(context, childNode, parent.styles));
          } else if (isElementNode(childNode)) {
            if (isSlotElement(childNode) && childNode.assignedNodes) {
              childNode.assignedNodes().forEach(function(childNode2) {
                return parseNodeTree(context, childNode2, parent, root2);
              });
            } else {
              var container = createContainer(context, childNode);
              if (container.styles.isVisible()) {
                if (createsRealStackingContext(childNode, container, root2)) {
                  container.flags |= 4;
                } else if (createsStackingContext(container.styles)) {
                  container.flags |= 2;
                }
                if (LIST_OWNERS.indexOf(childNode.tagName) !== -1) {
                  container.flags |= 8;
                }
                parent.elements.push(container);
                childNode.slot;
                if (childNode.shadowRoot) {
                  parseNodeTree(context, childNode.shadowRoot, container, root2);
                } else if (!isTextareaElement(childNode) && !isSVGElement(childNode) && !isSelectElement(childNode)) {
                  parseNodeTree(context, childNode, container, root2);
                }
              }
            }
          }
        }
      };
      var createContainer = function(context, element2) {
        if (isImageElement(element2)) {
          return new ImageElementContainer(context, element2);
        }
        if (isCanvasElement(element2)) {
          return new CanvasElementContainer(context, element2);
        }
        if (isSVGElement(element2)) {
          return new SVGElementContainer(context, element2);
        }
        if (isLIElement(element2)) {
          return new LIElementContainer(context, element2);
        }
        if (isOLElement(element2)) {
          return new OLElementContainer(context, element2);
        }
        if (isInputElement(element2)) {
          return new InputElementContainer(context, element2);
        }
        if (isSelectElement(element2)) {
          return new SelectElementContainer(context, element2);
        }
        if (isTextareaElement(element2)) {
          return new TextareaElementContainer(context, element2);
        }
        if (isIFrameElement(element2)) {
          return new IFrameElementContainer(context, element2);
        }
        return new ElementContainer(context, element2);
      };
      var parseTree3 = function(context, element2) {
        var container = createContainer(context, element2);
        container.flags |= 4;
        parseNodeTree(context, element2, container, container);
        return container;
      };
      var createsRealStackingContext = function(node3, container, root2) {
        return container.styles.isPositionedWithZIndex() || container.styles.opacity < 1 || container.styles.isTransformed() || isBodyElement(node3) && root2.styles.isTransparent();
      };
      var createsStackingContext = function(styles2) {
        return styles2.isPositioned() || styles2.isFloating();
      };
      var isTextNode = function(node3) {
        return node3.nodeType === Node.TEXT_NODE;
      };
      var isElementNode = function(node3) {
        return node3.nodeType === Node.ELEMENT_NODE;
      };
      var isHTMLElementNode = function(node3) {
        return isElementNode(node3) && typeof node3.style !== "undefined" && !isSVGElementNode(node3);
      };
      var isSVGElementNode = function(element2) {
        return typeof element2.className === "object";
      };
      var isLIElement = function(node3) {
        return node3.tagName === "LI";
      };
      var isOLElement = function(node3) {
        return node3.tagName === "OL";
      };
      var isInputElement = function(node3) {
        return node3.tagName === "INPUT";
      };
      var isHTMLElement = function(node3) {
        return node3.tagName === "HTML";
      };
      var isSVGElement = function(node3) {
        return node3.tagName === "svg";
      };
      var isBodyElement = function(node3) {
        return node3.tagName === "BODY";
      };
      var isCanvasElement = function(node3) {
        return node3.tagName === "CANVAS";
      };
      var isVideoElement = function(node3) {
        return node3.tagName === "VIDEO";
      };
      var isImageElement = function(node3) {
        return node3.tagName === "IMG";
      };
      var isIFrameElement = function(node3) {
        return node3.tagName === "IFRAME";
      };
      var isStyleElement = function(node3) {
        return node3.tagName === "STYLE";
      };
      var isScriptElement = function(node3) {
        return node3.tagName === "SCRIPT";
      };
      var isTextareaElement = function(node3) {
        return node3.tagName === "TEXTAREA";
      };
      var isSelectElement = function(node3) {
        return node3.tagName === "SELECT";
      };
      var isSlotElement = function(node3) {
        return node3.tagName === "SLOT";
      };
      var isCustomElement = function(node3) {
        return node3.tagName.indexOf("-") > 0;
      };
      var CounterState = (
        /** @class */
        function() {
          function CounterState2() {
            this.counters = {};
          }
          CounterState2.prototype.getCounterValue = function(name) {
            var counter = this.counters[name];
            if (counter && counter.length) {
              return counter[counter.length - 1];
            }
            return 1;
          };
          CounterState2.prototype.getCounterValues = function(name) {
            var counter = this.counters[name];
            return counter ? counter : [];
          };
          CounterState2.prototype.pop = function(counters) {
            var _this = this;
            counters.forEach(function(counter) {
              return _this.counters[counter].pop();
            });
          };
          CounterState2.prototype.parse = function(style) {
            var _this = this;
            var counterIncrement2 = style.counterIncrement;
            var counterReset2 = style.counterReset;
            var canReset = true;
            if (counterIncrement2 !== null) {
              counterIncrement2.forEach(function(entry) {
                var counter = _this.counters[entry.counter];
                if (counter && entry.increment !== 0) {
                  canReset = false;
                  if (!counter.length) {
                    counter.push(1);
                  }
                  counter[Math.max(0, counter.length - 1)] += entry.increment;
                }
              });
            }
            var counterNames = [];
            if (canReset) {
              counterReset2.forEach(function(entry) {
                var counter = _this.counters[entry.counter];
                counterNames.push(entry.counter);
                if (!counter) {
                  counter = _this.counters[entry.counter] = [];
                }
                counter.push(entry.reset);
              });
            }
            return counterNames;
          };
          return CounterState2;
        }()
      );
      var ROMAN_UPPER = {
        integers: [1e3, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1],
        values: ["M", "CM", "D", "CD", "C", "XC", "L", "XL", "X", "IX", "V", "IV", "I"]
      };
      var ARMENIAN = {
        integers: [
          9e3,
          8e3,
          7e3,
          6e3,
          5e3,
          4e3,
          3e3,
          2e3,
          1e3,
          900,
          800,
          700,
          600,
          500,
          400,
          300,
          200,
          100,
          90,
          80,
          70,
          60,
          50,
          40,
          30,
          20,
          10,
          9,
          8,
          7,
          6,
          5,
          4,
          3,
          2,
          1
        ],
        values: [
          "\u0554",
          "\u0553",
          "\u0552",
          "\u0551",
          "\u0550",
          "\u054F",
          "\u054E",
          "\u054D",
          "\u054C",
          "\u054B",
          "\u054A",
          "\u0549",
          "\u0548",
          "\u0547",
          "\u0546",
          "\u0545",
          "\u0544",
          "\u0543",
          "\u0542",
          "\u0541",
          "\u0540",
          "\u053F",
          "\u053E",
          "\u053D",
          "\u053C",
          "\u053B",
          "\u053A",
          "\u0539",
          "\u0538",
          "\u0537",
          "\u0536",
          "\u0535",
          "\u0534",
          "\u0533",
          "\u0532",
          "\u0531"
        ]
      };
      var HEBREW = {
        integers: [
          1e4,
          9e3,
          8e3,
          7e3,
          6e3,
          5e3,
          4e3,
          3e3,
          2e3,
          1e3,
          400,
          300,
          200,
          100,
          90,
          80,
          70,
          60,
          50,
          40,
          30,
          20,
          19,
          18,
          17,
          16,
          15,
          10,
          9,
          8,
          7,
          6,
          5,
          4,
          3,
          2,
          1
        ],
        values: [
          "\u05D9\u05F3",
          "\u05D8\u05F3",
          "\u05D7\u05F3",
          "\u05D6\u05F3",
          "\u05D5\u05F3",
          "\u05D4\u05F3",
          "\u05D3\u05F3",
          "\u05D2\u05F3",
          "\u05D1\u05F3",
          "\u05D0\u05F3",
          "\u05EA",
          "\u05E9",
          "\u05E8",
          "\u05E7",
          "\u05E6",
          "\u05E4",
          "\u05E2",
          "\u05E1",
          "\u05E0",
          "\u05DE",
          "\u05DC",
          "\u05DB",
          "\u05D9\u05D8",
          "\u05D9\u05D7",
          "\u05D9\u05D6",
          "\u05D8\u05D6",
          "\u05D8\u05D5",
          "\u05D9",
          "\u05D8",
          "\u05D7",
          "\u05D6",
          "\u05D5",
          "\u05D4",
          "\u05D3",
          "\u05D2",
          "\u05D1",
          "\u05D0"
        ]
      };
      var GEORGIAN = {
        integers: [
          1e4,
          9e3,
          8e3,
          7e3,
          6e3,
          5e3,
          4e3,
          3e3,
          2e3,
          1e3,
          900,
          800,
          700,
          600,
          500,
          400,
          300,
          200,
          100,
          90,
          80,
          70,
          60,
          50,
          40,
          30,
          20,
          10,
          9,
          8,
          7,
          6,
          5,
          4,
          3,
          2,
          1
        ],
        values: [
          "\u10F5",
          "\u10F0",
          "\u10EF",
          "\u10F4",
          "\u10EE",
          "\u10ED",
          "\u10EC",
          "\u10EB",
          "\u10EA",
          "\u10E9",
          "\u10E8",
          "\u10E7",
          "\u10E6",
          "\u10E5",
          "\u10E4",
          "\u10F3",
          "\u10E2",
          "\u10E1",
          "\u10E0",
          "\u10DF",
          "\u10DE",
          "\u10DD",
          "\u10F2",
          "\u10DC",
          "\u10DB",
          "\u10DA",
          "\u10D9",
          "\u10D8",
          "\u10D7",
          "\u10F1",
          "\u10D6",
          "\u10D5",
          "\u10D4",
          "\u10D3",
          "\u10D2",
          "\u10D1",
          "\u10D0"
        ]
      };
      var createAdditiveCounter = function(value, min, max2, symbols2, fallback, suffix) {
        if (value < min || value > max2) {
          return createCounterText(value, fallback, suffix.length > 0);
        }
        return symbols2.integers.reduce(function(string3, integer, index3) {
          while (value >= integer) {
            value -= integer;
            string3 += symbols2.values[index3];
          }
          return string3;
        }, "") + suffix;
      };
      var createCounterStyleWithSymbolResolver = function(value, codePointRangeLength, isNumeric, resolver2) {
        var string3 = "";
        do {
          if (!isNumeric) {
            value--;
          }
          string3 = resolver2(value) + string3;
          value /= codePointRangeLength;
        } while (value * codePointRangeLength >= codePointRangeLength);
        return string3;
      };
      var createCounterStyleFromRange = function(value, codePointRangeStart, codePointRangeEnd, isNumeric, suffix) {
        var codePointRangeLength = codePointRangeEnd - codePointRangeStart + 1;
        return (value < 0 ? "-" : "") + (createCounterStyleWithSymbolResolver(Math.abs(value), codePointRangeLength, isNumeric, function(codePoint) {
          return fromCodePoint$1(Math.floor(codePoint % codePointRangeLength) + codePointRangeStart);
        }) + suffix);
      };
      var createCounterStyleFromSymbols = function(value, symbols2, suffix) {
        if (suffix === void 0) {
          suffix = ". ";
        }
        var codePointRangeLength = symbols2.length;
        return createCounterStyleWithSymbolResolver(Math.abs(value), codePointRangeLength, false, function(codePoint) {
          return symbols2[Math.floor(codePoint % codePointRangeLength)];
        }) + suffix;
      };
      var CJK_ZEROS = 1 << 0;
      var CJK_TEN_COEFFICIENTS = 1 << 1;
      var CJK_TEN_HIGH_COEFFICIENTS = 1 << 2;
      var CJK_HUNDRED_COEFFICIENTS = 1 << 3;
      var createCJKCounter = function(value, numbers, multipliers, negativeSign, suffix, flags) {
        if (value < -9999 || value > 9999) {
          return createCounterText(value, 4, suffix.length > 0);
        }
        var tmp = Math.abs(value);
        var string3 = suffix;
        if (tmp === 0) {
          return numbers[0] + string3;
        }
        for (var digit = 0; tmp > 0 && digit <= 4; digit++) {
          var coefficient = tmp % 10;
          if (coefficient === 0 && contains3(flags, CJK_ZEROS) && string3 !== "") {
            string3 = numbers[coefficient] + string3;
          } else if (coefficient > 1 || coefficient === 1 && digit === 0 || coefficient === 1 && digit === 1 && contains3(flags, CJK_TEN_COEFFICIENTS) || coefficient === 1 && digit === 1 && contains3(flags, CJK_TEN_HIGH_COEFFICIENTS) && value > 100 || coefficient === 1 && digit > 1 && contains3(flags, CJK_HUNDRED_COEFFICIENTS)) {
            string3 = numbers[coefficient] + (digit > 0 ? multipliers[digit - 1] : "") + string3;
          } else if (coefficient === 1 && digit > 0) {
            string3 = multipliers[digit - 1] + string3;
          }
          tmp = Math.floor(tmp / 10);
        }
        return (value < 0 ? negativeSign : "") + string3;
      };
      var CHINESE_INFORMAL_MULTIPLIERS = "\u5341\u767E\u5343\u842C";
      var CHINESE_FORMAL_MULTIPLIERS = "\u62FE\u4F70\u4EDF\u842C";
      var JAPANESE_NEGATIVE = "\u30DE\u30A4\u30CA\u30B9";
      var KOREAN_NEGATIVE = "\uB9C8\uC774\uB108\uC2A4";
      var createCounterText = function(value, type, appendSuffix) {
        var defaultSuffix = appendSuffix ? ". " : "";
        var cjkSuffix = appendSuffix ? "\u3001" : "";
        var koreanSuffix = appendSuffix ? ", " : "";
        var spaceSuffix = appendSuffix ? " " : "";
        switch (type) {
          case 0:
            return "\u2022" + spaceSuffix;
          case 1:
            return "\u25E6" + spaceSuffix;
          case 2:
            return "\u25FE" + spaceSuffix;
          case 5:
            var string3 = createCounterStyleFromRange(value, 48, 57, true, defaultSuffix);
            return string3.length < 4 ? "0" + string3 : string3;
          case 4:
            return createCounterStyleFromSymbols(value, "\u3007\u4E00\u4E8C\u4E09\u56DB\u4E94\u516D\u4E03\u516B\u4E5D", cjkSuffix);
          case 6:
            return createAdditiveCounter(value, 1, 3999, ROMAN_UPPER, 3, defaultSuffix).toLowerCase();
          case 7:
            return createAdditiveCounter(value, 1, 3999, ROMAN_UPPER, 3, defaultSuffix);
          case 8:
            return createCounterStyleFromRange(value, 945, 969, false, defaultSuffix);
          case 9:
            return createCounterStyleFromRange(value, 97, 122, false, defaultSuffix);
          case 10:
            return createCounterStyleFromRange(value, 65, 90, false, defaultSuffix);
          case 11:
            return createCounterStyleFromRange(value, 1632, 1641, true, defaultSuffix);
          case 12:
          case 49:
            return createAdditiveCounter(value, 1, 9999, ARMENIAN, 3, defaultSuffix);
          case 35:
            return createAdditiveCounter(value, 1, 9999, ARMENIAN, 3, defaultSuffix).toLowerCase();
          case 13:
            return createCounterStyleFromRange(value, 2534, 2543, true, defaultSuffix);
          case 14:
          case 30:
            return createCounterStyleFromRange(value, 6112, 6121, true, defaultSuffix);
          case 15:
            return createCounterStyleFromSymbols(value, "\u5B50\u4E11\u5BC5\u536F\u8FB0\u5DF3\u5348\u672A\u7533\u9149\u620C\u4EA5", cjkSuffix);
          case 16:
            return createCounterStyleFromSymbols(value, "\u7532\u4E59\u4E19\u4E01\u620A\u5DF1\u5E9A\u8F9B\u58EC\u7678", cjkSuffix);
          case 17:
          case 48:
            return createCJKCounter(value, "\u96F6\u4E00\u4E8C\u4E09\u56DB\u4E94\u516D\u4E03\u516B\u4E5D", CHINESE_INFORMAL_MULTIPLIERS, "\u8CA0", cjkSuffix, CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS | CJK_HUNDRED_COEFFICIENTS);
          case 47:
            return createCJKCounter(value, "\u96F6\u58F9\u8CB3\u53C3\u8086\u4F0D\u9678\u67D2\u634C\u7396", CHINESE_FORMAL_MULTIPLIERS, "\u8CA0", cjkSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS | CJK_HUNDRED_COEFFICIENTS);
          case 42:
            return createCJKCounter(value, "\u96F6\u4E00\u4E8C\u4E09\u56DB\u4E94\u516D\u4E03\u516B\u4E5D", CHINESE_INFORMAL_MULTIPLIERS, "\u8D1F", cjkSuffix, CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS | CJK_HUNDRED_COEFFICIENTS);
          case 41:
            return createCJKCounter(value, "\u96F6\u58F9\u8D30\u53C1\u8086\u4F0D\u9646\u67D2\u634C\u7396", CHINESE_FORMAL_MULTIPLIERS, "\u8D1F", cjkSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS | CJK_HUNDRED_COEFFICIENTS);
          case 26:
            return createCJKCounter(value, "\u3007\u4E00\u4E8C\u4E09\u56DB\u4E94\u516D\u4E03\u516B\u4E5D", "\u5341\u767E\u5343\u4E07", JAPANESE_NEGATIVE, cjkSuffix, 0);
          case 25:
            return createCJKCounter(value, "\u96F6\u58F1\u5F10\u53C2\u56DB\u4F0D\u516D\u4E03\u516B\u4E5D", "\u62FE\u767E\u5343\u4E07", JAPANESE_NEGATIVE, cjkSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS);
          case 31:
            return createCJKCounter(value, "\uC601\uC77C\uC774\uC0BC\uC0AC\uC624\uC721\uCE60\uD314\uAD6C", "\uC2ED\uBC31\uCC9C\uB9CC", KOREAN_NEGATIVE, koreanSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS);
          case 33:
            return createCJKCounter(value, "\u96F6\u4E00\u4E8C\u4E09\u56DB\u4E94\u516D\u4E03\u516B\u4E5D", "\u5341\u767E\u5343\u842C", KOREAN_NEGATIVE, koreanSuffix, 0);
          case 32:
            return createCJKCounter(value, "\u96F6\u58F9\u8CB3\u53C3\u56DB\u4E94\u516D\u4E03\u516B\u4E5D", "\u62FE\u767E\u5343", KOREAN_NEGATIVE, koreanSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS);
          case 18:
            return createCounterStyleFromRange(value, 2406, 2415, true, defaultSuffix);
          case 20:
            return createAdditiveCounter(value, 1, 19999, GEORGIAN, 3, defaultSuffix);
          case 21:
            return createCounterStyleFromRange(value, 2790, 2799, true, defaultSuffix);
          case 22:
            return createCounterStyleFromRange(value, 2662, 2671, true, defaultSuffix);
          case 22:
            return createAdditiveCounter(value, 1, 10999, HEBREW, 3, defaultSuffix);
          case 23:
            return createCounterStyleFromSymbols(value, "\u3042\u3044\u3046\u3048\u304A\u304B\u304D\u304F\u3051\u3053\u3055\u3057\u3059\u305B\u305D\u305F\u3061\u3064\u3066\u3068\u306A\u306B\u306C\u306D\u306E\u306F\u3072\u3075\u3078\u307B\u307E\u307F\u3080\u3081\u3082\u3084\u3086\u3088\u3089\u308A\u308B\u308C\u308D\u308F\u3090\u3091\u3092\u3093");
          case 24:
            return createCounterStyleFromSymbols(value, "\u3044\u308D\u306F\u306B\u307B\u3078\u3068\u3061\u308A\u306C\u308B\u3092\u308F\u304B\u3088\u305F\u308C\u305D\u3064\u306D\u306A\u3089\u3080\u3046\u3090\u306E\u304A\u304F\u3084\u307E\u3051\u3075\u3053\u3048\u3066\u3042\u3055\u304D\u3086\u3081\u307F\u3057\u3091\u3072\u3082\u305B\u3059");
          case 27:
            return createCounterStyleFromRange(value, 3302, 3311, true, defaultSuffix);
          case 28:
            return createCounterStyleFromSymbols(value, "\u30A2\u30A4\u30A6\u30A8\u30AA\u30AB\u30AD\u30AF\u30B1\u30B3\u30B5\u30B7\u30B9\u30BB\u30BD\u30BF\u30C1\u30C4\u30C6\u30C8\u30CA\u30CB\u30CC\u30CD\u30CE\u30CF\u30D2\u30D5\u30D8\u30DB\u30DE\u30DF\u30E0\u30E1\u30E2\u30E4\u30E6\u30E8\u30E9\u30EA\u30EB\u30EC\u30ED\u30EF\u30F0\u30F1\u30F2\u30F3", cjkSuffix);
          case 29:
            return createCounterStyleFromSymbols(value, "\u30A4\u30ED\u30CF\u30CB\u30DB\u30D8\u30C8\u30C1\u30EA\u30CC\u30EB\u30F2\u30EF\u30AB\u30E8\u30BF\u30EC\u30BD\u30C4\u30CD\u30CA\u30E9\u30E0\u30A6\u30F0\u30CE\u30AA\u30AF\u30E4\u30DE\u30B1\u30D5\u30B3\u30A8\u30C6\u30A2\u30B5\u30AD\u30E6\u30E1\u30DF\u30B7\u30F1\u30D2\u30E2\u30BB\u30B9", cjkSuffix);
          case 34:
            return createCounterStyleFromRange(value, 3792, 3801, true, defaultSuffix);
          case 37:
            return createCounterStyleFromRange(value, 6160, 6169, true, defaultSuffix);
          case 38:
            return createCounterStyleFromRange(value, 4160, 4169, true, defaultSuffix);
          case 39:
            return createCounterStyleFromRange(value, 2918, 2927, true, defaultSuffix);
          case 40:
            return createCounterStyleFromRange(value, 1776, 1785, true, defaultSuffix);
          case 43:
            return createCounterStyleFromRange(value, 3046, 3055, true, defaultSuffix);
          case 44:
            return createCounterStyleFromRange(value, 3174, 3183, true, defaultSuffix);
          case 45:
            return createCounterStyleFromRange(value, 3664, 3673, true, defaultSuffix);
          case 46:
            return createCounterStyleFromRange(value, 3872, 3881, true, defaultSuffix);
          case 3:
          default:
            return createCounterStyleFromRange(value, 48, 57, true, defaultSuffix);
        }
      };
      var IGNORE_ATTRIBUTE = "data-html2canvas-ignore";
      var DocumentCloner = (
        /** @class */
        function() {
          function DocumentCloner2(context, element2, options) {
            this.context = context;
            this.options = options;
            this.scrolledElements = [];
            this.referenceElement = element2;
            this.counters = new CounterState();
            this.quoteDepth = 0;
            if (!element2.ownerDocument) {
              throw new Error("Cloned element does not have an owner document");
            }
            this.documentElement = this.cloneNode(element2.ownerDocument.documentElement, false);
          }
          DocumentCloner2.prototype.toIFrame = function(ownerDocument, windowSize) {
            var _this = this;
            var iframe = createIFrameContainer(ownerDocument, windowSize);
            if (!iframe.contentWindow) {
              return Promise.reject("Unable to find iframe window");
            }
            var scrollX = ownerDocument.defaultView.pageXOffset;
            var scrollY = ownerDocument.defaultView.pageYOffset;
            var cloneWindow = iframe.contentWindow;
            var documentClone = cloneWindow.document;
            var iframeLoad = iframeLoader(iframe).then(function() {
              return __awaiter(_this, void 0, void 0, function() {
                var onclone, referenceElement;
                return __generator(this, function(_a2) {
                  switch (_a2.label) {
                    case 0:
                      this.scrolledElements.forEach(restoreNodeScroll);
                      if (cloneWindow) {
                        cloneWindow.scrollTo(windowSize.left, windowSize.top);
                        if (/(iPad|iPhone|iPod)/g.test(navigator.userAgent) && (cloneWindow.scrollY !== windowSize.top || cloneWindow.scrollX !== windowSize.left)) {
                          this.context.logger.warn("Unable to restore scroll position for cloned document");
                          this.context.windowBounds = this.context.windowBounds.add(cloneWindow.scrollX - windowSize.left, cloneWindow.scrollY - windowSize.top, 0, 0);
                        }
                      }
                      onclone = this.options.onclone;
                      referenceElement = this.clonedReferenceElement;
                      if (typeof referenceElement === "undefined") {
                        return [2, Promise.reject("Error finding the " + this.referenceElement.nodeName + " in the cloned document")];
                      }
                      if (!(documentClone.fonts && documentClone.fonts.ready))
                        return [3, 2];
                      return [4, documentClone.fonts.ready];
                    case 1:
                      _a2.sent();
                      _a2.label = 2;
                    case 2:
                      if (!/(AppleWebKit)/g.test(navigator.userAgent))
                        return [3, 4];
                      return [4, imagesReady(documentClone)];
                    case 3:
                      _a2.sent();
                      _a2.label = 4;
                    case 4:
                      if (typeof onclone === "function") {
                        return [2, Promise.resolve().then(function() {
                          return onclone(documentClone, referenceElement);
                        }).then(function() {
                          return iframe;
                        })];
                      }
                      return [2, iframe];
                  }
                });
              });
            });
            documentClone.open();
            documentClone.write(serializeDoctype(document.doctype) + "<html></html>");
            restoreOwnerScroll(this.referenceElement.ownerDocument, scrollX, scrollY);
            documentClone.replaceChild(documentClone.adoptNode(this.documentElement), documentClone.documentElement);
            documentClone.close();
            return iframeLoad;
          };
          DocumentCloner2.prototype.createElementClone = function(node3) {
            if (isDebugging(
              node3,
              2
              /* CLONE */
            )) {
              debugger;
            }
            if (isCanvasElement(node3)) {
              return this.createCanvasClone(node3);
            }
            if (isVideoElement(node3)) {
              return this.createVideoClone(node3);
            }
            if (isStyleElement(node3)) {
              return this.createStyleClone(node3);
            }
            var clone = node3.cloneNode(false);
            if (isImageElement(clone)) {
              if (isImageElement(node3) && node3.currentSrc && node3.currentSrc !== node3.src) {
                clone.src = node3.currentSrc;
                clone.srcset = "";
              }
              if (clone.loading === "lazy") {
                clone.loading = "eager";
              }
            }
            if (isCustomElement(clone)) {
              return this.createCustomElementClone(clone);
            }
            return clone;
          };
          DocumentCloner2.prototype.createCustomElementClone = function(node3) {
            var clone = document.createElement("html2canvascustomelement");
            copyCSSStyles(node3.style, clone);
            return clone;
          };
          DocumentCloner2.prototype.createStyleClone = function(node3) {
            try {
              var sheet = node3.sheet;
              if (sheet && sheet.cssRules) {
                var css2 = [].slice.call(sheet.cssRules, 0).reduce(function(css3, rule) {
                  if (rule && typeof rule.cssText === "string") {
                    return css3 + rule.cssText;
                  }
                  return css3;
                }, "");
                var style = node3.cloneNode(false);
                style.textContent = css2;
                return style;
              }
            } catch (e3) {
              this.context.logger.error("Unable to access cssRules property", e3);
              if (e3.name !== "SecurityError") {
                throw e3;
              }
            }
            return node3.cloneNode(false);
          };
          DocumentCloner2.prototype.createCanvasClone = function(canvas) {
            var _a2;
            if (this.options.inlineImages && canvas.ownerDocument) {
              var img = canvas.ownerDocument.createElement("img");
              try {
                img.src = canvas.toDataURL();
                return img;
              } catch (e3) {
                this.context.logger.info("Unable to inline canvas contents, canvas is tainted", canvas);
              }
            }
            var clonedCanvas = canvas.cloneNode(false);
            try {
              clonedCanvas.width = canvas.width;
              clonedCanvas.height = canvas.height;
              var ctx = canvas.getContext("2d");
              var clonedCtx = clonedCanvas.getContext("2d");
              if (clonedCtx) {
                if (!this.options.allowTaint && ctx) {
                  clonedCtx.putImageData(ctx.getImageData(0, 0, canvas.width, canvas.height), 0, 0);
                } else {
                  var gl = (_a2 = canvas.getContext("webgl2")) !== null && _a2 !== void 0 ? _a2 : canvas.getContext("webgl");
                  if (gl) {
                    var attribs = gl.getContextAttributes();
                    if ((attribs === null || attribs === void 0 ? void 0 : attribs.preserveDrawingBuffer) === false) {
                      this.context.logger.warn("Unable to clone WebGL context as it has preserveDrawingBuffer=false", canvas);
                    }
                  }
                  clonedCtx.drawImage(canvas, 0, 0);
                }
              }
              return clonedCanvas;
            } catch (e3) {
              this.context.logger.info("Unable to clone canvas as it is tainted", canvas);
            }
            return clonedCanvas;
          };
          DocumentCloner2.prototype.createVideoClone = function(video) {
            var canvas = video.ownerDocument.createElement("canvas");
            canvas.width = video.offsetWidth;
            canvas.height = video.offsetHeight;
            var ctx = canvas.getContext("2d");
            try {
              if (ctx) {
                ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                if (!this.options.allowTaint) {
                  ctx.getImageData(0, 0, canvas.width, canvas.height);
                }
              }
              return canvas;
            } catch (e3) {
              this.context.logger.info("Unable to clone video as it is tainted", video);
            }
            var blankCanvas = video.ownerDocument.createElement("canvas");
            blankCanvas.width = video.offsetWidth;
            blankCanvas.height = video.offsetHeight;
            return blankCanvas;
          };
          DocumentCloner2.prototype.appendChildNode = function(clone, child, copyStyles) {
            if (!isElementNode(child) || !isScriptElement(child) && !child.hasAttribute(IGNORE_ATTRIBUTE) && (typeof this.options.ignoreElements !== "function" || !this.options.ignoreElements(child))) {
              if (!this.options.copyStyles || !isElementNode(child) || !isStyleElement(child)) {
                clone.appendChild(this.cloneNode(child, copyStyles));
              }
            }
          };
          DocumentCloner2.prototype.cloneChildNodes = function(node3, clone, copyStyles) {
            var _this = this;
            for (var child = node3.shadowRoot ? node3.shadowRoot.firstChild : node3.firstChild; child; child = child.nextSibling) {
              if (isElementNode(child) && isSlotElement(child) && typeof child.assignedNodes === "function") {
                var assignedNodes = child.assignedNodes();
                if (assignedNodes.length) {
                  assignedNodes.forEach(function(assignedNode) {
                    return _this.appendChildNode(clone, assignedNode, copyStyles);
                  });
                }
              } else {
                this.appendChildNode(clone, child, copyStyles);
              }
            }
          };
          DocumentCloner2.prototype.cloneNode = function(node3, copyStyles) {
            if (isTextNode(node3)) {
              return document.createTextNode(node3.data);
            }
            if (!node3.ownerDocument) {
              return node3.cloneNode(false);
            }
            var window2 = node3.ownerDocument.defaultView;
            if (window2 && isElementNode(node3) && (isHTMLElementNode(node3) || isSVGElementNode(node3))) {
              var clone = this.createElementClone(node3);
              clone.style.transitionProperty = "none";
              var style = window2.getComputedStyle(node3);
              var styleBefore = window2.getComputedStyle(node3, ":before");
              var styleAfter = window2.getComputedStyle(node3, ":after");
              if (this.referenceElement === node3 && isHTMLElementNode(clone)) {
                this.clonedReferenceElement = clone;
              }
              if (isBodyElement(clone)) {
                createPseudoHideStyles(clone);
              }
              var counters = this.counters.parse(new CSSParsedCounterDeclaration(this.context, style));
              var before2 = this.resolvePseudoContent(node3, clone, styleBefore, PseudoElementType.BEFORE);
              if (isCustomElement(node3)) {
                copyStyles = true;
              }
              if (!isVideoElement(node3)) {
                this.cloneChildNodes(node3, clone, copyStyles);
              }
              if (before2) {
                clone.insertBefore(before2, clone.firstChild);
              }
              var after2 = this.resolvePseudoContent(node3, clone, styleAfter, PseudoElementType.AFTER);
              if (after2) {
                clone.appendChild(after2);
              }
              this.counters.pop(counters);
              if (style && (this.options.copyStyles || isSVGElementNode(node3)) && !isIFrameElement(node3) || copyStyles) {
                copyCSSStyles(style, clone);
              }
              if (node3.scrollTop !== 0 || node3.scrollLeft !== 0) {
                this.scrolledElements.push([clone, node3.scrollLeft, node3.scrollTop]);
              }
              if ((isTextareaElement(node3) || isSelectElement(node3)) && (isTextareaElement(clone) || isSelectElement(clone))) {
                clone.value = node3.value;
              }
              return clone;
            }
            return node3.cloneNode(false);
          };
          DocumentCloner2.prototype.resolvePseudoContent = function(node3, clone, style, pseudoElt) {
            var _this = this;
            if (!style) {
              return;
            }
            var value = style.content;
            var document4 = clone.ownerDocument;
            if (!document4 || !value || value === "none" || value === "-moz-alt-content" || style.display === "none") {
              return;
            }
            this.counters.parse(new CSSParsedCounterDeclaration(this.context, style));
            var declaration = new CSSParsedPseudoDeclaration(this.context, style);
            var anonymousReplacedElement = document4.createElement("html2canvaspseudoelement");
            copyCSSStyles(style, anonymousReplacedElement);
            declaration.content.forEach(function(token) {
              if (token.type === 0) {
                anonymousReplacedElement.appendChild(document4.createTextNode(token.value));
              } else if (token.type === 22) {
                var img = document4.createElement("img");
                img.src = token.value;
                img.style.opacity = "1";
                anonymousReplacedElement.appendChild(img);
              } else if (token.type === 18) {
                if (token.name === "attr") {
                  var attr2 = token.values.filter(isIdentToken);
                  if (attr2.length) {
                    anonymousReplacedElement.appendChild(document4.createTextNode(node3.getAttribute(attr2[0].value) || ""));
                  }
                } else if (token.name === "counter") {
                  var _a2 = token.values.filter(nonFunctionArgSeparator), counter = _a2[0], counterStyle = _a2[1];
                  if (counter && isIdentToken(counter)) {
                    var counterState = _this.counters.getCounterValue(counter.value);
                    var counterType = counterStyle && isIdentToken(counterStyle) ? listStyleType.parse(_this.context, counterStyle.value) : 3;
                    anonymousReplacedElement.appendChild(document4.createTextNode(createCounterText(counterState, counterType, false)));
                  }
                } else if (token.name === "counters") {
                  var _b2 = token.values.filter(nonFunctionArgSeparator), counter = _b2[0], delim = _b2[1], counterStyle = _b2[2];
                  if (counter && isIdentToken(counter)) {
                    var counterStates = _this.counters.getCounterValues(counter.value);
                    var counterType_1 = counterStyle && isIdentToken(counterStyle) ? listStyleType.parse(_this.context, counterStyle.value) : 3;
                    var separator = delim && delim.type === 0 ? delim.value : "";
                    var text4 = counterStates.map(function(value2) {
                      return createCounterText(value2, counterType_1, false);
                    }).join(separator);
                    anonymousReplacedElement.appendChild(document4.createTextNode(text4));
                  }
                } else
                  ;
              } else if (token.type === 20) {
                switch (token.value) {
                  case "open-quote":
                    anonymousReplacedElement.appendChild(document4.createTextNode(getQuote(declaration.quotes, _this.quoteDepth++, true)));
                    break;
                  case "close-quote":
                    anonymousReplacedElement.appendChild(document4.createTextNode(getQuote(declaration.quotes, --_this.quoteDepth, false)));
                    break;
                  default:
                    anonymousReplacedElement.appendChild(document4.createTextNode(token.value));
                }
              }
            });
            anonymousReplacedElement.className = PSEUDO_HIDE_ELEMENT_CLASS_BEFORE + " " + PSEUDO_HIDE_ELEMENT_CLASS_AFTER;
            var newClassName = pseudoElt === PseudoElementType.BEFORE ? " " + PSEUDO_HIDE_ELEMENT_CLASS_BEFORE : " " + PSEUDO_HIDE_ELEMENT_CLASS_AFTER;
            if (isSVGElementNode(clone)) {
              clone.className.baseValue += newClassName;
            } else {
              clone.className += newClassName;
            }
            return anonymousReplacedElement;
          };
          DocumentCloner2.destroy = function(container) {
            if (container.parentNode) {
              container.parentNode.removeChild(container);
              return true;
            }
            return false;
          };
          return DocumentCloner2;
        }()
      );
      var PseudoElementType;
      (function(PseudoElementType2) {
        PseudoElementType2[PseudoElementType2["BEFORE"] = 0] = "BEFORE";
        PseudoElementType2[PseudoElementType2["AFTER"] = 1] = "AFTER";
      })(PseudoElementType || (PseudoElementType = {}));
      var createIFrameContainer = function(ownerDocument, bounds) {
        var cloneIframeContainer = ownerDocument.createElement("iframe");
        cloneIframeContainer.className = "html2canvas-container";
        cloneIframeContainer.style.visibility = "hidden";
        cloneIframeContainer.style.position = "fixed";
        cloneIframeContainer.style.left = "-10000px";
        cloneIframeContainer.style.top = "0px";
        cloneIframeContainer.style.border = "0";
        cloneIframeContainer.width = bounds.width.toString();
        cloneIframeContainer.height = bounds.height.toString();
        cloneIframeContainer.scrolling = "no";
        cloneIframeContainer.setAttribute(IGNORE_ATTRIBUTE, "true");
        ownerDocument.body.appendChild(cloneIframeContainer);
        return cloneIframeContainer;
      };
      var imageReady = function(img) {
        return new Promise(function(resolve) {
          if (img.complete) {
            resolve();
            return;
          }
          if (!img.src) {
            resolve();
            return;
          }
          img.onload = resolve;
          img.onerror = resolve;
        });
      };
      var imagesReady = function(document4) {
        return Promise.all([].slice.call(document4.images, 0).map(imageReady));
      };
      var iframeLoader = function(iframe) {
        return new Promise(function(resolve, reject) {
          var cloneWindow = iframe.contentWindow;
          if (!cloneWindow) {
            return reject("No window assigned for iframe");
          }
          var documentClone = cloneWindow.document;
          cloneWindow.onload = iframe.onload = function() {
            cloneWindow.onload = iframe.onload = null;
            var interval = setInterval(function() {
              if (documentClone.body.childNodes.length > 0 && documentClone.readyState === "complete") {
                clearInterval(interval);
                resolve(iframe);
              }
            }, 50);
          };
        });
      };
      var ignoredStyleProperties = [
        "all",
        "d",
        "content"
        // Safari shows pseudoelements if content is set
      ];
      var copyCSSStyles = function(style, target) {
        for (var i3 = style.length - 1; i3 >= 0; i3--) {
          var property = style.item(i3);
          if (ignoredStyleProperties.indexOf(property) === -1) {
            target.style.setProperty(property, style.getPropertyValue(property));
          }
        }
        return target;
      };
      var serializeDoctype = function(doctype) {
        var str = "";
        if (doctype) {
          str += "<!DOCTYPE ";
          if (doctype.name) {
            str += doctype.name;
          }
          if (doctype.internalSubset) {
            str += doctype.internalSubset;
          }
          if (doctype.publicId) {
            str += '"' + doctype.publicId + '"';
          }
          if (doctype.systemId) {
            str += '"' + doctype.systemId + '"';
          }
          str += ">";
        }
        return str;
      };
      var restoreOwnerScroll = function(ownerDocument, x2, y3) {
        if (ownerDocument && ownerDocument.defaultView && (x2 !== ownerDocument.defaultView.pageXOffset || y3 !== ownerDocument.defaultView.pageYOffset)) {
          ownerDocument.defaultView.scrollTo(x2, y3);
        }
      };
      var restoreNodeScroll = function(_a2) {
        var element2 = _a2[0], x2 = _a2[1], y3 = _a2[2];
        element2.scrollLeft = x2;
        element2.scrollTop = y3;
      };
      var PSEUDO_BEFORE = ":before";
      var PSEUDO_AFTER = ":after";
      var PSEUDO_HIDE_ELEMENT_CLASS_BEFORE = "___html2canvas___pseudoelement_before";
      var PSEUDO_HIDE_ELEMENT_CLASS_AFTER = "___html2canvas___pseudoelement_after";
      var PSEUDO_HIDE_ELEMENT_STYLE = '{\n    content: "" !important;\n    display: none !important;\n}';
      var createPseudoHideStyles = function(body) {
        createStyles(body, "." + PSEUDO_HIDE_ELEMENT_CLASS_BEFORE + PSEUDO_BEFORE + PSEUDO_HIDE_ELEMENT_STYLE + "\n         ." + PSEUDO_HIDE_ELEMENT_CLASS_AFTER + PSEUDO_AFTER + PSEUDO_HIDE_ELEMENT_STYLE);
      };
      var createStyles = function(body, styles2) {
        var document4 = body.ownerDocument;
        if (document4) {
          var style = document4.createElement("style");
          style.textContent = styles2;
          body.appendChild(style);
        }
      };
      var CacheStorage = (
        /** @class */
        function() {
          function CacheStorage2() {
          }
          CacheStorage2.getOrigin = function(url) {
            var link = CacheStorage2._link;
            if (!link) {
              return "about:blank";
            }
            link.href = url;
            link.href = link.href;
            return link.protocol + link.hostname + link.port;
          };
          CacheStorage2.isSameOrigin = function(src) {
            return CacheStorage2.getOrigin(src) === CacheStorage2._origin;
          };
          CacheStorage2.setContext = function(window2) {
            CacheStorage2._link = window2.document.createElement("a");
            CacheStorage2._origin = CacheStorage2.getOrigin(window2.location.href);
          };
          CacheStorage2._origin = "about:blank";
          return CacheStorage2;
        }()
      );
      var Cache = (
        /** @class */
        function() {
          function Cache2(context, _options) {
            this.context = context;
            this._options = _options;
            this._cache = {};
          }
          Cache2.prototype.addImage = function(src) {
            var result = Promise.resolve();
            if (this.has(src)) {
              return result;
            }
            if (isBlobImage(src) || isRenderable(src)) {
              (this._cache[src] = this.loadImage(src)).catch(function() {
              });
              return result;
            }
            return result;
          };
          Cache2.prototype.match = function(src) {
            return this._cache[src];
          };
          Cache2.prototype.loadImage = function(key) {
            return __awaiter(this, void 0, void 0, function() {
              var isSameOrigin, useCORS, useProxy, src;
              var _this = this;
              return __generator(this, function(_a2) {
                switch (_a2.label) {
                  case 0:
                    isSameOrigin = CacheStorage.isSameOrigin(key);
                    useCORS = !isInlineImage(key) && this._options.useCORS === true && FEATURES.SUPPORT_CORS_IMAGES && !isSameOrigin;
                    useProxy = !isInlineImage(key) && !isSameOrigin && !isBlobImage(key) && typeof this._options.proxy === "string" && FEATURES.SUPPORT_CORS_XHR && !useCORS;
                    if (!isSameOrigin && this._options.allowTaint === false && !isInlineImage(key) && !isBlobImage(key) && !useProxy && !useCORS) {
                      return [
                        2
                        /*return*/
                      ];
                    }
                    src = key;
                    if (!useProxy)
                      return [3, 2];
                    return [4, this.proxy(src)];
                  case 1:
                    src = _a2.sent();
                    _a2.label = 2;
                  case 2:
                    this.context.logger.debug("Added image " + key.substring(0, 256));
                    return [4, new Promise(function(resolve, reject) {
                      var img = new Image();
                      img.onload = function() {
                        return resolve(img);
                      };
                      img.onerror = reject;
                      if (isInlineBase64Image(src) || useCORS) {
                        img.crossOrigin = "anonymous";
                      }
                      img.src = src;
                      if (img.complete === true) {
                        setTimeout(function() {
                          return resolve(img);
                        }, 500);
                      }
                      if (_this._options.imageTimeout > 0) {
                        setTimeout(function() {
                          return reject("Timed out (" + _this._options.imageTimeout + "ms) loading image");
                        }, _this._options.imageTimeout);
                      }
                    })];
                  case 3:
                    return [2, _a2.sent()];
                }
              });
            });
          };
          Cache2.prototype.has = function(key) {
            return typeof this._cache[key] !== "undefined";
          };
          Cache2.prototype.keys = function() {
            return Promise.resolve(Object.keys(this._cache));
          };
          Cache2.prototype.proxy = function(src) {
            var _this = this;
            var proxy = this._options.proxy;
            if (!proxy) {
              throw new Error("No proxy defined");
            }
            var key = src.substring(0, 256);
            return new Promise(function(resolve, reject) {
              var responseType = FEATURES.SUPPORT_RESPONSE_TYPE ? "blob" : "text";
              var xhr = new XMLHttpRequest();
              xhr.onload = function() {
                if (xhr.status === 200) {
                  if (responseType === "text") {
                    resolve(xhr.response);
                  } else {
                    var reader_1 = new FileReader();
                    reader_1.addEventListener("load", function() {
                      return resolve(reader_1.result);
                    }, false);
                    reader_1.addEventListener("error", function(e3) {
                      return reject(e3);
                    }, false);
                    reader_1.readAsDataURL(xhr.response);
                  }
                } else {
                  reject("Failed to proxy resource " + key + " with status code " + xhr.status);
                }
              };
              xhr.onerror = reject;
              var queryString = proxy.indexOf("?") > -1 ? "&" : "?";
              xhr.open("GET", "" + proxy + queryString + "url=" + encodeURIComponent(src) + "&responseType=" + responseType);
              if (responseType !== "text" && xhr instanceof XMLHttpRequest) {
                xhr.responseType = responseType;
              }
              if (_this._options.imageTimeout) {
                var timeout_1 = _this._options.imageTimeout;
                xhr.timeout = timeout_1;
                xhr.ontimeout = function() {
                  return reject("Timed out (" + timeout_1 + "ms) proxying " + key);
                };
              }
              xhr.send();
            });
          };
          return Cache2;
        }()
      );
      var INLINE_SVG = /^data:image\/svg\+xml/i;
      var INLINE_BASE64 = /^data:image\/.*;base64,/i;
      var INLINE_IMG = /^data:image\/.*/i;
      var isRenderable = function(src) {
        return FEATURES.SUPPORT_SVG_DRAWING || !isSVG(src);
      };
      var isInlineImage = function(src) {
        return INLINE_IMG.test(src);
      };
      var isInlineBase64Image = function(src) {
        return INLINE_BASE64.test(src);
      };
      var isBlobImage = function(src) {
        return src.substr(0, 4) === "blob";
      };
      var isSVG = function(src) {
        return src.substr(-3).toLowerCase() === "svg" || INLINE_SVG.test(src);
      };
      var Vector = (
        /** @class */
        function() {
          function Vector2(x2, y3) {
            this.type = 0;
            this.x = x2;
            this.y = y3;
          }
          Vector2.prototype.add = function(deltaX, deltaY) {
            return new Vector2(this.x + deltaX, this.y + deltaY);
          };
          return Vector2;
        }()
      );
      var lerp = function(a3, b, t2) {
        return new Vector(a3.x + (b.x - a3.x) * t2, a3.y + (b.y - a3.y) * t2);
      };
      var BezierCurve = (
        /** @class */
        function() {
          function BezierCurve2(start, startControl, endControl, end) {
            this.type = 1;
            this.start = start;
            this.startControl = startControl;
            this.endControl = endControl;
            this.end = end;
          }
          BezierCurve2.prototype.subdivide = function(t2, firstHalf) {
            var ab = lerp(this.start, this.startControl, t2);
            var bc = lerp(this.startControl, this.endControl, t2);
            var cd = lerp(this.endControl, this.end, t2);
            var abbc = lerp(ab, bc, t2);
            var bccd = lerp(bc, cd, t2);
            var dest = lerp(abbc, bccd, t2);
            return firstHalf ? new BezierCurve2(this.start, ab, abbc, dest) : new BezierCurve2(dest, bccd, cd, this.end);
          };
          BezierCurve2.prototype.add = function(deltaX, deltaY) {
            return new BezierCurve2(this.start.add(deltaX, deltaY), this.startControl.add(deltaX, deltaY), this.endControl.add(deltaX, deltaY), this.end.add(deltaX, deltaY));
          };
          BezierCurve2.prototype.reverse = function() {
            return new BezierCurve2(this.end, this.endControl, this.startControl, this.start);
          };
          return BezierCurve2;
        }()
      );
      var isBezierCurve = function(path2) {
        return path2.type === 1;
      };
      var BoundCurves = (
        /** @class */
        function() {
          function BoundCurves2(element2) {
            var styles2 = element2.styles;
            var bounds = element2.bounds;
            var _a2 = getAbsoluteValueForTuple(styles2.borderTopLeftRadius, bounds.width, bounds.height), tlh = _a2[0], tlv = _a2[1];
            var _b2 = getAbsoluteValueForTuple(styles2.borderTopRightRadius, bounds.width, bounds.height), trh = _b2[0], trv = _b2[1];
            var _c = getAbsoluteValueForTuple(styles2.borderBottomRightRadius, bounds.width, bounds.height), brh = _c[0], brv = _c[1];
            var _d = getAbsoluteValueForTuple(styles2.borderBottomLeftRadius, bounds.width, bounds.height), blh = _d[0], blv = _d[1];
            var factors = [];
            factors.push((tlh + trh) / bounds.width);
            factors.push((blh + brh) / bounds.width);
            factors.push((tlv + blv) / bounds.height);
            factors.push((trv + brv) / bounds.height);
            var maxFactor = Math.max.apply(Math, factors);
            if (maxFactor > 1) {
              tlh /= maxFactor;
              tlv /= maxFactor;
              trh /= maxFactor;
              trv /= maxFactor;
              brh /= maxFactor;
              brv /= maxFactor;
              blh /= maxFactor;
              blv /= maxFactor;
            }
            var topWidth = bounds.width - trh;
            var rightHeight = bounds.height - brv;
            var bottomWidth = bounds.width - brh;
            var leftHeight = bounds.height - blv;
            var borderTopWidth2 = styles2.borderTopWidth;
            var borderRightWidth2 = styles2.borderRightWidth;
            var borderBottomWidth2 = styles2.borderBottomWidth;
            var borderLeftWidth2 = styles2.borderLeftWidth;
            var paddingTop2 = getAbsoluteValue(styles2.paddingTop, element2.bounds.width);
            var paddingRight2 = getAbsoluteValue(styles2.paddingRight, element2.bounds.width);
            var paddingBottom2 = getAbsoluteValue(styles2.paddingBottom, element2.bounds.width);
            var paddingLeft2 = getAbsoluteValue(styles2.paddingLeft, element2.bounds.width);
            this.topLeftBorderDoubleOuterBox = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 / 3, bounds.top + borderTopWidth2 / 3, tlh - borderLeftWidth2 / 3, tlv - borderTopWidth2 / 3, CORNER.TOP_LEFT) : new Vector(bounds.left + borderLeftWidth2 / 3, bounds.top + borderTopWidth2 / 3);
            this.topRightBorderDoubleOuterBox = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + topWidth, bounds.top + borderTopWidth2 / 3, trh - borderRightWidth2 / 3, trv - borderTopWidth2 / 3, CORNER.TOP_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2 / 3, bounds.top + borderTopWidth2 / 3);
            this.bottomRightBorderDoubleOuterBox = brh > 0 || brv > 0 ? getCurvePoints(bounds.left + bottomWidth, bounds.top + rightHeight, brh - borderRightWidth2 / 3, brv - borderBottomWidth2 / 3, CORNER.BOTTOM_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2 / 3, bounds.top + bounds.height - borderBottomWidth2 / 3);
            this.bottomLeftBorderDoubleOuterBox = blh > 0 || blv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 / 3, bounds.top + leftHeight, blh - borderLeftWidth2 / 3, blv - borderBottomWidth2 / 3, CORNER.BOTTOM_LEFT) : new Vector(bounds.left + borderLeftWidth2 / 3, bounds.top + bounds.height - borderBottomWidth2 / 3);
            this.topLeftBorderDoubleInnerBox = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 * 2 / 3, bounds.top + borderTopWidth2 * 2 / 3, tlh - borderLeftWidth2 * 2 / 3, tlv - borderTopWidth2 * 2 / 3, CORNER.TOP_LEFT) : new Vector(bounds.left + borderLeftWidth2 * 2 / 3, bounds.top + borderTopWidth2 * 2 / 3);
            this.topRightBorderDoubleInnerBox = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + topWidth, bounds.top + borderTopWidth2 * 2 / 3, trh - borderRightWidth2 * 2 / 3, trv - borderTopWidth2 * 2 / 3, CORNER.TOP_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2 * 2 / 3, bounds.top + borderTopWidth2 * 2 / 3);
            this.bottomRightBorderDoubleInnerBox = brh > 0 || brv > 0 ? getCurvePoints(bounds.left + bottomWidth, bounds.top + rightHeight, brh - borderRightWidth2 * 2 / 3, brv - borderBottomWidth2 * 2 / 3, CORNER.BOTTOM_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2 * 2 / 3, bounds.top + bounds.height - borderBottomWidth2 * 2 / 3);
            this.bottomLeftBorderDoubleInnerBox = blh > 0 || blv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 * 2 / 3, bounds.top + leftHeight, blh - borderLeftWidth2 * 2 / 3, blv - borderBottomWidth2 * 2 / 3, CORNER.BOTTOM_LEFT) : new Vector(bounds.left + borderLeftWidth2 * 2 / 3, bounds.top + bounds.height - borderBottomWidth2 * 2 / 3);
            this.topLeftBorderStroke = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 / 2, bounds.top + borderTopWidth2 / 2, tlh - borderLeftWidth2 / 2, tlv - borderTopWidth2 / 2, CORNER.TOP_LEFT) : new Vector(bounds.left + borderLeftWidth2 / 2, bounds.top + borderTopWidth2 / 2);
            this.topRightBorderStroke = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + topWidth, bounds.top + borderTopWidth2 / 2, trh - borderRightWidth2 / 2, trv - borderTopWidth2 / 2, CORNER.TOP_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2 / 2, bounds.top + borderTopWidth2 / 2);
            this.bottomRightBorderStroke = brh > 0 || brv > 0 ? getCurvePoints(bounds.left + bottomWidth, bounds.top + rightHeight, brh - borderRightWidth2 / 2, brv - borderBottomWidth2 / 2, CORNER.BOTTOM_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2 / 2, bounds.top + bounds.height - borderBottomWidth2 / 2);
            this.bottomLeftBorderStroke = blh > 0 || blv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 / 2, bounds.top + leftHeight, blh - borderLeftWidth2 / 2, blv - borderBottomWidth2 / 2, CORNER.BOTTOM_LEFT) : new Vector(bounds.left + borderLeftWidth2 / 2, bounds.top + bounds.height - borderBottomWidth2 / 2);
            this.topLeftBorderBox = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left, bounds.top, tlh, tlv, CORNER.TOP_LEFT) : new Vector(bounds.left, bounds.top);
            this.topRightBorderBox = trh > 0 || trv > 0 ? getCurvePoints(bounds.left + topWidth, bounds.top, trh, trv, CORNER.TOP_RIGHT) : new Vector(bounds.left + bounds.width, bounds.top);
            this.bottomRightBorderBox = brh > 0 || brv > 0 ? getCurvePoints(bounds.left + bottomWidth, bounds.top + rightHeight, brh, brv, CORNER.BOTTOM_RIGHT) : new Vector(bounds.left + bounds.width, bounds.top + bounds.height);
            this.bottomLeftBorderBox = blh > 0 || blv > 0 ? getCurvePoints(bounds.left, bounds.top + leftHeight, blh, blv, CORNER.BOTTOM_LEFT) : new Vector(bounds.left, bounds.top + bounds.height);
            this.topLeftPaddingBox = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2, bounds.top + borderTopWidth2, Math.max(0, tlh - borderLeftWidth2), Math.max(0, tlv - borderTopWidth2), CORNER.TOP_LEFT) : new Vector(bounds.left + borderLeftWidth2, bounds.top + borderTopWidth2);
            this.topRightPaddingBox = trh > 0 || trv > 0 ? getCurvePoints(bounds.left + Math.min(topWidth, bounds.width - borderRightWidth2), bounds.top + borderTopWidth2, topWidth > bounds.width + borderRightWidth2 ? 0 : Math.max(0, trh - borderRightWidth2), Math.max(0, trv - borderTopWidth2), CORNER.TOP_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2, bounds.top + borderTopWidth2);
            this.bottomRightPaddingBox = brh > 0 || brv > 0 ? getCurvePoints(bounds.left + Math.min(bottomWidth, bounds.width - borderLeftWidth2), bounds.top + Math.min(rightHeight, bounds.height - borderBottomWidth2), Math.max(0, brh - borderRightWidth2), Math.max(0, brv - borderBottomWidth2), CORNER.BOTTOM_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2, bounds.top + bounds.height - borderBottomWidth2);
            this.bottomLeftPaddingBox = blh > 0 || blv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2, bounds.top + Math.min(leftHeight, bounds.height - borderBottomWidth2), Math.max(0, blh - borderLeftWidth2), Math.max(0, blv - borderBottomWidth2), CORNER.BOTTOM_LEFT) : new Vector(bounds.left + borderLeftWidth2, bounds.top + bounds.height - borderBottomWidth2);
            this.topLeftContentBox = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 + paddingLeft2, bounds.top + borderTopWidth2 + paddingTop2, Math.max(0, tlh - (borderLeftWidth2 + paddingLeft2)), Math.max(0, tlv - (borderTopWidth2 + paddingTop2)), CORNER.TOP_LEFT) : new Vector(bounds.left + borderLeftWidth2 + paddingLeft2, bounds.top + borderTopWidth2 + paddingTop2);
            this.topRightContentBox = trh > 0 || trv > 0 ? getCurvePoints(bounds.left + Math.min(topWidth, bounds.width + borderLeftWidth2 + paddingLeft2), bounds.top + borderTopWidth2 + paddingTop2, topWidth > bounds.width + borderLeftWidth2 + paddingLeft2 ? 0 : trh - borderLeftWidth2 + paddingLeft2, trv - (borderTopWidth2 + paddingTop2), CORNER.TOP_RIGHT) : new Vector(bounds.left + bounds.width - (borderRightWidth2 + paddingRight2), bounds.top + borderTopWidth2 + paddingTop2);
            this.bottomRightContentBox = brh > 0 || brv > 0 ? getCurvePoints(bounds.left + Math.min(bottomWidth, bounds.width - (borderLeftWidth2 + paddingLeft2)), bounds.top + Math.min(rightHeight, bounds.height + borderTopWidth2 + paddingTop2), Math.max(0, brh - (borderRightWidth2 + paddingRight2)), brv - (borderBottomWidth2 + paddingBottom2), CORNER.BOTTOM_RIGHT) : new Vector(bounds.left + bounds.width - (borderRightWidth2 + paddingRight2), bounds.top + bounds.height - (borderBottomWidth2 + paddingBottom2));
            this.bottomLeftContentBox = blh > 0 || blv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 + paddingLeft2, bounds.top + leftHeight, Math.max(0, blh - (borderLeftWidth2 + paddingLeft2)), blv - (borderBottomWidth2 + paddingBottom2), CORNER.BOTTOM_LEFT) : new Vector(bounds.left + borderLeftWidth2 + paddingLeft2, bounds.top + bounds.height - (borderBottomWidth2 + paddingBottom2));
          }
          return BoundCurves2;
        }()
      );
      var CORNER;
      (function(CORNER2) {
        CORNER2[CORNER2["TOP_LEFT"] = 0] = "TOP_LEFT";
        CORNER2[CORNER2["TOP_RIGHT"] = 1] = "TOP_RIGHT";
        CORNER2[CORNER2["BOTTOM_RIGHT"] = 2] = "BOTTOM_RIGHT";
        CORNER2[CORNER2["BOTTOM_LEFT"] = 3] = "BOTTOM_LEFT";
      })(CORNER || (CORNER = {}));
      var getCurvePoints = function(x2, y3, r1, r2, position4) {
        var kappa = 4 * ((Math.sqrt(2) - 1) / 3);
        var ox = r1 * kappa;
        var oy = r2 * kappa;
        var xm = x2 + r1;
        var ym = y3 + r2;
        switch (position4) {
          case CORNER.TOP_LEFT:
            return new BezierCurve(new Vector(x2, ym), new Vector(x2, ym - oy), new Vector(xm - ox, y3), new Vector(xm, y3));
          case CORNER.TOP_RIGHT:
            return new BezierCurve(new Vector(x2, y3), new Vector(x2 + ox, y3), new Vector(xm, ym - oy), new Vector(xm, ym));
          case CORNER.BOTTOM_RIGHT:
            return new BezierCurve(new Vector(xm, y3), new Vector(xm, y3 + oy), new Vector(x2 + ox, ym), new Vector(x2, ym));
          case CORNER.BOTTOM_LEFT:
          default:
            return new BezierCurve(new Vector(xm, ym), new Vector(xm - ox, ym), new Vector(x2, y3 + oy), new Vector(x2, y3));
        }
      };
      var calculateBorderBoxPath = function(curves) {
        return [curves.topLeftBorderBox, curves.topRightBorderBox, curves.bottomRightBorderBox, curves.bottomLeftBorderBox];
      };
      var calculateContentBoxPath = function(curves) {
        return [
          curves.topLeftContentBox,
          curves.topRightContentBox,
          curves.bottomRightContentBox,
          curves.bottomLeftContentBox
        ];
      };
      var calculatePaddingBoxPath = function(curves) {
        return [
          curves.topLeftPaddingBox,
          curves.topRightPaddingBox,
          curves.bottomRightPaddingBox,
          curves.bottomLeftPaddingBox
        ];
      };
      var TransformEffect = (
        /** @class */
        function() {
          function TransformEffect2(offsetX, offsetY, matrix2) {
            this.offsetX = offsetX;
            this.offsetY = offsetY;
            this.matrix = matrix2;
            this.type = 0;
            this.target = 2 | 4;
          }
          return TransformEffect2;
        }()
      );
      var ClipEffect = (
        /** @class */
        function() {
          function ClipEffect2(path2, target) {
            this.path = path2;
            this.target = target;
            this.type = 1;
          }
          return ClipEffect2;
        }()
      );
      var OpacityEffect = (
        /** @class */
        function() {
          function OpacityEffect2(opacity2) {
            this.opacity = opacity2;
            this.type = 2;
            this.target = 2 | 4;
          }
          return OpacityEffect2;
        }()
      );
      var isTransformEffect = function(effect) {
        return effect.type === 0;
      };
      var isClipEffect = function(effect) {
        return effect.type === 1;
      };
      var isOpacityEffect = function(effect) {
        return effect.type === 2;
      };
      var equalPath = function(a3, b) {
        if (a3.length === b.length) {
          return a3.some(function(v2, i3) {
            return v2 === b[i3];
          });
        }
        return false;
      };
      var transformPath = function(path2, deltaX, deltaY, deltaW, deltaH) {
        return path2.map(function(point4, index3) {
          switch (index3) {
            case 0:
              return point4.add(deltaX, deltaY);
            case 1:
              return point4.add(deltaX + deltaW, deltaY);
            case 2:
              return point4.add(deltaX + deltaW, deltaY + deltaH);
            case 3:
              return point4.add(deltaX, deltaY + deltaH);
          }
          return point4;
        });
      };
      var StackingContext = (
        /** @class */
        function() {
          function StackingContext2(container) {
            this.element = container;
            this.inlineLevel = [];
            this.nonInlineLevel = [];
            this.negativeZIndex = [];
            this.zeroOrAutoZIndexOrTransformedOrOpacity = [];
            this.positiveZIndex = [];
            this.nonPositionedFloats = [];
            this.nonPositionedInlineLevel = [];
          }
          return StackingContext2;
        }()
      );
      var ElementPaint = (
        /** @class */
        function() {
          function ElementPaint2(container, parent) {
            this.container = container;
            this.parent = parent;
            this.effects = [];
            this.curves = new BoundCurves(this.container);
            if (this.container.styles.opacity < 1) {
              this.effects.push(new OpacityEffect(this.container.styles.opacity));
            }
            if (this.container.styles.transform !== null) {
              var offsetX = this.container.bounds.left + this.container.styles.transformOrigin[0].number;
              var offsetY = this.container.bounds.top + this.container.styles.transformOrigin[1].number;
              var matrix2 = this.container.styles.transform;
              this.effects.push(new TransformEffect(offsetX, offsetY, matrix2));
            }
            if (this.container.styles.overflowX !== 0) {
              var borderBox = calculateBorderBoxPath(this.curves);
              var paddingBox2 = calculatePaddingBoxPath(this.curves);
              if (equalPath(borderBox, paddingBox2)) {
                this.effects.push(new ClipEffect(
                  borderBox,
                  2 | 4
                  /* CONTENT */
                ));
              } else {
                this.effects.push(new ClipEffect(
                  borderBox,
                  2
                  /* BACKGROUND_BORDERS */
                ));
                this.effects.push(new ClipEffect(
                  paddingBox2,
                  4
                  /* CONTENT */
                ));
              }
            }
          }
          ElementPaint2.prototype.getEffects = function(target) {
            var inFlow = [
              2,
              3
              /* FIXED */
            ].indexOf(this.container.styles.position) === -1;
            var parent = this.parent;
            var effects = this.effects.slice(0);
            while (parent) {
              var croplessEffects = parent.effects.filter(function(effect) {
                return !isClipEffect(effect);
              });
              if (inFlow || parent.container.styles.position !== 0 || !parent.parent) {
                effects.unshift.apply(effects, croplessEffects);
                inFlow = [
                  2,
                  3
                  /* FIXED */
                ].indexOf(parent.container.styles.position) === -1;
                if (parent.container.styles.overflowX !== 0) {
                  var borderBox = calculateBorderBoxPath(parent.curves);
                  var paddingBox2 = calculatePaddingBoxPath(parent.curves);
                  if (!equalPath(borderBox, paddingBox2)) {
                    effects.unshift(new ClipEffect(
                      paddingBox2,
                      2 | 4
                      /* CONTENT */
                    ));
                  }
                }
              } else {
                effects.unshift.apply(effects, croplessEffects);
              }
              parent = parent.parent;
            }
            return effects.filter(function(effect) {
              return contains3(effect.target, target);
            });
          };
          return ElementPaint2;
        }()
      );
      var parseStackTree = function(parent, stackingContext, realStackingContext, listItems) {
        parent.container.elements.forEach(function(child) {
          var treatAsRealStackingContext = contains3(
            child.flags,
            4
            /* CREATES_REAL_STACKING_CONTEXT */
          );
          var createsStackingContext2 = contains3(
            child.flags,
            2
            /* CREATES_STACKING_CONTEXT */
          );
          var paintContainer = new ElementPaint(child, parent);
          if (contains3(
            child.styles.display,
            2048
            /* LIST_ITEM */
          )) {
            listItems.push(paintContainer);
          }
          var listOwnerItems = contains3(
            child.flags,
            8
            /* IS_LIST_OWNER */
          ) ? [] : listItems;
          if (treatAsRealStackingContext || createsStackingContext2) {
            var parentStack = treatAsRealStackingContext || child.styles.isPositioned() ? realStackingContext : stackingContext;
            var stack = new StackingContext(paintContainer);
            if (child.styles.isPositioned() || child.styles.opacity < 1 || child.styles.isTransformed()) {
              var order_1 = child.styles.zIndex.order;
              if (order_1 < 0) {
                var index_1 = 0;
                parentStack.negativeZIndex.some(function(current, i3) {
                  if (order_1 > current.element.container.styles.zIndex.order) {
                    index_1 = i3;
                    return false;
                  } else if (index_1 > 0) {
                    return true;
                  }
                  return false;
                });
                parentStack.negativeZIndex.splice(index_1, 0, stack);
              } else if (order_1 > 0) {
                var index_2 = 0;
                parentStack.positiveZIndex.some(function(current, i3) {
                  if (order_1 >= current.element.container.styles.zIndex.order) {
                    index_2 = i3 + 1;
                    return false;
                  } else if (index_2 > 0) {
                    return true;
                  }
                  return false;
                });
                parentStack.positiveZIndex.splice(index_2, 0, stack);
              } else {
                parentStack.zeroOrAutoZIndexOrTransformedOrOpacity.push(stack);
              }
            } else {
              if (child.styles.isFloating()) {
                parentStack.nonPositionedFloats.push(stack);
              } else {
                parentStack.nonPositionedInlineLevel.push(stack);
              }
            }
            parseStackTree(paintContainer, stack, treatAsRealStackingContext ? stack : realStackingContext, listOwnerItems);
          } else {
            if (child.styles.isInlineLevel()) {
              stackingContext.inlineLevel.push(paintContainer);
            } else {
              stackingContext.nonInlineLevel.push(paintContainer);
            }
            parseStackTree(paintContainer, stackingContext, realStackingContext, listOwnerItems);
          }
          if (contains3(
            child.flags,
            8
            /* IS_LIST_OWNER */
          )) {
            processListItems(child, listOwnerItems);
          }
        });
      };
      var processListItems = function(owner, elements3) {
        var numbering = owner instanceof OLElementContainer ? owner.start : 1;
        var reversed = owner instanceof OLElementContainer ? owner.reversed : false;
        for (var i3 = 0; i3 < elements3.length; i3++) {
          var item = elements3[i3];
          if (item.container instanceof LIElementContainer && typeof item.container.value === "number" && item.container.value !== 0) {
            numbering = item.container.value;
          }
          item.listValue = createCounterText(numbering, item.container.styles.listStyleType, true);
          numbering += reversed ? -1 : 1;
        }
      };
      var parseStackingContexts = function(container) {
        var paintContainer = new ElementPaint(container, null);
        var root2 = new StackingContext(paintContainer);
        var listItems = [];
        parseStackTree(paintContainer, root2, root2, listItems);
        processListItems(paintContainer.container, listItems);
        return root2;
      };
      var parsePathForBorder = function(curves, borderSide) {
        switch (borderSide) {
          case 0:
            return createPathFromCurves(curves.topLeftBorderBox, curves.topLeftPaddingBox, curves.topRightBorderBox, curves.topRightPaddingBox);
          case 1:
            return createPathFromCurves(curves.topRightBorderBox, curves.topRightPaddingBox, curves.bottomRightBorderBox, curves.bottomRightPaddingBox);
          case 2:
            return createPathFromCurves(curves.bottomRightBorderBox, curves.bottomRightPaddingBox, curves.bottomLeftBorderBox, curves.bottomLeftPaddingBox);
          case 3:
          default:
            return createPathFromCurves(curves.bottomLeftBorderBox, curves.bottomLeftPaddingBox, curves.topLeftBorderBox, curves.topLeftPaddingBox);
        }
      };
      var parsePathForBorderDoubleOuter = function(curves, borderSide) {
        switch (borderSide) {
          case 0:
            return createPathFromCurves(curves.topLeftBorderBox, curves.topLeftBorderDoubleOuterBox, curves.topRightBorderBox, curves.topRightBorderDoubleOuterBox);
          case 1:
            return createPathFromCurves(curves.topRightBorderBox, curves.topRightBorderDoubleOuterBox, curves.bottomRightBorderBox, curves.bottomRightBorderDoubleOuterBox);
          case 2:
            return createPathFromCurves(curves.bottomRightBorderBox, curves.bottomRightBorderDoubleOuterBox, curves.bottomLeftBorderBox, curves.bottomLeftBorderDoubleOuterBox);
          case 3:
          default:
            return createPathFromCurves(curves.bottomLeftBorderBox, curves.bottomLeftBorderDoubleOuterBox, curves.topLeftBorderBox, curves.topLeftBorderDoubleOuterBox);
        }
      };
      var parsePathForBorderDoubleInner = function(curves, borderSide) {
        switch (borderSide) {
          case 0:
            return createPathFromCurves(curves.topLeftBorderDoubleInnerBox, curves.topLeftPaddingBox, curves.topRightBorderDoubleInnerBox, curves.topRightPaddingBox);
          case 1:
            return createPathFromCurves(curves.topRightBorderDoubleInnerBox, curves.topRightPaddingBox, curves.bottomRightBorderDoubleInnerBox, curves.bottomRightPaddingBox);
          case 2:
            return createPathFromCurves(curves.bottomRightBorderDoubleInnerBox, curves.bottomRightPaddingBox, curves.bottomLeftBorderDoubleInnerBox, curves.bottomLeftPaddingBox);
          case 3:
          default:
            return createPathFromCurves(curves.bottomLeftBorderDoubleInnerBox, curves.bottomLeftPaddingBox, curves.topLeftBorderDoubleInnerBox, curves.topLeftPaddingBox);
        }
      };
      var parsePathForBorderStroke = function(curves, borderSide) {
        switch (borderSide) {
          case 0:
            return createStrokePathFromCurves(curves.topLeftBorderStroke, curves.topRightBorderStroke);
          case 1:
            return createStrokePathFromCurves(curves.topRightBorderStroke, curves.bottomRightBorderStroke);
          case 2:
            return createStrokePathFromCurves(curves.bottomRightBorderStroke, curves.bottomLeftBorderStroke);
          case 3:
          default:
            return createStrokePathFromCurves(curves.bottomLeftBorderStroke, curves.topLeftBorderStroke);
        }
      };
      var createStrokePathFromCurves = function(outer1, outer2) {
        var path2 = [];
        if (isBezierCurve(outer1)) {
          path2.push(outer1.subdivide(0.5, false));
        } else {
          path2.push(outer1);
        }
        if (isBezierCurve(outer2)) {
          path2.push(outer2.subdivide(0.5, true));
        } else {
          path2.push(outer2);
        }
        return path2;
      };
      var createPathFromCurves = function(outer1, inner1, outer2, inner2) {
        var path2 = [];
        if (isBezierCurve(outer1)) {
          path2.push(outer1.subdivide(0.5, false));
        } else {
          path2.push(outer1);
        }
        if (isBezierCurve(outer2)) {
          path2.push(outer2.subdivide(0.5, true));
        } else {
          path2.push(outer2);
        }
        if (isBezierCurve(inner2)) {
          path2.push(inner2.subdivide(0.5, true).reverse());
        } else {
          path2.push(inner2);
        }
        if (isBezierCurve(inner1)) {
          path2.push(inner1.subdivide(0.5, false).reverse());
        } else {
          path2.push(inner1);
        }
        return path2;
      };
      var paddingBox = function(element2) {
        var bounds = element2.bounds;
        var styles2 = element2.styles;
        return bounds.add(styles2.borderLeftWidth, styles2.borderTopWidth, -(styles2.borderRightWidth + styles2.borderLeftWidth), -(styles2.borderTopWidth + styles2.borderBottomWidth));
      };
      var contentBox = function(element2) {
        var styles2 = element2.styles;
        var bounds = element2.bounds;
        var paddingLeft2 = getAbsoluteValue(styles2.paddingLeft, bounds.width);
        var paddingRight2 = getAbsoluteValue(styles2.paddingRight, bounds.width);
        var paddingTop2 = getAbsoluteValue(styles2.paddingTop, bounds.width);
        var paddingBottom2 = getAbsoluteValue(styles2.paddingBottom, bounds.width);
        return bounds.add(paddingLeft2 + styles2.borderLeftWidth, paddingTop2 + styles2.borderTopWidth, -(styles2.borderRightWidth + styles2.borderLeftWidth + paddingLeft2 + paddingRight2), -(styles2.borderTopWidth + styles2.borderBottomWidth + paddingTop2 + paddingBottom2));
      };
      var calculateBackgroundPositioningArea = function(backgroundOrigin2, element2) {
        if (backgroundOrigin2 === 0) {
          return element2.bounds;
        }
        if (backgroundOrigin2 === 2) {
          return contentBox(element2);
        }
        return paddingBox(element2);
      };
      var calculateBackgroundPaintingArea = function(backgroundClip2, element2) {
        if (backgroundClip2 === 0) {
          return element2.bounds;
        }
        if (backgroundClip2 === 2) {
          return contentBox(element2);
        }
        return paddingBox(element2);
      };
      var calculateBackgroundRendering = function(container, index3, intrinsicSize) {
        var backgroundPositioningArea = calculateBackgroundPositioningArea(getBackgroundValueForIndex(container.styles.backgroundOrigin, index3), container);
        var backgroundPaintingArea = calculateBackgroundPaintingArea(getBackgroundValueForIndex(container.styles.backgroundClip, index3), container);
        var backgroundImageSize = calculateBackgroundSize(getBackgroundValueForIndex(container.styles.backgroundSize, index3), intrinsicSize, backgroundPositioningArea);
        var sizeWidth = backgroundImageSize[0], sizeHeight = backgroundImageSize[1];
        var position4 = getAbsoluteValueForTuple(getBackgroundValueForIndex(container.styles.backgroundPosition, index3), backgroundPositioningArea.width - sizeWidth, backgroundPositioningArea.height - sizeHeight);
        var path2 = calculateBackgroundRepeatPath(getBackgroundValueForIndex(container.styles.backgroundRepeat, index3), position4, backgroundImageSize, backgroundPositioningArea, backgroundPaintingArea);
        var offsetX = Math.round(backgroundPositioningArea.left + position4[0]);
        var offsetY = Math.round(backgroundPositioningArea.top + position4[1]);
        return [path2, offsetX, offsetY, sizeWidth, sizeHeight];
      };
      var isAuto = function(token) {
        return isIdentToken(token) && token.value === BACKGROUND_SIZE.AUTO;
      };
      var hasIntrinsicValue = function(value) {
        return typeof value === "number";
      };
      var calculateBackgroundSize = function(size2, _a2, bounds) {
        var intrinsicWidth = _a2[0], intrinsicHeight = _a2[1], intrinsicProportion = _a2[2];
        var first = size2[0], second = size2[1];
        if (!first) {
          return [0, 0];
        }
        if (isLengthPercentage(first) && second && isLengthPercentage(second)) {
          return [getAbsoluteValue(first, bounds.width), getAbsoluteValue(second, bounds.height)];
        }
        var hasIntrinsicProportion = hasIntrinsicValue(intrinsicProportion);
        if (isIdentToken(first) && (first.value === BACKGROUND_SIZE.CONTAIN || first.value === BACKGROUND_SIZE.COVER)) {
          if (hasIntrinsicValue(intrinsicProportion)) {
            var targetRatio = bounds.width / bounds.height;
            return targetRatio < intrinsicProportion !== (first.value === BACKGROUND_SIZE.COVER) ? [bounds.width, bounds.width / intrinsicProportion] : [bounds.height * intrinsicProportion, bounds.height];
          }
          return [bounds.width, bounds.height];
        }
        var hasIntrinsicWidth = hasIntrinsicValue(intrinsicWidth);
        var hasIntrinsicHeight = hasIntrinsicValue(intrinsicHeight);
        var hasIntrinsicDimensions = hasIntrinsicWidth || hasIntrinsicHeight;
        if (isAuto(first) && (!second || isAuto(second))) {
          if (hasIntrinsicWidth && hasIntrinsicHeight) {
            return [intrinsicWidth, intrinsicHeight];
          }
          if (!hasIntrinsicProportion && !hasIntrinsicDimensions) {
            return [bounds.width, bounds.height];
          }
          if (hasIntrinsicDimensions && hasIntrinsicProportion) {
            var width_1 = hasIntrinsicWidth ? intrinsicWidth : intrinsicHeight * intrinsicProportion;
            var height_1 = hasIntrinsicHeight ? intrinsicHeight : intrinsicWidth / intrinsicProportion;
            return [width_1, height_1];
          }
          var width_2 = hasIntrinsicWidth ? intrinsicWidth : bounds.width;
          var height_2 = hasIntrinsicHeight ? intrinsicHeight : bounds.height;
          return [width_2, height_2];
        }
        if (hasIntrinsicProportion) {
          var width_3 = 0;
          var height_3 = 0;
          if (isLengthPercentage(first)) {
            width_3 = getAbsoluteValue(first, bounds.width);
          } else if (isLengthPercentage(second)) {
            height_3 = getAbsoluteValue(second, bounds.height);
          }
          if (isAuto(first)) {
            width_3 = height_3 * intrinsicProportion;
          } else if (!second || isAuto(second)) {
            height_3 = width_3 / intrinsicProportion;
          }
          return [width_3, height_3];
        }
        var width2 = null;
        var height2 = null;
        if (isLengthPercentage(first)) {
          width2 = getAbsoluteValue(first, bounds.width);
        } else if (second && isLengthPercentage(second)) {
          height2 = getAbsoluteValue(second, bounds.height);
        }
        if (width2 !== null && (!second || isAuto(second))) {
          height2 = hasIntrinsicWidth && hasIntrinsicHeight ? width2 / intrinsicWidth * intrinsicHeight : bounds.height;
        }
        if (height2 !== null && isAuto(first)) {
          width2 = hasIntrinsicWidth && hasIntrinsicHeight ? height2 / intrinsicHeight * intrinsicWidth : bounds.width;
        }
        if (width2 !== null && height2 !== null) {
          return [width2, height2];
        }
        throw new Error("Unable to calculate background-size for element");
      };
      var getBackgroundValueForIndex = function(values, index3) {
        var value = values[index3];
        if (typeof value === "undefined") {
          return values[0];
        }
        return value;
      };
      var calculateBackgroundRepeatPath = function(repeat2, _a2, _b2, backgroundPositioningArea, backgroundPaintingArea) {
        var x2 = _a2[0], y3 = _a2[1];
        var width2 = _b2[0], height2 = _b2[1];
        switch (repeat2) {
          case 2:
            return [
              new Vector(Math.round(backgroundPositioningArea.left), Math.round(backgroundPositioningArea.top + y3)),
              new Vector(Math.round(backgroundPositioningArea.left + backgroundPositioningArea.width), Math.round(backgroundPositioningArea.top + y3)),
              new Vector(Math.round(backgroundPositioningArea.left + backgroundPositioningArea.width), Math.round(height2 + backgroundPositioningArea.top + y3)),
              new Vector(Math.round(backgroundPositioningArea.left), Math.round(height2 + backgroundPositioningArea.top + y3))
            ];
          case 3:
            return [
              new Vector(Math.round(backgroundPositioningArea.left + x2), Math.round(backgroundPositioningArea.top)),
              new Vector(Math.round(backgroundPositioningArea.left + x2 + width2), Math.round(backgroundPositioningArea.top)),
              new Vector(Math.round(backgroundPositioningArea.left + x2 + width2), Math.round(backgroundPositioningArea.height + backgroundPositioningArea.top)),
              new Vector(Math.round(backgroundPositioningArea.left + x2), Math.round(backgroundPositioningArea.height + backgroundPositioningArea.top))
            ];
          case 1:
            return [
              new Vector(Math.round(backgroundPositioningArea.left + x2), Math.round(backgroundPositioningArea.top + y3)),
              new Vector(Math.round(backgroundPositioningArea.left + x2 + width2), Math.round(backgroundPositioningArea.top + y3)),
              new Vector(Math.round(backgroundPositioningArea.left + x2 + width2), Math.round(backgroundPositioningArea.top + y3 + height2)),
              new Vector(Math.round(backgroundPositioningArea.left + x2), Math.round(backgroundPositioningArea.top + y3 + height2))
            ];
          default:
            return [
              new Vector(Math.round(backgroundPaintingArea.left), Math.round(backgroundPaintingArea.top)),
              new Vector(Math.round(backgroundPaintingArea.left + backgroundPaintingArea.width), Math.round(backgroundPaintingArea.top)),
              new Vector(Math.round(backgroundPaintingArea.left + backgroundPaintingArea.width), Math.round(backgroundPaintingArea.height + backgroundPaintingArea.top)),
              new Vector(Math.round(backgroundPaintingArea.left), Math.round(backgroundPaintingArea.height + backgroundPaintingArea.top))
            ];
        }
      };
      var SMALL_IMAGE = "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7";
      var SAMPLE_TEXT = "Hidden Text";
      var FontMetrics = (
        /** @class */
        function() {
          function FontMetrics2(document4) {
            this._data = {};
            this._document = document4;
          }
          FontMetrics2.prototype.parseMetrics = function(fontFamily2, fontSize2) {
            var container = this._document.createElement("div");
            var img = this._document.createElement("img");
            var span = this._document.createElement("span");
            var body = this._document.body;
            container.style.visibility = "hidden";
            container.style.fontFamily = fontFamily2;
            container.style.fontSize = fontSize2;
            container.style.margin = "0";
            container.style.padding = "0";
            container.style.whiteSpace = "nowrap";
            body.appendChild(container);
            img.src = SMALL_IMAGE;
            img.width = 1;
            img.height = 1;
            img.style.margin = "0";
            img.style.padding = "0";
            img.style.verticalAlign = "baseline";
            span.style.fontFamily = fontFamily2;
            span.style.fontSize = fontSize2;
            span.style.margin = "0";
            span.style.padding = "0";
            span.appendChild(this._document.createTextNode(SAMPLE_TEXT));
            container.appendChild(span);
            container.appendChild(img);
            var baseline = img.offsetTop - span.offsetTop + 2;
            container.removeChild(span);
            container.appendChild(this._document.createTextNode(SAMPLE_TEXT));
            container.style.lineHeight = "normal";
            img.style.verticalAlign = "super";
            var middle = img.offsetTop - container.offsetTop + 2;
            body.removeChild(container);
            return { baseline, middle };
          };
          FontMetrics2.prototype.getMetrics = function(fontFamily2, fontSize2) {
            var key = fontFamily2 + " " + fontSize2;
            if (typeof this._data[key] === "undefined") {
              this._data[key] = this.parseMetrics(fontFamily2, fontSize2);
            }
            return this._data[key];
          };
          return FontMetrics2;
        }()
      );
      var Renderer = (
        /** @class */
        function() {
          function Renderer2(context, options) {
            this.context = context;
            this.options = options;
          }
          return Renderer2;
        }()
      );
      var MASK_OFFSET = 1e4;
      var CanvasRenderer = (
        /** @class */
        function(_super) {
          __extends3(CanvasRenderer2, _super);
          function CanvasRenderer2(context, options) {
            var _this = _super.call(this, context, options) || this;
            _this._activeEffects = [];
            _this.canvas = options.canvas ? options.canvas : document.createElement("canvas");
            _this.ctx = _this.canvas.getContext("2d");
            if (!options.canvas) {
              _this.canvas.width = Math.floor(options.width * options.scale);
              _this.canvas.height = Math.floor(options.height * options.scale);
              _this.canvas.style.width = options.width + "px";
              _this.canvas.style.height = options.height + "px";
            }
            _this.fontMetrics = new FontMetrics(document);
            _this.ctx.scale(_this.options.scale, _this.options.scale);
            _this.ctx.translate(-options.x, -options.y);
            _this.ctx.textBaseline = "bottom";
            _this._activeEffects = [];
            _this.context.logger.debug("Canvas renderer initialized (" + options.width + "x" + options.height + ") with scale " + options.scale);
            return _this;
          }
          CanvasRenderer2.prototype.applyEffects = function(effects) {
            var _this = this;
            while (this._activeEffects.length) {
              this.popEffect();
            }
            effects.forEach(function(effect) {
              return _this.applyEffect(effect);
            });
          };
          CanvasRenderer2.prototype.applyEffect = function(effect) {
            this.ctx.save();
            if (isOpacityEffect(effect)) {
              this.ctx.globalAlpha = effect.opacity;
            }
            if (isTransformEffect(effect)) {
              this.ctx.translate(effect.offsetX, effect.offsetY);
              this.ctx.transform(effect.matrix[0], effect.matrix[1], effect.matrix[2], effect.matrix[3], effect.matrix[4], effect.matrix[5]);
              this.ctx.translate(-effect.offsetX, -effect.offsetY);
            }
            if (isClipEffect(effect)) {
              this.path(effect.path);
              this.ctx.clip();
            }
            this._activeEffects.push(effect);
          };
          CanvasRenderer2.prototype.popEffect = function() {
            this._activeEffects.pop();
            this.ctx.restore();
          };
          CanvasRenderer2.prototype.renderStack = function(stack) {
            return __awaiter(this, void 0, void 0, function() {
              var styles2;
              return __generator(this, function(_a2) {
                switch (_a2.label) {
                  case 0:
                    styles2 = stack.element.container.styles;
                    if (!styles2.isVisible())
                      return [3, 2];
                    return [4, this.renderStackContent(stack)];
                  case 1:
                    _a2.sent();
                    _a2.label = 2;
                  case 2:
                    return [
                      2
                      /*return*/
                    ];
                }
              });
            });
          };
          CanvasRenderer2.prototype.renderNode = function(paint) {
            return __awaiter(this, void 0, void 0, function() {
              return __generator(this, function(_a2) {
                switch (_a2.label) {
                  case 0:
                    if (contains3(
                      paint.container.flags,
                      16
                      /* DEBUG_RENDER */
                    )) {
                      debugger;
                    }
                    if (!paint.container.styles.isVisible())
                      return [3, 3];
                    return [4, this.renderNodeBackgroundAndBorders(paint)];
                  case 1:
                    _a2.sent();
                    return [4, this.renderNodeContent(paint)];
                  case 2:
                    _a2.sent();
                    _a2.label = 3;
                  case 3:
                    return [
                      2
                      /*return*/
                    ];
                }
              });
            });
          };
          CanvasRenderer2.prototype.renderTextWithLetterSpacing = function(text4, letterSpacing2, baseline) {
            var _this = this;
            if (letterSpacing2 === 0) {
              this.ctx.fillText(text4.text, text4.bounds.left, text4.bounds.top + baseline);
            } else {
              var letters2 = segmentGraphemes(text4.text);
              letters2.reduce(function(left, letter) {
                _this.ctx.fillText(letter, left, text4.bounds.top + baseline);
                return left + _this.ctx.measureText(letter).width;
              }, text4.bounds.left);
            }
          };
          CanvasRenderer2.prototype.createFontStyle = function(styles2) {
            var fontVariant2 = styles2.fontVariant.filter(function(variant) {
              return variant === "normal" || variant === "small-caps";
            }).join("");
            var fontFamily2 = fixIOSSystemFonts(styles2.fontFamily).join(", ");
            var fontSize2 = isDimensionToken(styles2.fontSize) ? "" + styles2.fontSize.number + styles2.fontSize.unit : styles2.fontSize.number + "px";
            return [
              [styles2.fontStyle, fontVariant2, styles2.fontWeight, fontSize2, fontFamily2].join(" "),
              fontFamily2,
              fontSize2
            ];
          };
          CanvasRenderer2.prototype.renderTextNode = function(text4, styles2) {
            return __awaiter(this, void 0, void 0, function() {
              var _a2, font, fontFamily2, fontSize2, _b2, baseline, middle, paintOrder2;
              var _this = this;
              return __generator(this, function(_c) {
                _a2 = this.createFontStyle(styles2), font = _a2[0], fontFamily2 = _a2[1], fontSize2 = _a2[2];
                this.ctx.font = font;
                this.ctx.direction = styles2.direction === 1 ? "rtl" : "ltr";
                this.ctx.textAlign = "left";
                this.ctx.textBaseline = "alphabetic";
                _b2 = this.fontMetrics.getMetrics(fontFamily2, fontSize2), baseline = _b2.baseline, middle = _b2.middle;
                paintOrder2 = styles2.paintOrder;
                text4.textBounds.forEach(function(text5) {
                  paintOrder2.forEach(function(paintOrderLayer) {
                    switch (paintOrderLayer) {
                      case 0:
                        _this.ctx.fillStyle = asString(styles2.color);
                        _this.renderTextWithLetterSpacing(text5, styles2.letterSpacing, baseline);
                        var textShadows = styles2.textShadow;
                        if (textShadows.length && text5.text.trim().length) {
                          textShadows.slice(0).reverse().forEach(function(textShadow2) {
                            _this.ctx.shadowColor = asString(textShadow2.color);
                            _this.ctx.shadowOffsetX = textShadow2.offsetX.number * _this.options.scale;
                            _this.ctx.shadowOffsetY = textShadow2.offsetY.number * _this.options.scale;
                            _this.ctx.shadowBlur = textShadow2.blur.number;
                            _this.renderTextWithLetterSpacing(text5, styles2.letterSpacing, baseline);
                          });
                          _this.ctx.shadowColor = "";
                          _this.ctx.shadowOffsetX = 0;
                          _this.ctx.shadowOffsetY = 0;
                          _this.ctx.shadowBlur = 0;
                        }
                        if (styles2.textDecorationLine.length) {
                          _this.ctx.fillStyle = asString(styles2.textDecorationColor || styles2.color);
                          styles2.textDecorationLine.forEach(function(textDecorationLine2) {
                            switch (textDecorationLine2) {
                              case 1:
                                _this.ctx.fillRect(text5.bounds.left, Math.round(text5.bounds.top + baseline), text5.bounds.width, 1);
                                break;
                              case 2:
                                _this.ctx.fillRect(text5.bounds.left, Math.round(text5.bounds.top), text5.bounds.width, 1);
                                break;
                              case 3:
                                _this.ctx.fillRect(text5.bounds.left, Math.ceil(text5.bounds.top + middle), text5.bounds.width, 1);
                                break;
                            }
                          });
                        }
                        break;
                      case 1:
                        if (styles2.webkitTextStrokeWidth && text5.text.trim().length) {
                          _this.ctx.strokeStyle = asString(styles2.webkitTextStrokeColor);
                          _this.ctx.lineWidth = styles2.webkitTextStrokeWidth;
                          _this.ctx.lineJoin = !!window.chrome ? "miter" : "round";
                          _this.ctx.strokeText(text5.text, text5.bounds.left, text5.bounds.top + baseline);
                        }
                        _this.ctx.strokeStyle = "";
                        _this.ctx.lineWidth = 0;
                        _this.ctx.lineJoin = "miter";
                        break;
                    }
                  });
                });
                return [
                  2
                  /*return*/
                ];
              });
            });
          };
          CanvasRenderer2.prototype.renderReplacedElement = function(container, curves, image2) {
            if (image2 && container.intrinsicWidth > 0 && container.intrinsicHeight > 0) {
              var box = contentBox(container);
              var path2 = calculatePaddingBoxPath(curves);
              this.path(path2);
              this.ctx.save();
              this.ctx.clip();
              this.ctx.drawImage(image2, 0, 0, container.intrinsicWidth, container.intrinsicHeight, box.left, box.top, box.width, box.height);
              this.ctx.restore();
            }
          };
          CanvasRenderer2.prototype.renderNodeContent = function(paint) {
            return __awaiter(this, void 0, void 0, function() {
              var container, curves, styles2, _i, _a2, child, image2, image2, iframeRenderer, canvas, size2, _b2, fontFamily2, fontSize2, baseline, bounds, x2, textBounds, img, image2, url, fontFamily2, bounds;
              return __generator(this, function(_c) {
                switch (_c.label) {
                  case 0:
                    this.applyEffects(paint.getEffects(
                      4
                      /* CONTENT */
                    ));
                    container = paint.container;
                    curves = paint.curves;
                    styles2 = container.styles;
                    _i = 0, _a2 = container.textNodes;
                    _c.label = 1;
                  case 1:
                    if (!(_i < _a2.length))
                      return [3, 4];
                    child = _a2[_i];
                    return [4, this.renderTextNode(child, styles2)];
                  case 2:
                    _c.sent();
                    _c.label = 3;
                  case 3:
                    _i++;
                    return [3, 1];
                  case 4:
                    if (!(container instanceof ImageElementContainer))
                      return [3, 8];
                    _c.label = 5;
                  case 5:
                    _c.trys.push([5, 7, , 8]);
                    return [4, this.context.cache.match(container.src)];
                  case 6:
                    image2 = _c.sent();
                    this.renderReplacedElement(container, curves, image2);
                    return [3, 8];
                  case 7:
                    _c.sent();
                    this.context.logger.error("Error loading image " + container.src);
                    return [3, 8];
                  case 8:
                    if (container instanceof CanvasElementContainer) {
                      this.renderReplacedElement(container, curves, container.canvas);
                    }
                    if (!(container instanceof SVGElementContainer))
                      return [3, 12];
                    _c.label = 9;
                  case 9:
                    _c.trys.push([9, 11, , 12]);
                    return [4, this.context.cache.match(container.svg)];
                  case 10:
                    image2 = _c.sent();
                    this.renderReplacedElement(container, curves, image2);
                    return [3, 12];
                  case 11:
                    _c.sent();
                    this.context.logger.error("Error loading svg " + container.svg.substring(0, 255));
                    return [3, 12];
                  case 12:
                    if (!(container instanceof IFrameElementContainer && container.tree))
                      return [3, 14];
                    iframeRenderer = new CanvasRenderer2(this.context, {
                      scale: this.options.scale,
                      backgroundColor: container.backgroundColor,
                      x: 0,
                      y: 0,
                      width: container.width,
                      height: container.height
                    });
                    return [4, iframeRenderer.render(container.tree)];
                  case 13:
                    canvas = _c.sent();
                    if (container.width && container.height) {
                      this.ctx.drawImage(canvas, 0, 0, container.width, container.height, container.bounds.left, container.bounds.top, container.bounds.width, container.bounds.height);
                    }
                    _c.label = 14;
                  case 14:
                    if (container instanceof InputElementContainer) {
                      size2 = Math.min(container.bounds.width, container.bounds.height);
                      if (container.type === CHECKBOX) {
                        if (container.checked) {
                          this.ctx.save();
                          this.path([
                            new Vector(container.bounds.left + size2 * 0.39363, container.bounds.top + size2 * 0.79),
                            new Vector(container.bounds.left + size2 * 0.16, container.bounds.top + size2 * 0.5549),
                            new Vector(container.bounds.left + size2 * 0.27347, container.bounds.top + size2 * 0.44071),
                            new Vector(container.bounds.left + size2 * 0.39694, container.bounds.top + size2 * 0.5649),
                            new Vector(container.bounds.left + size2 * 0.72983, container.bounds.top + size2 * 0.23),
                            new Vector(container.bounds.left + size2 * 0.84, container.bounds.top + size2 * 0.34085),
                            new Vector(container.bounds.left + size2 * 0.39363, container.bounds.top + size2 * 0.79)
                          ]);
                          this.ctx.fillStyle = asString(INPUT_COLOR);
                          this.ctx.fill();
                          this.ctx.restore();
                        }
                      } else if (container.type === RADIO) {
                        if (container.checked) {
                          this.ctx.save();
                          this.ctx.beginPath();
                          this.ctx.arc(container.bounds.left + size2 / 2, container.bounds.top + size2 / 2, size2 / 4, 0, Math.PI * 2, true);
                          this.ctx.fillStyle = asString(INPUT_COLOR);
                          this.ctx.fill();
                          this.ctx.restore();
                        }
                      }
                    }
                    if (isTextInputElement(container) && container.value.length) {
                      _b2 = this.createFontStyle(styles2), fontFamily2 = _b2[0], fontSize2 = _b2[1];
                      baseline = this.fontMetrics.getMetrics(fontFamily2, fontSize2).baseline;
                      this.ctx.font = fontFamily2;
                      this.ctx.fillStyle = asString(styles2.color);
                      this.ctx.textBaseline = "alphabetic";
                      this.ctx.textAlign = canvasTextAlign(container.styles.textAlign);
                      bounds = contentBox(container);
                      x2 = 0;
                      switch (container.styles.textAlign) {
                        case 1:
                          x2 += bounds.width / 2;
                          break;
                        case 2:
                          x2 += bounds.width;
                          break;
                      }
                      textBounds = bounds.add(x2, 0, 0, -bounds.height / 2 + 1);
                      this.ctx.save();
                      this.path([
                        new Vector(bounds.left, bounds.top),
                        new Vector(bounds.left + bounds.width, bounds.top),
                        new Vector(bounds.left + bounds.width, bounds.top + bounds.height),
                        new Vector(bounds.left, bounds.top + bounds.height)
                      ]);
                      this.ctx.clip();
                      this.renderTextWithLetterSpacing(new TextBounds(container.value, textBounds), styles2.letterSpacing, baseline);
                      this.ctx.restore();
                      this.ctx.textBaseline = "alphabetic";
                      this.ctx.textAlign = "left";
                    }
                    if (!contains3(
                      container.styles.display,
                      2048
                      /* LIST_ITEM */
                    ))
                      return [3, 20];
                    if (!(container.styles.listStyleImage !== null))
                      return [3, 19];
                    img = container.styles.listStyleImage;
                    if (!(img.type === 0))
                      return [3, 18];
                    image2 = void 0;
                    url = img.url;
                    _c.label = 15;
                  case 15:
                    _c.trys.push([15, 17, , 18]);
                    return [4, this.context.cache.match(url)];
                  case 16:
                    image2 = _c.sent();
                    this.ctx.drawImage(image2, container.bounds.left - (image2.width + 10), container.bounds.top);
                    return [3, 18];
                  case 17:
                    _c.sent();
                    this.context.logger.error("Error loading list-style-image " + url);
                    return [3, 18];
                  case 18:
                    return [3, 20];
                  case 19:
                    if (paint.listValue && container.styles.listStyleType !== -1) {
                      fontFamily2 = this.createFontStyle(styles2)[0];
                      this.ctx.font = fontFamily2;
                      this.ctx.fillStyle = asString(styles2.color);
                      this.ctx.textBaseline = "middle";
                      this.ctx.textAlign = "right";
                      bounds = new Bounds(container.bounds.left, container.bounds.top + getAbsoluteValue(container.styles.paddingTop, container.bounds.width), container.bounds.width, computeLineHeight(styles2.lineHeight, styles2.fontSize.number) / 2 + 1);
                      this.renderTextWithLetterSpacing(new TextBounds(paint.listValue, bounds), styles2.letterSpacing, computeLineHeight(styles2.lineHeight, styles2.fontSize.number) / 2 + 2);
                      this.ctx.textBaseline = "bottom";
                      this.ctx.textAlign = "left";
                    }
                    _c.label = 20;
                  case 20:
                    return [
                      2
                      /*return*/
                    ];
                }
              });
            });
          };
          CanvasRenderer2.prototype.renderStackContent = function(stack) {
            return __awaiter(this, void 0, void 0, function() {
              var _i, _a2, child, _b2, _c, child, _d, _e, child, _f, _g, child, _h, _j, child, _k, _l, child, _m, _o, child;
              return __generator(this, function(_p) {
                switch (_p.label) {
                  case 0:
                    if (contains3(
                      stack.element.container.flags,
                      16
                      /* DEBUG_RENDER */
                    )) {
                      debugger;
                    }
                    return [4, this.renderNodeBackgroundAndBorders(stack.element)];
                  case 1:
                    _p.sent();
                    _i = 0, _a2 = stack.negativeZIndex;
                    _p.label = 2;
                  case 2:
                    if (!(_i < _a2.length))
                      return [3, 5];
                    child = _a2[_i];
                    return [4, this.renderStack(child)];
                  case 3:
                    _p.sent();
                    _p.label = 4;
                  case 4:
                    _i++;
                    return [3, 2];
                  case 5:
                    return [4, this.renderNodeContent(stack.element)];
                  case 6:
                    _p.sent();
                    _b2 = 0, _c = stack.nonInlineLevel;
                    _p.label = 7;
                  case 7:
                    if (!(_b2 < _c.length))
                      return [3, 10];
                    child = _c[_b2];
                    return [4, this.renderNode(child)];
                  case 8:
                    _p.sent();
                    _p.label = 9;
                  case 9:
                    _b2++;
                    return [3, 7];
                  case 10:
                    _d = 0, _e = stack.nonPositionedFloats;
                    _p.label = 11;
                  case 11:
                    if (!(_d < _e.length))
                      return [3, 14];
                    child = _e[_d];
                    return [4, this.renderStack(child)];
                  case 12:
                    _p.sent();
                    _p.label = 13;
                  case 13:
                    _d++;
                    return [3, 11];
                  case 14:
                    _f = 0, _g = stack.nonPositionedInlineLevel;
                    _p.label = 15;
                  case 15:
                    if (!(_f < _g.length))
                      return [3, 18];
                    child = _g[_f];
                    return [4, this.renderStack(child)];
                  case 16:
                    _p.sent();
                    _p.label = 17;
                  case 17:
                    _f++;
                    return [3, 15];
                  case 18:
                    _h = 0, _j = stack.inlineLevel;
                    _p.label = 19;
                  case 19:
                    if (!(_h < _j.length))
                      return [3, 22];
                    child = _j[_h];
                    return [4, this.renderNode(child)];
                  case 20:
                    _p.sent();
                    _p.label = 21;
                  case 21:
                    _h++;
                    return [3, 19];
                  case 22:
                    _k = 0, _l = stack.zeroOrAutoZIndexOrTransformedOrOpacity;
                    _p.label = 23;
                  case 23:
                    if (!(_k < _l.length))
                      return [3, 26];
                    child = _l[_k];
                    return [4, this.renderStack(child)];
                  case 24:
                    _p.sent();
                    _p.label = 25;
                  case 25:
                    _k++;
                    return [3, 23];
                  case 26:
                    _m = 0, _o = stack.positiveZIndex;
                    _p.label = 27;
                  case 27:
                    if (!(_m < _o.length))
                      return [3, 30];
                    child = _o[_m];
                    return [4, this.renderStack(child)];
                  case 28:
                    _p.sent();
                    _p.label = 29;
                  case 29:
                    _m++;
                    return [3, 27];
                  case 30:
                    return [
                      2
                      /*return*/
                    ];
                }
              });
            });
          };
          CanvasRenderer2.prototype.mask = function(paths) {
            this.ctx.beginPath();
            this.ctx.moveTo(0, 0);
            this.ctx.lineTo(this.canvas.width, 0);
            this.ctx.lineTo(this.canvas.width, this.canvas.height);
            this.ctx.lineTo(0, this.canvas.height);
            this.ctx.lineTo(0, 0);
            this.formatPath(paths.slice(0).reverse());
            this.ctx.closePath();
          };
          CanvasRenderer2.prototype.path = function(paths) {
            this.ctx.beginPath();
            this.formatPath(paths);
            this.ctx.closePath();
          };
          CanvasRenderer2.prototype.formatPath = function(paths) {
            var _this = this;
            paths.forEach(function(point4, index3) {
              var start = isBezierCurve(point4) ? point4.start : point4;
              if (index3 === 0) {
                _this.ctx.moveTo(start.x, start.y);
              } else {
                _this.ctx.lineTo(start.x, start.y);
              }
              if (isBezierCurve(point4)) {
                _this.ctx.bezierCurveTo(point4.startControl.x, point4.startControl.y, point4.endControl.x, point4.endControl.y, point4.end.x, point4.end.y);
              }
            });
          };
          CanvasRenderer2.prototype.renderRepeat = function(path2, pattern, offsetX, offsetY) {
            this.path(path2);
            this.ctx.fillStyle = pattern;
            this.ctx.translate(offsetX, offsetY);
            this.ctx.fill();
            this.ctx.translate(-offsetX, -offsetY);
          };
          CanvasRenderer2.prototype.resizeImage = function(image2, width2, height2) {
            var _a2;
            if (image2.width === width2 && image2.height === height2) {
              return image2;
            }
            var ownerDocument = (_a2 = this.canvas.ownerDocument) !== null && _a2 !== void 0 ? _a2 : document;
            var canvas = ownerDocument.createElement("canvas");
            canvas.width = Math.max(1, width2);
            canvas.height = Math.max(1, height2);
            var ctx = canvas.getContext("2d");
            ctx.drawImage(image2, 0, 0, image2.width, image2.height, 0, 0, width2, height2);
            return canvas;
          };
          CanvasRenderer2.prototype.renderBackgroundImage = function(container) {
            return __awaiter(this, void 0, void 0, function() {
              var index3, _loop_1, this_1, _i, _a2, backgroundImage2;
              return __generator(this, function(_b2) {
                switch (_b2.label) {
                  case 0:
                    index3 = container.styles.backgroundImage.length - 1;
                    _loop_1 = function(backgroundImage3) {
                      var image2, url, _c, path2, x2, y3, width2, height2, pattern, _d, path2, x2, y3, width2, height2, _e, lineLength, x0, x1, y0, y1, canvas, ctx, gradient_1, pattern, _f, path2, left, top_1, width2, height2, position4, x2, y3, _g, rx2, ry2, radialGradient_1, midX, midY, f4, invF;
                      return __generator(this, function(_h) {
                        switch (_h.label) {
                          case 0:
                            if (!(backgroundImage3.type === 0))
                              return [3, 5];
                            image2 = void 0;
                            url = backgroundImage3.url;
                            _h.label = 1;
                          case 1:
                            _h.trys.push([1, 3, , 4]);
                            return [4, this_1.context.cache.match(url)];
                          case 2:
                            image2 = _h.sent();
                            return [3, 4];
                          case 3:
                            _h.sent();
                            this_1.context.logger.error("Error loading background-image " + url);
                            return [3, 4];
                          case 4:
                            if (image2) {
                              _c = calculateBackgroundRendering(container, index3, [
                                image2.width,
                                image2.height,
                                image2.width / image2.height
                              ]), path2 = _c[0], x2 = _c[1], y3 = _c[2], width2 = _c[3], height2 = _c[4];
                              pattern = this_1.ctx.createPattern(this_1.resizeImage(image2, width2, height2), "repeat");
                              this_1.renderRepeat(path2, pattern, x2, y3);
                            }
                            return [3, 6];
                          case 5:
                            if (isLinearGradient(backgroundImage3)) {
                              _d = calculateBackgroundRendering(container, index3, [null, null, null]), path2 = _d[0], x2 = _d[1], y3 = _d[2], width2 = _d[3], height2 = _d[4];
                              _e = calculateGradientDirection(backgroundImage3.angle, width2, height2), lineLength = _e[0], x0 = _e[1], x1 = _e[2], y0 = _e[3], y1 = _e[4];
                              canvas = document.createElement("canvas");
                              canvas.width = width2;
                              canvas.height = height2;
                              ctx = canvas.getContext("2d");
                              gradient_1 = ctx.createLinearGradient(x0, y0, x1, y1);
                              processColorStops(backgroundImage3.stops, lineLength).forEach(function(colorStop) {
                                return gradient_1.addColorStop(colorStop.stop, asString(colorStop.color));
                              });
                              ctx.fillStyle = gradient_1;
                              ctx.fillRect(0, 0, width2, height2);
                              if (width2 > 0 && height2 > 0) {
                                pattern = this_1.ctx.createPattern(canvas, "repeat");
                                this_1.renderRepeat(path2, pattern, x2, y3);
                              }
                            } else if (isRadialGradient(backgroundImage3)) {
                              _f = calculateBackgroundRendering(container, index3, [
                                null,
                                null,
                                null
                              ]), path2 = _f[0], left = _f[1], top_1 = _f[2], width2 = _f[3], height2 = _f[4];
                              position4 = backgroundImage3.position.length === 0 ? [FIFTY_PERCENT] : backgroundImage3.position;
                              x2 = getAbsoluteValue(position4[0], width2);
                              y3 = getAbsoluteValue(position4[position4.length - 1], height2);
                              _g = calculateRadius(backgroundImage3, x2, y3, width2, height2), rx2 = _g[0], ry2 = _g[1];
                              if (rx2 > 0 && ry2 > 0) {
                                radialGradient_1 = this_1.ctx.createRadialGradient(left + x2, top_1 + y3, 0, left + x2, top_1 + y3, rx2);
                                processColorStops(backgroundImage3.stops, rx2 * 2).forEach(function(colorStop) {
                                  return radialGradient_1.addColorStop(colorStop.stop, asString(colorStop.color));
                                });
                                this_1.path(path2);
                                this_1.ctx.fillStyle = radialGradient_1;
                                if (rx2 !== ry2) {
                                  midX = container.bounds.left + 0.5 * container.bounds.width;
                                  midY = container.bounds.top + 0.5 * container.bounds.height;
                                  f4 = ry2 / rx2;
                                  invF = 1 / f4;
                                  this_1.ctx.save();
                                  this_1.ctx.translate(midX, midY);
                                  this_1.ctx.transform(1, 0, 0, f4, 0, 0);
                                  this_1.ctx.translate(-midX, -midY);
                                  this_1.ctx.fillRect(left, invF * (top_1 - midY) + midY, width2, height2 * invF);
                                  this_1.ctx.restore();
                                } else {
                                  this_1.ctx.fill();
                                }
                              }
                            }
                            _h.label = 6;
                          case 6:
                            index3--;
                            return [
                              2
                              /*return*/
                            ];
                        }
                      });
                    };
                    this_1 = this;
                    _i = 0, _a2 = container.styles.backgroundImage.slice(0).reverse();
                    _b2.label = 1;
                  case 1:
                    if (!(_i < _a2.length))
                      return [3, 4];
                    backgroundImage2 = _a2[_i];
                    return [5, _loop_1(backgroundImage2)];
                  case 2:
                    _b2.sent();
                    _b2.label = 3;
                  case 3:
                    _i++;
                    return [3, 1];
                  case 4:
                    return [
                      2
                      /*return*/
                    ];
                }
              });
            });
          };
          CanvasRenderer2.prototype.renderSolidBorder = function(color2, side, curvePoints) {
            return __awaiter(this, void 0, void 0, function() {
              return __generator(this, function(_a2) {
                this.path(parsePathForBorder(curvePoints, side));
                this.ctx.fillStyle = asString(color2);
                this.ctx.fill();
                return [
                  2
                  /*return*/
                ];
              });
            });
          };
          CanvasRenderer2.prototype.renderDoubleBorder = function(color2, width2, side, curvePoints) {
            return __awaiter(this, void 0, void 0, function() {
              var outerPaths, innerPaths;
              return __generator(this, function(_a2) {
                switch (_a2.label) {
                  case 0:
                    if (!(width2 < 3))
                      return [3, 2];
                    return [4, this.renderSolidBorder(color2, side, curvePoints)];
                  case 1:
                    _a2.sent();
                    return [
                      2
                      /*return*/
                    ];
                  case 2:
                    outerPaths = parsePathForBorderDoubleOuter(curvePoints, side);
                    this.path(outerPaths);
                    this.ctx.fillStyle = asString(color2);
                    this.ctx.fill();
                    innerPaths = parsePathForBorderDoubleInner(curvePoints, side);
                    this.path(innerPaths);
                    this.ctx.fill();
                    return [
                      2
                      /*return*/
                    ];
                }
              });
            });
          };
          CanvasRenderer2.prototype.renderNodeBackgroundAndBorders = function(paint) {
            return __awaiter(this, void 0, void 0, function() {
              var styles2, hasBackground, borders, backgroundPaintingArea, side, _i, borders_1, border;
              var _this = this;
              return __generator(this, function(_a2) {
                switch (_a2.label) {
                  case 0:
                    this.applyEffects(paint.getEffects(
                      2
                      /* BACKGROUND_BORDERS */
                    ));
                    styles2 = paint.container.styles;
                    hasBackground = !isTransparent2(styles2.backgroundColor) || styles2.backgroundImage.length;
                    borders = [
                      { style: styles2.borderTopStyle, color: styles2.borderTopColor, width: styles2.borderTopWidth },
                      { style: styles2.borderRightStyle, color: styles2.borderRightColor, width: styles2.borderRightWidth },
                      { style: styles2.borderBottomStyle, color: styles2.borderBottomColor, width: styles2.borderBottomWidth },
                      { style: styles2.borderLeftStyle, color: styles2.borderLeftColor, width: styles2.borderLeftWidth }
                    ];
                    backgroundPaintingArea = calculateBackgroundCurvedPaintingArea(getBackgroundValueForIndex(styles2.backgroundClip, 0), paint.curves);
                    if (!(hasBackground || styles2.boxShadow.length))
                      return [3, 2];
                    this.ctx.save();
                    this.path(backgroundPaintingArea);
                    this.ctx.clip();
                    if (!isTransparent2(styles2.backgroundColor)) {
                      this.ctx.fillStyle = asString(styles2.backgroundColor);
                      this.ctx.fill();
                    }
                    return [4, this.renderBackgroundImage(paint.container)];
                  case 1:
                    _a2.sent();
                    this.ctx.restore();
                    styles2.boxShadow.slice(0).reverse().forEach(function(shadow) {
                      _this.ctx.save();
                      var borderBoxArea = calculateBorderBoxPath(paint.curves);
                      var maskOffset = shadow.inset ? 0 : MASK_OFFSET;
                      var shadowPaintingArea = transformPath(borderBoxArea, -maskOffset + (shadow.inset ? 1 : -1) * shadow.spread.number, (shadow.inset ? 1 : -1) * shadow.spread.number, shadow.spread.number * (shadow.inset ? -2 : 2), shadow.spread.number * (shadow.inset ? -2 : 2));
                      if (shadow.inset) {
                        _this.path(borderBoxArea);
                        _this.ctx.clip();
                        _this.mask(shadowPaintingArea);
                      } else {
                        _this.mask(borderBoxArea);
                        _this.ctx.clip();
                        _this.path(shadowPaintingArea);
                      }
                      _this.ctx.shadowOffsetX = shadow.offsetX.number + maskOffset;
                      _this.ctx.shadowOffsetY = shadow.offsetY.number;
                      _this.ctx.shadowColor = asString(shadow.color);
                      _this.ctx.shadowBlur = shadow.blur.number;
                      _this.ctx.fillStyle = shadow.inset ? asString(shadow.color) : "rgba(0,0,0,1)";
                      _this.ctx.fill();
                      _this.ctx.restore();
                    });
                    _a2.label = 2;
                  case 2:
                    side = 0;
                    _i = 0, borders_1 = borders;
                    _a2.label = 3;
                  case 3:
                    if (!(_i < borders_1.length))
                      return [3, 13];
                    border = borders_1[_i];
                    if (!(border.style !== 0 && !isTransparent2(border.color) && border.width > 0))
                      return [3, 11];
                    if (!(border.style === 2))
                      return [3, 5];
                    return [4, this.renderDashedDottedBorder(
                      border.color,
                      border.width,
                      side,
                      paint.curves,
                      2
                      /* DASHED */
                    )];
                  case 4:
                    _a2.sent();
                    return [3, 11];
                  case 5:
                    if (!(border.style === 3))
                      return [3, 7];
                    return [4, this.renderDashedDottedBorder(
                      border.color,
                      border.width,
                      side,
                      paint.curves,
                      3
                      /* DOTTED */
                    )];
                  case 6:
                    _a2.sent();
                    return [3, 11];
                  case 7:
                    if (!(border.style === 4))
                      return [3, 9];
                    return [4, this.renderDoubleBorder(border.color, border.width, side, paint.curves)];
                  case 8:
                    _a2.sent();
                    return [3, 11];
                  case 9:
                    return [4, this.renderSolidBorder(border.color, side, paint.curves)];
                  case 10:
                    _a2.sent();
                    _a2.label = 11;
                  case 11:
                    side++;
                    _a2.label = 12;
                  case 12:
                    _i++;
                    return [3, 3];
                  case 13:
                    return [
                      2
                      /*return*/
                    ];
                }
              });
            });
          };
          CanvasRenderer2.prototype.renderDashedDottedBorder = function(color2, width2, side, curvePoints, style) {
            return __awaiter(this, void 0, void 0, function() {
              var strokePaths, boxPaths, startX, startY, endX, endY, length2, dashLength, spaceLength, useLineDash, multiplier, numberOfDashes, minSpace, maxSpace, path1, path2, path1, path2;
              return __generator(this, function(_a2) {
                this.ctx.save();
                strokePaths = parsePathForBorderStroke(curvePoints, side);
                boxPaths = parsePathForBorder(curvePoints, side);
                if (style === 2) {
                  this.path(boxPaths);
                  this.ctx.clip();
                }
                if (isBezierCurve(boxPaths[0])) {
                  startX = boxPaths[0].start.x;
                  startY = boxPaths[0].start.y;
                } else {
                  startX = boxPaths[0].x;
                  startY = boxPaths[0].y;
                }
                if (isBezierCurve(boxPaths[1])) {
                  endX = boxPaths[1].end.x;
                  endY = boxPaths[1].end.y;
                } else {
                  endX = boxPaths[1].x;
                  endY = boxPaths[1].y;
                }
                if (side === 0 || side === 2) {
                  length2 = Math.abs(startX - endX);
                } else {
                  length2 = Math.abs(startY - endY);
                }
                this.ctx.beginPath();
                if (style === 3) {
                  this.formatPath(strokePaths);
                } else {
                  this.formatPath(boxPaths.slice(0, 2));
                }
                dashLength = width2 < 3 ? width2 * 3 : width2 * 2;
                spaceLength = width2 < 3 ? width2 * 2 : width2;
                if (style === 3) {
                  dashLength = width2;
                  spaceLength = width2;
                }
                useLineDash = true;
                if (length2 <= dashLength * 2) {
                  useLineDash = false;
                } else if (length2 <= dashLength * 2 + spaceLength) {
                  multiplier = length2 / (2 * dashLength + spaceLength);
                  dashLength *= multiplier;
                  spaceLength *= multiplier;
                } else {
                  numberOfDashes = Math.floor((length2 + spaceLength) / (dashLength + spaceLength));
                  minSpace = (length2 - numberOfDashes * dashLength) / (numberOfDashes - 1);
                  maxSpace = (length2 - (numberOfDashes + 1) * dashLength) / numberOfDashes;
                  spaceLength = maxSpace <= 0 || Math.abs(spaceLength - minSpace) < Math.abs(spaceLength - maxSpace) ? minSpace : maxSpace;
                }
                if (useLineDash) {
                  if (style === 3) {
                    this.ctx.setLineDash([0, dashLength + spaceLength]);
                  } else {
                    this.ctx.setLineDash([dashLength, spaceLength]);
                  }
                }
                if (style === 3) {
                  this.ctx.lineCap = "round";
                  this.ctx.lineWidth = width2;
                } else {
                  this.ctx.lineWidth = width2 * 2 + 1.1;
                }
                this.ctx.strokeStyle = asString(color2);
                this.ctx.stroke();
                this.ctx.setLineDash([]);
                if (style === 2) {
                  if (isBezierCurve(boxPaths[0])) {
                    path1 = boxPaths[3];
                    path2 = boxPaths[0];
                    this.ctx.beginPath();
                    this.formatPath([new Vector(path1.end.x, path1.end.y), new Vector(path2.start.x, path2.start.y)]);
                    this.ctx.stroke();
                  }
                  if (isBezierCurve(boxPaths[1])) {
                    path1 = boxPaths[1];
                    path2 = boxPaths[2];
                    this.ctx.beginPath();
                    this.formatPath([new Vector(path1.end.x, path1.end.y), new Vector(path2.start.x, path2.start.y)]);
                    this.ctx.stroke();
                  }
                }
                this.ctx.restore();
                return [
                  2
                  /*return*/
                ];
              });
            });
          };
          CanvasRenderer2.prototype.render = function(element2) {
            return __awaiter(this, void 0, void 0, function() {
              var stack;
              return __generator(this, function(_a2) {
                switch (_a2.label) {
                  case 0:
                    if (this.options.backgroundColor) {
                      this.ctx.fillStyle = asString(this.options.backgroundColor);
                      this.ctx.fillRect(this.options.x, this.options.y, this.options.width, this.options.height);
                    }
                    stack = parseStackingContexts(element2);
                    return [4, this.renderStack(stack)];
                  case 1:
                    _a2.sent();
                    this.applyEffects([]);
                    return [2, this.canvas];
                }
              });
            });
          };
          return CanvasRenderer2;
        }(Renderer)
      );
      var isTextInputElement = function(container) {
        if (container instanceof TextareaElementContainer) {
          return true;
        } else if (container instanceof SelectElementContainer) {
          return true;
        } else if (container instanceof InputElementContainer && container.type !== RADIO && container.type !== CHECKBOX) {
          return true;
        }
        return false;
      };
      var calculateBackgroundCurvedPaintingArea = function(clip, curves) {
        switch (clip) {
          case 0:
            return calculateBorderBoxPath(curves);
          case 2:
            return calculateContentBoxPath(curves);
          case 1:
          default:
            return calculatePaddingBoxPath(curves);
        }
      };
      var canvasTextAlign = function(textAlign2) {
        switch (textAlign2) {
          case 1:
            return "center";
          case 2:
            return "right";
          case 0:
          default:
            return "left";
        }
      };
      var iOSBrokenFonts = ["-apple-system", "system-ui"];
      var fixIOSSystemFonts = function(fontFamilies) {
        return /iPhone OS 15_(0|1)/.test(window.navigator.userAgent) ? fontFamilies.filter(function(fontFamily2) {
          return iOSBrokenFonts.indexOf(fontFamily2) === -1;
        }) : fontFamilies;
      };
      var ForeignObjectRenderer = (
        /** @class */
        function(_super) {
          __extends3(ForeignObjectRenderer2, _super);
          function ForeignObjectRenderer2(context, options) {
            var _this = _super.call(this, context, options) || this;
            _this.canvas = options.canvas ? options.canvas : document.createElement("canvas");
            _this.ctx = _this.canvas.getContext("2d");
            _this.options = options;
            _this.canvas.width = Math.floor(options.width * options.scale);
            _this.canvas.height = Math.floor(options.height * options.scale);
            _this.canvas.style.width = options.width + "px";
            _this.canvas.style.height = options.height + "px";
            _this.ctx.scale(_this.options.scale, _this.options.scale);
            _this.ctx.translate(-options.x, -options.y);
            _this.context.logger.debug("EXPERIMENTAL ForeignObject renderer initialized (" + options.width + "x" + options.height + " at " + options.x + "," + options.y + ") with scale " + options.scale);
            return _this;
          }
          ForeignObjectRenderer2.prototype.render = function(element2) {
            return __awaiter(this, void 0, void 0, function() {
              var svg2, img;
              return __generator(this, function(_a2) {
                switch (_a2.label) {
                  case 0:
                    svg2 = createForeignObjectSVG(this.options.width * this.options.scale, this.options.height * this.options.scale, this.options.scale, this.options.scale, element2);
                    return [4, loadSerializedSVG(svg2)];
                  case 1:
                    img = _a2.sent();
                    if (this.options.backgroundColor) {
                      this.ctx.fillStyle = asString(this.options.backgroundColor);
                      this.ctx.fillRect(0, 0, this.options.width * this.options.scale, this.options.height * this.options.scale);
                    }
                    this.ctx.drawImage(img, -this.options.x * this.options.scale, -this.options.y * this.options.scale);
                    return [2, this.canvas];
                }
              });
            });
          };
          return ForeignObjectRenderer2;
        }(Renderer)
      );
      var loadSerializedSVG = function(svg2) {
        return new Promise(function(resolve, reject) {
          var img = new Image();
          img.onload = function() {
            resolve(img);
          };
          img.onerror = reject;
          img.src = "data:image/svg+xml;charset=utf-8," + encodeURIComponent(new XMLSerializer().serializeToString(svg2));
        });
      };
      var Logger = (
        /** @class */
        function() {
          function Logger2(_a2) {
            var id = _a2.id, enabled = _a2.enabled;
            this.id = id;
            this.enabled = enabled;
            this.start = Date.now();
          }
          Logger2.prototype.debug = function() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            if (this.enabled) {
              if (typeof window !== "undefined" && window.console && typeof console.debug === "function") {
                console.debug.apply(console, __spreadArray([this.id, this.getTime() + "ms"], args));
              } else {
                this.info.apply(this, args);
              }
            }
          };
          Logger2.prototype.getTime = function() {
            return Date.now() - this.start;
          };
          Logger2.prototype.info = function() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            if (this.enabled) {
              if (typeof window !== "undefined" && window.console && typeof console.info === "function") {
                console.info.apply(console, __spreadArray([this.id, this.getTime() + "ms"], args));
              }
            }
          };
          Logger2.prototype.warn = function() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            if (this.enabled) {
              if (typeof window !== "undefined" && window.console && typeof console.warn === "function") {
                console.warn.apply(console, __spreadArray([this.id, this.getTime() + "ms"], args));
              } else {
                this.info.apply(this, args);
              }
            }
          };
          Logger2.prototype.error = function() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            if (this.enabled) {
              if (typeof window !== "undefined" && window.console && typeof console.error === "function") {
                console.error.apply(console, __spreadArray([this.id, this.getTime() + "ms"], args));
              } else {
                this.info.apply(this, args);
              }
            }
          };
          Logger2.instances = {};
          return Logger2;
        }()
      );
      var Context = (
        /** @class */
        function() {
          function Context2(options, windowBounds) {
            var _a2;
            this.windowBounds = windowBounds;
            this.instanceName = "#" + Context2.instanceCount++;
            this.logger = new Logger({ id: this.instanceName, enabled: options.logging });
            this.cache = (_a2 = options.cache) !== null && _a2 !== void 0 ? _a2 : new Cache(this, options);
          }
          Context2.instanceCount = 1;
          return Context2;
        }()
      );
      var html2canvas = function(element2, options) {
        if (options === void 0) {
          options = {};
        }
        return renderElement(element2, options);
      };
      if (typeof window !== "undefined") {
        CacheStorage.setContext(window);
      }
      var renderElement = function(element2, opts) {
        return __awaiter(void 0, void 0, void 0, function() {
          var ownerDocument, defaultView, resourceOptions, contextOptions, windowOptions, windowBounds, context, foreignObjectRendering, cloneOptions, documentCloner, clonedElement, container, _a2, width2, height2, left, top, backgroundColor2, renderOptions, canvas, renderer, root2, renderer;
          var _b2, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t;
          return __generator(this, function(_u) {
            switch (_u.label) {
              case 0:
                if (!element2 || typeof element2 !== "object") {
                  return [2, Promise.reject("Invalid element provided as first argument")];
                }
                ownerDocument = element2.ownerDocument;
                if (!ownerDocument) {
                  throw new Error("Element is not attached to a Document");
                }
                defaultView = ownerDocument.defaultView;
                if (!defaultView) {
                  throw new Error("Document is not attached to a Window");
                }
                resourceOptions = {
                  allowTaint: (_b2 = opts.allowTaint) !== null && _b2 !== void 0 ? _b2 : false,
                  imageTimeout: (_c = opts.imageTimeout) !== null && _c !== void 0 ? _c : 15e3,
                  proxy: opts.proxy,
                  useCORS: (_d = opts.useCORS) !== null && _d !== void 0 ? _d : false
                };
                contextOptions = __assign({ logging: (_e = opts.logging) !== null && _e !== void 0 ? _e : true, cache: opts.cache }, resourceOptions);
                windowOptions = {
                  windowWidth: (_f = opts.windowWidth) !== null && _f !== void 0 ? _f : defaultView.innerWidth,
                  windowHeight: (_g = opts.windowHeight) !== null && _g !== void 0 ? _g : defaultView.innerHeight,
                  scrollX: (_h = opts.scrollX) !== null && _h !== void 0 ? _h : defaultView.pageXOffset,
                  scrollY: (_j = opts.scrollY) !== null && _j !== void 0 ? _j : defaultView.pageYOffset
                };
                windowBounds = new Bounds(windowOptions.scrollX, windowOptions.scrollY, windowOptions.windowWidth, windowOptions.windowHeight);
                context = new Context(contextOptions, windowBounds);
                foreignObjectRendering = (_k = opts.foreignObjectRendering) !== null && _k !== void 0 ? _k : false;
                cloneOptions = {
                  allowTaint: (_l = opts.allowTaint) !== null && _l !== void 0 ? _l : false,
                  onclone: opts.onclone,
                  ignoreElements: opts.ignoreElements,
                  inlineImages: foreignObjectRendering,
                  copyStyles: foreignObjectRendering
                };
                context.logger.debug("Starting document clone with size " + windowBounds.width + "x" + windowBounds.height + " scrolled to " + -windowBounds.left + "," + -windowBounds.top);
                documentCloner = new DocumentCloner(context, element2, cloneOptions);
                clonedElement = documentCloner.clonedReferenceElement;
                if (!clonedElement) {
                  return [2, Promise.reject("Unable to find element in cloned iframe")];
                }
                return [4, documentCloner.toIFrame(ownerDocument, windowBounds)];
              case 1:
                container = _u.sent();
                _a2 = isBodyElement(clonedElement) || isHTMLElement(clonedElement) ? parseDocumentSize(clonedElement.ownerDocument) : parseBounds(context, clonedElement), width2 = _a2.width, height2 = _a2.height, left = _a2.left, top = _a2.top;
                backgroundColor2 = parseBackgroundColor(context, clonedElement, opts.backgroundColor);
                renderOptions = {
                  canvas: opts.canvas,
                  backgroundColor: backgroundColor2,
                  scale: (_o = (_m = opts.scale) !== null && _m !== void 0 ? _m : defaultView.devicePixelRatio) !== null && _o !== void 0 ? _o : 1,
                  x: ((_p = opts.x) !== null && _p !== void 0 ? _p : 0) + left,
                  y: ((_q = opts.y) !== null && _q !== void 0 ? _q : 0) + top,
                  width: (_r = opts.width) !== null && _r !== void 0 ? _r : Math.ceil(width2),
                  height: (_s = opts.height) !== null && _s !== void 0 ? _s : Math.ceil(height2)
                };
                if (!foreignObjectRendering)
                  return [3, 3];
                context.logger.debug("Document cloned, using foreign object rendering");
                renderer = new ForeignObjectRenderer(context, renderOptions);
                return [4, renderer.render(clonedElement)];
              case 2:
                canvas = _u.sent();
                return [3, 5];
              case 3:
                context.logger.debug("Document cloned, element located at " + left + "," + top + " with size " + width2 + "x" + height2 + " using computed rendering");
                context.logger.debug("Starting DOM parsing");
                root2 = parseTree3(context, clonedElement);
                if (backgroundColor2 === root2.styles.backgroundColor) {
                  root2.styles.backgroundColor = COLORS.TRANSPARENT;
                }
                context.logger.debug("Starting renderer for element at " + renderOptions.x + "," + renderOptions.y + " with size " + renderOptions.width + "x" + renderOptions.height);
                renderer = new CanvasRenderer(context, renderOptions);
                return [4, renderer.render(root2)];
              case 4:
                canvas = _u.sent();
                _u.label = 5;
              case 5:
                if ((_t = opts.removeContainer) !== null && _t !== void 0 ? _t : true) {
                  if (!DocumentCloner.destroy(container)) {
                    context.logger.error("Cannot detach cloned iframe as it is not in the DOM anymore");
                  }
                }
                context.logger.debug("Finished rendering");
                return [2, canvas];
            }
          });
        });
      };
      var parseBackgroundColor = function(context, element2, backgroundColorOverride) {
        var ownerDocument = element2.ownerDocument;
        var documentBackgroundColor = ownerDocument.documentElement ? parseColor(context, getComputedStyle(ownerDocument.documentElement).backgroundColor) : COLORS.TRANSPARENT;
        var bodyBackgroundColor = ownerDocument.body ? parseColor(context, getComputedStyle(ownerDocument.body).backgroundColor) : COLORS.TRANSPARENT;
        var defaultBackgroundColor = typeof backgroundColorOverride === "string" ? parseColor(context, backgroundColorOverride) : backgroundColorOverride === null ? COLORS.TRANSPARENT : 4294967295;
        return element2 === ownerDocument.documentElement ? isTransparent2(documentBackgroundColor) ? isTransparent2(bodyBackgroundColor) ? defaultBackgroundColor : bodyBackgroundColor : documentBackgroundColor : defaultBackgroundColor;
      };
      return html2canvas;
    });
  }
});

// ../simple-mind-map/node_modules/dompurify/dist/purify.js
var require_purify = __commonJS({
  "../simple-mind-map/node_modules/dompurify/dist/purify.js"(exports, module) {
    (function(global2, factory) {
      typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, global2.DOMPurify = factory());
    })(exports, function() {
      "use strict";
      function _typeof3(obj) {
        "@babel/helpers - typeof";
        return _typeof3 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
          return typeof obj2;
        } : function(obj2) {
          return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        }, _typeof3(obj);
      }
      function _setPrototypeOf(o2, p2) {
        _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
          o3.__proto__ = p3;
          return o3;
        };
        return _setPrototypeOf(o2, p2);
      }
      function _isNativeReflectConstruct() {
        if (typeof Reflect === "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy === "function")
          return true;
        try {
          Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
          }));
          return true;
        } catch (e2) {
          return false;
        }
      }
      function _construct(Parent, args, Class) {
        if (_isNativeReflectConstruct()) {
          _construct = Reflect.construct;
        } else {
          _construct = function _construct2(Parent2, args2, Class2) {
            var a2 = [null];
            a2.push.apply(a2, args2);
            var Constructor = Function.bind.apply(Parent2, a2);
            var instance = new Constructor();
            if (Class2)
              _setPrototypeOf(instance, Class2.prototype);
            return instance;
          };
        }
        return _construct.apply(null, arguments);
      }
      function _toConsumableArray(arr) {
        return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
      }
      function _arrayWithoutHoles(arr) {
        if (Array.isArray(arr))
          return _arrayLikeToArray(arr);
      }
      function _iterableToArray(iter) {
        if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
          return Array.from(iter);
      }
      function _unsupportedIterableToArray(o2, minLen) {
        if (!o2)
          return;
        if (typeof o2 === "string")
          return _arrayLikeToArray(o2, minLen);
        var n2 = Object.prototype.toString.call(o2).slice(8, -1);
        if (n2 === "Object" && o2.constructor)
          n2 = o2.constructor.name;
        if (n2 === "Map" || n2 === "Set")
          return Array.from(o2);
        if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
          return _arrayLikeToArray(o2, minLen);
      }
      function _arrayLikeToArray(arr, len) {
        if (len == null || len > arr.length)
          len = arr.length;
        for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++)
          arr2[i2] = arr[i2];
        return arr2;
      }
      function _nonIterableSpread() {
        throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      var hasOwnProperty2 = Object.hasOwnProperty, setPrototypeOf = Object.setPrototypeOf, isFrozen = Object.isFrozen, getPrototypeOf = Object.getPrototypeOf, getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
      var freeze = Object.freeze, seal = Object.seal, create2 = Object.create;
      var _ref = typeof Reflect !== "undefined" && Reflect, apply = _ref.apply, construct = _ref.construct;
      if (!apply) {
        apply = function apply2(fun, thisValue, args) {
          return fun.apply(thisValue, args);
        };
      }
      if (!freeze) {
        freeze = function freeze2(x2) {
          return x2;
        };
      }
      if (!seal) {
        seal = function seal2(x2) {
          return x2;
        };
      }
      if (!construct) {
        construct = function construct2(Func, args) {
          return _construct(Func, _toConsumableArray(args));
        };
      }
      var arrayForEach = unapply(Array.prototype.forEach);
      var arrayPop = unapply(Array.prototype.pop);
      var arrayPush = unapply(Array.prototype.push);
      var stringToLowerCase = unapply(String.prototype.toLowerCase);
      var stringToString = unapply(String.prototype.toString);
      var stringMatch = unapply(String.prototype.match);
      var stringReplace = unapply(String.prototype.replace);
      var stringIndexOf = unapply(String.prototype.indexOf);
      var stringTrim = unapply(String.prototype.trim);
      var regExpTest = unapply(RegExp.prototype.test);
      var typeErrorCreate = unconstruct(TypeError);
      function unapply(func) {
        return function(thisArg) {
          for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            args[_key - 1] = arguments[_key];
          }
          return apply(func, thisArg, args);
        };
      }
      function unconstruct(func) {
        return function() {
          for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            args[_key2] = arguments[_key2];
          }
          return construct(func, args);
        };
      }
      function addToSet(set, array2, transformCaseFunc) {
        var _transformCaseFunc;
        transformCaseFunc = (_transformCaseFunc = transformCaseFunc) !== null && _transformCaseFunc !== void 0 ? _transformCaseFunc : stringToLowerCase;
        if (setPrototypeOf) {
          setPrototypeOf(set, null);
        }
        var l2 = array2.length;
        while (l2--) {
          var element2 = array2[l2];
          if (typeof element2 === "string") {
            var lcElement = transformCaseFunc(element2);
            if (lcElement !== element2) {
              if (!isFrozen(array2)) {
                array2[l2] = lcElement;
              }
              element2 = lcElement;
            }
          }
          set[element2] = true;
        }
        return set;
      }
      function clone(object) {
        var newObject = create2(null);
        var property;
        for (property in object) {
          if (apply(hasOwnProperty2, object, [property]) === true) {
            newObject[property] = object[property];
          }
        }
        return newObject;
      }
      function lookupGetter(object, prop) {
        while (object !== null) {
          var desc = getOwnPropertyDescriptor(object, prop);
          if (desc) {
            if (desc.get) {
              return unapply(desc.get);
            }
            if (typeof desc.value === "function") {
              return unapply(desc.value);
            }
          }
          object = getPrototypeOf(object);
        }
        function fallbackValue(element2) {
          console.warn("fallback value for", element2);
          return null;
        }
        return fallbackValue;
      }
      var html$1 = freeze(["a", "abbr", "acronym", "address", "area", "article", "aside", "audio", "b", "bdi", "bdo", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "content", "data", "datalist", "dd", "decorator", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "fieldset", "figcaption", "figure", "font", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "map", "mark", "marquee", "menu", "menuitem", "meter", "nav", "nobr", "ol", "optgroup", "option", "output", "p", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "section", "select", "shadow", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "tt", "u", "ul", "var", "video", "wbr"]);
      var svg$1 = freeze(["svg", "a", "altglyph", "altglyphdef", "altglyphitem", "animatecolor", "animatemotion", "animatetransform", "circle", "clippath", "defs", "desc", "ellipse", "filter", "font", "g", "glyph", "glyphref", "hkern", "image", "line", "lineargradient", "marker", "mask", "metadata", "mpath", "path", "pattern", "polygon", "polyline", "radialgradient", "rect", "stop", "style", "switch", "symbol", "text", "textpath", "title", "tref", "tspan", "view", "vkern"]);
      var svgFilters = freeze(["feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence"]);
      var svgDisallowed = freeze(["animate", "color-profile", "cursor", "discard", "fedropshadow", "font-face", "font-face-format", "font-face-name", "font-face-src", "font-face-uri", "foreignobject", "hatch", "hatchpath", "mesh", "meshgradient", "meshpatch", "meshrow", "missing-glyph", "script", "set", "solidcolor", "unknown", "use"]);
      var mathMl$1 = freeze(["math", "menclose", "merror", "mfenced", "mfrac", "mglyph", "mi", "mlabeledtr", "mmultiscripts", "mn", "mo", "mover", "mpadded", "mphantom", "mroot", "mrow", "ms", "mspace", "msqrt", "mstyle", "msub", "msup", "msubsup", "mtable", "mtd", "mtext", "mtr", "munder", "munderover"]);
      var mathMlDisallowed = freeze(["maction", "maligngroup", "malignmark", "mlongdiv", "mscarries", "mscarry", "msgroup", "mstack", "msline", "msrow", "semantics", "annotation", "annotation-xml", "mprescripts", "none"]);
      var text4 = freeze(["#text"]);
      var html2 = freeze(["accept", "action", "align", "alt", "autocapitalize", "autocomplete", "autopictureinpicture", "autoplay", "background", "bgcolor", "border", "capture", "cellpadding", "cellspacing", "checked", "cite", "class", "clear", "color", "cols", "colspan", "controls", "controlslist", "coords", "crossorigin", "datetime", "decoding", "default", "dir", "disabled", "disablepictureinpicture", "disableremoteplayback", "download", "draggable", "enctype", "enterkeyhint", "face", "for", "headers", "height", "hidden", "high", "href", "hreflang", "id", "inputmode", "integrity", "ismap", "kind", "label", "lang", "list", "loading", "loop", "low", "max", "maxlength", "media", "method", "min", "minlength", "multiple", "muted", "name", "nonce", "noshade", "novalidate", "nowrap", "open", "optimum", "pattern", "placeholder", "playsinline", "poster", "preload", "pubdate", "radiogroup", "readonly", "rel", "required", "rev", "reversed", "role", "rows", "rowspan", "spellcheck", "scope", "selected", "shape", "size", "sizes", "span", "srclang", "start", "src", "srcset", "step", "style", "summary", "tabindex", "title", "translate", "type", "usemap", "valign", "value", "width", "xmlns", "slot"]);
      var svg2 = freeze(["accent-height", "accumulate", "additive", "alignment-baseline", "ascent", "attributename", "attributetype", "azimuth", "basefrequency", "baseline-shift", "begin", "bias", "by", "class", "clip", "clippathunits", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "cx", "cy", "d", "dx", "dy", "diffuseconstant", "direction", "display", "divisor", "dur", "edgemode", "elevation", "end", "fill", "fill-opacity", "fill-rule", "filter", "filterunits", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "fx", "fy", "g1", "g2", "glyph-name", "glyphref", "gradientunits", "gradienttransform", "height", "href", "id", "image-rendering", "in", "in2", "k", "k1", "k2", "k3", "k4", "kerning", "keypoints", "keysplines", "keytimes", "lang", "lengthadjust", "letter-spacing", "kernelmatrix", "kernelunitlength", "lighting-color", "local", "marker-end", "marker-mid", "marker-start", "markerheight", "markerunits", "markerwidth", "maskcontentunits", "maskunits", "max", "mask", "media", "method", "mode", "min", "name", "numoctaves", "offset", "operator", "opacity", "order", "orient", "orientation", "origin", "overflow", "paint-order", "path", "pathlength", "patterncontentunits", "patterntransform", "patternunits", "points", "preservealpha", "preserveaspectratio", "primitiveunits", "r", "rx", "ry", "radius", "refx", "refy", "repeatcount", "repeatdur", "restart", "result", "rotate", "scale", "seed", "shape-rendering", "specularconstant", "specularexponent", "spreadmethod", "startoffset", "stddeviation", "stitchtiles", "stop-color", "stop-opacity", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke", "stroke-width", "style", "surfacescale", "systemlanguage", "tabindex", "targetx", "targety", "transform", "transform-origin", "text-anchor", "text-decoration", "text-rendering", "textlength", "type", "u1", "u2", "unicode", "values", "viewbox", "visibility", "version", "vert-adv-y", "vert-origin-x", "vert-origin-y", "width", "word-spacing", "wrap", "writing-mode", "xchannelselector", "ychannelselector", "x", "x1", "x2", "xmlns", "y", "y1", "y2", "z", "zoomandpan"]);
      var mathMl = freeze(["accent", "accentunder", "align", "bevelled", "close", "columnsalign", "columnlines", "columnspan", "denomalign", "depth", "dir", "display", "displaystyle", "encoding", "fence", "frame", "height", "href", "id", "largeop", "length", "linethickness", "lspace", "lquote", "mathbackground", "mathcolor", "mathsize", "mathvariant", "maxsize", "minsize", "movablelimits", "notation", "numalign", "open", "rowalign", "rowlines", "rowspacing", "rowspan", "rspace", "rquote", "scriptlevel", "scriptminsize", "scriptsizemultiplier", "selection", "separator", "separators", "stretchy", "subscriptshift", "supscriptshift", "symmetric", "voffset", "width", "xmlns"]);
      var xml = freeze(["xlink:href", "xml:id", "xlink:title", "xml:space", "xmlns:xlink"]);
      var MUSTACHE_EXPR = seal(/\{\{[\w\W]*|[\w\W]*\}\}/gm);
      var ERB_EXPR = seal(/<%[\w\W]*|[\w\W]*%>/gm);
      var TMPLIT_EXPR = seal(/\${[\w\W]*}/gm);
      var DATA_ATTR = seal(/^data-[\-\w.\u00B7-\uFFFF]/);
      var ARIA_ATTR = seal(/^aria-[\-\w]+$/);
      var IS_ALLOWED_URI = seal(
        /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i
        // eslint-disable-line no-useless-escape
      );
      var IS_SCRIPT_OR_DATA = seal(/^(?:\w+script|data):/i);
      var ATTR_WHITESPACE = seal(
        /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g
        // eslint-disable-line no-control-regex
      );
      var DOCTYPE_NAME = seal(/^html$/i);
      var getGlobal = function getGlobal2() {
        return typeof window === "undefined" ? null : window;
      };
      var _createTrustedTypesPolicy = function _createTrustedTypesPolicy2(trustedTypes, document4) {
        if (_typeof3(trustedTypes) !== "object" || typeof trustedTypes.createPolicy !== "function") {
          return null;
        }
        var suffix = null;
        var ATTR_NAME = "data-tt-policy-suffix";
        if (document4.currentScript && document4.currentScript.hasAttribute(ATTR_NAME)) {
          suffix = document4.currentScript.getAttribute(ATTR_NAME);
        }
        var policyName = "dompurify" + (suffix ? "#" + suffix : "");
        try {
          return trustedTypes.createPolicy(policyName, {
            createHTML: function createHTML(html3) {
              return html3;
            },
            createScriptURL: function createScriptURL(scriptUrl) {
              return scriptUrl;
            }
          });
        } catch (_2) {
          console.warn("TrustedTypes policy " + policyName + " could not be created.");
          return null;
        }
      };
      function createDOMPurify() {
        var window2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : getGlobal();
        var DOMPurify = function DOMPurify2(root2) {
          return createDOMPurify(root2);
        };
        DOMPurify.version = "2.4.7";
        DOMPurify.removed = [];
        if (!window2 || !window2.document || window2.document.nodeType !== 9) {
          DOMPurify.isSupported = false;
          return DOMPurify;
        }
        var originalDocument = window2.document;
        var document4 = window2.document;
        var DocumentFragment2 = window2.DocumentFragment, HTMLTemplateElement = window2.HTMLTemplateElement, Node3 = window2.Node, Element3 = window2.Element, NodeFilter = window2.NodeFilter, _window$NamedNodeMap = window2.NamedNodeMap, NamedNodeMap = _window$NamedNodeMap === void 0 ? window2.NamedNodeMap || window2.MozNamedAttrMap : _window$NamedNodeMap, HTMLFormElement = window2.HTMLFormElement, DOMParser2 = window2.DOMParser, trustedTypes = window2.trustedTypes;
        var ElementPrototype = Element3.prototype;
        var cloneNode = lookupGetter(ElementPrototype, "cloneNode");
        var getNextSibling = lookupGetter(ElementPrototype, "nextSibling");
        var getChildNodes = lookupGetter(ElementPrototype, "childNodes");
        var getParentNode = lookupGetter(ElementPrototype, "parentNode");
        if (typeof HTMLTemplateElement === "function") {
          var template = document4.createElement("template");
          if (template.content && template.content.ownerDocument) {
            document4 = template.content.ownerDocument;
          }
        }
        var trustedTypesPolicy = _createTrustedTypesPolicy(trustedTypes, originalDocument);
        var emptyHTML = trustedTypesPolicy ? trustedTypesPolicy.createHTML("") : "";
        var _document = document4, implementation = _document.implementation, createNodeIterator = _document.createNodeIterator, createDocumentFragment = _document.createDocumentFragment, getElementsByTagName = _document.getElementsByTagName;
        var importNode = originalDocument.importNode;
        var documentMode = {};
        try {
          documentMode = clone(document4).documentMode ? document4.documentMode : {};
        } catch (_2) {
        }
        var hooks2 = {};
        DOMPurify.isSupported = typeof getParentNode === "function" && implementation && implementation.createHTMLDocument !== void 0 && documentMode !== 9;
        var MUSTACHE_EXPR$1 = MUSTACHE_EXPR, ERB_EXPR$1 = ERB_EXPR, TMPLIT_EXPR$1 = TMPLIT_EXPR, DATA_ATTR$1 = DATA_ATTR, ARIA_ATTR$1 = ARIA_ATTR, IS_SCRIPT_OR_DATA$1 = IS_SCRIPT_OR_DATA, ATTR_WHITESPACE$1 = ATTR_WHITESPACE;
        var IS_ALLOWED_URI$1 = IS_ALLOWED_URI;
        var ALLOWED_TAGS = null;
        var DEFAULT_ALLOWED_TAGS = addToSet({}, [].concat(_toConsumableArray(html$1), _toConsumableArray(svg$1), _toConsumableArray(svgFilters), _toConsumableArray(mathMl$1), _toConsumableArray(text4)));
        var ALLOWED_ATTR = null;
        var DEFAULT_ALLOWED_ATTR = addToSet({}, [].concat(_toConsumableArray(html2), _toConsumableArray(svg2), _toConsumableArray(mathMl), _toConsumableArray(xml)));
        var CUSTOM_ELEMENT_HANDLING = Object.seal(Object.create(null, {
          tagNameCheck: {
            writable: true,
            configurable: false,
            enumerable: true,
            value: null
          },
          attributeNameCheck: {
            writable: true,
            configurable: false,
            enumerable: true,
            value: null
          },
          allowCustomizedBuiltInElements: {
            writable: true,
            configurable: false,
            enumerable: true,
            value: false
          }
        }));
        var FORBID_TAGS = null;
        var FORBID_ATTR = null;
        var ALLOW_ARIA_ATTR = true;
        var ALLOW_DATA_ATTR = true;
        var ALLOW_UNKNOWN_PROTOCOLS = false;
        var ALLOW_SELF_CLOSE_IN_ATTR = true;
        var SAFE_FOR_TEMPLATES = false;
        var WHOLE_DOCUMENT = false;
        var SET_CONFIG = false;
        var FORCE_BODY = false;
        var RETURN_DOM = false;
        var RETURN_DOM_FRAGMENT = false;
        var RETURN_TRUSTED_TYPE = false;
        var SANITIZE_DOM = true;
        var SANITIZE_NAMED_PROPS = false;
        var SANITIZE_NAMED_PROPS_PREFIX = "user-content-";
        var KEEP_CONTENT = true;
        var IN_PLACE = false;
        var USE_PROFILES = {};
        var FORBID_CONTENTS = null;
        var DEFAULT_FORBID_CONTENTS = addToSet({}, ["annotation-xml", "audio", "colgroup", "desc", "foreignobject", "head", "iframe", "math", "mi", "mn", "mo", "ms", "mtext", "noembed", "noframes", "noscript", "plaintext", "script", "style", "svg", "template", "thead", "title", "video", "xmp"]);
        var DATA_URI_TAGS = null;
        var DEFAULT_DATA_URI_TAGS = addToSet({}, ["audio", "video", "img", "source", "image", "track"]);
        var URI_SAFE_ATTRIBUTES = null;
        var DEFAULT_URI_SAFE_ATTRIBUTES = addToSet({}, ["alt", "class", "for", "id", "label", "name", "pattern", "placeholder", "role", "summary", "title", "value", "style", "xmlns"]);
        var MATHML_NAMESPACE = "http://www.w3.org/1998/Math/MathML";
        var SVG_NAMESPACE = "http://www.w3.org/2000/svg";
        var HTML_NAMESPACE = "http://www.w3.org/1999/xhtml";
        var NAMESPACE = HTML_NAMESPACE;
        var IS_EMPTY_INPUT = false;
        var ALLOWED_NAMESPACES = null;
        var DEFAULT_ALLOWED_NAMESPACES = addToSet({}, [MATHML_NAMESPACE, SVG_NAMESPACE, HTML_NAMESPACE], stringToString);
        var PARSER_MEDIA_TYPE;
        var SUPPORTED_PARSER_MEDIA_TYPES = ["application/xhtml+xml", "text/html"];
        var DEFAULT_PARSER_MEDIA_TYPE = "text/html";
        var transformCaseFunc;
        var CONFIG = null;
        var formElement = document4.createElement("form");
        var isRegexOrFunction = function isRegexOrFunction2(testValue) {
          return testValue instanceof RegExp || testValue instanceof Function;
        };
        var _parseConfig = function _parseConfig2(cfg) {
          if (CONFIG && CONFIG === cfg) {
            return;
          }
          if (!cfg || _typeof3(cfg) !== "object") {
            cfg = {};
          }
          cfg = clone(cfg);
          PARSER_MEDIA_TYPE = // eslint-disable-next-line unicorn/prefer-includes
          SUPPORTED_PARSER_MEDIA_TYPES.indexOf(cfg.PARSER_MEDIA_TYPE) === -1 ? PARSER_MEDIA_TYPE = DEFAULT_PARSER_MEDIA_TYPE : PARSER_MEDIA_TYPE = cfg.PARSER_MEDIA_TYPE;
          transformCaseFunc = PARSER_MEDIA_TYPE === "application/xhtml+xml" ? stringToString : stringToLowerCase;
          ALLOWED_TAGS = "ALLOWED_TAGS" in cfg ? addToSet({}, cfg.ALLOWED_TAGS, transformCaseFunc) : DEFAULT_ALLOWED_TAGS;
          ALLOWED_ATTR = "ALLOWED_ATTR" in cfg ? addToSet({}, cfg.ALLOWED_ATTR, transformCaseFunc) : DEFAULT_ALLOWED_ATTR;
          ALLOWED_NAMESPACES = "ALLOWED_NAMESPACES" in cfg ? addToSet({}, cfg.ALLOWED_NAMESPACES, stringToString) : DEFAULT_ALLOWED_NAMESPACES;
          URI_SAFE_ATTRIBUTES = "ADD_URI_SAFE_ATTR" in cfg ? addToSet(
            clone(DEFAULT_URI_SAFE_ATTRIBUTES),
            // eslint-disable-line indent
            cfg.ADD_URI_SAFE_ATTR,
            // eslint-disable-line indent
            transformCaseFunc
            // eslint-disable-line indent
          ) : DEFAULT_URI_SAFE_ATTRIBUTES;
          DATA_URI_TAGS = "ADD_DATA_URI_TAGS" in cfg ? addToSet(
            clone(DEFAULT_DATA_URI_TAGS),
            // eslint-disable-line indent
            cfg.ADD_DATA_URI_TAGS,
            // eslint-disable-line indent
            transformCaseFunc
            // eslint-disable-line indent
          ) : DEFAULT_DATA_URI_TAGS;
          FORBID_CONTENTS = "FORBID_CONTENTS" in cfg ? addToSet({}, cfg.FORBID_CONTENTS, transformCaseFunc) : DEFAULT_FORBID_CONTENTS;
          FORBID_TAGS = "FORBID_TAGS" in cfg ? addToSet({}, cfg.FORBID_TAGS, transformCaseFunc) : {};
          FORBID_ATTR = "FORBID_ATTR" in cfg ? addToSet({}, cfg.FORBID_ATTR, transformCaseFunc) : {};
          USE_PROFILES = "USE_PROFILES" in cfg ? cfg.USE_PROFILES : false;
          ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false;
          ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false;
          ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false;
          ALLOW_SELF_CLOSE_IN_ATTR = cfg.ALLOW_SELF_CLOSE_IN_ATTR !== false;
          SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false;
          WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false;
          RETURN_DOM = cfg.RETURN_DOM || false;
          RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false;
          RETURN_TRUSTED_TYPE = cfg.RETURN_TRUSTED_TYPE || false;
          FORCE_BODY = cfg.FORCE_BODY || false;
          SANITIZE_DOM = cfg.SANITIZE_DOM !== false;
          SANITIZE_NAMED_PROPS = cfg.SANITIZE_NAMED_PROPS || false;
          KEEP_CONTENT = cfg.KEEP_CONTENT !== false;
          IN_PLACE = cfg.IN_PLACE || false;
          IS_ALLOWED_URI$1 = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI$1;
          NAMESPACE = cfg.NAMESPACE || HTML_NAMESPACE;
          CUSTOM_ELEMENT_HANDLING = cfg.CUSTOM_ELEMENT_HANDLING || {};
          if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck)) {
            CUSTOM_ELEMENT_HANDLING.tagNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck;
          }
          if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck)) {
            CUSTOM_ELEMENT_HANDLING.attributeNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck;
          }
          if (cfg.CUSTOM_ELEMENT_HANDLING && typeof cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements === "boolean") {
            CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements = cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements;
          }
          if (SAFE_FOR_TEMPLATES) {
            ALLOW_DATA_ATTR = false;
          }
          if (RETURN_DOM_FRAGMENT) {
            RETURN_DOM = true;
          }
          if (USE_PROFILES) {
            ALLOWED_TAGS = addToSet({}, _toConsumableArray(text4));
            ALLOWED_ATTR = [];
            if (USE_PROFILES.html === true) {
              addToSet(ALLOWED_TAGS, html$1);
              addToSet(ALLOWED_ATTR, html2);
            }
            if (USE_PROFILES.svg === true) {
              addToSet(ALLOWED_TAGS, svg$1);
              addToSet(ALLOWED_ATTR, svg2);
              addToSet(ALLOWED_ATTR, xml);
            }
            if (USE_PROFILES.svgFilters === true) {
              addToSet(ALLOWED_TAGS, svgFilters);
              addToSet(ALLOWED_ATTR, svg2);
              addToSet(ALLOWED_ATTR, xml);
            }
            if (USE_PROFILES.mathMl === true) {
              addToSet(ALLOWED_TAGS, mathMl$1);
              addToSet(ALLOWED_ATTR, mathMl);
              addToSet(ALLOWED_ATTR, xml);
            }
          }
          if (cfg.ADD_TAGS) {
            if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) {
              ALLOWED_TAGS = clone(ALLOWED_TAGS);
            }
            addToSet(ALLOWED_TAGS, cfg.ADD_TAGS, transformCaseFunc);
          }
          if (cfg.ADD_ATTR) {
            if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) {
              ALLOWED_ATTR = clone(ALLOWED_ATTR);
            }
            addToSet(ALLOWED_ATTR, cfg.ADD_ATTR, transformCaseFunc);
          }
          if (cfg.ADD_URI_SAFE_ATTR) {
            addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR, transformCaseFunc);
          }
          if (cfg.FORBID_CONTENTS) {
            if (FORBID_CONTENTS === DEFAULT_FORBID_CONTENTS) {
              FORBID_CONTENTS = clone(FORBID_CONTENTS);
            }
            addToSet(FORBID_CONTENTS, cfg.FORBID_CONTENTS, transformCaseFunc);
          }
          if (KEEP_CONTENT) {
            ALLOWED_TAGS["#text"] = true;
          }
          if (WHOLE_DOCUMENT) {
            addToSet(ALLOWED_TAGS, ["html", "head", "body"]);
          }
          if (ALLOWED_TAGS.table) {
            addToSet(ALLOWED_TAGS, ["tbody"]);
            delete FORBID_TAGS.tbody;
          }
          if (freeze) {
            freeze(cfg);
          }
          CONFIG = cfg;
        };
        var MATHML_TEXT_INTEGRATION_POINTS = addToSet({}, ["mi", "mo", "mn", "ms", "mtext"]);
        var HTML_INTEGRATION_POINTS = addToSet({}, ["foreignobject", "desc", "title", "annotation-xml"]);
        var COMMON_SVG_AND_HTML_ELEMENTS = addToSet({}, ["title", "style", "font", "a", "script"]);
        var ALL_SVG_TAGS = addToSet({}, svg$1);
        addToSet(ALL_SVG_TAGS, svgFilters);
        addToSet(ALL_SVG_TAGS, svgDisallowed);
        var ALL_MATHML_TAGS = addToSet({}, mathMl$1);
        addToSet(ALL_MATHML_TAGS, mathMlDisallowed);
        var _checkValidNamespace = function _checkValidNamespace2(element2) {
          var parent = getParentNode(element2);
          if (!parent || !parent.tagName) {
            parent = {
              namespaceURI: NAMESPACE,
              tagName: "template"
            };
          }
          var tagName = stringToLowerCase(element2.tagName);
          var parentTagName = stringToLowerCase(parent.tagName);
          if (!ALLOWED_NAMESPACES[element2.namespaceURI]) {
            return false;
          }
          if (element2.namespaceURI === SVG_NAMESPACE) {
            if (parent.namespaceURI === HTML_NAMESPACE) {
              return tagName === "svg";
            }
            if (parent.namespaceURI === MATHML_NAMESPACE) {
              return tagName === "svg" && (parentTagName === "annotation-xml" || MATHML_TEXT_INTEGRATION_POINTS[parentTagName]);
            }
            return Boolean(ALL_SVG_TAGS[tagName]);
          }
          if (element2.namespaceURI === MATHML_NAMESPACE) {
            if (parent.namespaceURI === HTML_NAMESPACE) {
              return tagName === "math";
            }
            if (parent.namespaceURI === SVG_NAMESPACE) {
              return tagName === "math" && HTML_INTEGRATION_POINTS[parentTagName];
            }
            return Boolean(ALL_MATHML_TAGS[tagName]);
          }
          if (element2.namespaceURI === HTML_NAMESPACE) {
            if (parent.namespaceURI === SVG_NAMESPACE && !HTML_INTEGRATION_POINTS[parentTagName]) {
              return false;
            }
            if (parent.namespaceURI === MATHML_NAMESPACE && !MATHML_TEXT_INTEGRATION_POINTS[parentTagName]) {
              return false;
            }
            return !ALL_MATHML_TAGS[tagName] && (COMMON_SVG_AND_HTML_ELEMENTS[tagName] || !ALL_SVG_TAGS[tagName]);
          }
          if (PARSER_MEDIA_TYPE === "application/xhtml+xml" && ALLOWED_NAMESPACES[element2.namespaceURI]) {
            return true;
          }
          return false;
        };
        var _forceRemove = function _forceRemove2(node3) {
          arrayPush(DOMPurify.removed, {
            element: node3
          });
          try {
            node3.parentNode.removeChild(node3);
          } catch (_2) {
            try {
              node3.outerHTML = emptyHTML;
            } catch (_3) {
              node3.remove();
            }
          }
        };
        var _removeAttribute = function _removeAttribute2(name, node3) {
          try {
            arrayPush(DOMPurify.removed, {
              attribute: node3.getAttributeNode(name),
              from: node3
            });
          } catch (_2) {
            arrayPush(DOMPurify.removed, {
              attribute: null,
              from: node3
            });
          }
          node3.removeAttribute(name);
          if (name === "is" && !ALLOWED_ATTR[name]) {
            if (RETURN_DOM || RETURN_DOM_FRAGMENT) {
              try {
                _forceRemove(node3);
              } catch (_2) {
              }
            } else {
              try {
                node3.setAttribute(name, "");
              } catch (_2) {
              }
            }
          }
        };
        var _initDocument = function _initDocument2(dirty) {
          var doc;
          var leadingWhitespace;
          if (FORCE_BODY) {
            dirty = "<remove></remove>" + dirty;
          } else {
            var matches = stringMatch(dirty, /^[\r\n\t ]+/);
            leadingWhitespace = matches && matches[0];
          }
          if (PARSER_MEDIA_TYPE === "application/xhtml+xml" && NAMESPACE === HTML_NAMESPACE) {
            dirty = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + dirty + "</body></html>";
          }
          var dirtyPayload = trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;
          if (NAMESPACE === HTML_NAMESPACE) {
            try {
              doc = new DOMParser2().parseFromString(dirtyPayload, PARSER_MEDIA_TYPE);
            } catch (_2) {
            }
          }
          if (!doc || !doc.documentElement) {
            doc = implementation.createDocument(NAMESPACE, "template", null);
            try {
              doc.documentElement.innerHTML = IS_EMPTY_INPUT ? emptyHTML : dirtyPayload;
            } catch (_2) {
            }
          }
          var body = doc.body || doc.documentElement;
          if (dirty && leadingWhitespace) {
            body.insertBefore(document4.createTextNode(leadingWhitespace), body.childNodes[0] || null);
          }
          if (NAMESPACE === HTML_NAMESPACE) {
            return getElementsByTagName.call(doc, WHOLE_DOCUMENT ? "html" : "body")[0];
          }
          return WHOLE_DOCUMENT ? doc.documentElement : body;
        };
        var _createIterator = function _createIterator2(root2) {
          return createNodeIterator.call(
            root2.ownerDocument || root2,
            root2,
            // eslint-disable-next-line no-bitwise
            NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT,
            null,
            false
          );
        };
        var _isClobbered = function _isClobbered2(elm) {
          return elm instanceof HTMLFormElement && (typeof elm.nodeName !== "string" || typeof elm.textContent !== "string" || typeof elm.removeChild !== "function" || !(elm.attributes instanceof NamedNodeMap) || typeof elm.removeAttribute !== "function" || typeof elm.setAttribute !== "function" || typeof elm.namespaceURI !== "string" || typeof elm.insertBefore !== "function" || typeof elm.hasChildNodes !== "function");
        };
        var _isNode = function _isNode2(object) {
          return _typeof3(Node3) === "object" ? object instanceof Node3 : object && _typeof3(object) === "object" && typeof object.nodeType === "number" && typeof object.nodeName === "string";
        };
        var _executeHook = function _executeHook2(entryPoint, currentNode, data2) {
          if (!hooks2[entryPoint]) {
            return;
          }
          arrayForEach(hooks2[entryPoint], function(hook) {
            hook.call(DOMPurify, currentNode, data2, CONFIG);
          });
        };
        var _sanitizeElements = function _sanitizeElements2(currentNode) {
          var content3;
          _executeHook("beforeSanitizeElements", currentNode, null);
          if (_isClobbered(currentNode)) {
            _forceRemove(currentNode);
            return true;
          }
          if (regExpTest(/[\u0080-\uFFFF]/, currentNode.nodeName)) {
            _forceRemove(currentNode);
            return true;
          }
          var tagName = transformCaseFunc(currentNode.nodeName);
          _executeHook("uponSanitizeElement", currentNode, {
            tagName,
            allowedTags: ALLOWED_TAGS
          });
          if (currentNode.hasChildNodes() && !_isNode(currentNode.firstElementChild) && (!_isNode(currentNode.content) || !_isNode(currentNode.content.firstElementChild)) && regExpTest(/<[/\w]/g, currentNode.innerHTML) && regExpTest(/<[/\w]/g, currentNode.textContent)) {
            _forceRemove(currentNode);
            return true;
          }
          if (tagName === "select" && regExpTest(/<template/i, currentNode.innerHTML)) {
            _forceRemove(currentNode);
            return true;
          }
          if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
            if (!FORBID_TAGS[tagName] && _basicCustomElementTest(tagName)) {
              if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, tagName))
                return false;
              if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(tagName))
                return false;
            }
            if (KEEP_CONTENT && !FORBID_CONTENTS[tagName]) {
              var parentNode = getParentNode(currentNode) || currentNode.parentNode;
              var childNodes = getChildNodes(currentNode) || currentNode.childNodes;
              if (childNodes && parentNode) {
                var childCount = childNodes.length;
                for (var i2 = childCount - 1; i2 >= 0; --i2) {
                  parentNode.insertBefore(cloneNode(childNodes[i2], true), getNextSibling(currentNode));
                }
              }
            }
            _forceRemove(currentNode);
            return true;
          }
          if (currentNode instanceof Element3 && !_checkValidNamespace(currentNode)) {
            _forceRemove(currentNode);
            return true;
          }
          if ((tagName === "noscript" || tagName === "noembed" || tagName === "noframes") && regExpTest(/<\/no(script|embed|frames)/i, currentNode.innerHTML)) {
            _forceRemove(currentNode);
            return true;
          }
          if (SAFE_FOR_TEMPLATES && currentNode.nodeType === 3) {
            content3 = currentNode.textContent;
            content3 = stringReplace(content3, MUSTACHE_EXPR$1, " ");
            content3 = stringReplace(content3, ERB_EXPR$1, " ");
            content3 = stringReplace(content3, TMPLIT_EXPR$1, " ");
            if (currentNode.textContent !== content3) {
              arrayPush(DOMPurify.removed, {
                element: currentNode.cloneNode()
              });
              currentNode.textContent = content3;
            }
          }
          _executeHook("afterSanitizeElements", currentNode, null);
          return false;
        };
        var _isValidAttribute = function _isValidAttribute2(lcTag, lcName, value) {
          if (SANITIZE_DOM && (lcName === "id" || lcName === "name") && (value in document4 || value in formElement)) {
            return false;
          }
          if (ALLOW_DATA_ATTR && !FORBID_ATTR[lcName] && regExpTest(DATA_ATTR$1, lcName))
            ;
          else if (ALLOW_ARIA_ATTR && regExpTest(ARIA_ATTR$1, lcName))
            ;
          else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {
            if (
              // First condition does a very basic check if a) it's basically a valid custom element tagname AND
              // b) if the tagName passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
              // and c) if the attribute name passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.attributeNameCheck
              _basicCustomElementTest(lcTag) && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, lcTag) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(lcTag)) && (CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.attributeNameCheck, lcName) || CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.attributeNameCheck(lcName)) || // Alternative, second condition checks if it's an `is`-attribute, AND
              // the value passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
              lcName === "is" && CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, value) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(value))
            )
              ;
            else {
              return false;
            }
          } else if (URI_SAFE_ATTRIBUTES[lcName])
            ;
          else if (regExpTest(IS_ALLOWED_URI$1, stringReplace(value, ATTR_WHITESPACE$1, "")))
            ;
          else if ((lcName === "src" || lcName === "xlink:href" || lcName === "href") && lcTag !== "script" && stringIndexOf(value, "data:") === 0 && DATA_URI_TAGS[lcTag])
            ;
          else if (ALLOW_UNKNOWN_PROTOCOLS && !regExpTest(IS_SCRIPT_OR_DATA$1, stringReplace(value, ATTR_WHITESPACE$1, "")))
            ;
          else if (value) {
            return false;
          } else
            ;
          return true;
        };
        var _basicCustomElementTest = function _basicCustomElementTest2(tagName) {
          return tagName.indexOf("-") > 0;
        };
        var _sanitizeAttributes = function _sanitizeAttributes2(currentNode) {
          var attr2;
          var value;
          var lcName;
          var l2;
          _executeHook("beforeSanitizeAttributes", currentNode, null);
          var attributes = currentNode.attributes;
          if (!attributes) {
            return;
          }
          var hookEvent = {
            attrName: "",
            attrValue: "",
            keepAttr: true,
            allowedAttributes: ALLOWED_ATTR
          };
          l2 = attributes.length;
          while (l2--) {
            attr2 = attributes[l2];
            var _attr = attr2, name = _attr.name, namespaceURI = _attr.namespaceURI;
            value = name === "value" ? attr2.value : stringTrim(attr2.value);
            lcName = transformCaseFunc(name);
            hookEvent.attrName = lcName;
            hookEvent.attrValue = value;
            hookEvent.keepAttr = true;
            hookEvent.forceKeepAttr = void 0;
            _executeHook("uponSanitizeAttribute", currentNode, hookEvent);
            value = hookEvent.attrValue;
            if (hookEvent.forceKeepAttr) {
              continue;
            }
            _removeAttribute(name, currentNode);
            if (!hookEvent.keepAttr) {
              continue;
            }
            if (!ALLOW_SELF_CLOSE_IN_ATTR && regExpTest(/\/>/i, value)) {
              _removeAttribute(name, currentNode);
              continue;
            }
            if (SAFE_FOR_TEMPLATES) {
              value = stringReplace(value, MUSTACHE_EXPR$1, " ");
              value = stringReplace(value, ERB_EXPR$1, " ");
              value = stringReplace(value, TMPLIT_EXPR$1, " ");
            }
            var lcTag = transformCaseFunc(currentNode.nodeName);
            if (!_isValidAttribute(lcTag, lcName, value)) {
              continue;
            }
            if (SANITIZE_NAMED_PROPS && (lcName === "id" || lcName === "name")) {
              _removeAttribute(name, currentNode);
              value = SANITIZE_NAMED_PROPS_PREFIX + value;
            }
            if (trustedTypesPolicy && _typeof3(trustedTypes) === "object" && typeof trustedTypes.getAttributeType === "function") {
              if (namespaceURI)
                ;
              else {
                switch (trustedTypes.getAttributeType(lcTag, lcName)) {
                  case "TrustedHTML": {
                    value = trustedTypesPolicy.createHTML(value);
                    break;
                  }
                  case "TrustedScriptURL": {
                    value = trustedTypesPolicy.createScriptURL(value);
                    break;
                  }
                }
              }
            }
            try {
              if (namespaceURI) {
                currentNode.setAttributeNS(namespaceURI, name, value);
              } else {
                currentNode.setAttribute(name, value);
              }
              arrayPop(DOMPurify.removed);
            } catch (_2) {
            }
          }
          _executeHook("afterSanitizeAttributes", currentNode, null);
        };
        var _sanitizeShadowDOM = function _sanitizeShadowDOM2(fragment) {
          var shadowNode;
          var shadowIterator = _createIterator(fragment);
          _executeHook("beforeSanitizeShadowDOM", fragment, null);
          while (shadowNode = shadowIterator.nextNode()) {
            _executeHook("uponSanitizeShadowNode", shadowNode, null);
            if (_sanitizeElements(shadowNode)) {
              continue;
            }
            if (shadowNode.content instanceof DocumentFragment2) {
              _sanitizeShadowDOM2(shadowNode.content);
            }
            _sanitizeAttributes(shadowNode);
          }
          _executeHook("afterSanitizeShadowDOM", fragment, null);
        };
        DOMPurify.sanitize = function(dirty) {
          var cfg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          var body;
          var importedNode;
          var currentNode;
          var oldNode;
          var returnNode;
          IS_EMPTY_INPUT = !dirty;
          if (IS_EMPTY_INPUT) {
            dirty = "<!-->";
          }
          if (typeof dirty !== "string" && !_isNode(dirty)) {
            if (typeof dirty.toString === "function") {
              dirty = dirty.toString();
              if (typeof dirty !== "string") {
                throw typeErrorCreate("dirty is not a string, aborting");
              }
            } else {
              throw typeErrorCreate("toString is not a function");
            }
          }
          if (!DOMPurify.isSupported) {
            if (_typeof3(window2.toStaticHTML) === "object" || typeof window2.toStaticHTML === "function") {
              if (typeof dirty === "string") {
                return window2.toStaticHTML(dirty);
              }
              if (_isNode(dirty)) {
                return window2.toStaticHTML(dirty.outerHTML);
              }
            }
            return dirty;
          }
          if (!SET_CONFIG) {
            _parseConfig(cfg);
          }
          DOMPurify.removed = [];
          if (typeof dirty === "string") {
            IN_PLACE = false;
          }
          if (IN_PLACE) {
            if (dirty.nodeName) {
              var tagName = transformCaseFunc(dirty.nodeName);
              if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
                throw typeErrorCreate("root node is forbidden and cannot be sanitized in-place");
              }
            }
          } else if (dirty instanceof Node3) {
            body = _initDocument("<!---->");
            importedNode = body.ownerDocument.importNode(dirty, true);
            if (importedNode.nodeType === 1 && importedNode.nodeName === "BODY") {
              body = importedNode;
            } else if (importedNode.nodeName === "HTML") {
              body = importedNode;
            } else {
              body.appendChild(importedNode);
            }
          } else {
            if (!RETURN_DOM && !SAFE_FOR_TEMPLATES && !WHOLE_DOCUMENT && // eslint-disable-next-line unicorn/prefer-includes
            dirty.indexOf("<") === -1) {
              return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(dirty) : dirty;
            }
            body = _initDocument(dirty);
            if (!body) {
              return RETURN_DOM ? null : RETURN_TRUSTED_TYPE ? emptyHTML : "";
            }
          }
          if (body && FORCE_BODY) {
            _forceRemove(body.firstChild);
          }
          var nodeIterator = _createIterator(IN_PLACE ? dirty : body);
          while (currentNode = nodeIterator.nextNode()) {
            if (currentNode.nodeType === 3 && currentNode === oldNode) {
              continue;
            }
            if (_sanitizeElements(currentNode)) {
              continue;
            }
            if (currentNode.content instanceof DocumentFragment2) {
              _sanitizeShadowDOM(currentNode.content);
            }
            _sanitizeAttributes(currentNode);
            oldNode = currentNode;
          }
          oldNode = null;
          if (IN_PLACE) {
            return dirty;
          }
          if (RETURN_DOM) {
            if (RETURN_DOM_FRAGMENT) {
              returnNode = createDocumentFragment.call(body.ownerDocument);
              while (body.firstChild) {
                returnNode.appendChild(body.firstChild);
              }
            } else {
              returnNode = body;
            }
            if (ALLOWED_ATTR.shadowroot || ALLOWED_ATTR.shadowrootmod) {
              returnNode = importNode.call(originalDocument, returnNode, true);
            }
            return returnNode;
          }
          var serializedHTML = WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;
          if (WHOLE_DOCUMENT && ALLOWED_TAGS["!doctype"] && body.ownerDocument && body.ownerDocument.doctype && body.ownerDocument.doctype.name && regExpTest(DOCTYPE_NAME, body.ownerDocument.doctype.name)) {
            serializedHTML = "<!DOCTYPE " + body.ownerDocument.doctype.name + ">\n" + serializedHTML;
          }
          if (SAFE_FOR_TEMPLATES) {
            serializedHTML = stringReplace(serializedHTML, MUSTACHE_EXPR$1, " ");
            serializedHTML = stringReplace(serializedHTML, ERB_EXPR$1, " ");
            serializedHTML = stringReplace(serializedHTML, TMPLIT_EXPR$1, " ");
          }
          return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(serializedHTML) : serializedHTML;
        };
        DOMPurify.setConfig = function(cfg) {
          _parseConfig(cfg);
          SET_CONFIG = true;
        };
        DOMPurify.clearConfig = function() {
          CONFIG = null;
          SET_CONFIG = false;
        };
        DOMPurify.isValidAttribute = function(tag, attr2, value) {
          if (!CONFIG) {
            _parseConfig({});
          }
          var lcTag = transformCaseFunc(tag);
          var lcName = transformCaseFunc(attr2);
          return _isValidAttribute(lcTag, lcName, value);
        };
        DOMPurify.addHook = function(entryPoint, hookFunction) {
          if (typeof hookFunction !== "function") {
            return;
          }
          hooks2[entryPoint] = hooks2[entryPoint] || [];
          arrayPush(hooks2[entryPoint], hookFunction);
        };
        DOMPurify.removeHook = function(entryPoint) {
          if (hooks2[entryPoint]) {
            return arrayPop(hooks2[entryPoint]);
          }
        };
        DOMPurify.removeHooks = function(entryPoint) {
          if (hooks2[entryPoint]) {
            hooks2[entryPoint] = [];
          }
        };
        DOMPurify.removeAllHooks = function() {
          hooks2 = {};
        };
        return DOMPurify;
      }
      var purify = createDOMPurify();
      return purify;
    });
  }
});

// ../simple-mind-map/node_modules/core-js/internals/global.js
var require_global = __commonJS({
  "../simple-mind-map/node_modules/core-js/internals/global.js"(exports, module) {
    "use strict";
    var check = function(it) {
      return it && it.Math === Math && it;
    };
    module.exports = // eslint-disable-next-line es/no-global-this -- safe
    check(typeof globalThis == "object" && globalThis) || check(typeof window == "object" && window) || // eslint-disable-next-line no-restricted-globals -- safe
    check(typeof self == "object" && self) || check(typeof global == "object" && global) || check(typeof exports == "object" && exports) || // eslint-disable-next-line no-new-func -- fallback
    function() {
      return this;
    }() || Function("return this")();
  }
});

// ../simple-mind-map/node_modules/core-js/internals/fails.js
var require_fails = __commonJS({
  "../simple-mind-map/node_modules/core-js/internals/fails.js"(exports, module) {
    "use strict";
    module.exports = function(exec) {
      try {
        return !!exec();
      } catch (error) {
        return true;
      }
    };
  }
});

// ../simple-mind-map/node_modules/core-js/internals/descriptors.js
var require_descriptors = __commonJS({
  "../simple-mind-map/node_modules/core-js/internals/descriptors.js"(exports, module) {
    "use strict";
    var fails = require_fails();
    module.exports = !fails(function() {
      return Object.defineProperty({}, 1, { get: function() {
        return 7;
      } })[1] !== 7;
    });
  }
});

// ../simple-mind-map/node_modules/core-js/internals/function-bind-native.js
var require_function_bind_native = __commonJS({
  "../simple-mind-map/node_modules/core-js/internals/function-bind-native.js"(exports, module) {
    "use strict";
    var fails = require_fails();
    module.exports = !fails(function() {
      var test = function() {
      }.bind();
      return typeof test != "function" || test.hasOwnProperty("prototype");
    });
  }
});

// ../simple-mind-map/node_modules/core-js/internals/function-call.js
var require_function_call = __commonJS({
  "../simple-mind-map/node_modules/core-js/internals/function-call.js"(exports, module) {
    "use strict";
    var NATIVE_BIND = require_function_bind_native();
    var call = Function.prototype.call;
    module.exports = NATIVE_BIND ? call.bind(call) : function() {
      return call.apply(call, arguments);
    };
  }
});

// ../simple-mind-map/node_modules/core-js/internals/object-property-is-enumerable.js
var require_object_property_is_enumerable = __commonJS({
  "../simple-mind-map/node_modules/core-js/internals/object-property-is-enumerable.js"(exports) {
    "use strict";
    var $propertyIsEnumerable = {}.propertyIsEnumerable;
    var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
    var NASHORN_BUG = getOwnPropertyDescriptor && !$propertyIsEnumerable.call({ 1: 2 }, 1);
    exports.f = NASHORN_BUG ? function propertyIsEnumerable(V) {
      var descriptor = getOwnPropertyDescriptor(this, V);
      return !!descriptor && descriptor.enumerable;
    } : $propertyIsEnumerable;
  }
});

// ../simple-mind-map/node_modules/core-js/internals/create-property-descriptor.js
var require_create_property_descriptor = __commonJS({
  "../simple-mind-map/node_modules/core-js/internals/create-property-descriptor.js"(exports, module) {
    "use strict";
    module.exports = function(bitmap, value) {
      return {
        enumerable: !(bitmap & 1),
        configurable: !(bitmap & 2),
        writable: !(bitmap & 4),
        value
      };
    };
  }
});

// ../simple-mind-map/node_modules/core-js/internals/function-uncurry-this.js
var require_function_uncurry_this = __commonJS({
  "../simple-mind-map/node_modules/core-js/internals/function-uncurry-this.js"(exports, module) {
    "use strict";
    var NATIVE_BIND = require_function_bind_native();
    var FunctionPrototype = Function.prototype;
    var call = FunctionPrototype.call;
    var uncurryThisWithBind = NATIVE_BIND && FunctionPrototype.bind.bind(call, call);
    module.exports = NATIVE_BIND ? uncurryThisWithBind : function(fn) {
      return function() {
        return call.apply(fn, arguments);
      };
    };
  }
});

// ../simple-mind-map/node_modules/core-js/internals/classof-raw.js
var require_classof_raw = __commonJS({
  "../simple-mind-map/node_modules/core-js/internals/classof-raw.js"(exports, module) {
    "use strict";
    var uncurryThis = require_function_uncurry_this();
    var toString2 = uncurryThis({}.toString);
    var stringSlice = uncurryThis("".slice);
    module.exports = function(it) {
      return stringSlice(toString2(it), 8, -1);
    };
  }
});

// ../simple-mind-map/node_modules/core-js/internals/indexed-object.js
var require_indexed_object = __commonJS({
  "../simple-mind-map/node_modules/core-js/internals/indexed-object.js"(exports, module) {
    "use strict";
    var uncurryThis = require_function_uncurry_this();
    var fails = require_fails();
    var classof = require_classof_raw();
    var $Object = Object;
    var split = uncurryThis("".split);
    module.exports = fails(function() {
      return !$Object("z").propertyIsEnumerable(0);
    }) ? function(it) {
      return classof(it) === "String" ? split(it, "") : $Object(it);
    } : $Object;
  }
});

// ../simple-mind-map/node_modules/core-js/internals/is-null-or-undefined.js
var require_is_null_or_undefined = __commonJS({
  "../simple-mind-map/node_modules/core-js/internals/is-null-or-undefined.js"(exports, module) {
    "use strict";
    module.exports = function(it) {
      return it === null || it === void 0;
    };
  }
});

// ../simple-mind-map/node_modules/core-js/internals/require-object-coercible.js
var require_require_object_coercible = __commonJS({
  "../simple-mind-map/node_modules/core-js/internals/require-object-coercible.js"(exports, module) {
    "use strict";
    var isNullOrUndefined = require_is_null_or_undefined();
    var $TypeError = TypeError;
    module.exports = function(it) {
      if (isNullOrUndefined(it))
        throw new $TypeError("Can't call method on " + it);
      return it;
    };
  }
});

// ../simple-mind-map/node_modules/core-js/internals/to-indexed-object.js
var require_to_indexed_object = __commonJS({
  "../simple-mind-map/node_modules/core-js/internals/to-indexed-object.js"(exports, module) {
    "use strict";
    var IndexedObject = require_indexed_object();
    var requireObjectCoercible = require_require_object_coercible();
    module.exports = function(it) {
      return IndexedObject(requireObjectCoercible(it));
    };
  }
});

// ../simple-mind-map/node_modules/core-js/internals/document-all.js
var require_document_all = __commonJS({
  "../simple-mind-map/node_modules/core-js/internals/document-all.js"(exports, module) {
    "use strict";
    var documentAll = typeof document == "object" && document.all;
    var IS_HTMLDDA = typeof documentAll == "undefined" && documentAll !== void 0;
    module.exports = {
      all: documentAll,
      IS_HTMLDDA
    };
  }
});

// ../simple-mind-map/node_modules/core-js/internals/is-callable.js
var require_is_callable = __commonJS({
  "../simple-mind-map/node_modules/core-js/internals/is-callable.js"(exports, module) {
    "use strict";
    var $documentAll = require_document_all();
    var documentAll = $documentAll.all;
    module.exports = $documentAll.IS_HTMLDDA ? function(argument) {
      return typeof argument == "function" || argument === documentAll;
    } : function(argument) {
      return typeof argument == "function";
    };
  }
});

// ../simple-mind-map/node_modules/core-js/internals/is-object.js
var require_is_object = __commonJS({
  "../simple-mind-map/node_modules/core-js/internals/is-object.js"(exports, module) {
    "use strict";
    var isCallable = require_is_callable();
    var $documentAll = require_document_all();
    var documentAll = $documentAll.all;
    module.exports = $documentAll.IS_HTMLDDA ? function(it) {
      return typeof it == "object" ? it !== null : isCallable(it) || it === documentAll;
    } : function(it) {
      return typeof it == "object" ? it !== null : isCallable(it);
    };
  }
});

// ../simple-mind-map/node_modules/core-js/internals/get-built-in.js
var require_get_built_in = __commonJS({
  "../simple-mind-map/node_modules/core-js/internals/get-built-in.js"(exports, module) {
    "use strict";
    var global2 = require_global();
    var isCallable = require_is_callable();
    var aFunction = function(argument) {
      return isCallable(argument) ? argument : void 0;
    };
    module.exports = function(namespace, method) {
      return arguments.length < 2 ? aFunction(global2[namespace]) : global2[namespace] && global2[namespace][method];
    };
  }
});

// ../simple-mind-map/node_modules/core-js/internals/object-is-prototype-of.js
var require_object_is_prototype_of = __commonJS({
  "../simple-mind-map/node_modules/core-js/internals/object-is-prototype-of.js"(exports, module) {
    "use strict";
    var uncurryThis = require_function_uncurry_this();
    module.exports = uncurryThis({}.isPrototypeOf);
  }
});

// ../simple-mind-map/node_modules/core-js/internals/engine-user-agent.js
var require_engine_user_agent = __commonJS({
  "../simple-mind-map/node_modules/core-js/internals/engine-user-agent.js"(exports, module) {
    "use strict";
    module.exports = typeof navigator != "undefined" && String(navigator.userAgent) || "";
  }
});

// ../simple-mind-map/node_modules/core-js/internals/engine-v8-version.js
var require_engine_v8_version = __commonJS({
  "../simple-mind-map/node_modules/core-js/internals/engine-v8-version.js"(exports, module) {
    "use strict";
    var global2 = require_global();
    var userAgent = require_engine_user_agent();
    var process2 = global2.process;
    var Deno2 = global2.Deno;
    var versions = process2 && process2.versions || Deno2 && Deno2.version;
    var v8 = versions && versions.v8;
    var match;
    var version;
    if (v8) {
      match = v8.split(".");
      version = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);
    }
    if (!version && userAgent) {
      match = userAgent.match(/Edge\/(\d+)/);
      if (!match || match[1] >= 74) {
        match = userAgent.match(/Chrome\/(\d+)/);
        if (match)
          version = +match[1];
      }
    }
    module.exports = version;
  }
});

// ../simple-mind-map/node_modules/core-js/internals/symbol-constructor-detection.js
var require_symbol_constructor_detection = __commonJS({
  "../simple-mind-map/node_modules/core-js/internals/symbol-constructor-detection.js"(exports, module) {
    "use strict";
    var V8_VERSION = require_engine_v8_version();
    var fails = require_fails();
    var global2 = require_global();
    var $String = global2.String;
    module.exports = !!Object.getOwnPropertySymbols && !fails(function() {
      var symbol = Symbol("symbol detection");
      return !$String(symbol) || !(Object(symbol) instanceof Symbol) || // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
      !Symbol.sham && V8_VERSION && V8_VERSION < 41;
    });
  }
});

// ../simple-mind-map/node_modules/core-js/internals/use-symbol-as-uid.js
var require_use_symbol_as_uid = __commonJS({
  "../simple-mind-map/node_modules/core-js/internals/use-symbol-as-uid.js"(exports, module) {
    "use strict";
    var NATIVE_SYMBOL = require_symbol_constructor_detection();
    module.exports = NATIVE_SYMBOL && !Symbol.sham && typeof Symbol.iterator == "symbol";
  }
});

// ../simple-mind-map/node_modules/core-js/internals/is-symbol.js
var require_is_symbol = __commonJS({
  "../simple-mind-map/node_modules/core-js/internals/is-symbol.js"(exports, module) {
    "use strict";
    var getBuiltIn = require_get_built_in();
    var isCallable = require_is_callable();
    var isPrototypeOf = require_object_is_prototype_of();
    var USE_SYMBOL_AS_UID = require_use_symbol_as_uid();
    var $Object = Object;
    module.exports = USE_SYMBOL_AS_UID ? function(it) {
      return typeof it == "symbol";
    } : function(it) {
      var $Symbol = getBuiltIn("Symbol");
      return isCallable($Symbol) && isPrototypeOf($Symbol.prototype, $Object(it));
    };
  }
});

// ../simple-mind-map/node_modules/core-js/internals/try-to-string.js
var require_try_to_string = __commonJS({
  "../simple-mind-map/node_modules/core-js/internals/try-to-string.js"(exports, module) {
    "use strict";
    var $String = String;
    module.exports = function(argument) {
      try {
        return $String(argument);
      } catch (error) {
        return "Object";
      }
    };
  }
});

// ../simple-mind-map/node_modules/core-js/internals/a-callable.js
var require_a_callable = __commonJS({
  "../simple-mind-map/node_modules/core-js/internals/a-callable.js"(exports, module) {
    "use strict";
    var isCallable = require_is_callable();
    var tryToString = require_try_to_string();
    var $TypeError = TypeError;
    module.exports = function(argument) {
      if (isCallable(argument))
        return argument;
      throw new $TypeError(tryToString(argument) + " is not a function");
    };
  }
});

// ../simple-mind-map/node_modules/core-js/internals/get-method.js
var require_get_method = __commonJS({
  "../simple-mind-map/node_modules/core-js/internals/get-method.js"(exports, module) {
    "use strict";
    var aCallable = require_a_callable();
    var isNullOrUndefined = require_is_null_or_undefined();
    module.exports = function(V, P) {
      var func = V[P];
      return isNullOrUndefined(func) ? void 0 : aCallable(func);
    };
  }
});

// ../simple-mind-map/node_modules/core-js/internals/ordinary-to-primitive.js
var require_ordinary_to_primitive = __commonJS({
  "../simple-mind-map/node_modules/core-js/internals/ordinary-to-primitive.js"(exports, module) {
    "use strict";
    var call = require_function_call();
    var isCallable = require_is_callable();
    var isObject = require_is_object();
    var $TypeError = TypeError;
    module.exports = function(input, pref) {
      var fn, val;
      if (pref === "string" && isCallable(fn = input.toString) && !isObject(val = call(fn, input)))
        return val;
      if (isCallable(fn = input.valueOf) && !isObject(val = call(fn, input)))
        return val;
      if (pref !== "string" && isCallable(fn = input.toString) && !isObject(val = call(fn, input)))
        return val;
      throw new $TypeError("Can't convert object to primitive value");
    };
  }
});

// ../simple-mind-map/node_modules/core-js/internals/is-pure.js
var require_is_pure = __commonJS({
  "../simple-mind-map/node_modules/core-js/internals/is-pure.js"(exports, module) {
    "use strict";
    module.exports = false;
  }
});

// ../simple-mind-map/node_modules/core-js/internals/define-global-property.js
var require_define_global_property = __commonJS({
  "../simple-mind-map/node_modules/core-js/internals/define-global-property.js"(exports, module) {
    "use strict";
    var global2 = require_global();
    var defineProperty = Object.defineProperty;
    module.exports = function(key, value) {
      try {
        defineProperty(global2, key, { value, configurable: true, writable: true });
      } catch (error) {
        global2[key] = value;
      }
      return value;
    };
  }
});

// ../simple-mind-map/node_modules/core-js/internals/shared-store.js
var require_shared_store = __commonJS({
  "../simple-mind-map/node_modules/core-js/internals/shared-store.js"(exports, module) {
    "use strict";
    var global2 = require_global();
    var defineGlobalProperty = require_define_global_property();
    var SHARED = "__core-js_shared__";
    var store = global2[SHARED] || defineGlobalProperty(SHARED, {});
    module.exports = store;
  }
});

// ../simple-mind-map/node_modules/core-js/internals/shared.js
var require_shared = __commonJS({
  "../simple-mind-map/node_modules/core-js/internals/shared.js"(exports, module) {
    "use strict";
    var IS_PURE = require_is_pure();
    var store = require_shared_store();
    (module.exports = function(key, value) {
      return store[key] || (store[key] = value !== void 0 ? value : {});
    })("versions", []).push({
      version: "3.33.3",
      mode: IS_PURE ? "pure" : "global",
      copyright: "\xA9 2014-2023 Denis Pushkarev (zloirock.ru)",
      license: "https://github.com/zloirock/core-js/blob/v3.33.3/LICENSE",
      source: "https://github.com/zloirock/core-js"
    });
  }
});

// ../simple-mind-map/node_modules/core-js/internals/to-object.js
var require_to_object = __commonJS({
  "../simple-mind-map/node_modules/core-js/internals/to-object.js"(exports, module) {
    "use strict";
    var requireObjectCoercible = require_require_object_coercible();
    var $Object = Object;
    module.exports = function(argument) {
      return $Object(requireObjectCoercible(argument));
    };
  }
});

// ../simple-mind-map/node_modules/core-js/internals/has-own-property.js
var require_has_own_property = __commonJS({
  "../simple-mind-map/node_modules/core-js/internals/has-own-property.js"(exports, module) {
    "use strict";
    var uncurryThis = require_function_uncurry_this();
    var toObject = require_to_object();
    var hasOwnProperty2 = uncurryThis({}.hasOwnProperty);
    module.exports = Object.hasOwn || function hasOwn(it, key) {
      return hasOwnProperty2(toObject(it), key);
    };
  }
});

// ../simple-mind-map/node_modules/core-js/internals/uid.js
var require_uid = __commonJS({
  "../simple-mind-map/node_modules/core-js/internals/uid.js"(exports, module) {
    "use strict";
    var uncurryThis = require_function_uncurry_this();
    var id = 0;
    var postfix = Math.random();
    var toString2 = uncurryThis(1 .toString);
    module.exports = function(key) {
      return "Symbol(" + (key === void 0 ? "" : key) + ")_" + toString2(++id + postfix, 36);
    };
  }
});

// ../simple-mind-map/node_modules/core-js/internals/well-known-symbol.js
var require_well_known_symbol = __commonJS({
  "../simple-mind-map/node_modules/core-js/internals/well-known-symbol.js"(exports, module) {
    "use strict";
    var global2 = require_global();
    var shared = require_shared();
    var hasOwn = require_has_own_property();
    var uid = require_uid();
    var NATIVE_SYMBOL = require_symbol_constructor_detection();
    var USE_SYMBOL_AS_UID = require_use_symbol_as_uid();
    var Symbol3 = global2.Symbol;
    var WellKnownSymbolsStore = shared("wks");
    var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol3["for"] || Symbol3 : Symbol3 && Symbol3.withoutSetter || uid;
    module.exports = function(name) {
      if (!hasOwn(WellKnownSymbolsStore, name)) {
        WellKnownSymbolsStore[name] = NATIVE_SYMBOL && hasOwn(Symbol3, name) ? Symbol3[name] : createWellKnownSymbol("Symbol." + name);
      }
      return WellKnownSymbolsStore[name];
    };
  }
});

// ../simple-mind-map/node_modules/core-js/internals/to-primitive.js
var require_to_primitive = __commonJS({
  "../simple-mind-map/node_modules/core-js/internals/to-primitive.js"(exports, module) {
    "use strict";
    var call = require_function_call();
    var isObject = require_is_object();
    var isSymbol = require_is_symbol();
    var getMethod = require_get_method();
    var ordinaryToPrimitive = require_ordinary_to_primitive();
    var wellKnownSymbol = require_well_known_symbol();
    var $TypeError = TypeError;
    var TO_PRIMITIVE = wellKnownSymbol("toPrimitive");
    module.exports = function(input, pref) {
      if (!isObject(input) || isSymbol(input))
        return input;
      var exoticToPrim = getMethod(input, TO_PRIMITIVE);
      var result;
      if (exoticToPrim) {
        if (pref === void 0)
          pref = "default";
        result = call(exoticToPrim, input, pref);
        if (!isObject(result) || isSymbol(result))
          return result;
        throw new $TypeError("Can't convert object to primitive value");
      }
      if (pref === void 0)
        pref = "number";
      return ordinaryToPrimitive(input, pref);
    };
  }
});

// ../simple-mind-map/node_modules/core-js/internals/to-property-key.js
var require_to_property_key = __commonJS({
  "../simple-mind-map/node_modules/core-js/internals/to-property-key.js"(exports, module) {
    "use strict";
    var toPrimitive = require_to_primitive();
    var isSymbol = require_is_symbol();
    module.exports = function(argument) {
      var key = toPrimitive(argument, "string");
      return isSymbol(key) ? key : key + "";
    };
  }
});

// ../simple-mind-map/node_modules/core-js/internals/document-create-element.js
var require_document_create_element = __commonJS({
  "../simple-mind-map/node_modules/core-js/internals/document-create-element.js"(exports, module) {
    "use strict";
    var global2 = require_global();
    var isObject = require_is_object();
    var document4 = global2.document;
    var EXISTS = isObject(document4) && isObject(document4.createElement);
    module.exports = function(it) {
      return EXISTS ? document4.createElement(it) : {};
    };
  }
});

// ../simple-mind-map/node_modules/core-js/internals/ie8-dom-define.js
var require_ie8_dom_define = __commonJS({
  "../simple-mind-map/node_modules/core-js/internals/ie8-dom-define.js"(exports, module) {
    "use strict";
    var DESCRIPTORS = require_descriptors();
    var fails = require_fails();
    var createElement = require_document_create_element();
    module.exports = !DESCRIPTORS && !fails(function() {
      return Object.defineProperty(createElement("div"), "a", {
        get: function() {
          return 7;
        }
      }).a !== 7;
    });
  }
});

// ../simple-mind-map/node_modules/core-js/internals/object-get-own-property-descriptor.js
var require_object_get_own_property_descriptor = __commonJS({
  "../simple-mind-map/node_modules/core-js/internals/object-get-own-property-descriptor.js"(exports) {
    "use strict";
    var DESCRIPTORS = require_descriptors();
    var call = require_function_call();
    var propertyIsEnumerableModule = require_object_property_is_enumerable();
    var createPropertyDescriptor = require_create_property_descriptor();
    var toIndexedObject = require_to_indexed_object();
    var toPropertyKey = require_to_property_key();
    var hasOwn = require_has_own_property();
    var IE8_DOM_DEFINE = require_ie8_dom_define();
    var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
    exports.f = DESCRIPTORS ? $getOwnPropertyDescriptor : function getOwnPropertyDescriptor(O2, P) {
      O2 = toIndexedObject(O2);
      P = toPropertyKey(P);
      if (IE8_DOM_DEFINE)
        try {
          return $getOwnPropertyDescriptor(O2, P);
        } catch (error) {
        }
      if (hasOwn(O2, P))
        return createPropertyDescriptor(!call(propertyIsEnumerableModule.f, O2, P), O2[P]);
    };
  }
});

// ../simple-mind-map/node_modules/core-js/internals/v8-prototype-define-bug.js
var require_v8_prototype_define_bug = __commonJS({
  "../simple-mind-map/node_modules/core-js/internals/v8-prototype-define-bug.js"(exports, module) {
    "use strict";
    var DESCRIPTORS = require_descriptors();
    var fails = require_fails();
    module.exports = DESCRIPTORS && fails(function() {
      return Object.defineProperty(function() {
      }, "prototype", {
        value: 42,
        writable: false
      }).prototype !== 42;
    });
  }
});

// ../simple-mind-map/node_modules/core-js/internals/an-object.js
var require_an_object = __commonJS({
  "../simple-mind-map/node_modules/core-js/internals/an-object.js"(exports, module) {
    "use strict";
    var isObject = require_is_object();
    var $String = String;
    var $TypeError = TypeError;
    module.exports = function(argument) {
      if (isObject(argument))
        return argument;
      throw new $TypeError($String(argument) + " is not an object");
    };
  }
});

// ../simple-mind-map/node_modules/core-js/internals/object-define-property.js
var require_object_define_property = __commonJS({
  "../simple-mind-map/node_modules/core-js/internals/object-define-property.js"(exports) {
    "use strict";
    var DESCRIPTORS = require_descriptors();
    var IE8_DOM_DEFINE = require_ie8_dom_define();
    var V8_PROTOTYPE_DEFINE_BUG = require_v8_prototype_define_bug();
    var anObject = require_an_object();
    var toPropertyKey = require_to_property_key();
    var $TypeError = TypeError;
    var $defineProperty = Object.defineProperty;
    var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
    var ENUMERABLE = "enumerable";
    var CONFIGURABLE = "configurable";
    var WRITABLE = "writable";
    exports.f = DESCRIPTORS ? V8_PROTOTYPE_DEFINE_BUG ? function defineProperty(O2, P, Attributes) {
      anObject(O2);
      P = toPropertyKey(P);
      anObject(Attributes);
      if (typeof O2 === "function" && P === "prototype" && "value" in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {
        var current = $getOwnPropertyDescriptor(O2, P);
        if (current && current[WRITABLE]) {
          O2[P] = Attributes.value;
          Attributes = {
            configurable: CONFIGURABLE in Attributes ? Attributes[CONFIGURABLE] : current[CONFIGURABLE],
            enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],
            writable: false
          };
        }
      }
      return $defineProperty(O2, P, Attributes);
    } : $defineProperty : function defineProperty(O2, P, Attributes) {
      anObject(O2);
      P = toPropertyKey(P);
      anObject(Attributes);
      if (IE8_DOM_DEFINE)
        try {
          return $defineProperty(O2, P, Attributes);
        } catch (error) {
        }
      if ("get" in Attributes || "set" in Attributes)
        throw new $TypeError("Accessors not supported");
      if ("value" in Attributes)
        O2[P] = Attributes.value;
      return O2;
    };
  }
});

// ../simple-mind-map/node_modules/core-js/internals/create-non-enumerable-property.js
var require_create_non_enumerable_property = __commonJS({
  "../simple-mind-map/node_modules/core-js/internals/create-non-enumerable-property.js"(exports, module) {
    "use strict";
    var DESCRIPTORS = require_descriptors();
    var definePropertyModule = require_object_define_property();
    var createPropertyDescriptor = require_create_property_descriptor();
    module.exports = DESCRIPTORS ? function(object, key, value) {
      return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));
    } : function(object, key, value) {
      object[key] = value;
      return object;
    };
  }
});

// ../simple-mind-map/node_modules/core-js/internals/function-name.js
var require_function_name = __commonJS({
  "../simple-mind-map/node_modules/core-js/internals/function-name.js"(exports, module) {
    "use strict";
    var DESCRIPTORS = require_descriptors();
    var hasOwn = require_has_own_property();
    var FunctionPrototype = Function.prototype;
    var getDescriptor = DESCRIPTORS && Object.getOwnPropertyDescriptor;
    var EXISTS = hasOwn(FunctionPrototype, "name");
    var PROPER = EXISTS && function something() {
    }.name === "something";
    var CONFIGURABLE = EXISTS && (!DESCRIPTORS || DESCRIPTORS && getDescriptor(FunctionPrototype, "name").configurable);
    module.exports = {
      EXISTS,
      PROPER,
      CONFIGURABLE
    };
  }
});

// ../simple-mind-map/node_modules/core-js/internals/inspect-source.js
var require_inspect_source = __commonJS({
  "../simple-mind-map/node_modules/core-js/internals/inspect-source.js"(exports, module) {
    "use strict";
    var uncurryThis = require_function_uncurry_this();
    var isCallable = require_is_callable();
    var store = require_shared_store();
    var functionToString = uncurryThis(Function.toString);
    if (!isCallable(store.inspectSource)) {
      store.inspectSource = function(it) {
        return functionToString(it);
      };
    }
    module.exports = store.inspectSource;
  }
});

// ../simple-mind-map/node_modules/core-js/internals/weak-map-basic-detection.js
var require_weak_map_basic_detection = __commonJS({
  "../simple-mind-map/node_modules/core-js/internals/weak-map-basic-detection.js"(exports, module) {
    "use strict";
    var global2 = require_global();
    var isCallable = require_is_callable();
    var WeakMap2 = global2.WeakMap;
    module.exports = isCallable(WeakMap2) && /native code/.test(String(WeakMap2));
  }
});

// ../simple-mind-map/node_modules/core-js/internals/shared-key.js
var require_shared_key = __commonJS({
  "../simple-mind-map/node_modules/core-js/internals/shared-key.js"(exports, module) {
    "use strict";
    var shared = require_shared();
    var uid = require_uid();
    var keys = shared("keys");
    module.exports = function(key) {
      return keys[key] || (keys[key] = uid(key));
    };
  }
});

// ../simple-mind-map/node_modules/core-js/internals/hidden-keys.js
var require_hidden_keys = __commonJS({
  "../simple-mind-map/node_modules/core-js/internals/hidden-keys.js"(exports, module) {
    "use strict";
    module.exports = {};
  }
});

// ../simple-mind-map/node_modules/core-js/internals/internal-state.js
var require_internal_state = __commonJS({
  "../simple-mind-map/node_modules/core-js/internals/internal-state.js"(exports, module) {
    "use strict";
    var NATIVE_WEAK_MAP = require_weak_map_basic_detection();
    var global2 = require_global();
    var isObject = require_is_object();
    var createNonEnumerableProperty = require_create_non_enumerable_property();
    var hasOwn = require_has_own_property();
    var shared = require_shared_store();
    var sharedKey = require_shared_key();
    var hiddenKeys = require_hidden_keys();
    var OBJECT_ALREADY_INITIALIZED = "Object already initialized";
    var TypeError2 = global2.TypeError;
    var WeakMap2 = global2.WeakMap;
    var set;
    var get;
    var has;
    var enforce = function(it) {
      return has(it) ? get(it) : set(it, {});
    };
    var getterFor = function(TYPE) {
      return function(it) {
        var state;
        if (!isObject(it) || (state = get(it)).type !== TYPE) {
          throw new TypeError2("Incompatible receiver, " + TYPE + " required");
        }
        return state;
      };
    };
    if (NATIVE_WEAK_MAP || shared.state) {
      store = shared.state || (shared.state = new WeakMap2());
      store.get = store.get;
      store.has = store.has;
      store.set = store.set;
      set = function(it, metadata) {
        if (store.has(it))
          throw new TypeError2(OBJECT_ALREADY_INITIALIZED);
        metadata.facade = it;
        store.set(it, metadata);
        return metadata;
      };
      get = function(it) {
        return store.get(it) || {};
      };
      has = function(it) {
        return store.has(it);
      };
    } else {
      STATE = sharedKey("state");
      hiddenKeys[STATE] = true;
      set = function(it, metadata) {
        if (hasOwn(it, STATE))
          throw new TypeError2(OBJECT_ALREADY_INITIALIZED);
        metadata.facade = it;
        createNonEnumerableProperty(it, STATE, metadata);
        return metadata;
      };
      get = function(it) {
        return hasOwn(it, STATE) ? it[STATE] : {};
      };
      has = function(it) {
        return hasOwn(it, STATE);
      };
    }
    var store;
    var STATE;
    module.exports = {
      set,
      get,
      has,
      enforce,
      getterFor
    };
  }
});

// ../simple-mind-map/node_modules/core-js/internals/make-built-in.js
var require_make_built_in = __commonJS({
  "../simple-mind-map/node_modules/core-js/internals/make-built-in.js"(exports, module) {
    "use strict";
    var uncurryThis = require_function_uncurry_this();
    var fails = require_fails();
    var isCallable = require_is_callable();
    var hasOwn = require_has_own_property();
    var DESCRIPTORS = require_descriptors();
    var CONFIGURABLE_FUNCTION_NAME = require_function_name().CONFIGURABLE;
    var inspectSource = require_inspect_source();
    var InternalStateModule = require_internal_state();
    var enforceInternalState = InternalStateModule.enforce;
    var getInternalState = InternalStateModule.get;
    var $String = String;
    var defineProperty = Object.defineProperty;
    var stringSlice = uncurryThis("".slice);
    var replace = uncurryThis("".replace);
    var join = uncurryThis([].join);
    var CONFIGURABLE_LENGTH = DESCRIPTORS && !fails(function() {
      return defineProperty(function() {
      }, "length", { value: 8 }).length !== 8;
    });
    var TEMPLATE = String(String).split("String");
    var makeBuiltIn = module.exports = function(value, name, options) {
      if (stringSlice($String(name), 0, 7) === "Symbol(") {
        name = "[" + replace($String(name), /^Symbol\(([^)]*)\)/, "$1") + "]";
      }
      if (options && options.getter)
        name = "get " + name;
      if (options && options.setter)
        name = "set " + name;
      if (!hasOwn(value, "name") || CONFIGURABLE_FUNCTION_NAME && value.name !== name) {
        if (DESCRIPTORS)
          defineProperty(value, "name", { value: name, configurable: true });
        else
          value.name = name;
      }
      if (CONFIGURABLE_LENGTH && options && hasOwn(options, "arity") && value.length !== options.arity) {
        defineProperty(value, "length", { value: options.arity });
      }
      try {
        if (options && hasOwn(options, "constructor") && options.constructor) {
          if (DESCRIPTORS)
            defineProperty(value, "prototype", { writable: false });
        } else if (value.prototype)
          value.prototype = void 0;
      } catch (error) {
      }
      var state = enforceInternalState(value);
      if (!hasOwn(state, "source")) {
        state.source = join(TEMPLATE, typeof name == "string" ? name : "");
      }
      return value;
    };
    Function.prototype.toString = makeBuiltIn(function toString2() {
      return isCallable(this) && getInternalState(this).source || inspectSource(this);
    }, "toString");
  }
});

// ../simple-mind-map/node_modules/core-js/internals/define-built-in.js
var require_define_built_in = __commonJS({
  "../simple-mind-map/node_modules/core-js/internals/define-built-in.js"(exports, module) {
    "use strict";
    var isCallable = require_is_callable();
    var definePropertyModule = require_object_define_property();
    var makeBuiltIn = require_make_built_in();
    var defineGlobalProperty = require_define_global_property();
    module.exports = function(O2, key, value, options) {
      if (!options)
        options = {};
      var simple = options.enumerable;
      var name = options.name !== void 0 ? options.name : key;
      if (isCallable(value))
        makeBuiltIn(value, name, options);
      if (options.global) {
        if (simple)
          O2[key] = value;
        else
          defineGlobalProperty(key, value);
      } else {
        try {
          if (!options.unsafe)
            delete O2[key];
          else if (O2[key])
            simple = true;
        } catch (error) {
        }
        if (simple)
          O2[key] = value;
        else
          definePropertyModule.f(O2, key, {
            value,
            enumerable: false,
            configurable: !options.nonConfigurable,
            writable: !options.nonWritable
          });
      }
      return O2;
    };
  }
});

// ../simple-mind-map/node_modules/core-js/internals/math-trunc.js
var require_math_trunc = __commonJS({
  "../simple-mind-map/node_modules/core-js/internals/math-trunc.js"(exports, module) {
    "use strict";
    var ceil = Math.ceil;
    var floor = Math.floor;
    module.exports = Math.trunc || function trunc(x2) {
      var n2 = +x2;
      return (n2 > 0 ? floor : ceil)(n2);
    };
  }
});

// ../simple-mind-map/node_modules/core-js/internals/to-integer-or-infinity.js
var require_to_integer_or_infinity = __commonJS({
  "../simple-mind-map/node_modules/core-js/internals/to-integer-or-infinity.js"(exports, module) {
    "use strict";
    var trunc = require_math_trunc();
    module.exports = function(argument) {
      var number = +argument;
      return number !== number || number === 0 ? 0 : trunc(number);
    };
  }
});

// ../simple-mind-map/node_modules/core-js/internals/to-absolute-index.js
var require_to_absolute_index = __commonJS({
  "../simple-mind-map/node_modules/core-js/internals/to-absolute-index.js"(exports, module) {
    "use strict";
    var toIntegerOrInfinity = require_to_integer_or_infinity();
    var max2 = Math.max;
    var min = Math.min;
    module.exports = function(index3, length2) {
      var integer = toIntegerOrInfinity(index3);
      return integer < 0 ? max2(integer + length2, 0) : min(integer, length2);
    };
  }
});

// ../simple-mind-map/node_modules/core-js/internals/to-length.js
var require_to_length = __commonJS({
  "../simple-mind-map/node_modules/core-js/internals/to-length.js"(exports, module) {
    "use strict";
    var toIntegerOrInfinity = require_to_integer_or_infinity();
    var min = Math.min;
    module.exports = function(argument) {
      return argument > 0 ? min(toIntegerOrInfinity(argument), 9007199254740991) : 0;
    };
  }
});

// ../simple-mind-map/node_modules/core-js/internals/length-of-array-like.js
var require_length_of_array_like = __commonJS({
  "../simple-mind-map/node_modules/core-js/internals/length-of-array-like.js"(exports, module) {
    "use strict";
    var toLength = require_to_length();
    module.exports = function(obj) {
      return toLength(obj.length);
    };
  }
});

// ../simple-mind-map/node_modules/core-js/internals/array-includes.js
var require_array_includes = __commonJS({
  "../simple-mind-map/node_modules/core-js/internals/array-includes.js"(exports, module) {
    "use strict";
    var toIndexedObject = require_to_indexed_object();
    var toAbsoluteIndex = require_to_absolute_index();
    var lengthOfArrayLike = require_length_of_array_like();
    var createMethod = function(IS_INCLUDES) {
      return function($this, el2, fromIndex) {
        var O2 = toIndexedObject($this);
        var length2 = lengthOfArrayLike(O2);
        var index3 = toAbsoluteIndex(fromIndex, length2);
        var value;
        if (IS_INCLUDES && el2 !== el2)
          while (length2 > index3) {
            value = O2[index3++];
            if (value !== value)
              return true;
          }
        else
          for (; length2 > index3; index3++) {
            if ((IS_INCLUDES || index3 in O2) && O2[index3] === el2)
              return IS_INCLUDES || index3 || 0;
          }
        return !IS_INCLUDES && -1;
      };
    };
    module.exports = {
      // `Array.prototype.includes` method
      // https://tc39.es/ecma262/#sec-array.prototype.includes
      includes: createMethod(true),
      // `Array.prototype.indexOf` method
      // https://tc39.es/ecma262/#sec-array.prototype.indexof
      indexOf: createMethod(false)
    };
  }
});

// ../simple-mind-map/node_modules/core-js/internals/object-keys-internal.js
var require_object_keys_internal = __commonJS({
  "../simple-mind-map/node_modules/core-js/internals/object-keys-internal.js"(exports, module) {
    "use strict";
    var uncurryThis = require_function_uncurry_this();
    var hasOwn = require_has_own_property();
    var toIndexedObject = require_to_indexed_object();
    var indexOf = require_array_includes().indexOf;
    var hiddenKeys = require_hidden_keys();
    var push2 = uncurryThis([].push);
    module.exports = function(object, names2) {
      var O2 = toIndexedObject(object);
      var i2 = 0;
      var result = [];
      var key;
      for (key in O2)
        !hasOwn(hiddenKeys, key) && hasOwn(O2, key) && push2(result, key);
      while (names2.length > i2)
        if (hasOwn(O2, key = names2[i2++])) {
          ~indexOf(result, key) || push2(result, key);
        }
      return result;
    };
  }
});

// ../simple-mind-map/node_modules/core-js/internals/enum-bug-keys.js
var require_enum_bug_keys = __commonJS({
  "../simple-mind-map/node_modules/core-js/internals/enum-bug-keys.js"(exports, module) {
    "use strict";
    module.exports = [
      "constructor",
      "hasOwnProperty",
      "isPrototypeOf",
      "propertyIsEnumerable",
      "toLocaleString",
      "toString",
      "valueOf"
    ];
  }
});

// ../simple-mind-map/node_modules/core-js/internals/object-get-own-property-names.js
var require_object_get_own_property_names = __commonJS({
  "../simple-mind-map/node_modules/core-js/internals/object-get-own-property-names.js"(exports) {
    "use strict";
    var internalObjectKeys = require_object_keys_internal();
    var enumBugKeys = require_enum_bug_keys();
    var hiddenKeys = enumBugKeys.concat("length", "prototype");
    exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O2) {
      return internalObjectKeys(O2, hiddenKeys);
    };
  }
});

// ../simple-mind-map/node_modules/core-js/internals/object-get-own-property-symbols.js
var require_object_get_own_property_symbols = __commonJS({
  "../simple-mind-map/node_modules/core-js/internals/object-get-own-property-symbols.js"(exports) {
    "use strict";
    exports.f = Object.getOwnPropertySymbols;
  }
});

// ../simple-mind-map/node_modules/core-js/internals/own-keys.js
var require_own_keys = __commonJS({
  "../simple-mind-map/node_modules/core-js/internals/own-keys.js"(exports, module) {
    "use strict";
    var getBuiltIn = require_get_built_in();
    var uncurryThis = require_function_uncurry_this();
    var getOwnPropertyNamesModule = require_object_get_own_property_names();
    var getOwnPropertySymbolsModule = require_object_get_own_property_symbols();
    var anObject = require_an_object();
    var concat = uncurryThis([].concat);
    module.exports = getBuiltIn("Reflect", "ownKeys") || function ownKeys2(it) {
      var keys = getOwnPropertyNamesModule.f(anObject(it));
      var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
      return getOwnPropertySymbols ? concat(keys, getOwnPropertySymbols(it)) : keys;
    };
  }
});

// ../simple-mind-map/node_modules/core-js/internals/copy-constructor-properties.js
var require_copy_constructor_properties = __commonJS({
  "../simple-mind-map/node_modules/core-js/internals/copy-constructor-properties.js"(exports, module) {
    "use strict";
    var hasOwn = require_has_own_property();
    var ownKeys2 = require_own_keys();
    var getOwnPropertyDescriptorModule = require_object_get_own_property_descriptor();
    var definePropertyModule = require_object_define_property();
    module.exports = function(target, source, exceptions) {
      var keys = ownKeys2(source);
      var defineProperty = definePropertyModule.f;
      var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
      for (var i2 = 0; i2 < keys.length; i2++) {
        var key = keys[i2];
        if (!hasOwn(target, key) && !(exceptions && hasOwn(exceptions, key))) {
          defineProperty(target, key, getOwnPropertyDescriptor(source, key));
        }
      }
    };
  }
});

// ../simple-mind-map/node_modules/core-js/internals/is-forced.js
var require_is_forced = __commonJS({
  "../simple-mind-map/node_modules/core-js/internals/is-forced.js"(exports, module) {
    "use strict";
    var fails = require_fails();
    var isCallable = require_is_callable();
    var replacement = /#|\.prototype\./;
    var isForced = function(feature, detection) {
      var value = data2[normalize(feature)];
      return value === POLYFILL ? true : value === NATIVE ? false : isCallable(detection) ? fails(detection) : !!detection;
    };
    var normalize = isForced.normalize = function(string3) {
      return String(string3).replace(replacement, ".").toLowerCase();
    };
    var data2 = isForced.data = {};
    var NATIVE = isForced.NATIVE = "N";
    var POLYFILL = isForced.POLYFILL = "P";
    module.exports = isForced;
  }
});

// ../simple-mind-map/node_modules/core-js/internals/export.js
var require_export = __commonJS({
  "../simple-mind-map/node_modules/core-js/internals/export.js"(exports, module) {
    "use strict";
    var global2 = require_global();
    var getOwnPropertyDescriptor = require_object_get_own_property_descriptor().f;
    var createNonEnumerableProperty = require_create_non_enumerable_property();
    var defineBuiltIn = require_define_built_in();
    var defineGlobalProperty = require_define_global_property();
    var copyConstructorProperties = require_copy_constructor_properties();
    var isForced = require_is_forced();
    module.exports = function(options, source) {
      var TARGET = options.target;
      var GLOBAL = options.global;
      var STATIC = options.stat;
      var FORCED, target, key, targetProperty, sourceProperty, descriptor;
      if (GLOBAL) {
        target = global2;
      } else if (STATIC) {
        target = global2[TARGET] || defineGlobalProperty(TARGET, {});
      } else {
        target = (global2[TARGET] || {}).prototype;
      }
      if (target)
        for (key in source) {
          sourceProperty = source[key];
          if (options.dontCallGetSet) {
            descriptor = getOwnPropertyDescriptor(target, key);
            targetProperty = descriptor && descriptor.value;
          } else
            targetProperty = target[key];
          FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? "." : "#") + key, options.forced);
          if (!FORCED && targetProperty !== void 0) {
            if (typeof sourceProperty == typeof targetProperty)
              continue;
            copyConstructorProperties(sourceProperty, targetProperty);
          }
          if (options.sham || targetProperty && targetProperty.sham) {
            createNonEnumerableProperty(sourceProperty, "sham", true);
          }
          defineBuiltIn(target, key, sourceProperty, options);
        }
    };
  }
});

// ../simple-mind-map/node_modules/core-js/internals/engine-is-node.js
var require_engine_is_node = __commonJS({
  "../simple-mind-map/node_modules/core-js/internals/engine-is-node.js"(exports, module) {
    "use strict";
    var global2 = require_global();
    var classof = require_classof_raw();
    module.exports = classof(global2.process) === "process";
  }
});

// ../simple-mind-map/node_modules/core-js/internals/function-uncurry-this-accessor.js
var require_function_uncurry_this_accessor = __commonJS({
  "../simple-mind-map/node_modules/core-js/internals/function-uncurry-this-accessor.js"(exports, module) {
    "use strict";
    var uncurryThis = require_function_uncurry_this();
    var aCallable = require_a_callable();
    module.exports = function(object, key, method) {
      try {
        return uncurryThis(aCallable(Object.getOwnPropertyDescriptor(object, key)[method]));
      } catch (error) {
      }
    };
  }
});

// ../simple-mind-map/node_modules/core-js/internals/a-possible-prototype.js
var require_a_possible_prototype = __commonJS({
  "../simple-mind-map/node_modules/core-js/internals/a-possible-prototype.js"(exports, module) {
    "use strict";
    var isCallable = require_is_callable();
    var $String = String;
    var $TypeError = TypeError;
    module.exports = function(argument) {
      if (typeof argument == "object" || isCallable(argument))
        return argument;
      throw new $TypeError("Can't set " + $String(argument) + " as a prototype");
    };
  }
});

// ../simple-mind-map/node_modules/core-js/internals/object-set-prototype-of.js
var require_object_set_prototype_of = __commonJS({
  "../simple-mind-map/node_modules/core-js/internals/object-set-prototype-of.js"(exports, module) {
    "use strict";
    var uncurryThisAccessor = require_function_uncurry_this_accessor();
    var anObject = require_an_object();
    var aPossiblePrototype = require_a_possible_prototype();
    module.exports = Object.setPrototypeOf || ("__proto__" in {} ? function() {
      var CORRECT_SETTER = false;
      var test = {};
      var setter;
      try {
        setter = uncurryThisAccessor(Object.prototype, "__proto__", "set");
        setter(test, []);
        CORRECT_SETTER = test instanceof Array;
      } catch (error) {
      }
      return function setPrototypeOf(O2, proto) {
        anObject(O2);
        aPossiblePrototype(proto);
        if (CORRECT_SETTER)
          setter(O2, proto);
        else
          O2.__proto__ = proto;
        return O2;
      };
    }() : void 0);
  }
});

// ../simple-mind-map/node_modules/core-js/internals/set-to-string-tag.js
var require_set_to_string_tag = __commonJS({
  "../simple-mind-map/node_modules/core-js/internals/set-to-string-tag.js"(exports, module) {
    "use strict";
    var defineProperty = require_object_define_property().f;
    var hasOwn = require_has_own_property();
    var wellKnownSymbol = require_well_known_symbol();
    var TO_STRING_TAG = wellKnownSymbol("toStringTag");
    module.exports = function(target, TAG, STATIC) {
      if (target && !STATIC)
        target = target.prototype;
      if (target && !hasOwn(target, TO_STRING_TAG)) {
        defineProperty(target, TO_STRING_TAG, { configurable: true, value: TAG });
      }
    };
  }
});

// ../simple-mind-map/node_modules/core-js/internals/define-built-in-accessor.js
var require_define_built_in_accessor = __commonJS({
  "../simple-mind-map/node_modules/core-js/internals/define-built-in-accessor.js"(exports, module) {
    "use strict";
    var makeBuiltIn = require_make_built_in();
    var defineProperty = require_object_define_property();
    module.exports = function(target, name, descriptor) {
      if (descriptor.get)
        makeBuiltIn(descriptor.get, name, { getter: true });
      if (descriptor.set)
        makeBuiltIn(descriptor.set, name, { setter: true });
      return defineProperty.f(target, name, descriptor);
    };
  }
});

// ../simple-mind-map/node_modules/core-js/internals/set-species.js
var require_set_species = __commonJS({
  "../simple-mind-map/node_modules/core-js/internals/set-species.js"(exports, module) {
    "use strict";
    var getBuiltIn = require_get_built_in();
    var defineBuiltInAccessor = require_define_built_in_accessor();
    var wellKnownSymbol = require_well_known_symbol();
    var DESCRIPTORS = require_descriptors();
    var SPECIES = wellKnownSymbol("species");
    module.exports = function(CONSTRUCTOR_NAME) {
      var Constructor = getBuiltIn(CONSTRUCTOR_NAME);
      if (DESCRIPTORS && Constructor && !Constructor[SPECIES]) {
        defineBuiltInAccessor(Constructor, SPECIES, {
          configurable: true,
          get: function() {
            return this;
          }
        });
      }
    };
  }
});

// ../simple-mind-map/node_modules/core-js/internals/an-instance.js
var require_an_instance = __commonJS({
  "../simple-mind-map/node_modules/core-js/internals/an-instance.js"(exports, module) {
    "use strict";
    var isPrototypeOf = require_object_is_prototype_of();
    var $TypeError = TypeError;
    module.exports = function(it, Prototype) {
      if (isPrototypeOf(Prototype, it))
        return it;
      throw new $TypeError("Incorrect invocation");
    };
  }
});

// ../simple-mind-map/node_modules/core-js/internals/to-string-tag-support.js
var require_to_string_tag_support = __commonJS({
  "../simple-mind-map/node_modules/core-js/internals/to-string-tag-support.js"(exports, module) {
    "use strict";
    var wellKnownSymbol = require_well_known_symbol();
    var TO_STRING_TAG = wellKnownSymbol("toStringTag");
    var test = {};
    test[TO_STRING_TAG] = "z";
    module.exports = String(test) === "[object z]";
  }
});

// ../simple-mind-map/node_modules/core-js/internals/classof.js
var require_classof = __commonJS({
  "../simple-mind-map/node_modules/core-js/internals/classof.js"(exports, module) {
    "use strict";
    var TO_STRING_TAG_SUPPORT = require_to_string_tag_support();
    var isCallable = require_is_callable();
    var classofRaw = require_classof_raw();
    var wellKnownSymbol = require_well_known_symbol();
    var TO_STRING_TAG = wellKnownSymbol("toStringTag");
    var $Object = Object;
    var CORRECT_ARGUMENTS = classofRaw(function() {
      return arguments;
    }()) === "Arguments";
    var tryGet = function(it, key) {
      try {
        return it[key];
      } catch (error) {
      }
    };
    module.exports = TO_STRING_TAG_SUPPORT ? classofRaw : function(it) {
      var O2, tag, result;
      return it === void 0 ? "Undefined" : it === null ? "Null" : typeof (tag = tryGet(O2 = $Object(it), TO_STRING_TAG)) == "string" ? tag : CORRECT_ARGUMENTS ? classofRaw(O2) : (result = classofRaw(O2)) === "Object" && isCallable(O2.callee) ? "Arguments" : result;
    };
  }
});

// ../simple-mind-map/node_modules/core-js/internals/is-constructor.js
var require_is_constructor = __commonJS({
  "../simple-mind-map/node_modules/core-js/internals/is-constructor.js"(exports, module) {
    "use strict";
    var uncurryThis = require_function_uncurry_this();
    var fails = require_fails();
    var isCallable = require_is_callable();
    var classof = require_classof();
    var getBuiltIn = require_get_built_in();
    var inspectSource = require_inspect_source();
    var noop3 = function() {
    };
    var empty = [];
    var construct = getBuiltIn("Reflect", "construct");
    var constructorRegExp = /^\s*(?:class|function)\b/;
    var exec = uncurryThis(constructorRegExp.exec);
    var INCORRECT_TO_STRING = !constructorRegExp.test(noop3);
    var isConstructorModern = function isConstructor(argument) {
      if (!isCallable(argument))
        return false;
      try {
        construct(noop3, empty, argument);
        return true;
      } catch (error) {
        return false;
      }
    };
    var isConstructorLegacy = function isConstructor(argument) {
      if (!isCallable(argument))
        return false;
      switch (classof(argument)) {
        case "AsyncFunction":
        case "GeneratorFunction":
        case "AsyncGeneratorFunction":
          return false;
      }
      try {
        return INCORRECT_TO_STRING || !!exec(constructorRegExp, inspectSource(argument));
      } catch (error) {
        return true;
      }
    };
    isConstructorLegacy.sham = true;
    module.exports = !construct || fails(function() {
      var called;
      return isConstructorModern(isConstructorModern.call) || !isConstructorModern(Object) || !isConstructorModern(function() {
        called = true;
      }) || called;
    }) ? isConstructorLegacy : isConstructorModern;
  }
});

// ../simple-mind-map/node_modules/core-js/internals/a-constructor.js
var require_a_constructor = __commonJS({
  "../simple-mind-map/node_modules/core-js/internals/a-constructor.js"(exports, module) {
    "use strict";
    var isConstructor = require_is_constructor();
    var tryToString = require_try_to_string();
    var $TypeError = TypeError;
    module.exports = function(argument) {
      if (isConstructor(argument))
        return argument;
      throw new $TypeError(tryToString(argument) + " is not a constructor");
    };
  }
});

// ../simple-mind-map/node_modules/core-js/internals/species-constructor.js
var require_species_constructor = __commonJS({
  "../simple-mind-map/node_modules/core-js/internals/species-constructor.js"(exports, module) {
    "use strict";
    var anObject = require_an_object();
    var aConstructor = require_a_constructor();
    var isNullOrUndefined = require_is_null_or_undefined();
    var wellKnownSymbol = require_well_known_symbol();
    var SPECIES = wellKnownSymbol("species");
    module.exports = function(O2, defaultConstructor) {
      var C = anObject(O2).constructor;
      var S2;
      return C === void 0 || isNullOrUndefined(S2 = anObject(C)[SPECIES]) ? defaultConstructor : aConstructor(S2);
    };
  }
});

// ../simple-mind-map/node_modules/core-js/internals/function-apply.js
var require_function_apply = __commonJS({
  "../simple-mind-map/node_modules/core-js/internals/function-apply.js"(exports, module) {
    "use strict";
    var NATIVE_BIND = require_function_bind_native();
    var FunctionPrototype = Function.prototype;
    var apply = FunctionPrototype.apply;
    var call = FunctionPrototype.call;
    module.exports = typeof Reflect == "object" && Reflect.apply || (NATIVE_BIND ? call.bind(apply) : function() {
      return call.apply(apply, arguments);
    });
  }
});

// ../simple-mind-map/node_modules/core-js/internals/function-uncurry-this-clause.js
var require_function_uncurry_this_clause = __commonJS({
  "../simple-mind-map/node_modules/core-js/internals/function-uncurry-this-clause.js"(exports, module) {
    "use strict";
    var classofRaw = require_classof_raw();
    var uncurryThis = require_function_uncurry_this();
    module.exports = function(fn) {
      if (classofRaw(fn) === "Function")
        return uncurryThis(fn);
    };
  }
});

// ../simple-mind-map/node_modules/core-js/internals/function-bind-context.js
var require_function_bind_context = __commonJS({
  "../simple-mind-map/node_modules/core-js/internals/function-bind-context.js"(exports, module) {
    "use strict";
    var uncurryThis = require_function_uncurry_this_clause();
    var aCallable = require_a_callable();
    var NATIVE_BIND = require_function_bind_native();
    var bind = uncurryThis(uncurryThis.bind);
    module.exports = function(fn, that) {
      aCallable(fn);
      return that === void 0 ? fn : NATIVE_BIND ? bind(fn, that) : function() {
        return fn.apply(that, arguments);
      };
    };
  }
});

// ../simple-mind-map/node_modules/core-js/internals/html.js
var require_html = __commonJS({
  "../simple-mind-map/node_modules/core-js/internals/html.js"(exports, module) {
    "use strict";
    var getBuiltIn = require_get_built_in();
    module.exports = getBuiltIn("document", "documentElement");
  }
});

// ../simple-mind-map/node_modules/core-js/internals/array-slice.js
var require_array_slice = __commonJS({
  "../simple-mind-map/node_modules/core-js/internals/array-slice.js"(exports, module) {
    "use strict";
    var uncurryThis = require_function_uncurry_this();
    module.exports = uncurryThis([].slice);
  }
});

// ../simple-mind-map/node_modules/core-js/internals/validate-arguments-length.js
var require_validate_arguments_length = __commonJS({
  "../simple-mind-map/node_modules/core-js/internals/validate-arguments-length.js"(exports, module) {
    "use strict";
    var $TypeError = TypeError;
    module.exports = function(passed, required) {
      if (passed < required)
        throw new $TypeError("Not enough arguments");
      return passed;
    };
  }
});

// ../simple-mind-map/node_modules/core-js/internals/engine-is-ios.js
var require_engine_is_ios = __commonJS({
  "../simple-mind-map/node_modules/core-js/internals/engine-is-ios.js"(exports, module) {
    "use strict";
    var userAgent = require_engine_user_agent();
    module.exports = /(?:ipad|iphone|ipod).*applewebkit/i.test(userAgent);
  }
});

// ../simple-mind-map/node_modules/core-js/internals/task.js
var require_task = __commonJS({
  "../simple-mind-map/node_modules/core-js/internals/task.js"(exports, module) {
    "use strict";
    var global2 = require_global();
    var apply = require_function_apply();
    var bind = require_function_bind_context();
    var isCallable = require_is_callable();
    var hasOwn = require_has_own_property();
    var fails = require_fails();
    var html2 = require_html();
    var arraySlice = require_array_slice();
    var createElement = require_document_create_element();
    var validateArgumentsLength = require_validate_arguments_length();
    var IS_IOS = require_engine_is_ios();
    var IS_NODE = require_engine_is_node();
    var set = global2.setImmediate;
    var clear2 = global2.clearImmediate;
    var process2 = global2.process;
    var Dispatch = global2.Dispatch;
    var Function2 = global2.Function;
    var MessageChannel2 = global2.MessageChannel;
    var String2 = global2.String;
    var counter = 0;
    var queue = {};
    var ONREADYSTATECHANGE = "onreadystatechange";
    var $location;
    var defer;
    var channel;
    var port;
    fails(function() {
      $location = global2.location;
    });
    var run = function(id) {
      if (hasOwn(queue, id)) {
        var fn = queue[id];
        delete queue[id];
        fn();
      }
    };
    var runner = function(id) {
      return function() {
        run(id);
      };
    };
    var eventListener = function(event) {
      run(event.data);
    };
    var globalPostMessageDefer = function(id) {
      global2.postMessage(String2(id), $location.protocol + "//" + $location.host);
    };
    if (!set || !clear2) {
      set = function setImmediate2(handler) {
        validateArgumentsLength(arguments.length, 1);
        var fn = isCallable(handler) ? handler : Function2(handler);
        var args = arraySlice(arguments, 1);
        queue[++counter] = function() {
          apply(fn, void 0, args);
        };
        defer(counter);
        return counter;
      };
      clear2 = function clearImmediate(id) {
        delete queue[id];
      };
      if (IS_NODE) {
        defer = function(id) {
          process2.nextTick(runner(id));
        };
      } else if (Dispatch && Dispatch.now) {
        defer = function(id) {
          Dispatch.now(runner(id));
        };
      } else if (MessageChannel2 && !IS_IOS) {
        channel = new MessageChannel2();
        port = channel.port2;
        channel.port1.onmessage = eventListener;
        defer = bind(port.postMessage, port);
      } else if (global2.addEventListener && isCallable(global2.postMessage) && !global2.importScripts && $location && $location.protocol !== "file:" && !fails(globalPostMessageDefer)) {
        defer = globalPostMessageDefer;
        global2.addEventListener("message", eventListener, false);
      } else if (ONREADYSTATECHANGE in createElement("script")) {
        defer = function(id) {
          html2.appendChild(createElement("script"))[ONREADYSTATECHANGE] = function() {
            html2.removeChild(this);
            run(id);
          };
        };
      } else {
        defer = function(id) {
          setTimeout(runner(id), 0);
        };
      }
    }
    module.exports = {
      set,
      clear: clear2
    };
  }
});

// ../simple-mind-map/node_modules/core-js/internals/queue.js
var require_queue = __commonJS({
  "../simple-mind-map/node_modules/core-js/internals/queue.js"(exports, module) {
    "use strict";
    var Queue2 = function() {
      this.head = null;
      this.tail = null;
    };
    Queue2.prototype = {
      add: function(item) {
        var entry = { item, next: null };
        var tail = this.tail;
        if (tail)
          tail.next = entry;
        else
          this.head = entry;
        this.tail = entry;
      },
      get: function() {
        var entry = this.head;
        if (entry) {
          var next2 = this.head = entry.next;
          if (next2 === null)
            this.tail = null;
          return entry.item;
        }
      }
    };
    module.exports = Queue2;
  }
});

// ../simple-mind-map/node_modules/core-js/internals/engine-is-ios-pebble.js
var require_engine_is_ios_pebble = __commonJS({
  "../simple-mind-map/node_modules/core-js/internals/engine-is-ios-pebble.js"(exports, module) {
    "use strict";
    var userAgent = require_engine_user_agent();
    module.exports = /ipad|iphone|ipod/i.test(userAgent) && typeof Pebble != "undefined";
  }
});

// ../simple-mind-map/node_modules/core-js/internals/engine-is-webos-webkit.js
var require_engine_is_webos_webkit = __commonJS({
  "../simple-mind-map/node_modules/core-js/internals/engine-is-webos-webkit.js"(exports, module) {
    "use strict";
    var userAgent = require_engine_user_agent();
    module.exports = /web0s(?!.*chrome)/i.test(userAgent);
  }
});

// ../simple-mind-map/node_modules/core-js/internals/microtask.js
var require_microtask = __commonJS({
  "../simple-mind-map/node_modules/core-js/internals/microtask.js"(exports, module) {
    "use strict";
    var global2 = require_global();
    var bind = require_function_bind_context();
    var getOwnPropertyDescriptor = require_object_get_own_property_descriptor().f;
    var macrotask = require_task().set;
    var Queue2 = require_queue();
    var IS_IOS = require_engine_is_ios();
    var IS_IOS_PEBBLE = require_engine_is_ios_pebble();
    var IS_WEBOS_WEBKIT = require_engine_is_webos_webkit();
    var IS_NODE = require_engine_is_node();
    var MutationObserver2 = global2.MutationObserver || global2.WebKitMutationObserver;
    var document4 = global2.document;
    var process2 = global2.process;
    var Promise2 = global2.Promise;
    var queueMicrotaskDescriptor = getOwnPropertyDescriptor(global2, "queueMicrotask");
    var microtask = queueMicrotaskDescriptor && queueMicrotaskDescriptor.value;
    var notify;
    var toggle;
    var node3;
    var promise;
    var then;
    if (!microtask) {
      queue = new Queue2();
      flush = function() {
        var parent, fn;
        if (IS_NODE && (parent = process2.domain))
          parent.exit();
        while (fn = queue.get())
          try {
            fn();
          } catch (error) {
            if (queue.head)
              notify();
            throw error;
          }
        if (parent)
          parent.enter();
      };
      if (!IS_IOS && !IS_NODE && !IS_WEBOS_WEBKIT && MutationObserver2 && document4) {
        toggle = true;
        node3 = document4.createTextNode("");
        new MutationObserver2(flush).observe(node3, { characterData: true });
        notify = function() {
          node3.data = toggle = !toggle;
        };
      } else if (!IS_IOS_PEBBLE && Promise2 && Promise2.resolve) {
        promise = Promise2.resolve(void 0);
        promise.constructor = Promise2;
        then = bind(promise.then, promise);
        notify = function() {
          then(flush);
        };
      } else if (IS_NODE) {
        notify = function() {
          process2.nextTick(flush);
        };
      } else {
        macrotask = bind(macrotask, global2);
        notify = function() {
          macrotask(flush);
        };
      }
      microtask = function(fn) {
        if (!queue.head)
          notify();
        queue.add(fn);
      };
    }
    var queue;
    var flush;
    module.exports = microtask;
  }
});

// ../simple-mind-map/node_modules/core-js/internals/host-report-errors.js
var require_host_report_errors = __commonJS({
  "../simple-mind-map/node_modules/core-js/internals/host-report-errors.js"(exports, module) {
    "use strict";
    module.exports = function(a2, b) {
      try {
        arguments.length === 1 ? console.error(a2) : console.error(a2, b);
      } catch (error) {
      }
    };
  }
});

// ../simple-mind-map/node_modules/core-js/internals/perform.js
var require_perform = __commonJS({
  "../simple-mind-map/node_modules/core-js/internals/perform.js"(exports, module) {
    "use strict";
    module.exports = function(exec) {
      try {
        return { error: false, value: exec() };
      } catch (error) {
        return { error: true, value: error };
      }
    };
  }
});

// ../simple-mind-map/node_modules/core-js/internals/promise-native-constructor.js
var require_promise_native_constructor = __commonJS({
  "../simple-mind-map/node_modules/core-js/internals/promise-native-constructor.js"(exports, module) {
    "use strict";
    var global2 = require_global();
    module.exports = global2.Promise;
  }
});

// ../simple-mind-map/node_modules/core-js/internals/engine-is-deno.js
var require_engine_is_deno = __commonJS({
  "../simple-mind-map/node_modules/core-js/internals/engine-is-deno.js"(exports, module) {
    "use strict";
    module.exports = typeof Deno == "object" && Deno && typeof Deno.version == "object";
  }
});

// ../simple-mind-map/node_modules/core-js/internals/engine-is-browser.js
var require_engine_is_browser = __commonJS({
  "../simple-mind-map/node_modules/core-js/internals/engine-is-browser.js"(exports, module) {
    "use strict";
    var IS_DENO = require_engine_is_deno();
    var IS_NODE = require_engine_is_node();
    module.exports = !IS_DENO && !IS_NODE && typeof window == "object" && typeof document == "object";
  }
});

// ../simple-mind-map/node_modules/core-js/internals/promise-constructor-detection.js
var require_promise_constructor_detection = __commonJS({
  "../simple-mind-map/node_modules/core-js/internals/promise-constructor-detection.js"(exports, module) {
    "use strict";
    var global2 = require_global();
    var NativePromiseConstructor = require_promise_native_constructor();
    var isCallable = require_is_callable();
    var isForced = require_is_forced();
    var inspectSource = require_inspect_source();
    var wellKnownSymbol = require_well_known_symbol();
    var IS_BROWSER = require_engine_is_browser();
    var IS_DENO = require_engine_is_deno();
    var IS_PURE = require_is_pure();
    var V8_VERSION = require_engine_v8_version();
    var NativePromisePrototype = NativePromiseConstructor && NativePromiseConstructor.prototype;
    var SPECIES = wellKnownSymbol("species");
    var SUBCLASSING = false;
    var NATIVE_PROMISE_REJECTION_EVENT = isCallable(global2.PromiseRejectionEvent);
    var FORCED_PROMISE_CONSTRUCTOR = isForced("Promise", function() {
      var PROMISE_CONSTRUCTOR_SOURCE = inspectSource(NativePromiseConstructor);
      var GLOBAL_CORE_JS_PROMISE = PROMISE_CONSTRUCTOR_SOURCE !== String(NativePromiseConstructor);
      if (!GLOBAL_CORE_JS_PROMISE && V8_VERSION === 66)
        return true;
      if (IS_PURE && !(NativePromisePrototype["catch"] && NativePromisePrototype["finally"]))
        return true;
      if (!V8_VERSION || V8_VERSION < 51 || !/native code/.test(PROMISE_CONSTRUCTOR_SOURCE)) {
        var promise = new NativePromiseConstructor(function(resolve) {
          resolve(1);
        });
        var FakePromise = function(exec) {
          exec(function() {
          }, function() {
          });
        };
        var constructor = promise.constructor = {};
        constructor[SPECIES] = FakePromise;
        SUBCLASSING = promise.then(function() {
        }) instanceof FakePromise;
        if (!SUBCLASSING)
          return true;
      }
      return !GLOBAL_CORE_JS_PROMISE && (IS_BROWSER || IS_DENO) && !NATIVE_PROMISE_REJECTION_EVENT;
    });
    module.exports = {
      CONSTRUCTOR: FORCED_PROMISE_CONSTRUCTOR,
      REJECTION_EVENT: NATIVE_PROMISE_REJECTION_EVENT,
      SUBCLASSING
    };
  }
});

// ../simple-mind-map/node_modules/core-js/internals/new-promise-capability.js
var require_new_promise_capability = __commonJS({
  "../simple-mind-map/node_modules/core-js/internals/new-promise-capability.js"(exports, module) {
    "use strict";
    var aCallable = require_a_callable();
    var $TypeError = TypeError;
    var PromiseCapability = function(C) {
      var resolve, reject;
      this.promise = new C(function($$resolve, $$reject) {
        if (resolve !== void 0 || reject !== void 0)
          throw new $TypeError("Bad Promise constructor");
        resolve = $$resolve;
        reject = $$reject;
      });
      this.resolve = aCallable(resolve);
      this.reject = aCallable(reject);
    };
    module.exports.f = function(C) {
      return new PromiseCapability(C);
    };
  }
});

// ../simple-mind-map/node_modules/core-js/modules/es.promise.constructor.js
var require_es_promise_constructor = __commonJS({
  "../simple-mind-map/node_modules/core-js/modules/es.promise.constructor.js"() {
    "use strict";
    var $ = require_export();
    var IS_PURE = require_is_pure();
    var IS_NODE = require_engine_is_node();
    var global2 = require_global();
    var call = require_function_call();
    var defineBuiltIn = require_define_built_in();
    var setPrototypeOf = require_object_set_prototype_of();
    var setToStringTag = require_set_to_string_tag();
    var setSpecies = require_set_species();
    var aCallable = require_a_callable();
    var isCallable = require_is_callable();
    var isObject = require_is_object();
    var anInstance = require_an_instance();
    var speciesConstructor = require_species_constructor();
    var task = require_task().set;
    var microtask = require_microtask();
    var hostReportErrors = require_host_report_errors();
    var perform = require_perform();
    var Queue2 = require_queue();
    var InternalStateModule = require_internal_state();
    var NativePromiseConstructor = require_promise_native_constructor();
    var PromiseConstructorDetection = require_promise_constructor_detection();
    var newPromiseCapabilityModule = require_new_promise_capability();
    var PROMISE = "Promise";
    var FORCED_PROMISE_CONSTRUCTOR = PromiseConstructorDetection.CONSTRUCTOR;
    var NATIVE_PROMISE_REJECTION_EVENT = PromiseConstructorDetection.REJECTION_EVENT;
    var NATIVE_PROMISE_SUBCLASSING = PromiseConstructorDetection.SUBCLASSING;
    var getInternalPromiseState = InternalStateModule.getterFor(PROMISE);
    var setInternalState = InternalStateModule.set;
    var NativePromisePrototype = NativePromiseConstructor && NativePromiseConstructor.prototype;
    var PromiseConstructor = NativePromiseConstructor;
    var PromisePrototype = NativePromisePrototype;
    var TypeError2 = global2.TypeError;
    var document4 = global2.document;
    var process2 = global2.process;
    var newPromiseCapability = newPromiseCapabilityModule.f;
    var newGenericPromiseCapability = newPromiseCapability;
    var DISPATCH_EVENT = !!(document4 && document4.createEvent && global2.dispatchEvent);
    var UNHANDLED_REJECTION = "unhandledrejection";
    var REJECTION_HANDLED = "rejectionhandled";
    var PENDING = 0;
    var FULFILLED = 1;
    var REJECTED = 2;
    var HANDLED = 1;
    var UNHANDLED = 2;
    var Internal;
    var OwnPromiseCapability;
    var PromiseWrapper;
    var nativeThen;
    var isThenable = function(it) {
      var then;
      return isObject(it) && isCallable(then = it.then) ? then : false;
    };
    var callReaction = function(reaction, state) {
      var value = state.value;
      var ok = state.state === FULFILLED;
      var handler = ok ? reaction.ok : reaction.fail;
      var resolve = reaction.resolve;
      var reject = reaction.reject;
      var domain = reaction.domain;
      var result, then, exited;
      try {
        if (handler) {
          if (!ok) {
            if (state.rejection === UNHANDLED)
              onHandleUnhandled(state);
            state.rejection = HANDLED;
          }
          if (handler === true)
            result = value;
          else {
            if (domain)
              domain.enter();
            result = handler(value);
            if (domain) {
              domain.exit();
              exited = true;
            }
          }
          if (result === reaction.promise) {
            reject(new TypeError2("Promise-chain cycle"));
          } else if (then = isThenable(result)) {
            call(then, result, resolve, reject);
          } else
            resolve(result);
        } else
          reject(value);
      } catch (error) {
        if (domain && !exited)
          domain.exit();
        reject(error);
      }
    };
    var notify = function(state, isReject) {
      if (state.notified)
        return;
      state.notified = true;
      microtask(function() {
        var reactions = state.reactions;
        var reaction;
        while (reaction = reactions.get()) {
          callReaction(reaction, state);
        }
        state.notified = false;
        if (isReject && !state.rejection)
          onUnhandled(state);
      });
    };
    var dispatchEvent = function(name, promise, reason) {
      var event, handler;
      if (DISPATCH_EVENT) {
        event = document4.createEvent("Event");
        event.promise = promise;
        event.reason = reason;
        event.initEvent(name, false, true);
        global2.dispatchEvent(event);
      } else
        event = { promise, reason };
      if (!NATIVE_PROMISE_REJECTION_EVENT && (handler = global2["on" + name]))
        handler(event);
      else if (name === UNHANDLED_REJECTION)
        hostReportErrors("Unhandled promise rejection", reason);
    };
    var onUnhandled = function(state) {
      call(task, global2, function() {
        var promise = state.facade;
        var value = state.value;
        var IS_UNHANDLED = isUnhandled(state);
        var result;
        if (IS_UNHANDLED) {
          result = perform(function() {
            if (IS_NODE) {
              process2.emit("unhandledRejection", value, promise);
            } else
              dispatchEvent(UNHANDLED_REJECTION, promise, value);
          });
          state.rejection = IS_NODE || isUnhandled(state) ? UNHANDLED : HANDLED;
          if (result.error)
            throw result.value;
        }
      });
    };
    var isUnhandled = function(state) {
      return state.rejection !== HANDLED && !state.parent;
    };
    var onHandleUnhandled = function(state) {
      call(task, global2, function() {
        var promise = state.facade;
        if (IS_NODE) {
          process2.emit("rejectionHandled", promise);
        } else
          dispatchEvent(REJECTION_HANDLED, promise, state.value);
      });
    };
    var bind = function(fn, state, unwrap) {
      return function(value) {
        fn(state, value, unwrap);
      };
    };
    var internalReject = function(state, value, unwrap) {
      if (state.done)
        return;
      state.done = true;
      if (unwrap)
        state = unwrap;
      state.value = value;
      state.state = REJECTED;
      notify(state, true);
    };
    var internalResolve = function(state, value, unwrap) {
      if (state.done)
        return;
      state.done = true;
      if (unwrap)
        state = unwrap;
      try {
        if (state.facade === value)
          throw new TypeError2("Promise can't be resolved itself");
        var then = isThenable(value);
        if (then) {
          microtask(function() {
            var wrapper = { done: false };
            try {
              call(
                then,
                value,
                bind(internalResolve, wrapper, state),
                bind(internalReject, wrapper, state)
              );
            } catch (error) {
              internalReject(wrapper, error, state);
            }
          });
        } else {
          state.value = value;
          state.state = FULFILLED;
          notify(state, false);
        }
      } catch (error) {
        internalReject({ done: false }, error, state);
      }
    };
    if (FORCED_PROMISE_CONSTRUCTOR) {
      PromiseConstructor = function Promise2(executor) {
        anInstance(this, PromisePrototype);
        aCallable(executor);
        call(Internal, this);
        var state = getInternalPromiseState(this);
        try {
          executor(bind(internalResolve, state), bind(internalReject, state));
        } catch (error) {
          internalReject(state, error);
        }
      };
      PromisePrototype = PromiseConstructor.prototype;
      Internal = function Promise2(executor) {
        setInternalState(this, {
          type: PROMISE,
          done: false,
          notified: false,
          parent: false,
          reactions: new Queue2(),
          rejection: false,
          state: PENDING,
          value: void 0
        });
      };
      Internal.prototype = defineBuiltIn(PromisePrototype, "then", function then(onFulfilled, onRejected) {
        var state = getInternalPromiseState(this);
        var reaction = newPromiseCapability(speciesConstructor(this, PromiseConstructor));
        state.parent = true;
        reaction.ok = isCallable(onFulfilled) ? onFulfilled : true;
        reaction.fail = isCallable(onRejected) && onRejected;
        reaction.domain = IS_NODE ? process2.domain : void 0;
        if (state.state === PENDING)
          state.reactions.add(reaction);
        else
          microtask(function() {
            callReaction(reaction, state);
          });
        return reaction.promise;
      });
      OwnPromiseCapability = function() {
        var promise = new Internal();
        var state = getInternalPromiseState(promise);
        this.promise = promise;
        this.resolve = bind(internalResolve, state);
        this.reject = bind(internalReject, state);
      };
      newPromiseCapabilityModule.f = newPromiseCapability = function(C) {
        return C === PromiseConstructor || C === PromiseWrapper ? new OwnPromiseCapability(C) : newGenericPromiseCapability(C);
      };
      if (!IS_PURE && isCallable(NativePromiseConstructor) && NativePromisePrototype !== Object.prototype) {
        nativeThen = NativePromisePrototype.then;
        if (!NATIVE_PROMISE_SUBCLASSING) {
          defineBuiltIn(NativePromisePrototype, "then", function then(onFulfilled, onRejected) {
            var that = this;
            return new PromiseConstructor(function(resolve, reject) {
              call(nativeThen, that, resolve, reject);
            }).then(onFulfilled, onRejected);
          }, { unsafe: true });
        }
        try {
          delete NativePromisePrototype.constructor;
        } catch (error) {
        }
        if (setPrototypeOf) {
          setPrototypeOf(NativePromisePrototype, PromisePrototype);
        }
      }
    }
    $({ global: true, constructor: true, wrap: true, forced: FORCED_PROMISE_CONSTRUCTOR }, {
      Promise: PromiseConstructor
    });
    setToStringTag(PromiseConstructor, PROMISE, false, true);
    setSpecies(PROMISE);
  }
});

// ../simple-mind-map/node_modules/core-js/internals/iterators.js
var require_iterators = __commonJS({
  "../simple-mind-map/node_modules/core-js/internals/iterators.js"(exports, module) {
    "use strict";
    module.exports = {};
  }
});

// ../simple-mind-map/node_modules/core-js/internals/is-array-iterator-method.js
var require_is_array_iterator_method = __commonJS({
  "../simple-mind-map/node_modules/core-js/internals/is-array-iterator-method.js"(exports, module) {
    "use strict";
    var wellKnownSymbol = require_well_known_symbol();
    var Iterators = require_iterators();
    var ITERATOR = wellKnownSymbol("iterator");
    var ArrayPrototype = Array.prototype;
    module.exports = function(it) {
      return it !== void 0 && (Iterators.Array === it || ArrayPrototype[ITERATOR] === it);
    };
  }
});

// ../simple-mind-map/node_modules/core-js/internals/get-iterator-method.js
var require_get_iterator_method = __commonJS({
  "../simple-mind-map/node_modules/core-js/internals/get-iterator-method.js"(exports, module) {
    "use strict";
    var classof = require_classof();
    var getMethod = require_get_method();
    var isNullOrUndefined = require_is_null_or_undefined();
    var Iterators = require_iterators();
    var wellKnownSymbol = require_well_known_symbol();
    var ITERATOR = wellKnownSymbol("iterator");
    module.exports = function(it) {
      if (!isNullOrUndefined(it))
        return getMethod(it, ITERATOR) || getMethod(it, "@@iterator") || Iterators[classof(it)];
    };
  }
});

// ../simple-mind-map/node_modules/core-js/internals/get-iterator.js
var require_get_iterator = __commonJS({
  "../simple-mind-map/node_modules/core-js/internals/get-iterator.js"(exports, module) {
    "use strict";
    var call = require_function_call();
    var aCallable = require_a_callable();
    var anObject = require_an_object();
    var tryToString = require_try_to_string();
    var getIteratorMethod = require_get_iterator_method();
    var $TypeError = TypeError;
    module.exports = function(argument, usingIterator) {
      var iteratorMethod = arguments.length < 2 ? getIteratorMethod(argument) : usingIterator;
      if (aCallable(iteratorMethod))
        return anObject(call(iteratorMethod, argument));
      throw new $TypeError(tryToString(argument) + " is not iterable");
    };
  }
});

// ../simple-mind-map/node_modules/core-js/internals/iterator-close.js
var require_iterator_close = __commonJS({
  "../simple-mind-map/node_modules/core-js/internals/iterator-close.js"(exports, module) {
    "use strict";
    var call = require_function_call();
    var anObject = require_an_object();
    var getMethod = require_get_method();
    module.exports = function(iterator, kind, value) {
      var innerResult, innerError;
      anObject(iterator);
      try {
        innerResult = getMethod(iterator, "return");
        if (!innerResult) {
          if (kind === "throw")
            throw value;
          return value;
        }
        innerResult = call(innerResult, iterator);
      } catch (error) {
        innerError = true;
        innerResult = error;
      }
      if (kind === "throw")
        throw value;
      if (innerError)
        throw innerResult;
      anObject(innerResult);
      return value;
    };
  }
});

// ../simple-mind-map/node_modules/core-js/internals/iterate.js
var require_iterate = __commonJS({
  "../simple-mind-map/node_modules/core-js/internals/iterate.js"(exports, module) {
    "use strict";
    var bind = require_function_bind_context();
    var call = require_function_call();
    var anObject = require_an_object();
    var tryToString = require_try_to_string();
    var isArrayIteratorMethod = require_is_array_iterator_method();
    var lengthOfArrayLike = require_length_of_array_like();
    var isPrototypeOf = require_object_is_prototype_of();
    var getIterator = require_get_iterator();
    var getIteratorMethod = require_get_iterator_method();
    var iteratorClose = require_iterator_close();
    var $TypeError = TypeError;
    var Result = function(stopped, result) {
      this.stopped = stopped;
      this.result = result;
    };
    var ResultPrototype = Result.prototype;
    module.exports = function(iterable, unboundFunction, options) {
      var that = options && options.that;
      var AS_ENTRIES = !!(options && options.AS_ENTRIES);
      var IS_RECORD = !!(options && options.IS_RECORD);
      var IS_ITERATOR = !!(options && options.IS_ITERATOR);
      var INTERRUPTED = !!(options && options.INTERRUPTED);
      var fn = bind(unboundFunction, that);
      var iterator, iterFn, index3, length2, result, next2, step;
      var stop = function(condition) {
        if (iterator)
          iteratorClose(iterator, "normal", condition);
        return new Result(true, condition);
      };
      var callFn = function(value) {
        if (AS_ENTRIES) {
          anObject(value);
          return INTERRUPTED ? fn(value[0], value[1], stop) : fn(value[0], value[1]);
        }
        return INTERRUPTED ? fn(value, stop) : fn(value);
      };
      if (IS_RECORD) {
        iterator = iterable.iterator;
      } else if (IS_ITERATOR) {
        iterator = iterable;
      } else {
        iterFn = getIteratorMethod(iterable);
        if (!iterFn)
          throw new $TypeError(tryToString(iterable) + " is not iterable");
        if (isArrayIteratorMethod(iterFn)) {
          for (index3 = 0, length2 = lengthOfArrayLike(iterable); length2 > index3; index3++) {
            result = callFn(iterable[index3]);
            if (result && isPrototypeOf(ResultPrototype, result))
              return result;
          }
          return new Result(false);
        }
        iterator = getIterator(iterable, iterFn);
      }
      next2 = IS_RECORD ? iterable.next : iterator.next;
      while (!(step = call(next2, iterator)).done) {
        try {
          result = callFn(step.value);
        } catch (error) {
          iteratorClose(iterator, "throw", error);
        }
        if (typeof result == "object" && result && isPrototypeOf(ResultPrototype, result))
          return result;
      }
      return new Result(false);
    };
  }
});

// ../simple-mind-map/node_modules/core-js/internals/check-correctness-of-iteration.js
var require_check_correctness_of_iteration = __commonJS({
  "../simple-mind-map/node_modules/core-js/internals/check-correctness-of-iteration.js"(exports, module) {
    "use strict";
    var wellKnownSymbol = require_well_known_symbol();
    var ITERATOR = wellKnownSymbol("iterator");
    var SAFE_CLOSING = false;
    try {
      called = 0;
      iteratorWithReturn = {
        next: function() {
          return { done: !!called++ };
        },
        "return": function() {
          SAFE_CLOSING = true;
        }
      };
      iteratorWithReturn[ITERATOR] = function() {
        return this;
      };
      Array.from(iteratorWithReturn, function() {
        throw 2;
      });
    } catch (error) {
    }
    var called;
    var iteratorWithReturn;
    module.exports = function(exec, SKIP_CLOSING) {
      try {
        if (!SKIP_CLOSING && !SAFE_CLOSING)
          return false;
      } catch (error) {
        return false;
      }
      var ITERATION_SUPPORT = false;
      try {
        var object = {};
        object[ITERATOR] = function() {
          return {
            next: function() {
              return { done: ITERATION_SUPPORT = true };
            }
          };
        };
        exec(object);
      } catch (error) {
      }
      return ITERATION_SUPPORT;
    };
  }
});

// ../simple-mind-map/node_modules/core-js/internals/promise-statics-incorrect-iteration.js
var require_promise_statics_incorrect_iteration = __commonJS({
  "../simple-mind-map/node_modules/core-js/internals/promise-statics-incorrect-iteration.js"(exports, module) {
    "use strict";
    var NativePromiseConstructor = require_promise_native_constructor();
    var checkCorrectnessOfIteration = require_check_correctness_of_iteration();
    var FORCED_PROMISE_CONSTRUCTOR = require_promise_constructor_detection().CONSTRUCTOR;
    module.exports = FORCED_PROMISE_CONSTRUCTOR || !checkCorrectnessOfIteration(function(iterable) {
      NativePromiseConstructor.all(iterable).then(void 0, function() {
      });
    });
  }
});

// ../simple-mind-map/node_modules/core-js/modules/es.promise.all.js
var require_es_promise_all = __commonJS({
  "../simple-mind-map/node_modules/core-js/modules/es.promise.all.js"() {
    "use strict";
    var $ = require_export();
    var call = require_function_call();
    var aCallable = require_a_callable();
    var newPromiseCapabilityModule = require_new_promise_capability();
    var perform = require_perform();
    var iterate = require_iterate();
    var PROMISE_STATICS_INCORRECT_ITERATION = require_promise_statics_incorrect_iteration();
    $({ target: "Promise", stat: true, forced: PROMISE_STATICS_INCORRECT_ITERATION }, {
      all: function all2(iterable) {
        var C = this;
        var capability = newPromiseCapabilityModule.f(C);
        var resolve = capability.resolve;
        var reject = capability.reject;
        var result = perform(function() {
          var $promiseResolve = aCallable(C.resolve);
          var values = [];
          var counter = 0;
          var remaining = 1;
          iterate(iterable, function(promise) {
            var index3 = counter++;
            var alreadyCalled = false;
            remaining++;
            call($promiseResolve, C, promise).then(function(value) {
              if (alreadyCalled)
                return;
              alreadyCalled = true;
              values[index3] = value;
              --remaining || resolve(values);
            }, reject);
          });
          --remaining || resolve(values);
        });
        if (result.error)
          reject(result.value);
        return capability.promise;
      }
    });
  }
});

// ../simple-mind-map/node_modules/core-js/modules/es.promise.catch.js
var require_es_promise_catch = __commonJS({
  "../simple-mind-map/node_modules/core-js/modules/es.promise.catch.js"() {
    "use strict";
    var $ = require_export();
    var IS_PURE = require_is_pure();
    var FORCED_PROMISE_CONSTRUCTOR = require_promise_constructor_detection().CONSTRUCTOR;
    var NativePromiseConstructor = require_promise_native_constructor();
    var getBuiltIn = require_get_built_in();
    var isCallable = require_is_callable();
    var defineBuiltIn = require_define_built_in();
    var NativePromisePrototype = NativePromiseConstructor && NativePromiseConstructor.prototype;
    $({ target: "Promise", proto: true, forced: FORCED_PROMISE_CONSTRUCTOR, real: true }, {
      "catch": function(onRejected) {
        return this.then(void 0, onRejected);
      }
    });
    if (!IS_PURE && isCallable(NativePromiseConstructor)) {
      method = getBuiltIn("Promise").prototype["catch"];
      if (NativePromisePrototype["catch"] !== method) {
        defineBuiltIn(NativePromisePrototype, "catch", method, { unsafe: true });
      }
    }
    var method;
  }
});

// ../simple-mind-map/node_modules/core-js/modules/es.promise.race.js
var require_es_promise_race = __commonJS({
  "../simple-mind-map/node_modules/core-js/modules/es.promise.race.js"() {
    "use strict";
    var $ = require_export();
    var call = require_function_call();
    var aCallable = require_a_callable();
    var newPromiseCapabilityModule = require_new_promise_capability();
    var perform = require_perform();
    var iterate = require_iterate();
    var PROMISE_STATICS_INCORRECT_ITERATION = require_promise_statics_incorrect_iteration();
    $({ target: "Promise", stat: true, forced: PROMISE_STATICS_INCORRECT_ITERATION }, {
      race: function race(iterable) {
        var C = this;
        var capability = newPromiseCapabilityModule.f(C);
        var reject = capability.reject;
        var result = perform(function() {
          var $promiseResolve = aCallable(C.resolve);
          iterate(iterable, function(promise) {
            call($promiseResolve, C, promise).then(capability.resolve, reject);
          });
        });
        if (result.error)
          reject(result.value);
        return capability.promise;
      }
    });
  }
});

// ../simple-mind-map/node_modules/core-js/modules/es.promise.reject.js
var require_es_promise_reject = __commonJS({
  "../simple-mind-map/node_modules/core-js/modules/es.promise.reject.js"() {
    "use strict";
    var $ = require_export();
    var call = require_function_call();
    var newPromiseCapabilityModule = require_new_promise_capability();
    var FORCED_PROMISE_CONSTRUCTOR = require_promise_constructor_detection().CONSTRUCTOR;
    $({ target: "Promise", stat: true, forced: FORCED_PROMISE_CONSTRUCTOR }, {
      reject: function reject(r2) {
        var capability = newPromiseCapabilityModule.f(this);
        call(capability.reject, void 0, r2);
        return capability.promise;
      }
    });
  }
});

// ../simple-mind-map/node_modules/core-js/internals/promise-resolve.js
var require_promise_resolve = __commonJS({
  "../simple-mind-map/node_modules/core-js/internals/promise-resolve.js"(exports, module) {
    "use strict";
    var anObject = require_an_object();
    var isObject = require_is_object();
    var newPromiseCapability = require_new_promise_capability();
    module.exports = function(C, x2) {
      anObject(C);
      if (isObject(x2) && x2.constructor === C)
        return x2;
      var promiseCapability = newPromiseCapability.f(C);
      var resolve = promiseCapability.resolve;
      resolve(x2);
      return promiseCapability.promise;
    };
  }
});

// ../simple-mind-map/node_modules/core-js/modules/es.promise.resolve.js
var require_es_promise_resolve = __commonJS({
  "../simple-mind-map/node_modules/core-js/modules/es.promise.resolve.js"() {
    "use strict";
    var $ = require_export();
    var getBuiltIn = require_get_built_in();
    var IS_PURE = require_is_pure();
    var NativePromiseConstructor = require_promise_native_constructor();
    var FORCED_PROMISE_CONSTRUCTOR = require_promise_constructor_detection().CONSTRUCTOR;
    var promiseResolve = require_promise_resolve();
    var PromiseConstructorWrapper = getBuiltIn("Promise");
    var CHECK_WRAPPER = IS_PURE && !FORCED_PROMISE_CONSTRUCTOR;
    $({ target: "Promise", stat: true, forced: IS_PURE || FORCED_PROMISE_CONSTRUCTOR }, {
      resolve: function resolve(x2) {
        return promiseResolve(CHECK_WRAPPER && this === PromiseConstructorWrapper ? NativePromiseConstructor : this, x2);
      }
    });
  }
});

// ../simple-mind-map/node_modules/core-js/modules/es.promise.js
var require_es_promise = __commonJS({
  "../simple-mind-map/node_modules/core-js/modules/es.promise.js"() {
    "use strict";
    require_es_promise_constructor();
    require_es_promise_all();
    require_es_promise_catch();
    require_es_promise_race();
    require_es_promise_reject();
    require_es_promise_resolve();
  }
});

// ../simple-mind-map/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }
  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}
function _asyncToGenerator(fn) {
  return function() {
    var self2 = this, args = arguments;
    return new Promise(function(resolve, reject) {
      var gen = fn.apply(self2, args);
      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }
      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }
      _next(void 0);
    });
  };
}
var init_asyncToGenerator = __esm({
  "../simple-mind-map/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js"() {
  }
});

// ../simple-mind-map/node_modules/core-js/internals/to-string.js
var require_to_string = __commonJS({
  "../simple-mind-map/node_modules/core-js/internals/to-string.js"(exports, module) {
    "use strict";
    var classof = require_classof();
    var $String = String;
    module.exports = function(argument) {
      if (classof(argument) === "Symbol")
        throw new TypeError("Cannot convert a Symbol value to a string");
      return $String(argument);
    };
  }
});

// ../simple-mind-map/node_modules/core-js/internals/regexp-flags.js
var require_regexp_flags = __commonJS({
  "../simple-mind-map/node_modules/core-js/internals/regexp-flags.js"(exports, module) {
    "use strict";
    var anObject = require_an_object();
    module.exports = function() {
      var that = anObject(this);
      var result = "";
      if (that.hasIndices)
        result += "d";
      if (that.global)
        result += "g";
      if (that.ignoreCase)
        result += "i";
      if (that.multiline)
        result += "m";
      if (that.dotAll)
        result += "s";
      if (that.unicode)
        result += "u";
      if (that.unicodeSets)
        result += "v";
      if (that.sticky)
        result += "y";
      return result;
    };
  }
});

// ../simple-mind-map/node_modules/core-js/internals/regexp-sticky-helpers.js
var require_regexp_sticky_helpers = __commonJS({
  "../simple-mind-map/node_modules/core-js/internals/regexp-sticky-helpers.js"(exports, module) {
    "use strict";
    var fails = require_fails();
    var global2 = require_global();
    var $RegExp = global2.RegExp;
    var UNSUPPORTED_Y = fails(function() {
      var re = $RegExp("a", "y");
      re.lastIndex = 2;
      return re.exec("abcd") !== null;
    });
    var MISSED_STICKY = UNSUPPORTED_Y || fails(function() {
      return !$RegExp("a", "y").sticky;
    });
    var BROKEN_CARET = UNSUPPORTED_Y || fails(function() {
      var re = $RegExp("^r", "gy");
      re.lastIndex = 2;
      return re.exec("str") !== null;
    });
    module.exports = {
      BROKEN_CARET,
      MISSED_STICKY,
      UNSUPPORTED_Y
    };
  }
});

// ../simple-mind-map/node_modules/core-js/internals/object-keys.js
var require_object_keys = __commonJS({
  "../simple-mind-map/node_modules/core-js/internals/object-keys.js"(exports, module) {
    "use strict";
    var internalObjectKeys = require_object_keys_internal();
    var enumBugKeys = require_enum_bug_keys();
    module.exports = Object.keys || function keys(O2) {
      return internalObjectKeys(O2, enumBugKeys);
    };
  }
});

// ../simple-mind-map/node_modules/core-js/internals/object-define-properties.js
var require_object_define_properties = __commonJS({
  "../simple-mind-map/node_modules/core-js/internals/object-define-properties.js"(exports) {
    "use strict";
    var DESCRIPTORS = require_descriptors();
    var V8_PROTOTYPE_DEFINE_BUG = require_v8_prototype_define_bug();
    var definePropertyModule = require_object_define_property();
    var anObject = require_an_object();
    var toIndexedObject = require_to_indexed_object();
    var objectKeys = require_object_keys();
    exports.f = DESCRIPTORS && !V8_PROTOTYPE_DEFINE_BUG ? Object.defineProperties : function defineProperties(O2, Properties) {
      anObject(O2);
      var props = toIndexedObject(Properties);
      var keys = objectKeys(Properties);
      var length2 = keys.length;
      var index3 = 0;
      var key;
      while (length2 > index3)
        definePropertyModule.f(O2, key = keys[index3++], props[key]);
      return O2;
    };
  }
});

// ../simple-mind-map/node_modules/core-js/internals/object-create.js
var require_object_create = __commonJS({
  "../simple-mind-map/node_modules/core-js/internals/object-create.js"(exports, module) {
    "use strict";
    var anObject = require_an_object();
    var definePropertiesModule = require_object_define_properties();
    var enumBugKeys = require_enum_bug_keys();
    var hiddenKeys = require_hidden_keys();
    var html2 = require_html();
    var documentCreateElement = require_document_create_element();
    var sharedKey = require_shared_key();
    var GT = ">";
    var LT = "<";
    var PROTOTYPE = "prototype";
    var SCRIPT = "script";
    var IE_PROTO = sharedKey("IE_PROTO");
    var EmptyConstructor = function() {
    };
    var scriptTag = function(content3) {
      return LT + SCRIPT + GT + content3 + LT + "/" + SCRIPT + GT;
    };
    var NullProtoObjectViaActiveX = function(activeXDocument2) {
      activeXDocument2.write(scriptTag(""));
      activeXDocument2.close();
      var temp = activeXDocument2.parentWindow.Object;
      activeXDocument2 = null;
      return temp;
    };
    var NullProtoObjectViaIFrame = function() {
      var iframe = documentCreateElement("iframe");
      var JS = "java" + SCRIPT + ":";
      var iframeDocument;
      iframe.style.display = "none";
      html2.appendChild(iframe);
      iframe.src = String(JS);
      iframeDocument = iframe.contentWindow.document;
      iframeDocument.open();
      iframeDocument.write(scriptTag("document.F=Object"));
      iframeDocument.close();
      return iframeDocument.F;
    };
    var activeXDocument;
    var NullProtoObject = function() {
      try {
        activeXDocument = new ActiveXObject("htmlfile");
      } catch (error) {
      }
      NullProtoObject = typeof document != "undefined" ? document.domain && activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) : NullProtoObjectViaIFrame() : NullProtoObjectViaActiveX(activeXDocument);
      var length2 = enumBugKeys.length;
      while (length2--)
        delete NullProtoObject[PROTOTYPE][enumBugKeys[length2]];
      return NullProtoObject();
    };
    hiddenKeys[IE_PROTO] = true;
    module.exports = Object.create || function create2(O2, Properties) {
      var result;
      if (O2 !== null) {
        EmptyConstructor[PROTOTYPE] = anObject(O2);
        result = new EmptyConstructor();
        EmptyConstructor[PROTOTYPE] = null;
        result[IE_PROTO] = O2;
      } else
        result = NullProtoObject();
      return Properties === void 0 ? result : definePropertiesModule.f(result, Properties);
    };
  }
});

// ../simple-mind-map/node_modules/core-js/internals/regexp-unsupported-dot-all.js
var require_regexp_unsupported_dot_all = __commonJS({
  "../simple-mind-map/node_modules/core-js/internals/regexp-unsupported-dot-all.js"(exports, module) {
    "use strict";
    var fails = require_fails();
    var global2 = require_global();
    var $RegExp = global2.RegExp;
    module.exports = fails(function() {
      var re = $RegExp(".", "s");
      return !(re.dotAll && re.test("\n") && re.flags === "s");
    });
  }
});

// ../simple-mind-map/node_modules/core-js/internals/regexp-unsupported-ncg.js
var require_regexp_unsupported_ncg = __commonJS({
  "../simple-mind-map/node_modules/core-js/internals/regexp-unsupported-ncg.js"(exports, module) {
    "use strict";
    var fails = require_fails();
    var global2 = require_global();
    var $RegExp = global2.RegExp;
    module.exports = fails(function() {
      var re = $RegExp("(?<a>b)", "g");
      return re.exec("b").groups.a !== "b" || "b".replace(re, "$<a>c") !== "bc";
    });
  }
});

// ../simple-mind-map/node_modules/core-js/internals/regexp-exec.js
var require_regexp_exec = __commonJS({
  "../simple-mind-map/node_modules/core-js/internals/regexp-exec.js"(exports, module) {
    "use strict";
    var call = require_function_call();
    var uncurryThis = require_function_uncurry_this();
    var toString2 = require_to_string();
    var regexpFlags = require_regexp_flags();
    var stickyHelpers = require_regexp_sticky_helpers();
    var shared = require_shared();
    var create2 = require_object_create();
    var getInternalState = require_internal_state().get;
    var UNSUPPORTED_DOT_ALL = require_regexp_unsupported_dot_all();
    var UNSUPPORTED_NCG = require_regexp_unsupported_ncg();
    var nativeReplace = shared("native-string-replace", String.prototype.replace);
    var nativeExec = RegExp.prototype.exec;
    var patchedExec = nativeExec;
    var charAt = uncurryThis("".charAt);
    var indexOf = uncurryThis("".indexOf);
    var replace = uncurryThis("".replace);
    var stringSlice = uncurryThis("".slice);
    var UPDATES_LAST_INDEX_WRONG = function() {
      var re1 = /a/;
      var re2 = /b*/g;
      call(nativeExec, re1, "a");
      call(nativeExec, re2, "a");
      return re1.lastIndex !== 0 || re2.lastIndex !== 0;
    }();
    var UNSUPPORTED_Y = stickyHelpers.BROKEN_CARET;
    var NPCG_INCLUDED = /()??/.exec("")[1] !== void 0;
    var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED || UNSUPPORTED_Y || UNSUPPORTED_DOT_ALL || UNSUPPORTED_NCG;
    if (PATCH) {
      patchedExec = function exec(string3) {
        var re = this;
        var state = getInternalState(re);
        var str = toString2(string3);
        var raw = state.raw;
        var result, reCopy, lastIndex, match, i2, object, group;
        if (raw) {
          raw.lastIndex = re.lastIndex;
          result = call(patchedExec, raw, str);
          re.lastIndex = raw.lastIndex;
          return result;
        }
        var groups = state.groups;
        var sticky = UNSUPPORTED_Y && re.sticky;
        var flags = call(regexpFlags, re);
        var source = re.source;
        var charsAdded = 0;
        var strCopy = str;
        if (sticky) {
          flags = replace(flags, "y", "");
          if (indexOf(flags, "g") === -1) {
            flags += "g";
          }
          strCopy = stringSlice(str, re.lastIndex);
          if (re.lastIndex > 0 && (!re.multiline || re.multiline && charAt(str, re.lastIndex - 1) !== "\n")) {
            source = "(?: " + source + ")";
            strCopy = " " + strCopy;
            charsAdded++;
          }
          reCopy = new RegExp("^(?:" + source + ")", flags);
        }
        if (NPCG_INCLUDED) {
          reCopy = new RegExp("^" + source + "$(?!\\s)", flags);
        }
        if (UPDATES_LAST_INDEX_WRONG)
          lastIndex = re.lastIndex;
        match = call(nativeExec, sticky ? reCopy : re, strCopy);
        if (sticky) {
          if (match) {
            match.input = stringSlice(match.input, charsAdded);
            match[0] = stringSlice(match[0], charsAdded);
            match.index = re.lastIndex;
            re.lastIndex += match[0].length;
          } else
            re.lastIndex = 0;
        } else if (UPDATES_LAST_INDEX_WRONG && match) {
          re.lastIndex = re.global ? match.index + match[0].length : lastIndex;
        }
        if (NPCG_INCLUDED && match && match.length > 1) {
          call(nativeReplace, match[0], reCopy, function() {
            for (i2 = 1; i2 < arguments.length - 2; i2++) {
              if (arguments[i2] === void 0)
                match[i2] = void 0;
            }
          });
        }
        if (match && groups) {
          match.groups = object = create2(null);
          for (i2 = 0; i2 < groups.length; i2++) {
            group = groups[i2];
            object[group[0]] = match[group[1]];
          }
        }
        return match;
      };
    }
    module.exports = patchedExec;
  }
});

// ../simple-mind-map/node_modules/core-js/modules/es.regexp.exec.js
var require_es_regexp_exec = __commonJS({
  "../simple-mind-map/node_modules/core-js/modules/es.regexp.exec.js"() {
    "use strict";
    var $ = require_export();
    var exec = require_regexp_exec();
    $({ target: "RegExp", proto: true, forced: /./.exec !== exec }, {
      exec
    });
  }
});

// ../simple-mind-map/node_modules/core-js/internals/fix-regexp-well-known-symbol-logic.js
var require_fix_regexp_well_known_symbol_logic = __commonJS({
  "../simple-mind-map/node_modules/core-js/internals/fix-regexp-well-known-symbol-logic.js"(exports, module) {
    "use strict";
    require_es_regexp_exec();
    var uncurryThis = require_function_uncurry_this_clause();
    var defineBuiltIn = require_define_built_in();
    var regexpExec = require_regexp_exec();
    var fails = require_fails();
    var wellKnownSymbol = require_well_known_symbol();
    var createNonEnumerableProperty = require_create_non_enumerable_property();
    var SPECIES = wellKnownSymbol("species");
    var RegExpPrototype = RegExp.prototype;
    module.exports = function(KEY, exec, FORCED, SHAM) {
      var SYMBOL = wellKnownSymbol(KEY);
      var DELEGATES_TO_SYMBOL = !fails(function() {
        var O2 = {};
        O2[SYMBOL] = function() {
          return 7;
        };
        return ""[KEY](O2) !== 7;
      });
      var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL && !fails(function() {
        var execCalled = false;
        var re = /a/;
        if (KEY === "split") {
          re = {};
          re.constructor = {};
          re.constructor[SPECIES] = function() {
            return re;
          };
          re.flags = "";
          re[SYMBOL] = /./[SYMBOL];
        }
        re.exec = function() {
          execCalled = true;
          return null;
        };
        re[SYMBOL]("");
        return !execCalled;
      });
      if (!DELEGATES_TO_SYMBOL || !DELEGATES_TO_EXEC || FORCED) {
        var uncurriedNativeRegExpMethod = uncurryThis(/./[SYMBOL]);
        var methods2 = exec(SYMBOL, ""[KEY], function(nativeMethod, regexp, str, arg2, forceStringMethod) {
          var uncurriedNativeMethod = uncurryThis(nativeMethod);
          var $exec = regexp.exec;
          if ($exec === regexpExec || $exec === RegExpPrototype.exec) {
            if (DELEGATES_TO_SYMBOL && !forceStringMethod) {
              return { done: true, value: uncurriedNativeRegExpMethod(regexp, str, arg2) };
            }
            return { done: true, value: uncurriedNativeMethod(str, regexp, arg2) };
          }
          return { done: false };
        });
        defineBuiltIn(String.prototype, KEY, methods2[0]);
        defineBuiltIn(RegExpPrototype, SYMBOL, methods2[1]);
      }
      if (SHAM)
        createNonEnumerableProperty(RegExpPrototype[SYMBOL], "sham", true);
    };
  }
});

// ../simple-mind-map/node_modules/core-js/internals/string-multibyte.js
var require_string_multibyte = __commonJS({
  "../simple-mind-map/node_modules/core-js/internals/string-multibyte.js"(exports, module) {
    "use strict";
    var uncurryThis = require_function_uncurry_this();
    var toIntegerOrInfinity = require_to_integer_or_infinity();
    var toString2 = require_to_string();
    var requireObjectCoercible = require_require_object_coercible();
    var charAt = uncurryThis("".charAt);
    var charCodeAt = uncurryThis("".charCodeAt);
    var stringSlice = uncurryThis("".slice);
    var createMethod = function(CONVERT_TO_STRING) {
      return function($this, pos) {
        var S2 = toString2(requireObjectCoercible($this));
        var position3 = toIntegerOrInfinity(pos);
        var size2 = S2.length;
        var first, second;
        if (position3 < 0 || position3 >= size2)
          return CONVERT_TO_STRING ? "" : void 0;
        first = charCodeAt(S2, position3);
        return first < 55296 || first > 56319 || position3 + 1 === size2 || (second = charCodeAt(S2, position3 + 1)) < 56320 || second > 57343 ? CONVERT_TO_STRING ? charAt(S2, position3) : first : CONVERT_TO_STRING ? stringSlice(S2, position3, position3 + 2) : (first - 55296 << 10) + (second - 56320) + 65536;
      };
    };
    module.exports = {
      // `String.prototype.codePointAt` method
      // https://tc39.es/ecma262/#sec-string.prototype.codepointat
      codeAt: createMethod(false),
      // `String.prototype.at` method
      // https://github.com/mathiasbynens/String.prototype.at
      charAt: createMethod(true)
    };
  }
});

// ../simple-mind-map/node_modules/core-js/internals/advance-string-index.js
var require_advance_string_index = __commonJS({
  "../simple-mind-map/node_modules/core-js/internals/advance-string-index.js"(exports, module) {
    "use strict";
    var charAt = require_string_multibyte().charAt;
    module.exports = function(S2, index3, unicode) {
      return index3 + (unicode ? charAt(S2, index3).length : 1);
    };
  }
});

// ../simple-mind-map/node_modules/core-js/internals/regexp-exec-abstract.js
var require_regexp_exec_abstract = __commonJS({
  "../simple-mind-map/node_modules/core-js/internals/regexp-exec-abstract.js"(exports, module) {
    "use strict";
    var call = require_function_call();
    var anObject = require_an_object();
    var isCallable = require_is_callable();
    var classof = require_classof_raw();
    var regexpExec = require_regexp_exec();
    var $TypeError = TypeError;
    module.exports = function(R, S2) {
      var exec = R.exec;
      if (isCallable(exec)) {
        var result = call(exec, R, S2);
        if (result !== null)
          anObject(result);
        return result;
      }
      if (classof(R) === "RegExp")
        return call(regexpExec, R, S2);
      throw new $TypeError("RegExp#exec called on incompatible receiver");
    };
  }
});

// ../simple-mind-map/node_modules/core-js/modules/es.string.match.js
var require_es_string_match = __commonJS({
  "../simple-mind-map/node_modules/core-js/modules/es.string.match.js"() {
    "use strict";
    var call = require_function_call();
    var fixRegExpWellKnownSymbolLogic = require_fix_regexp_well_known_symbol_logic();
    var anObject = require_an_object();
    var isNullOrUndefined = require_is_null_or_undefined();
    var toLength = require_to_length();
    var toString2 = require_to_string();
    var requireObjectCoercible = require_require_object_coercible();
    var getMethod = require_get_method();
    var advanceStringIndex = require_advance_string_index();
    var regExpExec = require_regexp_exec_abstract();
    fixRegExpWellKnownSymbolLogic("match", function(MATCH, nativeMatch, maybeCallNative) {
      return [
        // `String.prototype.match` method
        // https://tc39.es/ecma262/#sec-string.prototype.match
        function match(regexp) {
          var O2 = requireObjectCoercible(this);
          var matcher = isNullOrUndefined(regexp) ? void 0 : getMethod(regexp, MATCH);
          return matcher ? call(matcher, regexp, O2) : new RegExp(regexp)[MATCH](toString2(O2));
        },
        // `RegExp.prototype[@@match]` method
        // https://tc39.es/ecma262/#sec-regexp.prototype-@@match
        function(string3) {
          var rx2 = anObject(this);
          var S2 = toString2(string3);
          var res = maybeCallNative(nativeMatch, rx2, S2);
          if (res.done)
            return res.value;
          if (!rx2.global)
            return regExpExec(rx2, S2);
          var fullUnicode = rx2.unicode;
          rx2.lastIndex = 0;
          var A2 = [];
          var n2 = 0;
          var result;
          while ((result = regExpExec(rx2, S2)) !== null) {
            var matchStr = toString2(result[0]);
            A2[n2] = matchStr;
            if (matchStr === "")
              rx2.lastIndex = advanceStringIndex(S2, toLength(rx2.lastIndex), fullUnicode);
            n2++;
          }
          return n2 === 0 ? null : A2;
        }
      ];
    });
  }
});

// ../simple-mind-map/node_modules/core-js/internals/get-substitution.js
var require_get_substitution = __commonJS({
  "../simple-mind-map/node_modules/core-js/internals/get-substitution.js"(exports, module) {
    "use strict";
    var uncurryThis = require_function_uncurry_this();
    var toObject = require_to_object();
    var floor = Math.floor;
    var charAt = uncurryThis("".charAt);
    var replace = uncurryThis("".replace);
    var stringSlice = uncurryThis("".slice);
    var SUBSTITUTION_SYMBOLS = /\$([$&'`]|\d{1,2}|<[^>]*>)/g;
    var SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&'`]|\d{1,2})/g;
    module.exports = function(matched, str, position3, captures, namedCaptures, replacement) {
      var tailPos = position3 + matched.length;
      var m3 = captures.length;
      var symbols2 = SUBSTITUTION_SYMBOLS_NO_NAMED;
      if (namedCaptures !== void 0) {
        namedCaptures = toObject(namedCaptures);
        symbols2 = SUBSTITUTION_SYMBOLS;
      }
      return replace(replacement, symbols2, function(match, ch) {
        var capture;
        switch (charAt(ch, 0)) {
          case "$":
            return "$";
          case "&":
            return matched;
          case "`":
            return stringSlice(str, 0, position3);
          case "'":
            return stringSlice(str, tailPos);
          case "<":
            capture = namedCaptures[stringSlice(ch, 1, -1)];
            break;
          default:
            var n2 = +ch;
            if (n2 === 0)
              return match;
            if (n2 > m3) {
              var f3 = floor(n2 / 10);
              if (f3 === 0)
                return match;
              if (f3 <= m3)
                return captures[f3 - 1] === void 0 ? charAt(ch, 1) : captures[f3 - 1] + charAt(ch, 1);
              return match;
            }
            capture = captures[n2 - 1];
        }
        return capture === void 0 ? "" : capture;
      });
    };
  }
});

// ../simple-mind-map/node_modules/core-js/modules/es.string.replace.js
var require_es_string_replace = __commonJS({
  "../simple-mind-map/node_modules/core-js/modules/es.string.replace.js"() {
    "use strict";
    var apply = require_function_apply();
    var call = require_function_call();
    var uncurryThis = require_function_uncurry_this();
    var fixRegExpWellKnownSymbolLogic = require_fix_regexp_well_known_symbol_logic();
    var fails = require_fails();
    var anObject = require_an_object();
    var isCallable = require_is_callable();
    var isNullOrUndefined = require_is_null_or_undefined();
    var toIntegerOrInfinity = require_to_integer_or_infinity();
    var toLength = require_to_length();
    var toString2 = require_to_string();
    var requireObjectCoercible = require_require_object_coercible();
    var advanceStringIndex = require_advance_string_index();
    var getMethod = require_get_method();
    var getSubstitution = require_get_substitution();
    var regExpExec = require_regexp_exec_abstract();
    var wellKnownSymbol = require_well_known_symbol();
    var REPLACE = wellKnownSymbol("replace");
    var max2 = Math.max;
    var min = Math.min;
    var concat = uncurryThis([].concat);
    var push2 = uncurryThis([].push);
    var stringIndexOf = uncurryThis("".indexOf);
    var stringSlice = uncurryThis("".slice);
    var maybeToString = function(it) {
      return it === void 0 ? it : String(it);
    };
    var REPLACE_KEEPS_$0 = function() {
      return "a".replace(/./, "$0") === "$0";
    }();
    var REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE = function() {
      if (/./[REPLACE]) {
        return /./[REPLACE]("a", "$0") === "";
      }
      return false;
    }();
    var REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function() {
      var re = /./;
      re.exec = function() {
        var result = [];
        result.groups = { a: "7" };
        return result;
      };
      return "".replace(re, "$<a>") !== "7";
    });
    fixRegExpWellKnownSymbolLogic("replace", function(_2, nativeReplace, maybeCallNative) {
      var UNSAFE_SUBSTITUTE = REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE ? "$" : "$0";
      return [
        // `String.prototype.replace` method
        // https://tc39.es/ecma262/#sec-string.prototype.replace
        function replace(searchValue, replaceValue) {
          var O2 = requireObjectCoercible(this);
          var replacer = isNullOrUndefined(searchValue) ? void 0 : getMethod(searchValue, REPLACE);
          return replacer ? call(replacer, searchValue, O2, replaceValue) : call(nativeReplace, toString2(O2), searchValue, replaceValue);
        },
        // `RegExp.prototype[@@replace]` method
        // https://tc39.es/ecma262/#sec-regexp.prototype-@@replace
        function(string3, replaceValue) {
          var rx2 = anObject(this);
          var S2 = toString2(string3);
          if (typeof replaceValue == "string" && stringIndexOf(replaceValue, UNSAFE_SUBSTITUTE) === -1 && stringIndexOf(replaceValue, "$<") === -1) {
            var res = maybeCallNative(nativeReplace, rx2, S2, replaceValue);
            if (res.done)
              return res.value;
          }
          var functionalReplace = isCallable(replaceValue);
          if (!functionalReplace)
            replaceValue = toString2(replaceValue);
          var global2 = rx2.global;
          var fullUnicode;
          if (global2) {
            fullUnicode = rx2.unicode;
            rx2.lastIndex = 0;
          }
          var results = [];
          var result;
          while (true) {
            result = regExpExec(rx2, S2);
            if (result === null)
              break;
            push2(results, result);
            if (!global2)
              break;
            var matchStr = toString2(result[0]);
            if (matchStr === "")
              rx2.lastIndex = advanceStringIndex(S2, toLength(rx2.lastIndex), fullUnicode);
          }
          var accumulatedResult = "";
          var nextSourcePosition = 0;
          for (var i2 = 0; i2 < results.length; i2++) {
            result = results[i2];
            var matched = toString2(result[0]);
            var position3 = max2(min(toIntegerOrInfinity(result.index), S2.length), 0);
            var captures = [];
            var replacement;
            for (var j = 1; j < result.length; j++)
              push2(captures, maybeToString(result[j]));
            var namedCaptures = result.groups;
            if (functionalReplace) {
              var replacerArgs = concat([matched], captures, position3, S2);
              if (namedCaptures !== void 0)
                push2(replacerArgs, namedCaptures);
              replacement = toString2(apply(replaceValue, void 0, replacerArgs));
            } else {
              replacement = getSubstitution(matched, S2, position3, captures, namedCaptures, replaceValue);
            }
            if (position3 >= nextSourcePosition) {
              accumulatedResult += stringSlice(S2, nextSourcePosition, position3) + replacement;
              nextSourcePosition = position3 + matched.length;
            }
          }
          return accumulatedResult + stringSlice(S2, nextSourcePosition);
        }
      ];
    }, !REPLACE_SUPPORTS_NAMED_GROUPS || !REPLACE_KEEPS_$0 || REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE);
  }
});

// ../simple-mind-map/node_modules/core-js/internals/is-regexp.js
var require_is_regexp = __commonJS({
  "../simple-mind-map/node_modules/core-js/internals/is-regexp.js"(exports, module) {
    "use strict";
    var isObject = require_is_object();
    var classof = require_classof_raw();
    var wellKnownSymbol = require_well_known_symbol();
    var MATCH = wellKnownSymbol("match");
    module.exports = function(it) {
      var isRegExp;
      return isObject(it) && ((isRegExp = it[MATCH]) !== void 0 ? !!isRegExp : classof(it) === "RegExp");
    };
  }
});

// ../simple-mind-map/node_modules/core-js/internals/not-a-regexp.js
var require_not_a_regexp = __commonJS({
  "../simple-mind-map/node_modules/core-js/internals/not-a-regexp.js"(exports, module) {
    "use strict";
    var isRegExp = require_is_regexp();
    var $TypeError = TypeError;
    module.exports = function(it) {
      if (isRegExp(it)) {
        throw new $TypeError("The method doesn't accept regular expressions");
      }
      return it;
    };
  }
});

// ../simple-mind-map/node_modules/core-js/internals/correct-is-regexp-logic.js
var require_correct_is_regexp_logic = __commonJS({
  "../simple-mind-map/node_modules/core-js/internals/correct-is-regexp-logic.js"(exports, module) {
    "use strict";
    var wellKnownSymbol = require_well_known_symbol();
    var MATCH = wellKnownSymbol("match");
    module.exports = function(METHOD_NAME) {
      var regexp = /./;
      try {
        "/./"[METHOD_NAME](regexp);
      } catch (error1) {
        try {
          regexp[MATCH] = false;
          return "/./"[METHOD_NAME](regexp);
        } catch (error2) {
        }
      }
      return false;
    };
  }
});

// ../simple-mind-map/node_modules/core-js/modules/es.string.starts-with.js
var require_es_string_starts_with = __commonJS({
  "../simple-mind-map/node_modules/core-js/modules/es.string.starts-with.js"() {
    "use strict";
    var $ = require_export();
    var uncurryThis = require_function_uncurry_this_clause();
    var getOwnPropertyDescriptor = require_object_get_own_property_descriptor().f;
    var toLength = require_to_length();
    var toString2 = require_to_string();
    var notARegExp = require_not_a_regexp();
    var requireObjectCoercible = require_require_object_coercible();
    var correctIsRegExpLogic = require_correct_is_regexp_logic();
    var IS_PURE = require_is_pure();
    var nativeStartsWith = uncurryThis("".startsWith);
    var stringSlice = uncurryThis("".slice);
    var min = Math.min;
    var CORRECT_IS_REGEXP_LOGIC = correctIsRegExpLogic("startsWith");
    var MDN_POLYFILL_BUG = !IS_PURE && !CORRECT_IS_REGEXP_LOGIC && !!function() {
      var descriptor = getOwnPropertyDescriptor(String.prototype, "startsWith");
      return descriptor && !descriptor.writable;
    }();
    $({ target: "String", proto: true, forced: !MDN_POLYFILL_BUG && !CORRECT_IS_REGEXP_LOGIC }, {
      startsWith: function startsWith(searchString) {
        var that = toString2(requireObjectCoercible(this));
        notARegExp(searchString);
        var index3 = toLength(min(arguments.length > 1 ? arguments[1] : void 0, that.length));
        var search2 = toString2(searchString);
        return nativeStartsWith ? nativeStartsWith(that, search2, index3) : stringSlice(that, index3, index3 + search2.length) === search2;
      }
    });
  }
});

// ../simple-mind-map/node_modules/core-js/internals/add-to-unscopables.js
var require_add_to_unscopables = __commonJS({
  "../simple-mind-map/node_modules/core-js/internals/add-to-unscopables.js"(exports, module) {
    "use strict";
    var wellKnownSymbol = require_well_known_symbol();
    var create2 = require_object_create();
    var defineProperty = require_object_define_property().f;
    var UNSCOPABLES = wellKnownSymbol("unscopables");
    var ArrayPrototype = Array.prototype;
    if (ArrayPrototype[UNSCOPABLES] === void 0) {
      defineProperty(ArrayPrototype, UNSCOPABLES, {
        configurable: true,
        value: create2(null)
      });
    }
    module.exports = function(key) {
      ArrayPrototype[UNSCOPABLES][key] = true;
    };
  }
});

// ../simple-mind-map/node_modules/core-js/internals/correct-prototype-getter.js
var require_correct_prototype_getter = __commonJS({
  "../simple-mind-map/node_modules/core-js/internals/correct-prototype-getter.js"(exports, module) {
    "use strict";
    var fails = require_fails();
    module.exports = !fails(function() {
      function F() {
      }
      F.prototype.constructor = null;
      return Object.getPrototypeOf(new F()) !== F.prototype;
    });
  }
});

// ../simple-mind-map/node_modules/core-js/internals/object-get-prototype-of.js
var require_object_get_prototype_of = __commonJS({
  "../simple-mind-map/node_modules/core-js/internals/object-get-prototype-of.js"(exports, module) {
    "use strict";
    var hasOwn = require_has_own_property();
    var isCallable = require_is_callable();
    var toObject = require_to_object();
    var sharedKey = require_shared_key();
    var CORRECT_PROTOTYPE_GETTER = require_correct_prototype_getter();
    var IE_PROTO = sharedKey("IE_PROTO");
    var $Object = Object;
    var ObjectPrototype = $Object.prototype;
    module.exports = CORRECT_PROTOTYPE_GETTER ? $Object.getPrototypeOf : function(O2) {
      var object = toObject(O2);
      if (hasOwn(object, IE_PROTO))
        return object[IE_PROTO];
      var constructor = object.constructor;
      if (isCallable(constructor) && object instanceof constructor) {
        return constructor.prototype;
      }
      return object instanceof $Object ? ObjectPrototype : null;
    };
  }
});

// ../simple-mind-map/node_modules/core-js/internals/iterators-core.js
var require_iterators_core = __commonJS({
  "../simple-mind-map/node_modules/core-js/internals/iterators-core.js"(exports, module) {
    "use strict";
    var fails = require_fails();
    var isCallable = require_is_callable();
    var isObject = require_is_object();
    var create2 = require_object_create();
    var getPrototypeOf = require_object_get_prototype_of();
    var defineBuiltIn = require_define_built_in();
    var wellKnownSymbol = require_well_known_symbol();
    var IS_PURE = require_is_pure();
    var ITERATOR = wellKnownSymbol("iterator");
    var BUGGY_SAFARI_ITERATORS = false;
    var IteratorPrototype;
    var PrototypeOfArrayIteratorPrototype;
    var arrayIterator;
    if ([].keys) {
      arrayIterator = [].keys();
      if (!("next" in arrayIterator))
        BUGGY_SAFARI_ITERATORS = true;
      else {
        PrototypeOfArrayIteratorPrototype = getPrototypeOf(getPrototypeOf(arrayIterator));
        if (PrototypeOfArrayIteratorPrototype !== Object.prototype)
          IteratorPrototype = PrototypeOfArrayIteratorPrototype;
      }
    }
    var NEW_ITERATOR_PROTOTYPE = !isObject(IteratorPrototype) || fails(function() {
      var test = {};
      return IteratorPrototype[ITERATOR].call(test) !== test;
    });
    if (NEW_ITERATOR_PROTOTYPE)
      IteratorPrototype = {};
    else if (IS_PURE)
      IteratorPrototype = create2(IteratorPrototype);
    if (!isCallable(IteratorPrototype[ITERATOR])) {
      defineBuiltIn(IteratorPrototype, ITERATOR, function() {
        return this;
      });
    }
    module.exports = {
      IteratorPrototype,
      BUGGY_SAFARI_ITERATORS
    };
  }
});

// ../simple-mind-map/node_modules/core-js/internals/iterator-create-constructor.js
var require_iterator_create_constructor = __commonJS({
  "../simple-mind-map/node_modules/core-js/internals/iterator-create-constructor.js"(exports, module) {
    "use strict";
    var IteratorPrototype = require_iterators_core().IteratorPrototype;
    var create2 = require_object_create();
    var createPropertyDescriptor = require_create_property_descriptor();
    var setToStringTag = require_set_to_string_tag();
    var Iterators = require_iterators();
    var returnThis = function() {
      return this;
    };
    module.exports = function(IteratorConstructor, NAME, next2, ENUMERABLE_NEXT) {
      var TO_STRING_TAG = NAME + " Iterator";
      IteratorConstructor.prototype = create2(IteratorPrototype, { next: createPropertyDescriptor(+!ENUMERABLE_NEXT, next2) });
      setToStringTag(IteratorConstructor, TO_STRING_TAG, false, true);
      Iterators[TO_STRING_TAG] = returnThis;
      return IteratorConstructor;
    };
  }
});

// ../simple-mind-map/node_modules/core-js/internals/iterator-define.js
var require_iterator_define = __commonJS({
  "../simple-mind-map/node_modules/core-js/internals/iterator-define.js"(exports, module) {
    "use strict";
    var $ = require_export();
    var call = require_function_call();
    var IS_PURE = require_is_pure();
    var FunctionName = require_function_name();
    var isCallable = require_is_callable();
    var createIteratorConstructor = require_iterator_create_constructor();
    var getPrototypeOf = require_object_get_prototype_of();
    var setPrototypeOf = require_object_set_prototype_of();
    var setToStringTag = require_set_to_string_tag();
    var createNonEnumerableProperty = require_create_non_enumerable_property();
    var defineBuiltIn = require_define_built_in();
    var wellKnownSymbol = require_well_known_symbol();
    var Iterators = require_iterators();
    var IteratorsCore = require_iterators_core();
    var PROPER_FUNCTION_NAME = FunctionName.PROPER;
    var CONFIGURABLE_FUNCTION_NAME = FunctionName.CONFIGURABLE;
    var IteratorPrototype = IteratorsCore.IteratorPrototype;
    var BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;
    var ITERATOR = wellKnownSymbol("iterator");
    var KEYS = "keys";
    var VALUES = "values";
    var ENTRIES = "entries";
    var returnThis = function() {
      return this;
    };
    module.exports = function(Iterable, NAME, IteratorConstructor, next2, DEFAULT, IS_SET, FORCED) {
      createIteratorConstructor(IteratorConstructor, NAME, next2);
      var getIterationMethod = function(KIND) {
        if (KIND === DEFAULT && defaultIterator)
          return defaultIterator;
        if (!BUGGY_SAFARI_ITERATORS && KIND && KIND in IterablePrototype)
          return IterablePrototype[KIND];
        switch (KIND) {
          case KEYS:
            return function keys() {
              return new IteratorConstructor(this, KIND);
            };
          case VALUES:
            return function values() {
              return new IteratorConstructor(this, KIND);
            };
          case ENTRIES:
            return function entries() {
              return new IteratorConstructor(this, KIND);
            };
        }
        return function() {
          return new IteratorConstructor(this);
        };
      };
      var TO_STRING_TAG = NAME + " Iterator";
      var INCORRECT_VALUES_NAME = false;
      var IterablePrototype = Iterable.prototype;
      var nativeIterator = IterablePrototype[ITERATOR] || IterablePrototype["@@iterator"] || DEFAULT && IterablePrototype[DEFAULT];
      var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);
      var anyNativeIterator = NAME === "Array" ? IterablePrototype.entries || nativeIterator : nativeIterator;
      var CurrentIteratorPrototype, methods2, KEY;
      if (anyNativeIterator) {
        CurrentIteratorPrototype = getPrototypeOf(anyNativeIterator.call(new Iterable()));
        if (CurrentIteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {
          if (!IS_PURE && getPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype) {
            if (setPrototypeOf) {
              setPrototypeOf(CurrentIteratorPrototype, IteratorPrototype);
            } else if (!isCallable(CurrentIteratorPrototype[ITERATOR])) {
              defineBuiltIn(CurrentIteratorPrototype, ITERATOR, returnThis);
            }
          }
          setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, true, true);
          if (IS_PURE)
            Iterators[TO_STRING_TAG] = returnThis;
        }
      }
      if (PROPER_FUNCTION_NAME && DEFAULT === VALUES && nativeIterator && nativeIterator.name !== VALUES) {
        if (!IS_PURE && CONFIGURABLE_FUNCTION_NAME) {
          createNonEnumerableProperty(IterablePrototype, "name", VALUES);
        } else {
          INCORRECT_VALUES_NAME = true;
          defaultIterator = function values() {
            return call(nativeIterator, this);
          };
        }
      }
      if (DEFAULT) {
        methods2 = {
          values: getIterationMethod(VALUES),
          keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
          entries: getIterationMethod(ENTRIES)
        };
        if (FORCED)
          for (KEY in methods2) {
            if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
              defineBuiltIn(IterablePrototype, KEY, methods2[KEY]);
            }
          }
        else
          $({ target: NAME, proto: true, forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME }, methods2);
      }
      if ((!IS_PURE || FORCED) && IterablePrototype[ITERATOR] !== defaultIterator) {
        defineBuiltIn(IterablePrototype, ITERATOR, defaultIterator, { name: DEFAULT });
      }
      Iterators[NAME] = defaultIterator;
      return methods2;
    };
  }
});

// ../simple-mind-map/node_modules/core-js/internals/create-iter-result-object.js
var require_create_iter_result_object = __commonJS({
  "../simple-mind-map/node_modules/core-js/internals/create-iter-result-object.js"(exports, module) {
    "use strict";
    module.exports = function(value, done) {
      return { value, done };
    };
  }
});

// ../simple-mind-map/node_modules/core-js/modules/es.array.iterator.js
var require_es_array_iterator = __commonJS({
  "../simple-mind-map/node_modules/core-js/modules/es.array.iterator.js"(exports, module) {
    "use strict";
    var toIndexedObject = require_to_indexed_object();
    var addToUnscopables = require_add_to_unscopables();
    var Iterators = require_iterators();
    var InternalStateModule = require_internal_state();
    var defineProperty = require_object_define_property().f;
    var defineIterator = require_iterator_define();
    var createIterResultObject = require_create_iter_result_object();
    var IS_PURE = require_is_pure();
    var DESCRIPTORS = require_descriptors();
    var ARRAY_ITERATOR = "Array Iterator";
    var setInternalState = InternalStateModule.set;
    var getInternalState = InternalStateModule.getterFor(ARRAY_ITERATOR);
    module.exports = defineIterator(Array, "Array", function(iterated, kind) {
      setInternalState(this, {
        type: ARRAY_ITERATOR,
        target: toIndexedObject(iterated),
        // target
        index: 0,
        // next index
        kind
        // kind
      });
    }, function() {
      var state = getInternalState(this);
      var target = state.target;
      var index3 = state.index++;
      if (!target || index3 >= target.length) {
        state.target = void 0;
        return createIterResultObject(void 0, true);
      }
      switch (state.kind) {
        case "keys":
          return createIterResultObject(index3, false);
        case "values":
          return createIterResultObject(target[index3], false);
      }
      return createIterResultObject([index3, target[index3]], false);
    }, "values");
    var values = Iterators.Arguments = Iterators.Array;
    addToUnscopables("keys");
    addToUnscopables("values");
    addToUnscopables("entries");
    if (!IS_PURE && DESCRIPTORS && values.name !== "values")
      try {
        defineProperty(values, "name", { value: "values" });
      } catch (error) {
      }
  }
});

// ../simple-mind-map/node_modules/core-js/internals/dom-iterables.js
var require_dom_iterables = __commonJS({
  "../simple-mind-map/node_modules/core-js/internals/dom-iterables.js"(exports, module) {
    "use strict";
    module.exports = {
      CSSRuleList: 0,
      CSSStyleDeclaration: 0,
      CSSValueList: 0,
      ClientRectList: 0,
      DOMRectList: 0,
      DOMStringList: 0,
      DOMTokenList: 1,
      DataTransferItemList: 0,
      FileList: 0,
      HTMLAllCollection: 0,
      HTMLCollection: 0,
      HTMLFormElement: 0,
      HTMLSelectElement: 0,
      MediaList: 0,
      MimeTypeArray: 0,
      NamedNodeMap: 0,
      NodeList: 1,
      PaintRequestList: 0,
      Plugin: 0,
      PluginArray: 0,
      SVGLengthList: 0,
      SVGNumberList: 0,
      SVGPathSegList: 0,
      SVGPointList: 0,
      SVGStringList: 0,
      SVGTransformList: 0,
      SourceBufferList: 0,
      StyleSheetList: 0,
      TextTrackCueList: 0,
      TextTrackList: 0,
      TouchList: 0
    };
  }
});

// ../simple-mind-map/node_modules/core-js/internals/dom-token-list-prototype.js
var require_dom_token_list_prototype = __commonJS({
  "../simple-mind-map/node_modules/core-js/internals/dom-token-list-prototype.js"(exports, module) {
    "use strict";
    var documentCreateElement = require_document_create_element();
    var classList = documentCreateElement("span").classList;
    var DOMTokenListPrototype = classList && classList.constructor && classList.constructor.prototype;
    module.exports = DOMTokenListPrototype === Object.prototype ? void 0 : DOMTokenListPrototype;
  }
});

// ../simple-mind-map/node_modules/core-js/modules/web.dom-collections.iterator.js
var require_web_dom_collections_iterator = __commonJS({
  "../simple-mind-map/node_modules/core-js/modules/web.dom-collections.iterator.js"() {
    "use strict";
    var global2 = require_global();
    var DOMIterables = require_dom_iterables();
    var DOMTokenListPrototype = require_dom_token_list_prototype();
    var ArrayIteratorMethods = require_es_array_iterator();
    var createNonEnumerableProperty = require_create_non_enumerable_property();
    var wellKnownSymbol = require_well_known_symbol();
    var ITERATOR = wellKnownSymbol("iterator");
    var TO_STRING_TAG = wellKnownSymbol("toStringTag");
    var ArrayValues = ArrayIteratorMethods.values;
    var handlePrototype = function(CollectionPrototype, COLLECTION_NAME2) {
      if (CollectionPrototype) {
        if (CollectionPrototype[ITERATOR] !== ArrayValues)
          try {
            createNonEnumerableProperty(CollectionPrototype, ITERATOR, ArrayValues);
          } catch (error) {
            CollectionPrototype[ITERATOR] = ArrayValues;
          }
        if (!CollectionPrototype[TO_STRING_TAG]) {
          createNonEnumerableProperty(CollectionPrototype, TO_STRING_TAG, COLLECTION_NAME2);
        }
        if (DOMIterables[COLLECTION_NAME2])
          for (var METHOD_NAME in ArrayIteratorMethods) {
            if (CollectionPrototype[METHOD_NAME] !== ArrayIteratorMethods[METHOD_NAME])
              try {
                createNonEnumerableProperty(CollectionPrototype, METHOD_NAME, ArrayIteratorMethods[METHOD_NAME]);
              } catch (error) {
                CollectionPrototype[METHOD_NAME] = ArrayIteratorMethods[METHOD_NAME];
              }
          }
      }
    };
    for (COLLECTION_NAME in DOMIterables) {
      handlePrototype(global2[COLLECTION_NAME] && global2[COLLECTION_NAME].prototype, COLLECTION_NAME);
    }
    var COLLECTION_NAME;
    handlePrototype(DOMTokenListPrototype, "DOMTokenList");
  }
});

// ../simple-mind-map/node_modules/@babel/runtime/helpers/esm/toPrimitive.js
function _toPrimitive(input, hint) {
  if (_typeof(input) !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (_typeof(res) !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
var init_toPrimitive = __esm({
  "../simple-mind-map/node_modules/@babel/runtime/helpers/esm/toPrimitive.js"() {
    init_typeof();
  }
});

// ../simple-mind-map/node_modules/@babel/runtime/helpers/esm/toPropertyKey.js
function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return _typeof(key) === "symbol" ? key : String(key);
}
var init_toPropertyKey = __esm({
  "../simple-mind-map/node_modules/@babel/runtime/helpers/esm/toPropertyKey.js"() {
    init_typeof();
    init_toPrimitive();
  }
});

// ../simple-mind-map/node_modules/@babel/runtime/helpers/esm/defineProperty.js
function _defineProperty(obj, key, value) {
  key = _toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
var init_defineProperty = __esm({
  "../simple-mind-map/node_modules/@babel/runtime/helpers/esm/defineProperty.js"() {
    init_toPropertyKey();
  }
});

// ../simple-mind-map/node_modules/core-js/internals/array-reduce.js
var require_array_reduce = __commonJS({
  "../simple-mind-map/node_modules/core-js/internals/array-reduce.js"(exports, module) {
    "use strict";
    var aCallable = require_a_callable();
    var toObject = require_to_object();
    var IndexedObject = require_indexed_object();
    var lengthOfArrayLike = require_length_of_array_like();
    var $TypeError = TypeError;
    var createMethod = function(IS_RIGHT) {
      return function(that, callbackfn, argumentsLength, memo) {
        aCallable(callbackfn);
        var O2 = toObject(that);
        var self2 = IndexedObject(O2);
        var length2 = lengthOfArrayLike(O2);
        var index3 = IS_RIGHT ? length2 - 1 : 0;
        var i2 = IS_RIGHT ? -1 : 1;
        if (argumentsLength < 2)
          while (true) {
            if (index3 in self2) {
              memo = self2[index3];
              index3 += i2;
              break;
            }
            index3 += i2;
            if (IS_RIGHT ? index3 < 0 : length2 <= index3) {
              throw new $TypeError("Reduce of empty array with no initial value");
            }
          }
        for (; IS_RIGHT ? index3 >= 0 : length2 > index3; index3 += i2)
          if (index3 in self2) {
            memo = callbackfn(memo, self2[index3], index3, O2);
          }
        return memo;
      };
    };
    module.exports = {
      // `Array.prototype.reduce` method
      // https://tc39.es/ecma262/#sec-array.prototype.reduce
      left: createMethod(false),
      // `Array.prototype.reduceRight` method
      // https://tc39.es/ecma262/#sec-array.prototype.reduceright
      right: createMethod(true)
    };
  }
});

// ../simple-mind-map/node_modules/core-js/internals/array-method-is-strict.js
var require_array_method_is_strict = __commonJS({
  "../simple-mind-map/node_modules/core-js/internals/array-method-is-strict.js"(exports, module) {
    "use strict";
    var fails = require_fails();
    module.exports = function(METHOD_NAME, argument) {
      var method = [][METHOD_NAME];
      return !!method && fails(function() {
        method.call(null, argument || function() {
          return 1;
        }, 1);
      });
    };
  }
});

// ../simple-mind-map/node_modules/core-js/modules/es.array.reduce.js
var require_es_array_reduce = __commonJS({
  "../simple-mind-map/node_modules/core-js/modules/es.array.reduce.js"() {
    "use strict";
    var $ = require_export();
    var $reduce = require_array_reduce().left;
    var arrayMethodIsStrict = require_array_method_is_strict();
    var CHROME_VERSION = require_engine_v8_version();
    var IS_NODE = require_engine_is_node();
    var CHROME_BUG = !IS_NODE && CHROME_VERSION > 79 && CHROME_VERSION < 83;
    var FORCED = CHROME_BUG || !arrayMethodIsStrict("reduce");
    $({ target: "Array", proto: true, forced: FORCED }, {
      reduce: function reduce(callbackfn) {
        var length2 = arguments.length;
        return $reduce(this, callbackfn, length2, length2 > 1 ? arguments[1] : void 0);
      }
    });
  }
});

// ../simple-mind-map/node_modules/core-js/modules/es.string.ends-with.js
var require_es_string_ends_with = __commonJS({
  "../simple-mind-map/node_modules/core-js/modules/es.string.ends-with.js"() {
    "use strict";
    var $ = require_export();
    var uncurryThis = require_function_uncurry_this_clause();
    var getOwnPropertyDescriptor = require_object_get_own_property_descriptor().f;
    var toLength = require_to_length();
    var toString2 = require_to_string();
    var notARegExp = require_not_a_regexp();
    var requireObjectCoercible = require_require_object_coercible();
    var correctIsRegExpLogic = require_correct_is_regexp_logic();
    var IS_PURE = require_is_pure();
    var nativeEndsWith = uncurryThis("".endsWith);
    var slice = uncurryThis("".slice);
    var min = Math.min;
    var CORRECT_IS_REGEXP_LOGIC = correctIsRegExpLogic("endsWith");
    var MDN_POLYFILL_BUG = !IS_PURE && !CORRECT_IS_REGEXP_LOGIC && !!function() {
      var descriptor = getOwnPropertyDescriptor(String.prototype, "endsWith");
      return descriptor && !descriptor.writable;
    }();
    $({ target: "String", proto: true, forced: !MDN_POLYFILL_BUG && !CORRECT_IS_REGEXP_LOGIC }, {
      endsWith: function endsWith(searchString) {
        var that = toString2(requireObjectCoercible(this));
        notARegExp(searchString);
        var endPosition = arguments.length > 1 ? arguments[1] : void 0;
        var len = that.length;
        var end = endPosition === void 0 ? len : min(toLength(endPosition), len);
        var search2 = toString2(searchString);
        return nativeEndsWith ? nativeEndsWith(that, search2, end) : slice(that, end - search2.length, end) === search2;
      }
    });
  }
});

// ../simple-mind-map/node_modules/core-js/internals/create-property.js
var require_create_property = __commonJS({
  "../simple-mind-map/node_modules/core-js/internals/create-property.js"(exports, module) {
    "use strict";
    var toPropertyKey = require_to_property_key();
    var definePropertyModule = require_object_define_property();
    var createPropertyDescriptor = require_create_property_descriptor();
    module.exports = function(object, key, value) {
      var propertyKey = toPropertyKey(key);
      if (propertyKey in object)
        definePropertyModule.f(object, propertyKey, createPropertyDescriptor(0, value));
      else
        object[propertyKey] = value;
    };
  }
});

// ../simple-mind-map/node_modules/core-js/internals/array-slice-simple.js
var require_array_slice_simple = __commonJS({
  "../simple-mind-map/node_modules/core-js/internals/array-slice-simple.js"(exports, module) {
    "use strict";
    var toAbsoluteIndex = require_to_absolute_index();
    var lengthOfArrayLike = require_length_of_array_like();
    var createProperty = require_create_property();
    var $Array = Array;
    var max2 = Math.max;
    module.exports = function(O2, start, end) {
      var length2 = lengthOfArrayLike(O2);
      var k = toAbsoluteIndex(start, length2);
      var fin = toAbsoluteIndex(end === void 0 ? length2 : end, length2);
      var result = $Array(max2(fin - k, 0));
      var n2 = 0;
      for (; k < fin; k++, n2++)
        createProperty(result, n2, O2[k]);
      result.length = n2;
      return result;
    };
  }
});

// ../simple-mind-map/node_modules/core-js/modules/es.string.split.js
var require_es_string_split = __commonJS({
  "../simple-mind-map/node_modules/core-js/modules/es.string.split.js"() {
    "use strict";
    var apply = require_function_apply();
    var call = require_function_call();
    var uncurryThis = require_function_uncurry_this();
    var fixRegExpWellKnownSymbolLogic = require_fix_regexp_well_known_symbol_logic();
    var anObject = require_an_object();
    var isNullOrUndefined = require_is_null_or_undefined();
    var isRegExp = require_is_regexp();
    var requireObjectCoercible = require_require_object_coercible();
    var speciesConstructor = require_species_constructor();
    var advanceStringIndex = require_advance_string_index();
    var toLength = require_to_length();
    var toString2 = require_to_string();
    var getMethod = require_get_method();
    var arraySlice = require_array_slice_simple();
    var callRegExpExec = require_regexp_exec_abstract();
    var regexpExec = require_regexp_exec();
    var stickyHelpers = require_regexp_sticky_helpers();
    var fails = require_fails();
    var UNSUPPORTED_Y = stickyHelpers.UNSUPPORTED_Y;
    var MAX_UINT32 = 4294967295;
    var min = Math.min;
    var $push = [].push;
    var exec = uncurryThis(/./.exec);
    var push2 = uncurryThis($push);
    var stringSlice = uncurryThis("".slice);
    var SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = !fails(function() {
      var re = /(?:)/;
      var originalExec = re.exec;
      re.exec = function() {
        return originalExec.apply(this, arguments);
      };
      var result = "ab".split(re);
      return result.length !== 2 || result[0] !== "a" || result[1] !== "b";
    });
    fixRegExpWellKnownSymbolLogic("split", function(SPLIT, nativeSplit, maybeCallNative) {
      var internalSplit;
      if ("abbc".split(/(b)*/)[1] === "c" || // eslint-disable-next-line regexp/no-empty-group -- required for testing
      "test".split(/(?:)/, -1).length !== 4 || "ab".split(/(?:ab)*/).length !== 2 || ".".split(/(.?)(.?)/).length !== 4 || // eslint-disable-next-line regexp/no-empty-capturing-group, regexp/no-empty-group -- required for testing
      ".".split(/()()/).length > 1 || "".split(/.?/).length) {
        internalSplit = function(separator, limit) {
          var string3 = toString2(requireObjectCoercible(this));
          var lim = limit === void 0 ? MAX_UINT32 : limit >>> 0;
          if (lim === 0)
            return [];
          if (separator === void 0)
            return [string3];
          if (!isRegExp(separator)) {
            return call(nativeSplit, string3, separator, lim);
          }
          var output = [];
          var flags = (separator.ignoreCase ? "i" : "") + (separator.multiline ? "m" : "") + (separator.unicode ? "u" : "") + (separator.sticky ? "y" : "");
          var lastLastIndex = 0;
          var separatorCopy = new RegExp(separator.source, flags + "g");
          var match, lastIndex, lastLength;
          while (match = call(regexpExec, separatorCopy, string3)) {
            lastIndex = separatorCopy.lastIndex;
            if (lastIndex > lastLastIndex) {
              push2(output, stringSlice(string3, lastLastIndex, match.index));
              if (match.length > 1 && match.index < string3.length)
                apply($push, output, arraySlice(match, 1));
              lastLength = match[0].length;
              lastLastIndex = lastIndex;
              if (output.length >= lim)
                break;
            }
            if (separatorCopy.lastIndex === match.index)
              separatorCopy.lastIndex++;
          }
          if (lastLastIndex === string3.length) {
            if (lastLength || !exec(separatorCopy, ""))
              push2(output, "");
          } else
            push2(output, stringSlice(string3, lastLastIndex));
          return output.length > lim ? arraySlice(output, 0, lim) : output;
        };
      } else if ("0".split(void 0, 0).length) {
        internalSplit = function(separator, limit) {
          return separator === void 0 && limit === 0 ? [] : call(nativeSplit, this, separator, limit);
        };
      } else
        internalSplit = nativeSplit;
      return [
        // `String.prototype.split` method
        // https://tc39.es/ecma262/#sec-string.prototype.split
        function split(separator, limit) {
          var O2 = requireObjectCoercible(this);
          var splitter = isNullOrUndefined(separator) ? void 0 : getMethod(separator, SPLIT);
          return splitter ? call(splitter, separator, O2, limit) : call(internalSplit, toString2(O2), separator, limit);
        },
        // `RegExp.prototype[@@split]` method
        // https://tc39.es/ecma262/#sec-regexp.prototype-@@split
        //
        // NOTE: This cannot be properly polyfilled in engines that don't support
        // the 'y' flag.
        function(string3, limit) {
          var rx2 = anObject(this);
          var S2 = toString2(string3);
          var res = maybeCallNative(internalSplit, rx2, S2, limit, internalSplit !== nativeSplit);
          if (res.done)
            return res.value;
          var C = speciesConstructor(rx2, RegExp);
          var unicodeMatching = rx2.unicode;
          var flags = (rx2.ignoreCase ? "i" : "") + (rx2.multiline ? "m" : "") + (rx2.unicode ? "u" : "") + (UNSUPPORTED_Y ? "g" : "y");
          var splitter = new C(UNSUPPORTED_Y ? "^(?:" + rx2.source + ")" : rx2, flags);
          var lim = limit === void 0 ? MAX_UINT32 : limit >>> 0;
          if (lim === 0)
            return [];
          if (S2.length === 0)
            return callRegExpExec(splitter, S2) === null ? [S2] : [];
          var p2 = 0;
          var q = 0;
          var A2 = [];
          while (q < S2.length) {
            splitter.lastIndex = UNSUPPORTED_Y ? 0 : q;
            var z = callRegExpExec(splitter, UNSUPPORTED_Y ? stringSlice(S2, q) : S2);
            var e2;
            if (z === null || (e2 = min(toLength(splitter.lastIndex + (UNSUPPORTED_Y ? q : 0)), S2.length)) === p2) {
              q = advanceStringIndex(S2, q, unicodeMatching);
            } else {
              push2(A2, stringSlice(S2, p2, q));
              if (A2.length === lim)
                return A2;
              for (var i2 = 1; i2 <= z.length - 1; i2++) {
                push2(A2, z[i2]);
                if (A2.length === lim)
                  return A2;
              }
              q = p2 = e2;
            }
          }
          push2(A2, stringSlice(S2, p2));
          return A2;
        }
      ];
    }, !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC, UNSUPPORTED_Y);
  }
});

// ../simple-mind-map/node_modules/performance-now/lib/performance-now.js
var require_performance_now = __commonJS({
  "../simple-mind-map/node_modules/performance-now/lib/performance-now.js"(exports, module) {
    (function() {
      var getNanoSeconds, hrtime, loadTime, moduleLoadTime, nodeLoadTime, upTime;
      if (typeof performance !== "undefined" && performance !== null && performance.now) {
        module.exports = function() {
          return performance.now();
        };
      } else if (typeof process !== "undefined" && process !== null && process.hrtime) {
        module.exports = function() {
          return (getNanoSeconds() - nodeLoadTime) / 1e6;
        };
        hrtime = process.hrtime;
        getNanoSeconds = function() {
          var hr;
          hr = hrtime();
          return hr[0] * 1e9 + hr[1];
        };
        moduleLoadTime = getNanoSeconds();
        upTime = process.uptime() * 1e9;
        nodeLoadTime = moduleLoadTime - upTime;
      } else if (Date.now) {
        module.exports = function() {
          return Date.now() - loadTime;
        };
        loadTime = Date.now();
      } else {
        module.exports = function() {
          return (/* @__PURE__ */ new Date()).getTime() - loadTime;
        };
        loadTime = (/* @__PURE__ */ new Date()).getTime();
      }
    }).call(exports);
  }
});

// ../simple-mind-map/node_modules/raf/index.js
var require_raf = __commonJS({
  "../simple-mind-map/node_modules/raf/index.js"(exports, module) {
    var now = require_performance_now();
    var root2 = typeof window === "undefined" ? global : window;
    var vendors = ["moz", "webkit"];
    var suffix = "AnimationFrame";
    var raf = root2["request" + suffix];
    var caf = root2["cancel" + suffix] || root2["cancelRequest" + suffix];
    for (i2 = 0; !raf && i2 < vendors.length; i2++) {
      raf = root2[vendors[i2] + "Request" + suffix];
      caf = root2[vendors[i2] + "Cancel" + suffix] || root2[vendors[i2] + "CancelRequest" + suffix];
    }
    var i2;
    if (!raf || !caf) {
      last = 0, id = 0, queue = [], frameDuration = 1e3 / 60;
      raf = function(callback) {
        if (queue.length === 0) {
          var _now = now(), next2 = Math.max(0, frameDuration - (_now - last));
          last = next2 + _now;
          setTimeout(function() {
            var cp = queue.slice(0);
            queue.length = 0;
            for (var i3 = 0; i3 < cp.length; i3++) {
              if (!cp[i3].cancelled) {
                try {
                  cp[i3].callback(last);
                } catch (e2) {
                  setTimeout(function() {
                    throw e2;
                  }, 0);
                }
              }
            }
          }, Math.round(next2));
        }
        queue.push({
          handle: ++id,
          callback,
          cancelled: false
        });
        return id;
      };
      caf = function(handle) {
        for (var i3 = 0; i3 < queue.length; i3++) {
          if (queue[i3].handle === handle) {
            queue[i3].cancelled = true;
          }
        }
      };
    }
    var last;
    var id;
    var queue;
    var frameDuration;
    module.exports = function(fn) {
      return raf.call(root2, fn);
    };
    module.exports.cancel = function() {
      caf.apply(root2, arguments);
    };
    module.exports.polyfill = function(object) {
      if (!object) {
        object = root2;
      }
      object.requestAnimationFrame = raf;
      object.cancelAnimationFrame = caf;
    };
  }
});

// ../simple-mind-map/node_modules/core-js/internals/whitespaces.js
var require_whitespaces = __commonJS({
  "../simple-mind-map/node_modules/core-js/internals/whitespaces.js"(exports, module) {
    "use strict";
    module.exports = "	\n\v\f\r \xA0\u1680\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF";
  }
});

// ../simple-mind-map/node_modules/core-js/internals/string-trim.js
var require_string_trim = __commonJS({
  "../simple-mind-map/node_modules/core-js/internals/string-trim.js"(exports, module) {
    "use strict";
    var uncurryThis = require_function_uncurry_this();
    var requireObjectCoercible = require_require_object_coercible();
    var toString2 = require_to_string();
    var whitespaces = require_whitespaces();
    var replace = uncurryThis("".replace);
    var ltrim = RegExp("^[" + whitespaces + "]+");
    var rtrim = RegExp("(^|[^" + whitespaces + "])[" + whitespaces + "]+$");
    var createMethod = function(TYPE) {
      return function($this) {
        var string3 = toString2(requireObjectCoercible($this));
        if (TYPE & 1)
          string3 = replace(string3, ltrim, "");
        if (TYPE & 2)
          string3 = replace(string3, rtrim, "$1");
        return string3;
      };
    };
    module.exports = {
      // `String.prototype.{ trimLeft, trimStart }` methods
      // https://tc39.es/ecma262/#sec-string.prototype.trimstart
      start: createMethod(1),
      // `String.prototype.{ trimRight, trimEnd }` methods
      // https://tc39.es/ecma262/#sec-string.prototype.trimend
      end: createMethod(2),
      // `String.prototype.trim` method
      // https://tc39.es/ecma262/#sec-string.prototype.trim
      trim: createMethod(3)
    };
  }
});

// ../simple-mind-map/node_modules/core-js/internals/string-trim-forced.js
var require_string_trim_forced = __commonJS({
  "../simple-mind-map/node_modules/core-js/internals/string-trim-forced.js"(exports, module) {
    "use strict";
    var PROPER_FUNCTION_NAME = require_function_name().PROPER;
    var fails = require_fails();
    var whitespaces = require_whitespaces();
    var non = "\u200B\x85\u180E";
    module.exports = function(METHOD_NAME) {
      return fails(function() {
        return !!whitespaces[METHOD_NAME]() || non[METHOD_NAME]() !== non || PROPER_FUNCTION_NAME && whitespaces[METHOD_NAME].name !== METHOD_NAME;
      });
    };
  }
});

// ../simple-mind-map/node_modules/core-js/modules/es.string.trim.js
var require_es_string_trim = __commonJS({
  "../simple-mind-map/node_modules/core-js/modules/es.string.trim.js"() {
    "use strict";
    var $ = require_export();
    var $trim = require_string_trim().trim;
    var forcedStringTrimMethod = require_string_trim_forced();
    $({ target: "String", proto: true, forced: forcedStringTrimMethod("trim") }, {
      trim: function trim() {
        return $trim(this);
      }
    });
  }
});

// ../simple-mind-map/node_modules/rgbcolor/index.js
var require_rgbcolor = __commonJS({
  "../simple-mind-map/node_modules/rgbcolor/index.js"(exports, module) {
    module.exports = function(color_string) {
      this.ok = false;
      this.alpha = 1;
      if (color_string.charAt(0) == "#") {
        color_string = color_string.substr(1, 6);
      }
      color_string = color_string.replace(/ /g, "");
      color_string = color_string.toLowerCase();
      var simple_colors = {
        aliceblue: "f0f8ff",
        antiquewhite: "faebd7",
        aqua: "00ffff",
        aquamarine: "7fffd4",
        azure: "f0ffff",
        beige: "f5f5dc",
        bisque: "ffe4c4",
        black: "000000",
        blanchedalmond: "ffebcd",
        blue: "0000ff",
        blueviolet: "8a2be2",
        brown: "a52a2a",
        burlywood: "deb887",
        cadetblue: "5f9ea0",
        chartreuse: "7fff00",
        chocolate: "d2691e",
        coral: "ff7f50",
        cornflowerblue: "6495ed",
        cornsilk: "fff8dc",
        crimson: "dc143c",
        cyan: "00ffff",
        darkblue: "00008b",
        darkcyan: "008b8b",
        darkgoldenrod: "b8860b",
        darkgray: "a9a9a9",
        darkgreen: "006400",
        darkkhaki: "bdb76b",
        darkmagenta: "8b008b",
        darkolivegreen: "556b2f",
        darkorange: "ff8c00",
        darkorchid: "9932cc",
        darkred: "8b0000",
        darksalmon: "e9967a",
        darkseagreen: "8fbc8f",
        darkslateblue: "483d8b",
        darkslategray: "2f4f4f",
        darkturquoise: "00ced1",
        darkviolet: "9400d3",
        deeppink: "ff1493",
        deepskyblue: "00bfff",
        dimgray: "696969",
        dodgerblue: "1e90ff",
        feldspar: "d19275",
        firebrick: "b22222",
        floralwhite: "fffaf0",
        forestgreen: "228b22",
        fuchsia: "ff00ff",
        gainsboro: "dcdcdc",
        ghostwhite: "f8f8ff",
        gold: "ffd700",
        goldenrod: "daa520",
        gray: "808080",
        green: "008000",
        greenyellow: "adff2f",
        honeydew: "f0fff0",
        hotpink: "ff69b4",
        indianred: "cd5c5c",
        indigo: "4b0082",
        ivory: "fffff0",
        khaki: "f0e68c",
        lavender: "e6e6fa",
        lavenderblush: "fff0f5",
        lawngreen: "7cfc00",
        lemonchiffon: "fffacd",
        lightblue: "add8e6",
        lightcoral: "f08080",
        lightcyan: "e0ffff",
        lightgoldenrodyellow: "fafad2",
        lightgrey: "d3d3d3",
        lightgreen: "90ee90",
        lightpink: "ffb6c1",
        lightsalmon: "ffa07a",
        lightseagreen: "20b2aa",
        lightskyblue: "87cefa",
        lightslateblue: "8470ff",
        lightslategray: "778899",
        lightsteelblue: "b0c4de",
        lightyellow: "ffffe0",
        lime: "00ff00",
        limegreen: "32cd32",
        linen: "faf0e6",
        magenta: "ff00ff",
        maroon: "800000",
        mediumaquamarine: "66cdaa",
        mediumblue: "0000cd",
        mediumorchid: "ba55d3",
        mediumpurple: "9370d8",
        mediumseagreen: "3cb371",
        mediumslateblue: "7b68ee",
        mediumspringgreen: "00fa9a",
        mediumturquoise: "48d1cc",
        mediumvioletred: "c71585",
        midnightblue: "191970",
        mintcream: "f5fffa",
        mistyrose: "ffe4e1",
        moccasin: "ffe4b5",
        navajowhite: "ffdead",
        navy: "000080",
        oldlace: "fdf5e6",
        olive: "808000",
        olivedrab: "6b8e23",
        orange: "ffa500",
        orangered: "ff4500",
        orchid: "da70d6",
        palegoldenrod: "eee8aa",
        palegreen: "98fb98",
        paleturquoise: "afeeee",
        palevioletred: "d87093",
        papayawhip: "ffefd5",
        peachpuff: "ffdab9",
        peru: "cd853f",
        pink: "ffc0cb",
        plum: "dda0dd",
        powderblue: "b0e0e6",
        purple: "800080",
        rebeccapurple: "663399",
        red: "ff0000",
        rosybrown: "bc8f8f",
        royalblue: "4169e1",
        saddlebrown: "8b4513",
        salmon: "fa8072",
        sandybrown: "f4a460",
        seagreen: "2e8b57",
        seashell: "fff5ee",
        sienna: "a0522d",
        silver: "c0c0c0",
        skyblue: "87ceeb",
        slateblue: "6a5acd",
        slategray: "708090",
        snow: "fffafa",
        springgreen: "00ff7f",
        steelblue: "4682b4",
        tan: "d2b48c",
        teal: "008080",
        thistle: "d8bfd8",
        tomato: "ff6347",
        turquoise: "40e0d0",
        violet: "ee82ee",
        violetred: "d02090",
        wheat: "f5deb3",
        white: "ffffff",
        whitesmoke: "f5f5f5",
        yellow: "ffff00",
        yellowgreen: "9acd32"
      };
      color_string = simple_colors[color_string] || color_string;
      var color_defs = [
        {
          re: /^rgba\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3}),\s*((?:\d?\.)?\d)\)$/,
          example: ["rgba(123, 234, 45, 0.8)", "rgba(255,234,245,1.0)"],
          process: function(bits3) {
            return [
              parseInt(bits3[1]),
              parseInt(bits3[2]),
              parseInt(bits3[3]),
              parseFloat(bits3[4])
            ];
          }
        },
        {
          re: /^rgb\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)$/,
          example: ["rgb(123, 234, 45)", "rgb(255,234,245)"],
          process: function(bits3) {
            return [
              parseInt(bits3[1]),
              parseInt(bits3[2]),
              parseInt(bits3[3])
            ];
          }
        },
        {
          re: /^([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
          example: ["#00ff00", "336699"],
          process: function(bits3) {
            return [
              parseInt(bits3[1], 16),
              parseInt(bits3[2], 16),
              parseInt(bits3[3], 16)
            ];
          }
        },
        {
          re: /^([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
          example: ["#fb0", "f0f"],
          process: function(bits3) {
            return [
              parseInt(bits3[1] + bits3[1], 16),
              parseInt(bits3[2] + bits3[2], 16),
              parseInt(bits3[3] + bits3[3], 16)
            ];
          }
        }
      ];
      for (var i2 = 0; i2 < color_defs.length; i2++) {
        var re = color_defs[i2].re;
        var processor = color_defs[i2].process;
        var bits2 = re.exec(color_string);
        if (bits2) {
          var channels = processor(bits2);
          this.r = channels[0];
          this.g = channels[1];
          this.b = channels[2];
          if (channels.length > 3) {
            this.alpha = channels[3];
          }
          this.ok = true;
        }
      }
      this.r = this.r < 0 || isNaN(this.r) ? 0 : this.r > 255 ? 255 : this.r;
      this.g = this.g < 0 || isNaN(this.g) ? 0 : this.g > 255 ? 255 : this.g;
      this.b = this.b < 0 || isNaN(this.b) ? 0 : this.b > 255 ? 255 : this.b;
      this.alpha = this.alpha < 0 ? 0 : this.alpha > 1 || isNaN(this.alpha) ? 1 : this.alpha;
      this.toRGB = function() {
        return "rgb(" + this.r + ", " + this.g + ", " + this.b + ")";
      };
      this.toRGBA = function() {
        return "rgba(" + this.r + ", " + this.g + ", " + this.b + ", " + this.alpha + ")";
      };
      this.toHex = function() {
        var r2 = this.r.toString(16);
        var g = this.g.toString(16);
        var b = this.b.toString(16);
        if (r2.length == 1)
          r2 = "0" + r2;
        if (g.length == 1)
          g = "0" + g;
        if (b.length == 1)
          b = "0" + b;
        return "#" + r2 + g + b;
      };
      this.getHelpXML = function() {
        var examples = new Array();
        for (var i3 = 0; i3 < color_defs.length; i3++) {
          var example = color_defs[i3].example;
          for (var j = 0; j < example.length; j++) {
            examples[examples.length] = example[j];
          }
        }
        for (var sc in simple_colors) {
          examples[examples.length] = sc;
        }
        var xml = document.createElement("ul");
        xml.setAttribute("id", "rgbcolor-examples");
        for (var i3 = 0; i3 < examples.length; i3++) {
          try {
            var list_item = document.createElement("li");
            var list_color = new RGBColor(examples[i3]);
            var example_div = document.createElement("div");
            example_div.style.cssText = "margin: 3px; border: 1px solid black; background:" + list_color.toHex() + "; color:" + list_color.toHex();
            example_div.appendChild(document.createTextNode("test"));
            var list_item_value = document.createTextNode(
              " " + examples[i3] + " -> " + list_color.toRGB() + " -> " + list_color.toHex()
            );
            list_item.appendChild(example_div);
            list_item.appendChild(list_item_value);
            xml.appendChild(list_item);
          } catch (e2) {
          }
        }
        return xml;
      };
    };
  }
});

// ../simple-mind-map/node_modules/core-js/modules/es.array.index-of.js
var require_es_array_index_of = __commonJS({
  "../simple-mind-map/node_modules/core-js/modules/es.array.index-of.js"() {
    "use strict";
    var $ = require_export();
    var uncurryThis = require_function_uncurry_this_clause();
    var $indexOf = require_array_includes().indexOf;
    var arrayMethodIsStrict = require_array_method_is_strict();
    var nativeIndexOf = uncurryThis([].indexOf);
    var NEGATIVE_ZERO = !!nativeIndexOf && 1 / nativeIndexOf([1], 1, -0) < 0;
    var FORCED = NEGATIVE_ZERO || !arrayMethodIsStrict("indexOf");
    $({ target: "Array", proto: true, forced: FORCED }, {
      indexOf: function indexOf(searchElement) {
        var fromIndex = arguments.length > 1 ? arguments[1] : void 0;
        return NEGATIVE_ZERO ? nativeIndexOf(this, searchElement, fromIndex) || 0 : $indexOf(this, searchElement, fromIndex);
      }
    });
  }
});

// ../simple-mind-map/node_modules/core-js/modules/es.string.includes.js
var require_es_string_includes = __commonJS({
  "../simple-mind-map/node_modules/core-js/modules/es.string.includes.js"() {
    "use strict";
    var $ = require_export();
    var uncurryThis = require_function_uncurry_this();
    var notARegExp = require_not_a_regexp();
    var requireObjectCoercible = require_require_object_coercible();
    var toString2 = require_to_string();
    var correctIsRegExpLogic = require_correct_is_regexp_logic();
    var stringIndexOf = uncurryThis("".indexOf);
    $({ target: "String", proto: true, forced: !correctIsRegExpLogic("includes") }, {
      includes: function includes(searchString) {
        return !!~stringIndexOf(
          toString2(requireObjectCoercible(this)),
          toString2(notARegExp(searchString)),
          arguments.length > 1 ? arguments[1] : void 0
        );
      }
    });
  }
});

// ../simple-mind-map/node_modules/core-js/internals/is-array.js
var require_is_array = __commonJS({
  "../simple-mind-map/node_modules/core-js/internals/is-array.js"(exports, module) {
    "use strict";
    var classof = require_classof_raw();
    module.exports = Array.isArray || function isArray(argument) {
      return classof(argument) === "Array";
    };
  }
});

// ../simple-mind-map/node_modules/core-js/modules/es.array.reverse.js
var require_es_array_reverse = __commonJS({
  "../simple-mind-map/node_modules/core-js/modules/es.array.reverse.js"() {
    "use strict";
    var $ = require_export();
    var uncurryThis = require_function_uncurry_this();
    var isArray = require_is_array();
    var nativeReverse = uncurryThis([].reverse);
    var test = [1, 2];
    $({ target: "Array", proto: true, forced: String(test) === String(test.reverse()) }, {
      reverse: function reverse() {
        if (isArray(this))
          this.length = this.length;
        return nativeReverse(this);
      }
    });
  }
});

// ../simple-mind-map/node_modules/svg-pathdata/lib/SVGPathData.module.js
function r(r2, e2) {
  if ("function" != typeof e2 && null !== e2)
    throw new TypeError("Class extends value " + String(e2) + " is not a constructor or null");
  function i2() {
    this.constructor = r2;
  }
  t(r2, e2), r2.prototype = null === e2 ? Object.create(e2) : (i2.prototype = e2.prototype, new i2());
}
function e(t2) {
  var r2 = "";
  Array.isArray(t2) || (t2 = [t2]);
  for (var e2 = 0; e2 < t2.length; e2++) {
    var i2 = t2[e2];
    if (i2.type === _.CLOSE_PATH)
      r2 += "z";
    else if (i2.type === _.HORIZ_LINE_TO)
      r2 += (i2.relative ? "h" : "H") + i2.x;
    else if (i2.type === _.VERT_LINE_TO)
      r2 += (i2.relative ? "v" : "V") + i2.y;
    else if (i2.type === _.MOVE_TO)
      r2 += (i2.relative ? "m" : "M") + i2.x + " " + i2.y;
    else if (i2.type === _.LINE_TO)
      r2 += (i2.relative ? "l" : "L") + i2.x + " " + i2.y;
    else if (i2.type === _.CURVE_TO)
      r2 += (i2.relative ? "c" : "C") + i2.x1 + " " + i2.y1 + " " + i2.x2 + " " + i2.y2 + " " + i2.x + " " + i2.y;
    else if (i2.type === _.SMOOTH_CURVE_TO)
      r2 += (i2.relative ? "s" : "S") + i2.x2 + " " + i2.y2 + " " + i2.x + " " + i2.y;
    else if (i2.type === _.QUAD_TO)
      r2 += (i2.relative ? "q" : "Q") + i2.x1 + " " + i2.y1 + " " + i2.x + " " + i2.y;
    else if (i2.type === _.SMOOTH_QUAD_TO)
      r2 += (i2.relative ? "t" : "T") + i2.x + " " + i2.y;
    else {
      if (i2.type !== _.ARC)
        throw new Error('Unexpected command type "' + i2.type + '" at index ' + e2 + ".");
      r2 += (i2.relative ? "a" : "A") + i2.rX + " " + i2.rY + " " + i2.xRot + " " + +i2.lArcFlag + " " + +i2.sweepFlag + " " + i2.x + " " + i2.y;
    }
  }
  return r2;
}
function i(t2, r2) {
  var e2 = t2[0], i2 = t2[1];
  return [e2 * Math.cos(r2) - i2 * Math.sin(r2), e2 * Math.sin(r2) + i2 * Math.cos(r2)];
}
function a() {
  for (var t2 = [], r2 = 0; r2 < arguments.length; r2++)
    t2[r2] = arguments[r2];
  for (var e2 = 0; e2 < t2.length; e2++)
    if ("number" != typeof t2[e2])
      throw new Error("assertNumbers arguments[" + e2 + "] is not a number. " + typeof t2[e2] + " == typeof " + t2[e2]);
  return true;
}
function o(t2, r2, e2) {
  t2.lArcFlag = 0 === t2.lArcFlag ? 0 : 1, t2.sweepFlag = 0 === t2.sweepFlag ? 0 : 1;
  var a2 = t2.rX, o2 = t2.rY, s2 = t2.x, u2 = t2.y;
  a2 = Math.abs(t2.rX), o2 = Math.abs(t2.rY);
  var h2 = i([(r2 - s2) / 2, (e2 - u2) / 2], -t2.xRot / 180 * n), c3 = h2[0], y3 = h2[1], p2 = Math.pow(c3, 2) / Math.pow(a2, 2) + Math.pow(y3, 2) / Math.pow(o2, 2);
  1 < p2 && (a2 *= Math.sqrt(p2), o2 *= Math.sqrt(p2)), t2.rX = a2, t2.rY = o2;
  var m3 = Math.pow(a2, 2) * Math.pow(y3, 2) + Math.pow(o2, 2) * Math.pow(c3, 2), O2 = (t2.lArcFlag !== t2.sweepFlag ? 1 : -1) * Math.sqrt(Math.max(0, (Math.pow(a2, 2) * Math.pow(o2, 2) - m3) / m3)), l2 = a2 * y3 / o2 * O2, T3 = -o2 * c3 / a2 * O2, v2 = i([l2, T3], t2.xRot / 180 * n);
  t2.cX = v2[0] + (r2 + s2) / 2, t2.cY = v2[1] + (e2 + u2) / 2, t2.phi1 = Math.atan2((y3 - T3) / o2, (c3 - l2) / a2), t2.phi2 = Math.atan2((-y3 - T3) / o2, (-c3 - l2) / a2), 0 === t2.sweepFlag && t2.phi2 > t2.phi1 && (t2.phi2 -= 2 * n), 1 === t2.sweepFlag && t2.phi2 < t2.phi1 && (t2.phi2 += 2 * n), t2.phi1 *= 180 / n, t2.phi2 *= 180 / n;
}
function s(t2, r2, e2) {
  a(t2, r2, e2);
  var i2 = t2 * t2 + r2 * r2 - e2 * e2;
  if (0 > i2)
    return [];
  if (0 === i2)
    return [[t2 * e2 / (t2 * t2 + r2 * r2), r2 * e2 / (t2 * t2 + r2 * r2)]];
  var n2 = Math.sqrt(i2);
  return [[(t2 * e2 + r2 * n2) / (t2 * t2 + r2 * r2), (r2 * e2 - t2 * n2) / (t2 * t2 + r2 * r2)], [(t2 * e2 - r2 * n2) / (t2 * t2 + r2 * r2), (r2 * e2 + t2 * n2) / (t2 * t2 + r2 * r2)]];
}
function c(t2, r2, e2) {
  return (1 - e2) * t2 + e2 * r2;
}
function y2(t2, r2, e2, i2) {
  return t2 + Math.cos(i2 / 180 * n) * r2 + Math.sin(i2 / 180 * n) * e2;
}
function p(t2, r2, e2, i2) {
  var a2 = 1e-6, n2 = r2 - t2, o2 = e2 - r2, s2 = 3 * n2 + 3 * (i2 - e2) - 6 * o2, u2 = 6 * (o2 - n2), h2 = 3 * n2;
  return Math.abs(s2) < a2 ? [-h2 / u2] : function(t3, r3, e3) {
    void 0 === e3 && (e3 = 1e-6);
    var i3 = t3 * t3 / 4 - r3;
    if (i3 < -e3)
      return [];
    if (i3 <= e3)
      return [-t3 / 2];
    var a3 = Math.sqrt(i3);
    return [-t3 / 2 - a3, -t3 / 2 + a3];
  }(u2 / s2, h2 / s2, a2);
}
function m(t2, r2, e2, i2, a2) {
  var n2 = 1 - a2;
  return t2 * (n2 * n2 * n2) + r2 * (3 * n2 * n2 * a2) + e2 * (3 * n2 * a2 * a2) + i2 * (a2 * a2 * a2);
}
var t, n, u, h, O, l, T, v, f, _, N;
var init_SVGPathData_module = __esm({
  "../simple-mind-map/node_modules/svg-pathdata/lib/SVGPathData.module.js"() {
    t = function(r2, e2) {
      return (t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t2, r3) {
        t2.__proto__ = r3;
      } || function(t2, r3) {
        for (var e3 in r3)
          Object.prototype.hasOwnProperty.call(r3, e3) && (t2[e3] = r3[e3]);
      })(r2, e2);
    };
    n = Math.PI;
    h = Math.PI / 180;
    !function(t2) {
      function r2() {
        return u2(function(t3, r3, e3) {
          return t3.relative && (void 0 !== t3.x1 && (t3.x1 += r3), void 0 !== t3.y1 && (t3.y1 += e3), void 0 !== t3.x2 && (t3.x2 += r3), void 0 !== t3.y2 && (t3.y2 += e3), void 0 !== t3.x && (t3.x += r3), void 0 !== t3.y && (t3.y += e3), t3.relative = false), t3;
        });
      }
      function e2() {
        var t3 = NaN, r3 = NaN, e3 = NaN, i2 = NaN;
        return u2(function(a2, n3, o2) {
          return a2.type & _.SMOOTH_CURVE_TO && (a2.type = _.CURVE_TO, t3 = isNaN(t3) ? n3 : t3, r3 = isNaN(r3) ? o2 : r3, a2.x1 = a2.relative ? n3 - t3 : 2 * n3 - t3, a2.y1 = a2.relative ? o2 - r3 : 2 * o2 - r3), a2.type & _.CURVE_TO ? (t3 = a2.relative ? n3 + a2.x2 : a2.x2, r3 = a2.relative ? o2 + a2.y2 : a2.y2) : (t3 = NaN, r3 = NaN), a2.type & _.SMOOTH_QUAD_TO && (a2.type = _.QUAD_TO, e3 = isNaN(e3) ? n3 : e3, i2 = isNaN(i2) ? o2 : i2, a2.x1 = a2.relative ? n3 - e3 : 2 * n3 - e3, a2.y1 = a2.relative ? o2 - i2 : 2 * o2 - i2), a2.type & _.QUAD_TO ? (e3 = a2.relative ? n3 + a2.x1 : a2.x1, i2 = a2.relative ? o2 + a2.y1 : a2.y1) : (e3 = NaN, i2 = NaN), a2;
        });
      }
      function n2() {
        var t3 = NaN, r3 = NaN;
        return u2(function(e3, i2, a2) {
          if (e3.type & _.SMOOTH_QUAD_TO && (e3.type = _.QUAD_TO, t3 = isNaN(t3) ? i2 : t3, r3 = isNaN(r3) ? a2 : r3, e3.x1 = e3.relative ? i2 - t3 : 2 * i2 - t3, e3.y1 = e3.relative ? a2 - r3 : 2 * a2 - r3), e3.type & _.QUAD_TO) {
            t3 = e3.relative ? i2 + e3.x1 : e3.x1, r3 = e3.relative ? a2 + e3.y1 : e3.y1;
            var n3 = e3.x1, o2 = e3.y1;
            e3.type = _.CURVE_TO, e3.x1 = ((e3.relative ? 0 : i2) + 2 * n3) / 3, e3.y1 = ((e3.relative ? 0 : a2) + 2 * o2) / 3, e3.x2 = (e3.x + 2 * n3) / 3, e3.y2 = (e3.y + 2 * o2) / 3;
          } else
            t3 = NaN, r3 = NaN;
          return e3;
        });
      }
      function u2(t3) {
        var r3 = 0, e3 = 0, i2 = NaN, a2 = NaN;
        return function(n3) {
          if (isNaN(i2) && !(n3.type & _.MOVE_TO))
            throw new Error("path must start with moveto");
          var o2 = t3(n3, r3, e3, i2, a2);
          return n3.type & _.CLOSE_PATH && (r3 = i2, e3 = a2), void 0 !== n3.x && (r3 = n3.relative ? r3 + n3.x : n3.x), void 0 !== n3.y && (e3 = n3.relative ? e3 + n3.y : n3.y), n3.type & _.MOVE_TO && (i2 = r3, a2 = e3), o2;
        };
      }
      function O2(t3, r3, e3, i2, n3, o2) {
        return a(t3, r3, e3, i2, n3, o2), u2(function(a2, s2, u3, h2) {
          var c3 = a2.x1, y3 = a2.x2, p2 = a2.relative && !isNaN(h2), m3 = void 0 !== a2.x ? a2.x : p2 ? 0 : s2, O3 = void 0 !== a2.y ? a2.y : p2 ? 0 : u3;
          function l3(t4) {
            return t4 * t4;
          }
          a2.type & _.HORIZ_LINE_TO && 0 !== r3 && (a2.type = _.LINE_TO, a2.y = a2.relative ? 0 : u3), a2.type & _.VERT_LINE_TO && 0 !== e3 && (a2.type = _.LINE_TO, a2.x = a2.relative ? 0 : s2), void 0 !== a2.x && (a2.x = a2.x * t3 + O3 * e3 + (p2 ? 0 : n3)), void 0 !== a2.y && (a2.y = m3 * r3 + a2.y * i2 + (p2 ? 0 : o2)), void 0 !== a2.x1 && (a2.x1 = a2.x1 * t3 + a2.y1 * e3 + (p2 ? 0 : n3)), void 0 !== a2.y1 && (a2.y1 = c3 * r3 + a2.y1 * i2 + (p2 ? 0 : o2)), void 0 !== a2.x2 && (a2.x2 = a2.x2 * t3 + a2.y2 * e3 + (p2 ? 0 : n3)), void 0 !== a2.y2 && (a2.y2 = y3 * r3 + a2.y2 * i2 + (p2 ? 0 : o2));
          var T3 = t3 * i2 - r3 * e3;
          if (void 0 !== a2.xRot && (1 !== t3 || 0 !== r3 || 0 !== e3 || 1 !== i2))
            if (0 === T3)
              delete a2.rX, delete a2.rY, delete a2.xRot, delete a2.lArcFlag, delete a2.sweepFlag, a2.type = _.LINE_TO;
            else {
              var v2 = a2.xRot * Math.PI / 180, f3 = Math.sin(v2), N2 = Math.cos(v2), x2 = 1 / l3(a2.rX), d = 1 / l3(a2.rY), E = l3(N2) * x2 + l3(f3) * d, A2 = 2 * f3 * N2 * (x2 - d), C = l3(f3) * x2 + l3(N2) * d, M = E * i2 * i2 - A2 * r3 * i2 + C * r3 * r3, R = A2 * (t3 * i2 + r3 * e3) - 2 * (E * e3 * i2 + C * t3 * r3), g = E * e3 * e3 - A2 * t3 * e3 + C * t3 * t3, I = (Math.atan2(R, M - g) + Math.PI) % Math.PI / 2, S2 = Math.sin(I), L = Math.cos(I);
              a2.rX = Math.abs(T3) / Math.sqrt(M * l3(L) + R * S2 * L + g * l3(S2)), a2.rY = Math.abs(T3) / Math.sqrt(M * l3(S2) - R * S2 * L + g * l3(L)), a2.xRot = 180 * I / Math.PI;
            }
          return void 0 !== a2.sweepFlag && 0 > T3 && (a2.sweepFlag = +!a2.sweepFlag), a2;
        });
      }
      function l2() {
        return function(t3) {
          var r3 = {};
          for (var e3 in t3)
            r3[e3] = t3[e3];
          return r3;
        };
      }
      t2.ROUND = function(t3) {
        function r3(r4) {
          return Math.round(r4 * t3) / t3;
        }
        return void 0 === t3 && (t3 = 1e13), a(t3), function(t4) {
          return void 0 !== t4.x1 && (t4.x1 = r3(t4.x1)), void 0 !== t4.y1 && (t4.y1 = r3(t4.y1)), void 0 !== t4.x2 && (t4.x2 = r3(t4.x2)), void 0 !== t4.y2 && (t4.y2 = r3(t4.y2)), void 0 !== t4.x && (t4.x = r3(t4.x)), void 0 !== t4.y && (t4.y = r3(t4.y)), void 0 !== t4.rX && (t4.rX = r3(t4.rX)), void 0 !== t4.rY && (t4.rY = r3(t4.rY)), t4;
        };
      }, t2.TO_ABS = r2, t2.TO_REL = function() {
        return u2(function(t3, r3, e3) {
          return t3.relative || (void 0 !== t3.x1 && (t3.x1 -= r3), void 0 !== t3.y1 && (t3.y1 -= e3), void 0 !== t3.x2 && (t3.x2 -= r3), void 0 !== t3.y2 && (t3.y2 -= e3), void 0 !== t3.x && (t3.x -= r3), void 0 !== t3.y && (t3.y -= e3), t3.relative = true), t3;
        });
      }, t2.NORMALIZE_HVZ = function(t3, r3, e3) {
        return void 0 === t3 && (t3 = true), void 0 === r3 && (r3 = true), void 0 === e3 && (e3 = true), u2(function(i2, a2, n3, o2, s2) {
          if (isNaN(o2) && !(i2.type & _.MOVE_TO))
            throw new Error("path must start with moveto");
          return r3 && i2.type & _.HORIZ_LINE_TO && (i2.type = _.LINE_TO, i2.y = i2.relative ? 0 : n3), e3 && i2.type & _.VERT_LINE_TO && (i2.type = _.LINE_TO, i2.x = i2.relative ? 0 : a2), t3 && i2.type & _.CLOSE_PATH && (i2.type = _.LINE_TO, i2.x = i2.relative ? o2 - a2 : o2, i2.y = i2.relative ? s2 - n3 : s2), i2.type & _.ARC && (0 === i2.rX || 0 === i2.rY) && (i2.type = _.LINE_TO, delete i2.rX, delete i2.rY, delete i2.xRot, delete i2.lArcFlag, delete i2.sweepFlag), i2;
        });
      }, t2.NORMALIZE_ST = e2, t2.QT_TO_C = n2, t2.INFO = u2, t2.SANITIZE = function(t3) {
        void 0 === t3 && (t3 = 0), a(t3);
        var r3 = NaN, e3 = NaN, i2 = NaN, n3 = NaN;
        return u2(function(a2, o2, s2, u3, h2) {
          var c3 = Math.abs, y3 = false, p2 = 0, m3 = 0;
          if (a2.type & _.SMOOTH_CURVE_TO && (p2 = isNaN(r3) ? 0 : o2 - r3, m3 = isNaN(e3) ? 0 : s2 - e3), a2.type & (_.CURVE_TO | _.SMOOTH_CURVE_TO) ? (r3 = a2.relative ? o2 + a2.x2 : a2.x2, e3 = a2.relative ? s2 + a2.y2 : a2.y2) : (r3 = NaN, e3 = NaN), a2.type & _.SMOOTH_QUAD_TO ? (i2 = isNaN(i2) ? o2 : 2 * o2 - i2, n3 = isNaN(n3) ? s2 : 2 * s2 - n3) : a2.type & _.QUAD_TO ? (i2 = a2.relative ? o2 + a2.x1 : a2.x1, n3 = a2.relative ? s2 + a2.y1 : a2.y2) : (i2 = NaN, n3 = NaN), a2.type & _.LINE_COMMANDS || a2.type & _.ARC && (0 === a2.rX || 0 === a2.rY || !a2.lArcFlag) || a2.type & _.CURVE_TO || a2.type & _.SMOOTH_CURVE_TO || a2.type & _.QUAD_TO || a2.type & _.SMOOTH_QUAD_TO) {
            var O3 = void 0 === a2.x ? 0 : a2.relative ? a2.x : a2.x - o2, l3 = void 0 === a2.y ? 0 : a2.relative ? a2.y : a2.y - s2;
            p2 = isNaN(i2) ? void 0 === a2.x1 ? p2 : a2.relative ? a2.x : a2.x1 - o2 : i2 - o2, m3 = isNaN(n3) ? void 0 === a2.y1 ? m3 : a2.relative ? a2.y : a2.y1 - s2 : n3 - s2;
            var T3 = void 0 === a2.x2 ? 0 : a2.relative ? a2.x : a2.x2 - o2, v2 = void 0 === a2.y2 ? 0 : a2.relative ? a2.y : a2.y2 - s2;
            c3(O3) <= t3 && c3(l3) <= t3 && c3(p2) <= t3 && c3(m3) <= t3 && c3(T3) <= t3 && c3(v2) <= t3 && (y3 = true);
          }
          return a2.type & _.CLOSE_PATH && c3(o2 - u3) <= t3 && c3(s2 - h2) <= t3 && (y3 = true), y3 ? [] : a2;
        });
      }, t2.MATRIX = O2, t2.ROTATE = function(t3, r3, e3) {
        void 0 === r3 && (r3 = 0), void 0 === e3 && (e3 = 0), a(t3, r3, e3);
        var i2 = Math.sin(t3), n3 = Math.cos(t3);
        return O2(n3, i2, -i2, n3, r3 - r3 * n3 + e3 * i2, e3 - r3 * i2 - e3 * n3);
      }, t2.TRANSLATE = function(t3, r3) {
        return void 0 === r3 && (r3 = 0), a(t3, r3), O2(1, 0, 0, 1, t3, r3);
      }, t2.SCALE = function(t3, r3) {
        return void 0 === r3 && (r3 = t3), a(t3, r3), O2(t3, 0, 0, r3, 0, 0);
      }, t2.SKEW_X = function(t3) {
        return a(t3), O2(1, 0, Math.atan(t3), 1, 0, 0);
      }, t2.SKEW_Y = function(t3) {
        return a(t3), O2(1, Math.atan(t3), 0, 1, 0, 0);
      }, t2.X_AXIS_SYMMETRY = function(t3) {
        return void 0 === t3 && (t3 = 0), a(t3), O2(-1, 0, 0, 1, t3, 0);
      }, t2.Y_AXIS_SYMMETRY = function(t3) {
        return void 0 === t3 && (t3 = 0), a(t3), O2(1, 0, 0, -1, 0, t3);
      }, t2.A_TO_C = function() {
        return u2(function(t3, r3, e3) {
          return _.ARC === t3.type ? function(t4, r4, e4) {
            var a2, n3, s2, u3;
            t4.cX || o(t4, r4, e4);
            for (var y3 = Math.min(t4.phi1, t4.phi2), p2 = Math.max(t4.phi1, t4.phi2) - y3, m3 = Math.ceil(p2 / 90), O3 = new Array(m3), l3 = r4, T3 = e4, v2 = 0; v2 < m3; v2++) {
              var f3 = c(t4.phi1, t4.phi2, v2 / m3), N2 = c(t4.phi1, t4.phi2, (v2 + 1) / m3), x2 = N2 - f3, d = 4 / 3 * Math.tan(x2 * h / 4), E = [Math.cos(f3 * h) - d * Math.sin(f3 * h), Math.sin(f3 * h) + d * Math.cos(f3 * h)], A2 = E[0], C = E[1], M = [Math.cos(N2 * h), Math.sin(N2 * h)], R = M[0], g = M[1], I = [R + d * Math.sin(N2 * h), g - d * Math.cos(N2 * h)], S2 = I[0], L = I[1];
              O3[v2] = { relative: t4.relative, type: _.CURVE_TO };
              var H = function(r5, e5) {
                var a3 = i([r5 * t4.rX, e5 * t4.rY], t4.xRot), n4 = a3[0], o2 = a3[1];
                return [t4.cX + n4, t4.cY + o2];
              };
              a2 = H(A2, C), O3[v2].x1 = a2[0], O3[v2].y1 = a2[1], n3 = H(S2, L), O3[v2].x2 = n3[0], O3[v2].y2 = n3[1], s2 = H(R, g), O3[v2].x = s2[0], O3[v2].y = s2[1], t4.relative && (O3[v2].x1 -= l3, O3[v2].y1 -= T3, O3[v2].x2 -= l3, O3[v2].y2 -= T3, O3[v2].x -= l3, O3[v2].y -= T3), l3 = (u3 = [O3[v2].x, O3[v2].y])[0], T3 = u3[1];
            }
            return O3;
          }(t3, t3.relative ? 0 : r3, t3.relative ? 0 : e3) : t3;
        });
      }, t2.ANNOTATE_ARCS = function() {
        return u2(function(t3, r3, e3) {
          return t3.relative && (r3 = 0, e3 = 0), _.ARC === t3.type && o(t3, r3, e3), t3;
        });
      }, t2.CLONE = l2, t2.CALCULATE_BOUNDS = function() {
        var t3 = function(t4) {
          var r3 = {};
          for (var e3 in t4)
            r3[e3] = t4[e3];
          return r3;
        }, i2 = r2(), a2 = n2(), h2 = e2(), c3 = u2(function(r3, e3, n3) {
          var u3 = h2(a2(i2(t3(r3))));
          function O3(t4) {
            t4 > c3.maxX && (c3.maxX = t4), t4 < c3.minX && (c3.minX = t4);
          }
          function l3(t4) {
            t4 > c3.maxY && (c3.maxY = t4), t4 < c3.minY && (c3.minY = t4);
          }
          if (u3.type & _.DRAWING_COMMANDS && (O3(e3), l3(n3)), u3.type & _.HORIZ_LINE_TO && O3(u3.x), u3.type & _.VERT_LINE_TO && l3(u3.y), u3.type & _.LINE_TO && (O3(u3.x), l3(u3.y)), u3.type & _.CURVE_TO) {
            O3(u3.x), l3(u3.y);
            for (var T3 = 0, v2 = p(e3, u3.x1, u3.x2, u3.x); T3 < v2.length; T3++) {
              0 < (w = v2[T3]) && 1 > w && O3(m(e3, u3.x1, u3.x2, u3.x, w));
            }
            for (var f3 = 0, N2 = p(n3, u3.y1, u3.y2, u3.y); f3 < N2.length; f3++) {
              0 < (w = N2[f3]) && 1 > w && l3(m(n3, u3.y1, u3.y2, u3.y, w));
            }
          }
          if (u3.type & _.ARC) {
            O3(u3.x), l3(u3.y), o(u3, e3, n3);
            for (var x2 = u3.xRot / 180 * Math.PI, d = Math.cos(x2) * u3.rX, E = Math.sin(x2) * u3.rX, A2 = -Math.sin(x2) * u3.rY, C = Math.cos(x2) * u3.rY, M = u3.phi1 < u3.phi2 ? [u3.phi1, u3.phi2] : -180 > u3.phi2 ? [u3.phi2 + 360, u3.phi1 + 360] : [u3.phi2, u3.phi1], R = M[0], g = M[1], I = function(t4) {
              var r4 = t4[0], e4 = t4[1], i3 = 180 * Math.atan2(e4, r4) / Math.PI;
              return i3 < R ? i3 + 360 : i3;
            }, S2 = 0, L = s(A2, -d, 0).map(I); S2 < L.length; S2++) {
              (w = L[S2]) > R && w < g && O3(y2(u3.cX, d, A2, w));
            }
            for (var H = 0, U = s(C, -E, 0).map(I); H < U.length; H++) {
              var w;
              (w = U[H]) > R && w < g && l3(y2(u3.cY, E, C, w));
            }
          }
          return r3;
        });
        return c3.minX = 1 / 0, c3.maxX = -1 / 0, c3.minY = 1 / 0, c3.maxY = -1 / 0, c3;
      };
    }(u || (u = {}));
    l = function() {
      function t2() {
      }
      return t2.prototype.round = function(t3) {
        return this.transform(u.ROUND(t3));
      }, t2.prototype.toAbs = function() {
        return this.transform(u.TO_ABS());
      }, t2.prototype.toRel = function() {
        return this.transform(u.TO_REL());
      }, t2.prototype.normalizeHVZ = function(t3, r2, e2) {
        return this.transform(u.NORMALIZE_HVZ(t3, r2, e2));
      }, t2.prototype.normalizeST = function() {
        return this.transform(u.NORMALIZE_ST());
      }, t2.prototype.qtToC = function() {
        return this.transform(u.QT_TO_C());
      }, t2.prototype.aToC = function() {
        return this.transform(u.A_TO_C());
      }, t2.prototype.sanitize = function(t3) {
        return this.transform(u.SANITIZE(t3));
      }, t2.prototype.translate = function(t3, r2) {
        return this.transform(u.TRANSLATE(t3, r2));
      }, t2.prototype.scale = function(t3, r2) {
        return this.transform(u.SCALE(t3, r2));
      }, t2.prototype.rotate = function(t3, r2, e2) {
        return this.transform(u.ROTATE(t3, r2, e2));
      }, t2.prototype.matrix = function(t3, r2, e2, i2, a2, n2) {
        return this.transform(u.MATRIX(t3, r2, e2, i2, a2, n2));
      }, t2.prototype.skewX = function(t3) {
        return this.transform(u.SKEW_X(t3));
      }, t2.prototype.skewY = function(t3) {
        return this.transform(u.SKEW_Y(t3));
      }, t2.prototype.xSymmetry = function(t3) {
        return this.transform(u.X_AXIS_SYMMETRY(t3));
      }, t2.prototype.ySymmetry = function(t3) {
        return this.transform(u.Y_AXIS_SYMMETRY(t3));
      }, t2.prototype.annotateArcs = function() {
        return this.transform(u.ANNOTATE_ARCS());
      }, t2;
    }();
    T = function(t2) {
      return " " === t2 || "	" === t2 || "\r" === t2 || "\n" === t2;
    };
    v = function(t2) {
      return "0".charCodeAt(0) <= t2.charCodeAt(0) && t2.charCodeAt(0) <= "9".charCodeAt(0);
    };
    f = function(t2) {
      function e2() {
        var r2 = t2.call(this) || this;
        return r2.curNumber = "", r2.curCommandType = -1, r2.curCommandRelative = false, r2.canParseCommandOrComma = true, r2.curNumberHasExp = false, r2.curNumberHasExpDigits = false, r2.curNumberHasDecimal = false, r2.curArgs = [], r2;
      }
      return r(e2, t2), e2.prototype.finish = function(t3) {
        if (void 0 === t3 && (t3 = []), this.parse(" ", t3), 0 !== this.curArgs.length || !this.canParseCommandOrComma)
          throw new SyntaxError("Unterminated command at the path end.");
        return t3;
      }, e2.prototype.parse = function(t3, r2) {
        var e3 = this;
        void 0 === r2 && (r2 = []);
        for (var i2 = function(t4) {
          r2.push(t4), e3.curArgs.length = 0, e3.canParseCommandOrComma = true;
        }, a2 = 0; a2 < t3.length; a2++) {
          var n2 = t3[a2], o2 = !(this.curCommandType !== _.ARC || 3 !== this.curArgs.length && 4 !== this.curArgs.length || 1 !== this.curNumber.length || "0" !== this.curNumber && "1" !== this.curNumber), s2 = v(n2) && ("0" === this.curNumber && "0" === n2 || o2);
          if (!v(n2) || s2)
            if ("e" !== n2 && "E" !== n2)
              if ("-" !== n2 && "+" !== n2 || !this.curNumberHasExp || this.curNumberHasExpDigits)
                if ("." !== n2 || this.curNumberHasExp || this.curNumberHasDecimal || o2) {
                  if (this.curNumber && -1 !== this.curCommandType) {
                    var u2 = Number(this.curNumber);
                    if (isNaN(u2))
                      throw new SyntaxError("Invalid number ending at " + a2);
                    if (this.curCommandType === _.ARC) {
                      if (0 === this.curArgs.length || 1 === this.curArgs.length) {
                        if (0 > u2)
                          throw new SyntaxError('Expected positive number, got "' + u2 + '" at index "' + a2 + '"');
                      } else if ((3 === this.curArgs.length || 4 === this.curArgs.length) && "0" !== this.curNumber && "1" !== this.curNumber)
                        throw new SyntaxError('Expected a flag, got "' + this.curNumber + '" at index "' + a2 + '"');
                    }
                    this.curArgs.push(u2), this.curArgs.length === N[this.curCommandType] && (_.HORIZ_LINE_TO === this.curCommandType ? i2({ type: _.HORIZ_LINE_TO, relative: this.curCommandRelative, x: u2 }) : _.VERT_LINE_TO === this.curCommandType ? i2({ type: _.VERT_LINE_TO, relative: this.curCommandRelative, y: u2 }) : this.curCommandType === _.MOVE_TO || this.curCommandType === _.LINE_TO || this.curCommandType === _.SMOOTH_QUAD_TO ? (i2({ type: this.curCommandType, relative: this.curCommandRelative, x: this.curArgs[0], y: this.curArgs[1] }), _.MOVE_TO === this.curCommandType && (this.curCommandType = _.LINE_TO)) : this.curCommandType === _.CURVE_TO ? i2({ type: _.CURVE_TO, relative: this.curCommandRelative, x1: this.curArgs[0], y1: this.curArgs[1], x2: this.curArgs[2], y2: this.curArgs[3], x: this.curArgs[4], y: this.curArgs[5] }) : this.curCommandType === _.SMOOTH_CURVE_TO ? i2({ type: _.SMOOTH_CURVE_TO, relative: this.curCommandRelative, x2: this.curArgs[0], y2: this.curArgs[1], x: this.curArgs[2], y: this.curArgs[3] }) : this.curCommandType === _.QUAD_TO ? i2({ type: _.QUAD_TO, relative: this.curCommandRelative, x1: this.curArgs[0], y1: this.curArgs[1], x: this.curArgs[2], y: this.curArgs[3] }) : this.curCommandType === _.ARC && i2({ type: _.ARC, relative: this.curCommandRelative, rX: this.curArgs[0], rY: this.curArgs[1], xRot: this.curArgs[2], lArcFlag: this.curArgs[3], sweepFlag: this.curArgs[4], x: this.curArgs[5], y: this.curArgs[6] })), this.curNumber = "", this.curNumberHasExpDigits = false, this.curNumberHasExp = false, this.curNumberHasDecimal = false, this.canParseCommandOrComma = true;
                  }
                  if (!T(n2))
                    if ("," === n2 && this.canParseCommandOrComma)
                      this.canParseCommandOrComma = false;
                    else if ("+" !== n2 && "-" !== n2 && "." !== n2)
                      if (s2)
                        this.curNumber = n2, this.curNumberHasDecimal = false;
                      else {
                        if (0 !== this.curArgs.length)
                          throw new SyntaxError("Unterminated command at index " + a2 + ".");
                        if (!this.canParseCommandOrComma)
                          throw new SyntaxError('Unexpected character "' + n2 + '" at index ' + a2 + ". Command cannot follow comma");
                        if (this.canParseCommandOrComma = false, "z" !== n2 && "Z" !== n2)
                          if ("h" === n2 || "H" === n2)
                            this.curCommandType = _.HORIZ_LINE_TO, this.curCommandRelative = "h" === n2;
                          else if ("v" === n2 || "V" === n2)
                            this.curCommandType = _.VERT_LINE_TO, this.curCommandRelative = "v" === n2;
                          else if ("m" === n2 || "M" === n2)
                            this.curCommandType = _.MOVE_TO, this.curCommandRelative = "m" === n2;
                          else if ("l" === n2 || "L" === n2)
                            this.curCommandType = _.LINE_TO, this.curCommandRelative = "l" === n2;
                          else if ("c" === n2 || "C" === n2)
                            this.curCommandType = _.CURVE_TO, this.curCommandRelative = "c" === n2;
                          else if ("s" === n2 || "S" === n2)
                            this.curCommandType = _.SMOOTH_CURVE_TO, this.curCommandRelative = "s" === n2;
                          else if ("q" === n2 || "Q" === n2)
                            this.curCommandType = _.QUAD_TO, this.curCommandRelative = "q" === n2;
                          else if ("t" === n2 || "T" === n2)
                            this.curCommandType = _.SMOOTH_QUAD_TO, this.curCommandRelative = "t" === n2;
                          else {
                            if ("a" !== n2 && "A" !== n2)
                              throw new SyntaxError('Unexpected character "' + n2 + '" at index ' + a2 + ".");
                            this.curCommandType = _.ARC, this.curCommandRelative = "a" === n2;
                          }
                        else
                          r2.push({ type: _.CLOSE_PATH }), this.canParseCommandOrComma = true, this.curCommandType = -1;
                      }
                    else
                      this.curNumber = n2, this.curNumberHasDecimal = "." === n2;
                } else
                  this.curNumber += n2, this.curNumberHasDecimal = true;
              else
                this.curNumber += n2;
            else
              this.curNumber += n2, this.curNumberHasExp = true;
          else
            this.curNumber += n2, this.curNumberHasExpDigits = this.curNumberHasExp;
        }
        return r2;
      }, e2.prototype.transform = function(t3) {
        return Object.create(this, { parse: { value: function(r2, e3) {
          void 0 === e3 && (e3 = []);
          for (var i2 = 0, a2 = Object.getPrototypeOf(this).parse.call(this, r2); i2 < a2.length; i2++) {
            var n2 = a2[i2], o2 = t3(n2);
            Array.isArray(o2) ? e3.push.apply(e3, o2) : e3.push(o2);
          }
          return e3;
        } } });
      }, e2;
    }(l);
    _ = function(t2) {
      function i2(r2) {
        var e2 = t2.call(this) || this;
        return e2.commands = "string" == typeof r2 ? i2.parse(r2) : r2, e2;
      }
      return r(i2, t2), i2.prototype.encode = function() {
        return i2.encode(this.commands);
      }, i2.prototype.getBounds = function() {
        var t3 = u.CALCULATE_BOUNDS();
        return this.transform(t3), t3;
      }, i2.prototype.transform = function(t3) {
        for (var r2 = [], e2 = 0, i3 = this.commands; e2 < i3.length; e2++) {
          var a2 = t3(i3[e2]);
          Array.isArray(a2) ? r2.push.apply(r2, a2) : r2.push(a2);
        }
        return this.commands = r2, this;
      }, i2.encode = function(t3) {
        return e(t3);
      }, i2.parse = function(t3) {
        var r2 = new f(), e2 = [];
        return r2.parse(t3, e2), r2.finish(e2), e2;
      }, i2.CLOSE_PATH = 1, i2.MOVE_TO = 2, i2.HORIZ_LINE_TO = 4, i2.VERT_LINE_TO = 8, i2.LINE_TO = 16, i2.CURVE_TO = 32, i2.SMOOTH_CURVE_TO = 64, i2.QUAD_TO = 128, i2.SMOOTH_QUAD_TO = 256, i2.ARC = 512, i2.LINE_COMMANDS = i2.LINE_TO | i2.HORIZ_LINE_TO | i2.VERT_LINE_TO, i2.DRAWING_COMMANDS = i2.HORIZ_LINE_TO | i2.VERT_LINE_TO | i2.LINE_TO | i2.CURVE_TO | i2.SMOOTH_CURVE_TO | i2.QUAD_TO | i2.SMOOTH_QUAD_TO | i2.ARC, i2;
    }(l);
    N = ((O = {})[_.MOVE_TO] = 2, O[_.LINE_TO] = 2, O[_.HORIZ_LINE_TO] = 1, O[_.VERT_LINE_TO] = 1, O[_.CLOSE_PATH] = 0, O[_.QUAD_TO] = 4, O[_.SMOOTH_QUAD_TO] = 2, O[_.CURVE_TO] = 6, O[_.SMOOTH_CURVE_TO] = 4, O[_.ARC] = 7, O);
  }
});

// ../simple-mind-map/node_modules/core-js/internals/regexp-get-flags.js
var require_regexp_get_flags = __commonJS({
  "../simple-mind-map/node_modules/core-js/internals/regexp-get-flags.js"(exports, module) {
    "use strict";
    var call = require_function_call();
    var hasOwn = require_has_own_property();
    var isPrototypeOf = require_object_is_prototype_of();
    var regExpFlags = require_regexp_flags();
    var RegExpPrototype = RegExp.prototype;
    module.exports = function(R) {
      var flags = R.flags;
      return flags === void 0 && !("flags" in RegExpPrototype) && !hasOwn(R, "flags") && isPrototypeOf(RegExpPrototype, R) ? call(regExpFlags, R) : flags;
    };
  }
});

// ../simple-mind-map/node_modules/core-js/modules/es.regexp.to-string.js
var require_es_regexp_to_string = __commonJS({
  "../simple-mind-map/node_modules/core-js/modules/es.regexp.to-string.js"() {
    "use strict";
    var PROPER_FUNCTION_NAME = require_function_name().PROPER;
    var defineBuiltIn = require_define_built_in();
    var anObject = require_an_object();
    var $toString = require_to_string();
    var fails = require_fails();
    var getRegExpFlags = require_regexp_get_flags();
    var TO_STRING = "toString";
    var RegExpPrototype = RegExp.prototype;
    var nativeToString = RegExpPrototype[TO_STRING];
    var NOT_GENERIC = fails(function() {
      return nativeToString.call({ source: "a", flags: "b" }) !== "/a/b";
    });
    var INCORRECT_NAME = PROPER_FUNCTION_NAME && nativeToString.name !== TO_STRING;
    if (NOT_GENERIC || INCORRECT_NAME) {
      defineBuiltIn(RegExp.prototype, TO_STRING, function toString2() {
        var R = anObject(this);
        var pattern = $toString(R.source);
        var flags = $toString(getRegExpFlags(R));
        return "/" + pattern + "/" + flags;
      }, { unsafe: true });
    }
  }
});

// ../simple-mind-map/node_modules/stackblur-canvas/dist/stackblur-es.js
function _typeof2(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof2 = function(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof2 = function(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof2(obj);
}
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function getImageDataFromCanvas(canvas, topX, topY, width2, height2) {
  if (typeof canvas === "string") {
    canvas = document.getElementById(canvas);
  }
  if (!canvas || _typeof2(canvas) !== "object" || !("getContext" in canvas)) {
    throw new TypeError("Expecting canvas with `getContext` method in processCanvasRGB(A) calls!");
  }
  var context = canvas.getContext("2d");
  try {
    return context.getImageData(topX, topY, width2, height2);
  } catch (e2) {
    throw new Error("unable to access image data: " + e2);
  }
}
function processCanvasRGBA(canvas, topX, topY, width2, height2, radius) {
  if (isNaN(radius) || radius < 1) {
    return;
  }
  radius |= 0;
  var imageData = getImageDataFromCanvas(canvas, topX, topY, width2, height2);
  imageData = processImageDataRGBA(imageData, topX, topY, width2, height2, radius);
  canvas.getContext("2d").putImageData(imageData, topX, topY);
}
function processImageDataRGBA(imageData, topX, topY, width2, height2, radius) {
  var pixels = imageData.data;
  var div = 2 * radius + 1;
  var widthMinus1 = width2 - 1;
  var heightMinus1 = height2 - 1;
  var radiusPlus1 = radius + 1;
  var sumFactor = radiusPlus1 * (radiusPlus1 + 1) / 2;
  var stackStart = new BlurStack();
  var stack = stackStart;
  var stackEnd;
  for (var i2 = 1; i2 < div; i2++) {
    stack = stack.next = new BlurStack();
    if (i2 === radiusPlus1) {
      stackEnd = stack;
    }
  }
  stack.next = stackStart;
  var stackIn = null, stackOut = null, yw = 0, yi = 0;
  var mulSum = mulTable[radius];
  var shgSum = shgTable[radius];
  for (var y3 = 0; y3 < height2; y3++) {
    stack = stackStart;
    var pr = pixels[yi], pg = pixels[yi + 1], pb = pixels[yi + 2], pa = pixels[yi + 3];
    for (var _i = 0; _i < radiusPlus1; _i++) {
      stack.r = pr;
      stack.g = pg;
      stack.b = pb;
      stack.a = pa;
      stack = stack.next;
    }
    var rInSum = 0, gInSum = 0, bInSum = 0, aInSum = 0, rOutSum = radiusPlus1 * pr, gOutSum = radiusPlus1 * pg, bOutSum = radiusPlus1 * pb, aOutSum = radiusPlus1 * pa, rSum = sumFactor * pr, gSum = sumFactor * pg, bSum = sumFactor * pb, aSum = sumFactor * pa;
    for (var _i2 = 1; _i2 < radiusPlus1; _i2++) {
      var p2 = yi + ((widthMinus1 < _i2 ? widthMinus1 : _i2) << 2);
      var r2 = pixels[p2], g = pixels[p2 + 1], b = pixels[p2 + 2], a2 = pixels[p2 + 3];
      var rbs = radiusPlus1 - _i2;
      rSum += (stack.r = r2) * rbs;
      gSum += (stack.g = g) * rbs;
      bSum += (stack.b = b) * rbs;
      aSum += (stack.a = a2) * rbs;
      rInSum += r2;
      gInSum += g;
      bInSum += b;
      aInSum += a2;
      stack = stack.next;
    }
    stackIn = stackStart;
    stackOut = stackEnd;
    for (var x2 = 0; x2 < width2; x2++) {
      var paInitial = aSum * mulSum >> shgSum;
      pixels[yi + 3] = paInitial;
      if (paInitial !== 0) {
        var _a2 = 255 / paInitial;
        pixels[yi] = (rSum * mulSum >> shgSum) * _a2;
        pixels[yi + 1] = (gSum * mulSum >> shgSum) * _a2;
        pixels[yi + 2] = (bSum * mulSum >> shgSum) * _a2;
      } else {
        pixels[yi] = pixels[yi + 1] = pixels[yi + 2] = 0;
      }
      rSum -= rOutSum;
      gSum -= gOutSum;
      bSum -= bOutSum;
      aSum -= aOutSum;
      rOutSum -= stackIn.r;
      gOutSum -= stackIn.g;
      bOutSum -= stackIn.b;
      aOutSum -= stackIn.a;
      var _p = x2 + radius + 1;
      _p = yw + (_p < widthMinus1 ? _p : widthMinus1) << 2;
      rInSum += stackIn.r = pixels[_p];
      gInSum += stackIn.g = pixels[_p + 1];
      bInSum += stackIn.b = pixels[_p + 2];
      aInSum += stackIn.a = pixels[_p + 3];
      rSum += rInSum;
      gSum += gInSum;
      bSum += bInSum;
      aSum += aInSum;
      stackIn = stackIn.next;
      var _stackOut = stackOut, _r = _stackOut.r, _g = _stackOut.g, _b2 = _stackOut.b, _a3 = _stackOut.a;
      rOutSum += _r;
      gOutSum += _g;
      bOutSum += _b2;
      aOutSum += _a3;
      rInSum -= _r;
      gInSum -= _g;
      bInSum -= _b2;
      aInSum -= _a3;
      stackOut = stackOut.next;
      yi += 4;
    }
    yw += width2;
  }
  for (var _x = 0; _x < width2; _x++) {
    yi = _x << 2;
    var _pr = pixels[yi], _pg = pixels[yi + 1], _pb = pixels[yi + 2], _pa = pixels[yi + 3], _rOutSum = radiusPlus1 * _pr, _gOutSum = radiusPlus1 * _pg, _bOutSum = radiusPlus1 * _pb, _aOutSum = radiusPlus1 * _pa, _rSum = sumFactor * _pr, _gSum = sumFactor * _pg, _bSum = sumFactor * _pb, _aSum = sumFactor * _pa;
    stack = stackStart;
    for (var _i3 = 0; _i3 < radiusPlus1; _i3++) {
      stack.r = _pr;
      stack.g = _pg;
      stack.b = _pb;
      stack.a = _pa;
      stack = stack.next;
    }
    var yp = width2;
    var _gInSum = 0, _bInSum = 0, _aInSum = 0, _rInSum = 0;
    for (var _i4 = 1; _i4 <= radius; _i4++) {
      yi = yp + _x << 2;
      var _rbs = radiusPlus1 - _i4;
      _rSum += (stack.r = _pr = pixels[yi]) * _rbs;
      _gSum += (stack.g = _pg = pixels[yi + 1]) * _rbs;
      _bSum += (stack.b = _pb = pixels[yi + 2]) * _rbs;
      _aSum += (stack.a = _pa = pixels[yi + 3]) * _rbs;
      _rInSum += _pr;
      _gInSum += _pg;
      _bInSum += _pb;
      _aInSum += _pa;
      stack = stack.next;
      if (_i4 < heightMinus1) {
        yp += width2;
      }
    }
    yi = _x;
    stackIn = stackStart;
    stackOut = stackEnd;
    for (var _y = 0; _y < height2; _y++) {
      var _p2 = yi << 2;
      pixels[_p2 + 3] = _pa = _aSum * mulSum >> shgSum;
      if (_pa > 0) {
        _pa = 255 / _pa;
        pixels[_p2] = (_rSum * mulSum >> shgSum) * _pa;
        pixels[_p2 + 1] = (_gSum * mulSum >> shgSum) * _pa;
        pixels[_p2 + 2] = (_bSum * mulSum >> shgSum) * _pa;
      } else {
        pixels[_p2] = pixels[_p2 + 1] = pixels[_p2 + 2] = 0;
      }
      _rSum -= _rOutSum;
      _gSum -= _gOutSum;
      _bSum -= _bOutSum;
      _aSum -= _aOutSum;
      _rOutSum -= stackIn.r;
      _gOutSum -= stackIn.g;
      _bOutSum -= stackIn.b;
      _aOutSum -= stackIn.a;
      _p2 = _x + ((_p2 = _y + radiusPlus1) < heightMinus1 ? _p2 : heightMinus1) * width2 << 2;
      _rSum += _rInSum += stackIn.r = pixels[_p2];
      _gSum += _gInSum += stackIn.g = pixels[_p2 + 1];
      _bSum += _bInSum += stackIn.b = pixels[_p2 + 2];
      _aSum += _aInSum += stackIn.a = pixels[_p2 + 3];
      stackIn = stackIn.next;
      _rOutSum += _pr = stackOut.r;
      _gOutSum += _pg = stackOut.g;
      _bOutSum += _pb = stackOut.b;
      _aOutSum += _pa = stackOut.a;
      _rInSum -= _pr;
      _gInSum -= _pg;
      _bInSum -= _pb;
      _aInSum -= _pa;
      stackOut = stackOut.next;
      yi += width2;
    }
  }
  return imageData;
}
var mulTable, shgTable, BlurStack;
var init_stackblur_es = __esm({
  "../simple-mind-map/node_modules/stackblur-canvas/dist/stackblur-es.js"() {
    mulTable = [512, 512, 456, 512, 328, 456, 335, 512, 405, 328, 271, 456, 388, 335, 292, 512, 454, 405, 364, 328, 298, 271, 496, 456, 420, 388, 360, 335, 312, 292, 273, 512, 482, 454, 428, 405, 383, 364, 345, 328, 312, 298, 284, 271, 259, 496, 475, 456, 437, 420, 404, 388, 374, 360, 347, 335, 323, 312, 302, 292, 282, 273, 265, 512, 497, 482, 468, 454, 441, 428, 417, 405, 394, 383, 373, 364, 354, 345, 337, 328, 320, 312, 305, 298, 291, 284, 278, 271, 265, 259, 507, 496, 485, 475, 465, 456, 446, 437, 428, 420, 412, 404, 396, 388, 381, 374, 367, 360, 354, 347, 341, 335, 329, 323, 318, 312, 307, 302, 297, 292, 287, 282, 278, 273, 269, 265, 261, 512, 505, 497, 489, 482, 475, 468, 461, 454, 447, 441, 435, 428, 422, 417, 411, 405, 399, 394, 389, 383, 378, 373, 368, 364, 359, 354, 350, 345, 341, 337, 332, 328, 324, 320, 316, 312, 309, 305, 301, 298, 294, 291, 287, 284, 281, 278, 274, 271, 268, 265, 262, 259, 257, 507, 501, 496, 491, 485, 480, 475, 470, 465, 460, 456, 451, 446, 442, 437, 433, 428, 424, 420, 416, 412, 408, 404, 400, 396, 392, 388, 385, 381, 377, 374, 370, 367, 363, 360, 357, 354, 350, 347, 344, 341, 338, 335, 332, 329, 326, 323, 320, 318, 315, 312, 310, 307, 304, 302, 299, 297, 294, 292, 289, 287, 285, 282, 280, 278, 275, 273, 271, 269, 267, 265, 263, 261, 259];
    shgTable = [9, 11, 12, 13, 13, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 17, 17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 18, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24];
    BlurStack = /**
     * Set properties.
     */
    function BlurStack2() {
      _classCallCheck(this, BlurStack2);
      this.r = 0;
      this.g = 0;
      this.b = 0;
      this.a = 0;
      this.next = null;
    };
  }
});

// ../simple-mind-map/node_modules/canvg/lib/index.es.js
var index_es_exports = {};
__export(index_es_exports, {
  AElement: () => AElement,
  AnimateColorElement: () => AnimateColorElement,
  AnimateElement: () => AnimateElement,
  AnimateTransformElement: () => AnimateTransformElement,
  BoundingBox: () => BoundingBox,
  CB1: () => CB1,
  CB2: () => CB2,
  CB3: () => CB3,
  CB4: () => CB4,
  Canvg: () => Canvg,
  CircleElement: () => CircleElement,
  ClipPathElement: () => ClipPathElement,
  DefsElement: () => DefsElement,
  DescElement: () => DescElement,
  Document: () => Document,
  Element: () => Element2,
  EllipseElement: () => EllipseElement,
  FeColorMatrixElement: () => FeColorMatrixElement,
  FeCompositeElement: () => FeCompositeElement,
  FeDropShadowElement: () => FeDropShadowElement,
  FeGaussianBlurElement: () => FeGaussianBlurElement,
  FeMorphologyElement: () => FeMorphologyElement,
  FilterElement: () => FilterElement,
  Font: () => Font,
  FontElement: () => FontElement,
  FontFaceElement: () => FontFaceElement,
  GElement: () => GElement,
  GlyphElement: () => GlyphElement,
  GradientElement: () => GradientElement,
  ImageElement: () => ImageElement,
  LineElement: () => LineElement,
  LinearGradientElement: () => LinearGradientElement,
  MarkerElement: () => MarkerElement,
  MaskElement: () => MaskElement,
  Matrix: () => Matrix2,
  MissingGlyphElement: () => MissingGlyphElement,
  Mouse: () => Mouse,
  PSEUDO_ZERO: () => PSEUDO_ZERO,
  Parser: () => Parser,
  PathElement: () => PathElement,
  PathParser: () => PathParser,
  PatternElement: () => PatternElement,
  Point: () => Point2,
  PolygonElement: () => PolygonElement,
  PolylineElement: () => PolylineElement,
  Property: () => Property,
  QB1: () => QB1,
  QB2: () => QB2,
  QB3: () => QB3,
  RadialGradientElement: () => RadialGradientElement,
  RectElement: () => RectElement,
  RenderedElement: () => RenderedElement,
  Rotate: () => Rotate,
  SVGElement: () => SVGElement,
  SVGFontLoader: () => SVGFontLoader,
  Scale: () => Scale,
  Screen: () => Screen,
  Skew: () => Skew,
  SkewX: () => SkewX,
  SkewY: () => SkewY,
  StopElement: () => StopElement,
  StyleElement: () => StyleElement,
  SymbolElement: () => SymbolElement,
  TRefElement: () => TRefElement,
  TSpanElement: () => TSpanElement,
  TextElement: () => TextElement,
  TextPathElement: () => TextPathElement,
  TitleElement: () => TitleElement,
  Transform: () => Transform,
  Translate: () => Translate,
  UnknownElement: () => UnknownElement,
  UseElement: () => UseElement,
  ViewPort: () => ViewPort,
  compressSpaces: () => compressSpaces,
  default: () => Canvg,
  getSelectorSpecificity: () => getSelectorSpecificity,
  normalizeAttributeName: () => normalizeAttributeName,
  normalizeColor: () => normalizeColor,
  parseExternalUrl: () => parseExternalUrl,
  presets: () => index,
  toNumbers: () => toNumbers,
  trimLeft: () => trimLeft,
  trimRight: () => trimRight,
  vectorMagnitude: () => vectorMagnitude,
  vectorsAngle: () => vectorsAngle,
  vectorsRatio: () => vectorsRatio
});
function offscreen() {
  var {
    DOMParser: DOMParserFallback
  } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  var preset = {
    window: null,
    ignoreAnimation: true,
    ignoreMouse: true,
    DOMParser: DOMParserFallback,
    createCanvas(width2, height2) {
      return new OffscreenCanvas(width2, height2);
    },
    createImage(url) {
      return _asyncToGenerator(function* () {
        var response = yield fetch(url);
        var blob = yield response.blob();
        var img = yield createImageBitmap(blob);
        return img;
      })();
    }
  };
  if (typeof DOMParser !== "undefined" || typeof DOMParserFallback === "undefined") {
    Reflect.deleteProperty(preset, "DOMParser");
  }
  return preset;
}
function node(_ref) {
  var {
    DOMParser: DOMParser2,
    canvas,
    fetch: fetch2
  } = _ref;
  return {
    window: null,
    ignoreAnimation: true,
    ignoreMouse: true,
    DOMParser: DOMParser2,
    fetch: fetch2,
    createCanvas: canvas.createCanvas,
    createImage: canvas.loadImage
  };
}
function compressSpaces(str) {
  return str.replace(/(?!\u3000)\s+/gm, " ");
}
function trimLeft(str) {
  return str.replace(/^[\n \t]+/, "");
}
function trimRight(str) {
  return str.replace(/[\n \t]+$/, "");
}
function toNumbers(str) {
  var matches = (str || "").match(/-?(\d+(?:\.\d*(?:[eE][+-]?\d+)?)?|\.\d+)(?=\D|$)/gm) || [];
  return matches.map(parseFloat);
}
function normalizeAttributeName(name) {
  if (allUppercase.test(name)) {
    return name.toLowerCase();
  }
  return name;
}
function parseExternalUrl(url) {
  var urlMatch = /url\(('([^']+)'|"([^"]+)"|([^'")]+))\)/.exec(url) || [];
  return urlMatch[2] || urlMatch[3] || urlMatch[4];
}
function normalizeColor(color) {
  if (!color.startsWith("rgb")) {
    return color;
  }
  var rgbParts = 3;
  var normalizedColor = color.replace(/\d+(\.\d+)?/g, (num, isFloat) => rgbParts-- && isFloat ? String(Math.round(parseFloat(num))) : num);
  return normalizedColor;
}
function findSelectorMatch(selector, regex) {
  var matches = regex.exec(selector);
  if (!matches) {
    return [selector, 0];
  }
  return [selector.replace(regex, " "), matches.length];
}
function getSelectorSpecificity(selector) {
  var specificity = [0, 0, 0];
  var currentSelector = selector.replace(/:not\(([^)]*)\)/g, "     $1 ").replace(/{[\s\S]*/gm, " ");
  var delta = 0;
  [currentSelector, delta] = findSelectorMatch(currentSelector, attributeRegex);
  specificity[1] += delta;
  [currentSelector, delta] = findSelectorMatch(currentSelector, idRegex);
  specificity[0] += delta;
  [currentSelector, delta] = findSelectorMatch(currentSelector, classRegex);
  specificity[1] += delta;
  [currentSelector, delta] = findSelectorMatch(currentSelector, pseudoElementRegex);
  specificity[2] += delta;
  [currentSelector, delta] = findSelectorMatch(currentSelector, pseudoClassWithBracketsRegex);
  specificity[1] += delta;
  [currentSelector, delta] = findSelectorMatch(currentSelector, pseudoClassRegex);
  specificity[1] += delta;
  currentSelector = currentSelector.replace(/[*\s+>~]/g, " ").replace(/[#.]/g, " ");
  [currentSelector, delta] = findSelectorMatch(currentSelector, elementRegex);
  specificity[2] += delta;
  return specificity.join("");
}
function vectorMagnitude(v2) {
  return Math.sqrt(Math.pow(v2[0], 2) + Math.pow(v2[1], 2));
}
function vectorsRatio(u2, v2) {
  return (u2[0] * v2[0] + u2[1] * v2[1]) / (vectorMagnitude(u2) * vectorMagnitude(v2));
}
function vectorsAngle(u2, v2) {
  return (u2[0] * v2[1] < u2[1] * v2[0] ? -1 : 1) * Math.acos(vectorsRatio(u2, v2));
}
function CB1(t2) {
  return t2 * t2 * t2;
}
function CB2(t2) {
  return 3 * t2 * t2 * (1 - t2);
}
function CB3(t2) {
  return 3 * t2 * (1 - t2) * (1 - t2);
}
function CB4(t2) {
  return (1 - t2) * (1 - t2) * (1 - t2);
}
function QB1(t2) {
  return t2 * t2;
}
function QB2(t2) {
  return 2 * t2 * (1 - t2);
}
function QB3(t2) {
  return (1 - t2) * (1 - t2);
}
function parseTransforms(transform2) {
  return compressSpaces(transform2).trim().replace(/\)([a-zA-Z])/g, ") $1").replace(/\)(\s?,\s?)/g, ") ").split(/\s(?=[a-z])/);
}
function parseTransform(transform2) {
  var [type, value] = transform2.split("(");
  return [type.trim(), value.trim().replace(")", "")];
}
function wrapFontFamily(fontFamily) {
  var trimmed = fontFamily.trim();
  return /^('|")/.test(trimmed) ? trimmed : '"'.concat(trimmed, '"');
}
function prepareFontFamily(fontFamily) {
  return typeof process === "undefined" ? fontFamily : fontFamily.trim().split(",").map(wrapFontFamily).join(",");
}
function prepareFontStyle(fontStyle) {
  if (!fontStyle) {
    return "";
  }
  var targetFontStyle = fontStyle.trim().toLowerCase();
  switch (targetFontStyle) {
    case "normal":
    case "italic":
    case "oblique":
    case "inherit":
    case "initial":
    case "unset":
      return targetFontStyle;
    default:
      if (/^oblique\s+(-|)\d+deg$/.test(targetFontStyle)) {
        return targetFontStyle;
      }
      return "";
  }
}
function prepareFontWeight(fontWeight) {
  if (!fontWeight) {
    return "";
  }
  var targetFontWeight = fontWeight.trim().toLowerCase();
  switch (targetFontWeight) {
    case "normal":
    case "bold":
    case "lighter":
    case "bolder":
    case "inherit":
    case "initial":
    case "unset":
      return targetFontWeight;
    default:
      if (/^[\d.]+$/.test(targetFontWeight)) {
        return targetFontWeight;
      }
      return "";
  }
}
function ownKeys$2(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols2 = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols2 = symbols2.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys.push.apply(keys, symbols2);
  }
  return keys;
}
function _objectSpread$2(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    if (i2 % 2) {
      ownKeys$2(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$2(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function imGet(img, x2, y3, width2, _height, rgba) {
  return img[y3 * width2 * 4 + x2 * 4 + rgba];
}
function imSet(img, x2, y3, width2, _height, rgba, val) {
  img[y3 * width2 * 4 + x2 * 4 + rgba] = val;
}
function m2(matrix, i2, v2) {
  var mi = matrix[i2];
  return mi * v2;
}
function c2(a2, m1, m22, m3) {
  return m1 + Math.cos(a2) * m22 + Math.sin(a2) * m3;
}
function ownKeys$1(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols2 = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols2 = symbols2.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys.push.apply(keys, symbols2);
  }
  return keys;
}
function _objectSpread$1(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    if (i2 % 2) {
      ownKeys$1(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$1(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function createCanvas(width2, height2) {
  var canvas = document.createElement("canvas");
  canvas.width = width2;
  canvas.height = height2;
  return canvas;
}
function createImage(_x) {
  return _createImage.apply(this, arguments);
}
function _createImage() {
  _createImage = _asyncToGenerator(function* (src) {
    var anonymousCrossOrigin = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    var image = document.createElement("img");
    if (anonymousCrossOrigin) {
      image.crossOrigin = "Anonymous";
    }
    return new Promise((resolve, reject) => {
      image.onload = () => {
        resolve(image);
      };
      image.onerror = (_event, _source, _lineno, _colno, error) => {
        reject(error);
      };
      image.src = src;
    });
  });
  return _createImage.apply(this, arguments);
}
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols2 = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols2 = symbols2.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys.push.apply(keys, symbols2);
  }
  return keys;
}
function _objectSpread(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    if (i2 % 2) {
      ownKeys(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
var import_es_promise, import_es_string_match, import_es_string_replace, import_es_string_starts_with, import_es_array_iterator, import_web_dom_collections_iterator, import_es_array_reduce, import_es_string_ends_with, import_es_string_split, import_raf, import_es_string_trim, import_rgbcolor, import_es_array_index_of, import_es_string_includes, import_es_array_reverse, import_es_regexp_to_string, index, allUppercase, attributeRegex, idRegex, classRegex, pseudoElementRegex, pseudoClassWithBracketsRegex, pseudoClassRegex, elementRegex, PSEUDO_ZERO, Property, ViewPort, Point2, Mouse, defaultWindow, defaultFetch$1, Screen, defaultFetch, DefaultDOMParser, Parser, Translate, Rotate, Scale, Matrix2, Skew, SkewX, SkewY, Transform, Element2, UnknownElement, Font, BoundingBox, PathParser, RenderedElement, PathElement, GlyphElement, TextElement, TSpanElement, TextNode, SVGElement, RectElement, CircleElement, EllipseElement, LineElement, PolylineElement, PolygonElement, PatternElement, MarkerElement, DefsElement, GElement, GradientElement, LinearGradientElement, RadialGradientElement, StopElement, AnimateElement, AnimateColorElement, AnimateTransformElement, FontElement, FontFaceElement, MissingGlyphElement, TRefElement, AElement, TextPathElement, dataUriRegex, ImageElement, SymbolElement, SVGFontLoader, StyleElement, UseElement, FeColorMatrixElement, MaskElement, noop2, ClipPathElement, FilterElement, FeDropShadowElement, FeMorphologyElement, FeCompositeElement, FeGaussianBlurElement, TitleElement, DescElement, elements2, Document, Canvg;
var init_index_es = __esm({
  "../simple-mind-map/node_modules/canvg/lib/index.es.js"() {
    import_es_promise = __toESM(require_es_promise(), 1);
    init_asyncToGenerator();
    import_es_string_match = __toESM(require_es_string_match(), 1);
    import_es_string_replace = __toESM(require_es_string_replace(), 1);
    import_es_string_starts_with = __toESM(require_es_string_starts_with(), 1);
    import_es_array_iterator = __toESM(require_es_array_iterator(), 1);
    import_web_dom_collections_iterator = __toESM(require_web_dom_collections_iterator(), 1);
    init_defineProperty();
    import_es_array_reduce = __toESM(require_es_array_reduce(), 1);
    import_es_string_ends_with = __toESM(require_es_string_ends_with(), 1);
    import_es_string_split = __toESM(require_es_string_split(), 1);
    import_raf = __toESM(require_raf(), 1);
    import_es_string_trim = __toESM(require_es_string_trim(), 1);
    import_rgbcolor = __toESM(require_rgbcolor(), 1);
    import_es_array_index_of = __toESM(require_es_array_index_of(), 1);
    import_es_string_includes = __toESM(require_es_string_includes(), 1);
    import_es_array_reverse = __toESM(require_es_array_reverse(), 1);
    init_SVGPathData_module();
    import_es_regexp_to_string = __toESM(require_es_regexp_to_string(), 1);
    init_stackblur_es();
    index = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      offscreen,
      node
    });
    allUppercase = /^[A-Z-]+$/;
    attributeRegex = /(\[[^\]]+\])/g;
    idRegex = /(#[^\s+>~.[:]+)/g;
    classRegex = /(\.[^\s+>~.[:]+)/g;
    pseudoElementRegex = /(::[^\s+>~.[:]+|:first-line|:first-letter|:before|:after)/gi;
    pseudoClassWithBracketsRegex = /(:[\w-]+\([^)]*\))/gi;
    pseudoClassRegex = /(:[^\s+>~.[:]+)/g;
    elementRegex = /([^\s+>~.[:]+)/g;
    PSEUDO_ZERO = 1e-8;
    Property = class {
      constructor(document4, name, value) {
        this.document = document4;
        this.name = name;
        this.value = value;
        this.isNormalizedColor = false;
      }
      static empty(document4) {
        return new Property(document4, "EMPTY", "");
      }
      split() {
        var separator = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : " ";
        var {
          document: document4,
          name
        } = this;
        return compressSpaces(this.getString()).trim().split(separator).map((value) => new Property(document4, name, value));
      }
      hasValue(zeroIsValue) {
        var {
          value
        } = this;
        return value !== null && value !== "" && (zeroIsValue || value !== 0) && typeof value !== "undefined";
      }
      isString(regexp) {
        var {
          value
        } = this;
        var result = typeof value === "string";
        if (!result || !regexp) {
          return result;
        }
        return regexp.test(value);
      }
      isUrlDefinition() {
        return this.isString(/^url\(/);
      }
      isPixels() {
        if (!this.hasValue()) {
          return false;
        }
        var asString = this.getString();
        switch (true) {
          case asString.endsWith("px"):
          case /^[0-9]+$/.test(asString):
            return true;
          default:
            return false;
        }
      }
      setValue(value) {
        this.value = value;
        return this;
      }
      getValue(def) {
        if (typeof def === "undefined" || this.hasValue()) {
          return this.value;
        }
        return def;
      }
      getNumber(def) {
        if (!this.hasValue()) {
          if (typeof def === "undefined") {
            return 0;
          }
          return parseFloat(def);
        }
        var {
          value
        } = this;
        var n2 = parseFloat(value);
        if (this.isString(/%$/)) {
          n2 /= 100;
        }
        return n2;
      }
      getString(def) {
        if (typeof def === "undefined" || this.hasValue()) {
          return typeof this.value === "undefined" ? "" : String(this.value);
        }
        return String(def);
      }
      getColor(def) {
        var color = this.getString(def);
        if (this.isNormalizedColor) {
          return color;
        }
        this.isNormalizedColor = true;
        color = normalizeColor(color);
        this.value = color;
        return color;
      }
      getDpi() {
        return 96;
      }
      getRem() {
        return this.document.rootEmSize;
      }
      getEm() {
        return this.document.emSize;
      }
      getUnits() {
        return this.getString().replace(/[0-9.-]/g, "");
      }
      getPixels(axisOrIsFontSize) {
        var processPercent = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        if (!this.hasValue()) {
          return 0;
        }
        var [axis, isFontSize] = typeof axisOrIsFontSize === "boolean" ? [void 0, axisOrIsFontSize] : [axisOrIsFontSize];
        var {
          viewPort
        } = this.document.screen;
        switch (true) {
          case this.isString(/vmin$/):
            return this.getNumber() / 100 * Math.min(viewPort.computeSize("x"), viewPort.computeSize("y"));
          case this.isString(/vmax$/):
            return this.getNumber() / 100 * Math.max(viewPort.computeSize("x"), viewPort.computeSize("y"));
          case this.isString(/vw$/):
            return this.getNumber() / 100 * viewPort.computeSize("x");
          case this.isString(/vh$/):
            return this.getNumber() / 100 * viewPort.computeSize("y");
          case this.isString(/rem$/):
            return this.getNumber() * this.getRem();
          case this.isString(/em$/):
            return this.getNumber() * this.getEm();
          case this.isString(/ex$/):
            return this.getNumber() * this.getEm() / 2;
          case this.isString(/px$/):
            return this.getNumber();
          case this.isString(/pt$/):
            return this.getNumber() * this.getDpi() * (1 / 72);
          case this.isString(/pc$/):
            return this.getNumber() * 15;
          case this.isString(/cm$/):
            return this.getNumber() * this.getDpi() / 2.54;
          case this.isString(/mm$/):
            return this.getNumber() * this.getDpi() / 25.4;
          case this.isString(/in$/):
            return this.getNumber() * this.getDpi();
          case (this.isString(/%$/) && isFontSize):
            return this.getNumber() * this.getEm();
          case this.isString(/%$/):
            return this.getNumber() * viewPort.computeSize(axis);
          default: {
            var n2 = this.getNumber();
            if (processPercent && n2 < 1) {
              return n2 * viewPort.computeSize(axis);
            }
            return n2;
          }
        }
      }
      getMilliseconds() {
        if (!this.hasValue()) {
          return 0;
        }
        if (this.isString(/ms$/)) {
          return this.getNumber();
        }
        return this.getNumber() * 1e3;
      }
      getRadians() {
        if (!this.hasValue()) {
          return 0;
        }
        switch (true) {
          case this.isString(/deg$/):
            return this.getNumber() * (Math.PI / 180);
          case this.isString(/grad$/):
            return this.getNumber() * (Math.PI / 200);
          case this.isString(/rad$/):
            return this.getNumber();
          default:
            return this.getNumber() * (Math.PI / 180);
        }
      }
      getDefinition() {
        var asString = this.getString();
        var name = /#([^)'"]+)/.exec(asString);
        if (name) {
          name = name[1];
        }
        if (!name) {
          name = asString;
        }
        return this.document.definitions[name];
      }
      getFillStyleDefinition(element2, opacity) {
        var def = this.getDefinition();
        if (!def) {
          return null;
        }
        if (typeof def.createGradient === "function") {
          return def.createGradient(this.document.ctx, element2, opacity);
        }
        if (typeof def.createPattern === "function") {
          if (def.getHrefAttribute().hasValue()) {
            var patternTransform = def.getAttribute("patternTransform");
            def = def.getHrefAttribute().getDefinition();
            if (patternTransform.hasValue()) {
              def.getAttribute("patternTransform", true).setValue(patternTransform.value);
            }
          }
          return def.createPattern(this.document.ctx, element2, opacity);
        }
        return null;
      }
      getTextBaseline() {
        if (!this.hasValue()) {
          return null;
        }
        return Property.textBaselineMapping[this.getString()];
      }
      addOpacity(opacity) {
        var value = this.getColor();
        var len = value.length;
        var commas = 0;
        for (var i2 = 0; i2 < len; i2++) {
          if (value[i2] === ",") {
            commas++;
          }
          if (commas === 3) {
            break;
          }
        }
        if (opacity.hasValue() && this.isString() && commas !== 3) {
          var color = new import_rgbcolor.default(value);
          if (color.ok) {
            color.alpha = opacity.getNumber();
            value = color.toRGBA();
          }
        }
        return new Property(this.document, this.name, value);
      }
    };
    Property.textBaselineMapping = {
      "baseline": "alphabetic",
      "before-edge": "top",
      "text-before-edge": "top",
      "middle": "middle",
      "central": "middle",
      "after-edge": "bottom",
      "text-after-edge": "bottom",
      "ideographic": "ideographic",
      "alphabetic": "alphabetic",
      "hanging": "hanging",
      "mathematical": "alphabetic"
    };
    ViewPort = class {
      constructor() {
        this.viewPorts = [];
      }
      clear() {
        this.viewPorts = [];
      }
      setCurrent(width2, height2) {
        this.viewPorts.push({
          width: width2,
          height: height2
        });
      }
      removeCurrent() {
        this.viewPorts.pop();
      }
      getCurrent() {
        var {
          viewPorts
        } = this;
        return viewPorts[viewPorts.length - 1];
      }
      get width() {
        return this.getCurrent().width;
      }
      get height() {
        return this.getCurrent().height;
      }
      computeSize(d) {
        if (typeof d === "number") {
          return d;
        }
        if (d === "x") {
          return this.width;
        }
        if (d === "y") {
          return this.height;
        }
        return Math.sqrt(Math.pow(this.width, 2) + Math.pow(this.height, 2)) / Math.sqrt(2);
      }
    };
    Point2 = class {
      constructor(x2, y3) {
        this.x = x2;
        this.y = y3;
      }
      static parse(point4) {
        var defaultValue = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
        var [x2 = defaultValue, y3 = defaultValue] = toNumbers(point4);
        return new Point2(x2, y3);
      }
      static parseScale(scale3) {
        var defaultValue = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
        var [x2 = defaultValue, y3 = x2] = toNumbers(scale3);
        return new Point2(x2, y3);
      }
      static parsePath(path2) {
        var points = toNumbers(path2);
        var len = points.length;
        var pathPoints = [];
        for (var i2 = 0; i2 < len; i2 += 2) {
          pathPoints.push(new Point2(points[i2], points[i2 + 1]));
        }
        return pathPoints;
      }
      angleTo(point4) {
        return Math.atan2(point4.y - this.y, point4.x - this.x);
      }
      applyTransform(transform2) {
        var {
          x: x2,
          y: y3
        } = this;
        var xp = x2 * transform2[0] + y3 * transform2[2] + transform2[4];
        var yp = x2 * transform2[1] + y3 * transform2[3] + transform2[5];
        this.x = xp;
        this.y = yp;
      }
    };
    Mouse = class {
      constructor(screen) {
        this.screen = screen;
        this.working = false;
        this.events = [];
        this.eventElements = [];
        this.onClick = this.onClick.bind(this);
        this.onMouseMove = this.onMouseMove.bind(this);
      }
      isWorking() {
        return this.working;
      }
      start() {
        if (this.working) {
          return;
        }
        var {
          screen,
          onClick,
          onMouseMove
        } = this;
        var canvas = screen.ctx.canvas;
        canvas.onclick = onClick;
        canvas.onmousemove = onMouseMove;
        this.working = true;
      }
      stop() {
        if (!this.working) {
          return;
        }
        var canvas = this.screen.ctx.canvas;
        this.working = false;
        canvas.onclick = null;
        canvas.onmousemove = null;
      }
      hasEvents() {
        return this.working && this.events.length > 0;
      }
      runEvents() {
        if (!this.working) {
          return;
        }
        var {
          screen: document4,
          events,
          eventElements
        } = this;
        var {
          style
        } = document4.ctx.canvas;
        if (style) {
          style.cursor = "";
        }
        events.forEach((_ref, i2) => {
          var {
            run
          } = _ref;
          var element2 = eventElements[i2];
          while (element2) {
            run(element2);
            element2 = element2.parent;
          }
        });
        this.events = [];
        this.eventElements = [];
      }
      checkPath(element2, ctx) {
        if (!this.working || !ctx) {
          return;
        }
        var {
          events,
          eventElements
        } = this;
        events.forEach((_ref2, i2) => {
          var {
            x: x2,
            y: y3
          } = _ref2;
          if (!eventElements[i2] && ctx.isPointInPath && ctx.isPointInPath(x2, y3)) {
            eventElements[i2] = element2;
          }
        });
      }
      checkBoundingBox(element2, boundingBox) {
        if (!this.working || !boundingBox) {
          return;
        }
        var {
          events,
          eventElements
        } = this;
        events.forEach((_ref3, i2) => {
          var {
            x: x2,
            y: y3
          } = _ref3;
          if (!eventElements[i2] && boundingBox.isPointInBox(x2, y3)) {
            eventElements[i2] = element2;
          }
        });
      }
      mapXY(x2, y3) {
        var {
          window: window2,
          ctx
        } = this.screen;
        var point4 = new Point2(x2, y3);
        var element2 = ctx.canvas;
        while (element2) {
          point4.x -= element2.offsetLeft;
          point4.y -= element2.offsetTop;
          element2 = element2.offsetParent;
        }
        if (window2.scrollX) {
          point4.x += window2.scrollX;
        }
        if (window2.scrollY) {
          point4.y += window2.scrollY;
        }
        return point4;
      }
      onClick(event) {
        var {
          x: x2,
          y: y3
        } = this.mapXY(event.clientX, event.clientY);
        this.events.push({
          type: "onclick",
          x: x2,
          y: y3,
          run(eventTarget) {
            if (eventTarget.onClick) {
              eventTarget.onClick();
            }
          }
        });
      }
      onMouseMove(event) {
        var {
          x: x2,
          y: y3
        } = this.mapXY(event.clientX, event.clientY);
        this.events.push({
          type: "onmousemove",
          x: x2,
          y: y3,
          run(eventTarget) {
            if (eventTarget.onMouseMove) {
              eventTarget.onMouseMove();
            }
          }
        });
      }
    };
    defaultWindow = typeof window !== "undefined" ? window : null;
    defaultFetch$1 = typeof fetch !== "undefined" ? fetch.bind(void 0) : null;
    Screen = class {
      constructor(ctx) {
        var {
          fetch: fetch2 = defaultFetch$1,
          window: window2 = defaultWindow
        } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        this.ctx = ctx;
        this.FRAMERATE = 30;
        this.MAX_VIRTUAL_PIXELS = 3e4;
        this.CLIENT_WIDTH = 800;
        this.CLIENT_HEIGHT = 600;
        this.viewPort = new ViewPort();
        this.mouse = new Mouse(this);
        this.animations = [];
        this.waits = [];
        this.frameDuration = 0;
        this.isReadyLock = false;
        this.isFirstRender = true;
        this.intervalId = null;
        this.window = window2;
        this.fetch = fetch2;
      }
      wait(checker) {
        this.waits.push(checker);
      }
      ready() {
        if (!this.readyPromise) {
          return Promise.resolve();
        }
        return this.readyPromise;
      }
      isReady() {
        if (this.isReadyLock) {
          return true;
        }
        var isReadyLock = this.waits.every((_2) => _2());
        if (isReadyLock) {
          this.waits = [];
          if (this.resolveReady) {
            this.resolveReady();
          }
        }
        this.isReadyLock = isReadyLock;
        return isReadyLock;
      }
      setDefaults(ctx) {
        ctx.strokeStyle = "rgba(0,0,0,0)";
        ctx.lineCap = "butt";
        ctx.lineJoin = "miter";
        ctx.miterLimit = 4;
      }
      setViewBox(_ref) {
        var {
          document: document4,
          ctx,
          aspectRatio,
          width: width2,
          desiredWidth,
          height: height2,
          desiredHeight,
          minX = 0,
          minY = 0,
          refX,
          refY,
          clip = false,
          clipX = 0,
          clipY = 0
        } = _ref;
        var cleanAspectRatio = compressSpaces(aspectRatio).replace(/^defer\s/, "");
        var [aspectRatioAlign, aspectRatioMeetOrSlice] = cleanAspectRatio.split(" ");
        var align = aspectRatioAlign || "xMidYMid";
        var meetOrSlice = aspectRatioMeetOrSlice || "meet";
        var scaleX = width2 / desiredWidth;
        var scaleY = height2 / desiredHeight;
        var scaleMin = Math.min(scaleX, scaleY);
        var scaleMax = Math.max(scaleX, scaleY);
        var finalDesiredWidth = desiredWidth;
        var finalDesiredHeight = desiredHeight;
        if (meetOrSlice === "meet") {
          finalDesiredWidth *= scaleMin;
          finalDesiredHeight *= scaleMin;
        }
        if (meetOrSlice === "slice") {
          finalDesiredWidth *= scaleMax;
          finalDesiredHeight *= scaleMax;
        }
        var refXProp = new Property(document4, "refX", refX);
        var refYProp = new Property(document4, "refY", refY);
        var hasRefs = refXProp.hasValue() && refYProp.hasValue();
        if (hasRefs) {
          ctx.translate(-scaleMin * refXProp.getPixels("x"), -scaleMin * refYProp.getPixels("y"));
        }
        if (clip) {
          var scaledClipX = scaleMin * clipX;
          var scaledClipY = scaleMin * clipY;
          ctx.beginPath();
          ctx.moveTo(scaledClipX, scaledClipY);
          ctx.lineTo(width2, scaledClipY);
          ctx.lineTo(width2, height2);
          ctx.lineTo(scaledClipX, height2);
          ctx.closePath();
          ctx.clip();
        }
        if (!hasRefs) {
          var isMeetMinY = meetOrSlice === "meet" && scaleMin === scaleY;
          var isSliceMaxY = meetOrSlice === "slice" && scaleMax === scaleY;
          var isMeetMinX = meetOrSlice === "meet" && scaleMin === scaleX;
          var isSliceMaxX = meetOrSlice === "slice" && scaleMax === scaleX;
          if (align.startsWith("xMid") && (isMeetMinY || isSliceMaxY)) {
            ctx.translate(width2 / 2 - finalDesiredWidth / 2, 0);
          }
          if (align.endsWith("YMid") && (isMeetMinX || isSliceMaxX)) {
            ctx.translate(0, height2 / 2 - finalDesiredHeight / 2);
          }
          if (align.startsWith("xMax") && (isMeetMinY || isSliceMaxY)) {
            ctx.translate(width2 - finalDesiredWidth, 0);
          }
          if (align.endsWith("YMax") && (isMeetMinX || isSliceMaxX)) {
            ctx.translate(0, height2 - finalDesiredHeight);
          }
        }
        switch (true) {
          case align === "none":
            ctx.scale(scaleX, scaleY);
            break;
          case meetOrSlice === "meet":
            ctx.scale(scaleMin, scaleMin);
            break;
          case meetOrSlice === "slice":
            ctx.scale(scaleMax, scaleMax);
            break;
        }
        ctx.translate(-minX, -minY);
      }
      start(element2) {
        var {
          enableRedraw = false,
          ignoreMouse = false,
          ignoreAnimation = false,
          ignoreDimensions = false,
          ignoreClear = false,
          forceRedraw,
          scaleWidth,
          scaleHeight,
          offsetX,
          offsetY
        } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        var {
          FRAMERATE,
          mouse
        } = this;
        var frameDuration = 1e3 / FRAMERATE;
        this.frameDuration = frameDuration;
        this.readyPromise = new Promise((resolve) => {
          this.resolveReady = resolve;
        });
        if (this.isReady()) {
          this.render(element2, ignoreDimensions, ignoreClear, scaleWidth, scaleHeight, offsetX, offsetY);
        }
        if (!enableRedraw) {
          return;
        }
        var now = Date.now();
        var then = now;
        var delta = 0;
        var tick = () => {
          now = Date.now();
          delta = now - then;
          if (delta >= frameDuration) {
            then = now - delta % frameDuration;
            if (this.shouldUpdate(ignoreAnimation, forceRedraw)) {
              this.render(element2, ignoreDimensions, ignoreClear, scaleWidth, scaleHeight, offsetX, offsetY);
              mouse.runEvents();
            }
          }
          this.intervalId = (0, import_raf.default)(tick);
        };
        if (!ignoreMouse) {
          mouse.start();
        }
        this.intervalId = (0, import_raf.default)(tick);
      }
      stop() {
        if (this.intervalId) {
          import_raf.default.cancel(this.intervalId);
          this.intervalId = null;
        }
        this.mouse.stop();
      }
      shouldUpdate(ignoreAnimation, forceRedraw) {
        if (!ignoreAnimation) {
          var {
            frameDuration
          } = this;
          var shouldUpdate = this.animations.reduce((shouldUpdate2, animation) => animation.update(frameDuration) || shouldUpdate2, false);
          if (shouldUpdate) {
            return true;
          }
        }
        if (typeof forceRedraw === "function" && forceRedraw()) {
          return true;
        }
        if (!this.isReadyLock && this.isReady()) {
          return true;
        }
        if (this.mouse.hasEvents()) {
          return true;
        }
        return false;
      }
      render(element2, ignoreDimensions, ignoreClear, scaleWidth, scaleHeight, offsetX, offsetY) {
        var {
          CLIENT_WIDTH,
          CLIENT_HEIGHT,
          viewPort,
          ctx,
          isFirstRender
        } = this;
        var canvas = ctx.canvas;
        viewPort.clear();
        if (canvas.width && canvas.height) {
          viewPort.setCurrent(canvas.width, canvas.height);
        } else {
          viewPort.setCurrent(CLIENT_WIDTH, CLIENT_HEIGHT);
        }
        var widthStyle = element2.getStyle("width");
        var heightStyle = element2.getStyle("height");
        if (!ignoreDimensions && (isFirstRender || typeof scaleWidth !== "number" && typeof scaleHeight !== "number")) {
          if (widthStyle.hasValue()) {
            canvas.width = widthStyle.getPixels("x");
            if (canvas.style) {
              canvas.style.width = "".concat(canvas.width, "px");
            }
          }
          if (heightStyle.hasValue()) {
            canvas.height = heightStyle.getPixels("y");
            if (canvas.style) {
              canvas.style.height = "".concat(canvas.height, "px");
            }
          }
        }
        var cWidth = canvas.clientWidth || canvas.width;
        var cHeight = canvas.clientHeight || canvas.height;
        if (ignoreDimensions && widthStyle.hasValue() && heightStyle.hasValue()) {
          cWidth = widthStyle.getPixels("x");
          cHeight = heightStyle.getPixels("y");
        }
        viewPort.setCurrent(cWidth, cHeight);
        if (typeof offsetX === "number") {
          element2.getAttribute("x", true).setValue(offsetX);
        }
        if (typeof offsetY === "number") {
          element2.getAttribute("y", true).setValue(offsetY);
        }
        if (typeof scaleWidth === "number" || typeof scaleHeight === "number") {
          var viewBox = toNumbers(element2.getAttribute("viewBox").getString());
          var xRatio = 0;
          var yRatio = 0;
          if (typeof scaleWidth === "number") {
            var _widthStyle = element2.getStyle("width");
            if (_widthStyle.hasValue()) {
              xRatio = _widthStyle.getPixels("x") / scaleWidth;
            } else if (!isNaN(viewBox[2])) {
              xRatio = viewBox[2] / scaleWidth;
            }
          }
          if (typeof scaleHeight === "number") {
            var _heightStyle = element2.getStyle("height");
            if (_heightStyle.hasValue()) {
              yRatio = _heightStyle.getPixels("y") / scaleHeight;
            } else if (!isNaN(viewBox[3])) {
              yRatio = viewBox[3] / scaleHeight;
            }
          }
          if (!xRatio) {
            xRatio = yRatio;
          }
          if (!yRatio) {
            yRatio = xRatio;
          }
          element2.getAttribute("width", true).setValue(scaleWidth);
          element2.getAttribute("height", true).setValue(scaleHeight);
          var transformStyle = element2.getStyle("transform", true, true);
          transformStyle.setValue("".concat(transformStyle.getString(), " scale(").concat(1 / xRatio, ", ").concat(1 / yRatio, ")"));
        }
        if (!ignoreClear) {
          ctx.clearRect(0, 0, cWidth, cHeight);
        }
        element2.render(ctx);
        if (isFirstRender) {
          this.isFirstRender = false;
        }
      }
    };
    Screen.defaultWindow = defaultWindow;
    Screen.defaultFetch = defaultFetch$1;
    ({
      defaultFetch
    } = Screen);
    DefaultDOMParser = typeof DOMParser !== "undefined" ? DOMParser : null;
    Parser = class {
      constructor() {
        var {
          fetch: fetch2 = defaultFetch,
          DOMParser: DOMParser2 = DefaultDOMParser
        } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        this.fetch = fetch2;
        this.DOMParser = DOMParser2;
      }
      parse(resource) {
        var _this = this;
        return _asyncToGenerator(function* () {
          if (resource.startsWith("<")) {
            return _this.parseFromString(resource);
          }
          return _this.load(resource);
        })();
      }
      parseFromString(xml) {
        var parser2 = new this.DOMParser();
        try {
          return this.checkDocument(parser2.parseFromString(xml, "image/svg+xml"));
        } catch (err) {
          return this.checkDocument(parser2.parseFromString(xml, "text/xml"));
        }
      }
      checkDocument(document4) {
        var parserError = document4.getElementsByTagName("parsererror")[0];
        if (parserError) {
          throw new Error(parserError.textContent);
        }
        return document4;
      }
      load(url) {
        var _this2 = this;
        return _asyncToGenerator(function* () {
          var response = yield _this2.fetch(url);
          var xml = yield response.text();
          return _this2.parseFromString(xml);
        })();
      }
    };
    Translate = class {
      constructor(_2, point4) {
        this.type = "translate";
        this.point = null;
        this.point = Point2.parse(point4);
      }
      apply(ctx) {
        var {
          x: x2,
          y: y3
        } = this.point;
        ctx.translate(x2 || 0, y3 || 0);
      }
      unapply(ctx) {
        var {
          x: x2,
          y: y3
        } = this.point;
        ctx.translate(-1 * x2 || 0, -1 * y3 || 0);
      }
      applyToPoint(point4) {
        var {
          x: x2,
          y: y3
        } = this.point;
        point4.applyTransform([1, 0, 0, 1, x2 || 0, y3 || 0]);
      }
    };
    Rotate = class {
      constructor(document4, rotate, transformOrigin) {
        this.type = "rotate";
        this.angle = null;
        this.originX = null;
        this.originY = null;
        this.cx = 0;
        this.cy = 0;
        var numbers = toNumbers(rotate);
        this.angle = new Property(document4, "angle", numbers[0]);
        this.originX = transformOrigin[0];
        this.originY = transformOrigin[1];
        this.cx = numbers[1] || 0;
        this.cy = numbers[2] || 0;
      }
      apply(ctx) {
        var {
          cx: cx2,
          cy: cy2,
          originX,
          originY,
          angle
        } = this;
        var tx = cx2 + originX.getPixels("x");
        var ty = cy2 + originY.getPixels("y");
        ctx.translate(tx, ty);
        ctx.rotate(angle.getRadians());
        ctx.translate(-tx, -ty);
      }
      unapply(ctx) {
        var {
          cx: cx2,
          cy: cy2,
          originX,
          originY,
          angle
        } = this;
        var tx = cx2 + originX.getPixels("x");
        var ty = cy2 + originY.getPixels("y");
        ctx.translate(tx, ty);
        ctx.rotate(-1 * angle.getRadians());
        ctx.translate(-tx, -ty);
      }
      applyToPoint(point4) {
        var {
          cx: cx2,
          cy: cy2,
          angle
        } = this;
        var rad = angle.getRadians();
        point4.applyTransform([
          1,
          0,
          0,
          1,
          cx2 || 0,
          cy2 || 0
          // this.p.y
        ]);
        point4.applyTransform([Math.cos(rad), Math.sin(rad), -Math.sin(rad), Math.cos(rad), 0, 0]);
        point4.applyTransform([
          1,
          0,
          0,
          1,
          -cx2 || 0,
          -cy2 || 0
          // -this.p.y
        ]);
      }
    };
    Scale = class {
      constructor(_2, scale3, transformOrigin) {
        this.type = "scale";
        this.scale = null;
        this.originX = null;
        this.originY = null;
        var scaleSize = Point2.parseScale(scale3);
        if (scaleSize.x === 0 || scaleSize.y === 0) {
          scaleSize.x = PSEUDO_ZERO;
          scaleSize.y = PSEUDO_ZERO;
        }
        this.scale = scaleSize;
        this.originX = transformOrigin[0];
        this.originY = transformOrigin[1];
      }
      apply(ctx) {
        var {
          scale: {
            x: x2,
            y: y3
          },
          originX,
          originY
        } = this;
        var tx = originX.getPixels("x");
        var ty = originY.getPixels("y");
        ctx.translate(tx, ty);
        ctx.scale(x2, y3 || x2);
        ctx.translate(-tx, -ty);
      }
      unapply(ctx) {
        var {
          scale: {
            x: x2,
            y: y3
          },
          originX,
          originY
        } = this;
        var tx = originX.getPixels("x");
        var ty = originY.getPixels("y");
        ctx.translate(tx, ty);
        ctx.scale(1 / x2, 1 / y3 || x2);
        ctx.translate(-tx, -ty);
      }
      applyToPoint(point4) {
        var {
          x: x2,
          y: y3
        } = this.scale;
        point4.applyTransform([x2 || 0, 0, 0, y3 || 0, 0, 0]);
      }
    };
    Matrix2 = class {
      constructor(_2, matrix, transformOrigin) {
        this.type = "matrix";
        this.matrix = [];
        this.originX = null;
        this.originY = null;
        this.matrix = toNumbers(matrix);
        this.originX = transformOrigin[0];
        this.originY = transformOrigin[1];
      }
      apply(ctx) {
        var {
          originX,
          originY,
          matrix
        } = this;
        var tx = originX.getPixels("x");
        var ty = originY.getPixels("y");
        ctx.translate(tx, ty);
        ctx.transform(matrix[0], matrix[1], matrix[2], matrix[3], matrix[4], matrix[5]);
        ctx.translate(-tx, -ty);
      }
      unapply(ctx) {
        var {
          originX,
          originY,
          matrix
        } = this;
        var a2 = matrix[0];
        var b = matrix[2];
        var c3 = matrix[4];
        var d = matrix[1];
        var e2 = matrix[3];
        var f3 = matrix[5];
        var g = 0;
        var h2 = 0;
        var i2 = 1;
        var det = 1 / (a2 * (e2 * i2 - f3 * h2) - b * (d * i2 - f3 * g) + c3 * (d * h2 - e2 * g));
        var tx = originX.getPixels("x");
        var ty = originY.getPixels("y");
        ctx.translate(tx, ty);
        ctx.transform(det * (e2 * i2 - f3 * h2), det * (f3 * g - d * i2), det * (c3 * h2 - b * i2), det * (a2 * i2 - c3 * g), det * (b * f3 - c3 * e2), det * (c3 * d - a2 * f3));
        ctx.translate(-tx, -ty);
      }
      applyToPoint(point4) {
        point4.applyTransform(this.matrix);
      }
    };
    Skew = class extends Matrix2 {
      constructor(document4, skew, transformOrigin) {
        super(document4, skew, transformOrigin);
        this.type = "skew";
        this.angle = null;
        this.angle = new Property(document4, "angle", skew);
      }
    };
    SkewX = class extends Skew {
      constructor(document4, skew, transformOrigin) {
        super(document4, skew, transformOrigin);
        this.type = "skewX";
        this.matrix = [1, 0, Math.tan(this.angle.getRadians()), 1, 0, 0];
      }
    };
    SkewY = class extends Skew {
      constructor(document4, skew, transformOrigin) {
        super(document4, skew, transformOrigin);
        this.type = "skewY";
        this.matrix = [1, Math.tan(this.angle.getRadians()), 0, 1, 0, 0];
      }
    };
    Transform = class {
      constructor(document4, transform2, transformOrigin) {
        this.document = document4;
        this.transforms = [];
        var data2 = parseTransforms(transform2);
        data2.forEach((transform3) => {
          if (transform3 === "none") {
            return;
          }
          var [type, value] = parseTransform(transform3);
          var TransformType = Transform.transformTypes[type];
          if (typeof TransformType !== "undefined") {
            this.transforms.push(new TransformType(this.document, value, transformOrigin));
          }
        });
      }
      static fromElement(document4, element2) {
        var transformStyle = element2.getStyle("transform", false, true);
        var [transformOriginXProperty, transformOriginYProperty = transformOriginXProperty] = element2.getStyle("transform-origin", false, true).split();
        var transformOrigin = [transformOriginXProperty, transformOriginYProperty];
        if (transformStyle.hasValue()) {
          return new Transform(document4, transformStyle.getString(), transformOrigin);
        }
        return null;
      }
      apply(ctx) {
        var {
          transforms: transforms2
        } = this;
        var len = transforms2.length;
        for (var i2 = 0; i2 < len; i2++) {
          transforms2[i2].apply(ctx);
        }
      }
      unapply(ctx) {
        var {
          transforms: transforms2
        } = this;
        var len = transforms2.length;
        for (var i2 = len - 1; i2 >= 0; i2--) {
          transforms2[i2].unapply(ctx);
        }
      }
      // TODO: applyToPoint unused ... remove?
      applyToPoint(point4) {
        var {
          transforms: transforms2
        } = this;
        var len = transforms2.length;
        for (var i2 = 0; i2 < len; i2++) {
          transforms2[i2].applyToPoint(point4);
        }
      }
    };
    Transform.transformTypes = {
      translate: Translate,
      rotate: Rotate,
      scale: Scale,
      matrix: Matrix2,
      skewX: SkewX,
      skewY: SkewY
    };
    Element2 = class {
      constructor(document4, node3) {
        var captureTextNodes = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
        this.document = document4;
        this.node = node3;
        this.captureTextNodes = captureTextNodes;
        this.attributes = {};
        this.styles = {};
        this.stylesSpecificity = {};
        this.animationFrozen = false;
        this.animationFrozenValue = "";
        this.parent = null;
        this.children = [];
        if (!node3 || node3.nodeType !== 1) {
          return;
        }
        Array.from(node3.attributes).forEach((attribute) => {
          var nodeName = normalizeAttributeName(attribute.nodeName);
          this.attributes[nodeName] = new Property(document4, nodeName, attribute.value);
        });
        this.addStylesFromStyleDefinition();
        if (this.getAttribute("style").hasValue()) {
          var styles2 = this.getAttribute("style").getString().split(";").map((_2) => _2.trim());
          styles2.forEach((style) => {
            if (!style) {
              return;
            }
            var [name, value] = style.split(":").map((_2) => _2.trim());
            this.styles[name] = new Property(document4, name, value);
          });
        }
        var {
          definitions
        } = document4;
        var id = this.getAttribute("id");
        if (id.hasValue()) {
          if (!definitions[id.getString()]) {
            definitions[id.getString()] = this;
          }
        }
        Array.from(node3.childNodes).forEach((childNode) => {
          if (childNode.nodeType === 1) {
            this.addChild(childNode);
          } else if (captureTextNodes && (childNode.nodeType === 3 || childNode.nodeType === 4)) {
            var textNode = document4.createTextNode(childNode);
            if (textNode.getText().length > 0) {
              this.addChild(textNode);
            }
          }
        });
      }
      getAttribute(name) {
        var createIfNotExists = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        var attr2 = this.attributes[name];
        if (!attr2 && createIfNotExists) {
          var _attr = new Property(this.document, name, "");
          this.attributes[name] = _attr;
          return _attr;
        }
        return attr2 || Property.empty(this.document);
      }
      getHrefAttribute() {
        for (var key in this.attributes) {
          if (key === "href" || key.endsWith(":href")) {
            return this.attributes[key];
          }
        }
        return Property.empty(this.document);
      }
      getStyle(name) {
        var createIfNotExists = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        var skipAncestors = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
        var style = this.styles[name];
        if (style) {
          return style;
        }
        var attr2 = this.getAttribute(name);
        if (attr2 !== null && attr2 !== void 0 && attr2.hasValue()) {
          this.styles[name] = attr2;
          return attr2;
        }
        if (!skipAncestors) {
          var {
            parent
          } = this;
          if (parent) {
            var parentStyle = parent.getStyle(name);
            if (parentStyle !== null && parentStyle !== void 0 && parentStyle.hasValue()) {
              return parentStyle;
            }
          }
        }
        if (createIfNotExists) {
          var _style = new Property(this.document, name, "");
          this.styles[name] = _style;
          return _style;
        }
        return style || Property.empty(this.document);
      }
      render(ctx) {
        if (this.getStyle("display").getString() === "none" || this.getStyle("visibility").getString() === "hidden") {
          return;
        }
        ctx.save();
        if (this.getStyle("mask").hasValue()) {
          var mask = this.getStyle("mask").getDefinition();
          if (mask) {
            this.applyEffects(ctx);
            mask.apply(ctx, this);
          }
        } else if (this.getStyle("filter").getValue("none") !== "none") {
          var filter2 = this.getStyle("filter").getDefinition();
          if (filter2) {
            this.applyEffects(ctx);
            filter2.apply(ctx, this);
          }
        } else {
          this.setContext(ctx);
          this.renderChildren(ctx);
          this.clearContext(ctx);
        }
        ctx.restore();
      }
      setContext(_2) {
      }
      applyEffects(ctx) {
        var transform2 = Transform.fromElement(this.document, this);
        if (transform2) {
          transform2.apply(ctx);
        }
        var clipPathStyleProp = this.getStyle("clip-path", false, true);
        if (clipPathStyleProp.hasValue()) {
          var clip = clipPathStyleProp.getDefinition();
          if (clip) {
            clip.apply(ctx);
          }
        }
      }
      clearContext(_2) {
      }
      renderChildren(ctx) {
        this.children.forEach((child) => {
          child.render(ctx);
        });
      }
      addChild(childNode) {
        var child = childNode instanceof Element2 ? childNode : this.document.createElement(childNode);
        child.parent = this;
        if (!Element2.ignoreChildTypes.includes(child.type)) {
          this.children.push(child);
        }
      }
      matchesSelector(selector) {
        var _node$getAttribute;
        var {
          node: node3
        } = this;
        if (typeof node3.matches === "function") {
          return node3.matches(selector);
        }
        var styleClasses = (_node$getAttribute = node3.getAttribute) === null || _node$getAttribute === void 0 ? void 0 : _node$getAttribute.call(node3, "class");
        if (!styleClasses || styleClasses === "") {
          return false;
        }
        return styleClasses.split(" ").some((styleClass) => ".".concat(styleClass) === selector);
      }
      addStylesFromStyleDefinition() {
        var {
          styles: styles2,
          stylesSpecificity
        } = this.document;
        for (var selector in styles2) {
          if (!selector.startsWith("@") && this.matchesSelector(selector)) {
            var style = styles2[selector];
            var specificity = stylesSpecificity[selector];
            if (style) {
              for (var name in style) {
                var existingSpecificity = this.stylesSpecificity[name];
                if (typeof existingSpecificity === "undefined") {
                  existingSpecificity = "000";
                }
                if (specificity >= existingSpecificity) {
                  this.styles[name] = style[name];
                  this.stylesSpecificity[name] = specificity;
                }
              }
            }
          }
        }
      }
      removeStyles(element2, ignoreStyles) {
        var toRestore = ignoreStyles.reduce((toRestore2, name) => {
          var styleProp = element2.getStyle(name);
          if (!styleProp.hasValue()) {
            return toRestore2;
          }
          var value = styleProp.getString();
          styleProp.setValue("");
          return [...toRestore2, [name, value]];
        }, []);
        return toRestore;
      }
      restoreStyles(element2, styles2) {
        styles2.forEach((_ref) => {
          var [name, value] = _ref;
          element2.getStyle(name, true).setValue(value);
        });
      }
      isFirstChild() {
        var _this$parent;
        return ((_this$parent = this.parent) === null || _this$parent === void 0 ? void 0 : _this$parent.children.indexOf(this)) === 0;
      }
    };
    Element2.ignoreChildTypes = ["title"];
    UnknownElement = class extends Element2 {
      constructor(document4, node3, captureTextNodes) {
        super(document4, node3, captureTextNodes);
      }
    };
    Font = class {
      constructor(fontStyle, fontVariant, fontWeight, fontSize, fontFamily, inherit3) {
        var inheritFont = inherit3 ? typeof inherit3 === "string" ? Font.parse(inherit3) : inherit3 : {};
        this.fontFamily = fontFamily || inheritFont.fontFamily;
        this.fontSize = fontSize || inheritFont.fontSize;
        this.fontStyle = fontStyle || inheritFont.fontStyle;
        this.fontWeight = fontWeight || inheritFont.fontWeight;
        this.fontVariant = fontVariant || inheritFont.fontVariant;
      }
      static parse() {
        var font = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
        var inherit3 = arguments.length > 1 ? arguments[1] : void 0;
        var fontStyle = "";
        var fontVariant = "";
        var fontWeight = "";
        var fontSize = "";
        var fontFamily = "";
        var parts = compressSpaces(font).trim().split(" ");
        var set = {
          fontSize: false,
          fontStyle: false,
          fontWeight: false,
          fontVariant: false
        };
        parts.forEach((part) => {
          switch (true) {
            case (!set.fontStyle && Font.styles.includes(part)):
              if (part !== "inherit") {
                fontStyle = part;
              }
              set.fontStyle = true;
              break;
            case (!set.fontVariant && Font.variants.includes(part)):
              if (part !== "inherit") {
                fontVariant = part;
              }
              set.fontStyle = true;
              set.fontVariant = true;
              break;
            case (!set.fontWeight && Font.weights.includes(part)):
              if (part !== "inherit") {
                fontWeight = part;
              }
              set.fontStyle = true;
              set.fontVariant = true;
              set.fontWeight = true;
              break;
            case !set.fontSize:
              if (part !== "inherit") {
                [fontSize] = part.split("/");
              }
              set.fontStyle = true;
              set.fontVariant = true;
              set.fontWeight = true;
              set.fontSize = true;
              break;
            default:
              if (part !== "inherit") {
                fontFamily += part;
              }
          }
        });
        return new Font(fontStyle, fontVariant, fontWeight, fontSize, fontFamily, inherit3);
      }
      toString() {
        return [
          prepareFontStyle(this.fontStyle),
          this.fontVariant,
          prepareFontWeight(this.fontWeight),
          this.fontSize,
          // Wrap fontFamily only on nodejs and only for canvas.ctx
          prepareFontFamily(this.fontFamily)
        ].join(" ").trim();
      }
    };
    Font.styles = "normal|italic|oblique|inherit";
    Font.variants = "normal|small-caps|inherit";
    Font.weights = "normal|bold|bolder|lighter|100|200|300|400|500|600|700|800|900|inherit";
    BoundingBox = class {
      constructor() {
        var x1 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : Number.NaN;
        var y1 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Number.NaN;
        var x2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Number.NaN;
        var y22 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : Number.NaN;
        this.x1 = x1;
        this.y1 = y1;
        this.x2 = x2;
        this.y2 = y22;
        this.addPoint(x1, y1);
        this.addPoint(x2, y22);
      }
      get x() {
        return this.x1;
      }
      get y() {
        return this.y1;
      }
      get width() {
        return this.x2 - this.x1;
      }
      get height() {
        return this.y2 - this.y1;
      }
      addPoint(x2, y3) {
        if (typeof x2 !== "undefined") {
          if (isNaN(this.x1) || isNaN(this.x2)) {
            this.x1 = x2;
            this.x2 = x2;
          }
          if (x2 < this.x1) {
            this.x1 = x2;
          }
          if (x2 > this.x2) {
            this.x2 = x2;
          }
        }
        if (typeof y3 !== "undefined") {
          if (isNaN(this.y1) || isNaN(this.y2)) {
            this.y1 = y3;
            this.y2 = y3;
          }
          if (y3 < this.y1) {
            this.y1 = y3;
          }
          if (y3 > this.y2) {
            this.y2 = y3;
          }
        }
      }
      addX(x2) {
        this.addPoint(x2, null);
      }
      addY(y3) {
        this.addPoint(null, y3);
      }
      addBoundingBox(boundingBox) {
        if (!boundingBox) {
          return;
        }
        var {
          x1,
          y1,
          x2,
          y2: y22
        } = boundingBox;
        this.addPoint(x1, y1);
        this.addPoint(x2, y22);
      }
      sumCubic(t2, p0, p1, p2, p3) {
        return Math.pow(1 - t2, 3) * p0 + 3 * Math.pow(1 - t2, 2) * t2 * p1 + 3 * (1 - t2) * Math.pow(t2, 2) * p2 + Math.pow(t2, 3) * p3;
      }
      bezierCurveAdd(forX, p0, p1, p2, p3) {
        var b = 6 * p0 - 12 * p1 + 6 * p2;
        var a2 = -3 * p0 + 9 * p1 - 9 * p2 + 3 * p3;
        var c3 = 3 * p1 - 3 * p0;
        if (a2 === 0) {
          if (b === 0) {
            return;
          }
          var t2 = -c3 / b;
          if (0 < t2 && t2 < 1) {
            if (forX) {
              this.addX(this.sumCubic(t2, p0, p1, p2, p3));
            } else {
              this.addY(this.sumCubic(t2, p0, p1, p2, p3));
            }
          }
          return;
        }
        var b2ac = Math.pow(b, 2) - 4 * c3 * a2;
        if (b2ac < 0) {
          return;
        }
        var t1 = (-b + Math.sqrt(b2ac)) / (2 * a2);
        if (0 < t1 && t1 < 1) {
          if (forX) {
            this.addX(this.sumCubic(t1, p0, p1, p2, p3));
          } else {
            this.addY(this.sumCubic(t1, p0, p1, p2, p3));
          }
        }
        var t22 = (-b - Math.sqrt(b2ac)) / (2 * a2);
        if (0 < t22 && t22 < 1) {
          if (forX) {
            this.addX(this.sumCubic(t22, p0, p1, p2, p3));
          } else {
            this.addY(this.sumCubic(t22, p0, p1, p2, p3));
          }
        }
      }
      // from http://blog.hackers-cafe.net/2009/06/how-to-calculate-bezier-curves-bounding.html
      addBezierCurve(p0x, p0y, p1x, p1y, p2x, p2y, p3x, p3y) {
        this.addPoint(p0x, p0y);
        this.addPoint(p3x, p3y);
        this.bezierCurveAdd(true, p0x, p1x, p2x, p3x);
        this.bezierCurveAdd(false, p0y, p1y, p2y, p3y);
      }
      addQuadraticCurve(p0x, p0y, p1x, p1y, p2x, p2y) {
        var cp1x = p0x + 2 / 3 * (p1x - p0x);
        var cp1y = p0y + 2 / 3 * (p1y - p0y);
        var cp2x = cp1x + 1 / 3 * (p2x - p0x);
        var cp2y = cp1y + 1 / 3 * (p2y - p0y);
        this.addBezierCurve(p0x, p0y, cp1x, cp2x, cp1y, cp2y, p2x, p2y);
      }
      isPointInBox(x2, y3) {
        var {
          x1,
          y1,
          x2: x22,
          y2: y22
        } = this;
        return x1 <= x2 && x2 <= x22 && y1 <= y3 && y3 <= y22;
      }
    };
    PathParser = class extends _ {
      constructor(path2) {
        super(path2.replace(/([+\-.])\s+/gm, "$1").replace(/[^MmZzLlHhVvCcSsQqTtAae\d\s.,+-].*/g, ""));
        this.control = null;
        this.start = null;
        this.current = null;
        this.command = null;
        this.commands = this.commands;
        this.i = -1;
        this.previousCommand = null;
        this.points = [];
        this.angles = [];
      }
      reset() {
        this.i = -1;
        this.command = null;
        this.previousCommand = null;
        this.start = new Point2(0, 0);
        this.control = new Point2(0, 0);
        this.current = new Point2(0, 0);
        this.points = [];
        this.angles = [];
      }
      isEnd() {
        var {
          i: i2,
          commands
        } = this;
        return i2 >= commands.length - 1;
      }
      next() {
        var command = this.commands[++this.i];
        this.previousCommand = this.command;
        this.command = command;
        return command;
      }
      getPoint() {
        var xProp = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "x";
        var yProp = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "y";
        var point4 = new Point2(this.command[xProp], this.command[yProp]);
        return this.makeAbsolute(point4);
      }
      getAsControlPoint(xProp, yProp) {
        var point4 = this.getPoint(xProp, yProp);
        this.control = point4;
        return point4;
      }
      getAsCurrentPoint(xProp, yProp) {
        var point4 = this.getPoint(xProp, yProp);
        this.current = point4;
        return point4;
      }
      getReflectedControlPoint() {
        var previousCommand = this.previousCommand.type;
        if (previousCommand !== _.CURVE_TO && previousCommand !== _.SMOOTH_CURVE_TO && previousCommand !== _.QUAD_TO && previousCommand !== _.SMOOTH_QUAD_TO) {
          return this.current;
        }
        var {
          current: {
            x: cx2,
            y: cy2
          },
          control: {
            x: ox,
            y: oy
          }
        } = this;
        var point4 = new Point2(2 * cx2 - ox, 2 * cy2 - oy);
        return point4;
      }
      makeAbsolute(point4) {
        if (this.command.relative) {
          var {
            x: x2,
            y: y3
          } = this.current;
          point4.x += x2;
          point4.y += y3;
        }
        return point4;
      }
      addMarker(point4, from2, priorTo) {
        var {
          points,
          angles
        } = this;
        if (priorTo && angles.length > 0 && !angles[angles.length - 1]) {
          angles[angles.length - 1] = points[points.length - 1].angleTo(priorTo);
        }
        this.addMarkerAngle(point4, from2 ? from2.angleTo(point4) : null);
      }
      addMarkerAngle(point4, angle) {
        this.points.push(point4);
        this.angles.push(angle);
      }
      getMarkerPoints() {
        return this.points;
      }
      getMarkerAngles() {
        var {
          angles
        } = this;
        var len = angles.length;
        for (var i2 = 0; i2 < len; i2++) {
          if (!angles[i2]) {
            for (var j = i2 + 1; j < len; j++) {
              if (angles[j]) {
                angles[i2] = angles[j];
                break;
              }
            }
          }
        }
        return angles;
      }
    };
    RenderedElement = class extends Element2 {
      constructor() {
        super(...arguments);
        this.modifiedEmSizeStack = false;
      }
      calculateOpacity() {
        var opacity = 1;
        var element2 = this;
        while (element2) {
          var opacityStyle = element2.getStyle("opacity", false, true);
          if (opacityStyle.hasValue(true)) {
            opacity *= opacityStyle.getNumber();
          }
          element2 = element2.parent;
        }
        return opacity;
      }
      setContext(ctx) {
        var fromMeasure = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        if (!fromMeasure) {
          var fillStyleProp = this.getStyle("fill");
          var fillOpacityStyleProp = this.getStyle("fill-opacity");
          var strokeStyleProp = this.getStyle("stroke");
          var strokeOpacityProp = this.getStyle("stroke-opacity");
          if (fillStyleProp.isUrlDefinition()) {
            var fillStyle = fillStyleProp.getFillStyleDefinition(this, fillOpacityStyleProp);
            if (fillStyle) {
              ctx.fillStyle = fillStyle;
            }
          } else if (fillStyleProp.hasValue()) {
            if (fillStyleProp.getString() === "currentColor") {
              fillStyleProp.setValue(this.getStyle("color").getColor());
            }
            var _fillStyle = fillStyleProp.getColor();
            if (_fillStyle !== "inherit") {
              ctx.fillStyle = _fillStyle === "none" ? "rgba(0,0,0,0)" : _fillStyle;
            }
          }
          if (fillOpacityStyleProp.hasValue()) {
            var _fillStyle2 = new Property(this.document, "fill", ctx.fillStyle).addOpacity(fillOpacityStyleProp).getColor();
            ctx.fillStyle = _fillStyle2;
          }
          if (strokeStyleProp.isUrlDefinition()) {
            var strokeStyle = strokeStyleProp.getFillStyleDefinition(this, strokeOpacityProp);
            if (strokeStyle) {
              ctx.strokeStyle = strokeStyle;
            }
          } else if (strokeStyleProp.hasValue()) {
            if (strokeStyleProp.getString() === "currentColor") {
              strokeStyleProp.setValue(this.getStyle("color").getColor());
            }
            var _strokeStyle = strokeStyleProp.getString();
            if (_strokeStyle !== "inherit") {
              ctx.strokeStyle = _strokeStyle === "none" ? "rgba(0,0,0,0)" : _strokeStyle;
            }
          }
          if (strokeOpacityProp.hasValue()) {
            var _strokeStyle2 = new Property(this.document, "stroke", ctx.strokeStyle).addOpacity(strokeOpacityProp).getString();
            ctx.strokeStyle = _strokeStyle2;
          }
          var strokeWidthStyleProp = this.getStyle("stroke-width");
          if (strokeWidthStyleProp.hasValue()) {
            var newLineWidth = strokeWidthStyleProp.getPixels();
            ctx.lineWidth = !newLineWidth ? PSEUDO_ZERO : newLineWidth;
          }
          var strokeLinecapStyleProp = this.getStyle("stroke-linecap");
          var strokeLinejoinStyleProp = this.getStyle("stroke-linejoin");
          var strokeMiterlimitProp = this.getStyle("stroke-miterlimit");
          var strokeDasharrayStyleProp = this.getStyle("stroke-dasharray");
          var strokeDashoffsetProp = this.getStyle("stroke-dashoffset");
          if (strokeLinecapStyleProp.hasValue()) {
            ctx.lineCap = strokeLinecapStyleProp.getString();
          }
          if (strokeLinejoinStyleProp.hasValue()) {
            ctx.lineJoin = strokeLinejoinStyleProp.getString();
          }
          if (strokeMiterlimitProp.hasValue()) {
            ctx.miterLimit = strokeMiterlimitProp.getNumber();
          }
          if (strokeDasharrayStyleProp.hasValue() && strokeDasharrayStyleProp.getString() !== "none") {
            var gaps = toNumbers(strokeDasharrayStyleProp.getString());
            if (typeof ctx.setLineDash !== "undefined") {
              ctx.setLineDash(gaps);
            } else if (typeof ctx.webkitLineDash !== "undefined") {
              ctx.webkitLineDash = gaps;
            } else if (typeof ctx.mozDash !== "undefined" && !(gaps.length === 1 && gaps[0] === 0)) {
              ctx.mozDash = gaps;
            }
            var offset = strokeDashoffsetProp.getPixels();
            if (typeof ctx.lineDashOffset !== "undefined") {
              ctx.lineDashOffset = offset;
            } else if (typeof ctx.webkitLineDashOffset !== "undefined") {
              ctx.webkitLineDashOffset = offset;
            } else if (typeof ctx.mozDashOffset !== "undefined") {
              ctx.mozDashOffset = offset;
            }
          }
        }
        this.modifiedEmSizeStack = false;
        if (typeof ctx.font !== "undefined") {
          var fontStyleProp = this.getStyle("font");
          var fontStyleStyleProp = this.getStyle("font-style");
          var fontVariantStyleProp = this.getStyle("font-variant");
          var fontWeightStyleProp = this.getStyle("font-weight");
          var fontSizeStyleProp = this.getStyle("font-size");
          var fontFamilyStyleProp = this.getStyle("font-family");
          var font = new Font(fontStyleStyleProp.getString(), fontVariantStyleProp.getString(), fontWeightStyleProp.getString(), fontSizeStyleProp.hasValue() ? "".concat(fontSizeStyleProp.getPixels(true), "px") : "", fontFamilyStyleProp.getString(), Font.parse(fontStyleProp.getString(), ctx.font));
          fontStyleStyleProp.setValue(font.fontStyle);
          fontVariantStyleProp.setValue(font.fontVariant);
          fontWeightStyleProp.setValue(font.fontWeight);
          fontSizeStyleProp.setValue(font.fontSize);
          fontFamilyStyleProp.setValue(font.fontFamily);
          ctx.font = font.toString();
          if (fontSizeStyleProp.isPixels()) {
            this.document.emSize = fontSizeStyleProp.getPixels();
            this.modifiedEmSizeStack = true;
          }
        }
        if (!fromMeasure) {
          this.applyEffects(ctx);
          ctx.globalAlpha = this.calculateOpacity();
        }
      }
      clearContext(ctx) {
        super.clearContext(ctx);
        if (this.modifiedEmSizeStack) {
          this.document.popEmSize();
        }
      }
    };
    PathElement = class extends RenderedElement {
      constructor(document4, node3, captureTextNodes) {
        super(document4, node3, captureTextNodes);
        this.type = "path";
        this.pathParser = null;
        this.pathParser = new PathParser(this.getAttribute("d").getString());
      }
      path(ctx) {
        var {
          pathParser: pathParser2
        } = this;
        var boundingBox = new BoundingBox();
        pathParser2.reset();
        if (ctx) {
          ctx.beginPath();
        }
        while (!pathParser2.isEnd()) {
          switch (pathParser2.next().type) {
            case PathParser.MOVE_TO:
              this.pathM(ctx, boundingBox);
              break;
            case PathParser.LINE_TO:
              this.pathL(ctx, boundingBox);
              break;
            case PathParser.HORIZ_LINE_TO:
              this.pathH(ctx, boundingBox);
              break;
            case PathParser.VERT_LINE_TO:
              this.pathV(ctx, boundingBox);
              break;
            case PathParser.CURVE_TO:
              this.pathC(ctx, boundingBox);
              break;
            case PathParser.SMOOTH_CURVE_TO:
              this.pathS(ctx, boundingBox);
              break;
            case PathParser.QUAD_TO:
              this.pathQ(ctx, boundingBox);
              break;
            case PathParser.SMOOTH_QUAD_TO:
              this.pathT(ctx, boundingBox);
              break;
            case PathParser.ARC:
              this.pathA(ctx, boundingBox);
              break;
            case PathParser.CLOSE_PATH:
              this.pathZ(ctx, boundingBox);
              break;
          }
        }
        return boundingBox;
      }
      getBoundingBox(_2) {
        return this.path();
      }
      getMarkers() {
        var {
          pathParser: pathParser2
        } = this;
        var points = pathParser2.getMarkerPoints();
        var angles = pathParser2.getMarkerAngles();
        var markers = points.map((point4, i2) => [point4, angles[i2]]);
        return markers;
      }
      renderChildren(ctx) {
        this.path(ctx);
        this.document.screen.mouse.checkPath(this, ctx);
        var fillRuleStyleProp = this.getStyle("fill-rule");
        if (ctx.fillStyle !== "") {
          if (fillRuleStyleProp.getString("inherit") !== "inherit") {
            ctx.fill(fillRuleStyleProp.getString());
          } else {
            ctx.fill();
          }
        }
        if (ctx.strokeStyle !== "") {
          if (this.getAttribute("vector-effect").getString() === "non-scaling-stroke") {
            ctx.save();
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.stroke();
            ctx.restore();
          } else {
            ctx.stroke();
          }
        }
        var markers = this.getMarkers();
        if (markers) {
          var markersLastIndex = markers.length - 1;
          var markerStartStyleProp = this.getStyle("marker-start");
          var markerMidStyleProp = this.getStyle("marker-mid");
          var markerEndStyleProp = this.getStyle("marker-end");
          if (markerStartStyleProp.isUrlDefinition()) {
            var marker = markerStartStyleProp.getDefinition();
            var [point4, angle] = markers[0];
            marker.render(ctx, point4, angle);
          }
          if (markerMidStyleProp.isUrlDefinition()) {
            var _marker = markerMidStyleProp.getDefinition();
            for (var i2 = 1; i2 < markersLastIndex; i2++) {
              var [_point, _angle] = markers[i2];
              _marker.render(ctx, _point, _angle);
            }
          }
          if (markerEndStyleProp.isUrlDefinition()) {
            var _marker2 = markerEndStyleProp.getDefinition();
            var [_point2, _angle2] = markers[markersLastIndex];
            _marker2.render(ctx, _point2, _angle2);
          }
        }
      }
      static pathM(pathParser2) {
        var point4 = pathParser2.getAsCurrentPoint();
        pathParser2.start = pathParser2.current;
        return {
          point: point4
        };
      }
      pathM(ctx, boundingBox) {
        var {
          pathParser: pathParser2
        } = this;
        var {
          point: point4
        } = PathElement.pathM(pathParser2);
        var {
          x: x2,
          y: y3
        } = point4;
        pathParser2.addMarker(point4);
        boundingBox.addPoint(x2, y3);
        if (ctx) {
          ctx.moveTo(x2, y3);
        }
      }
      static pathL(pathParser2) {
        var {
          current
        } = pathParser2;
        var point4 = pathParser2.getAsCurrentPoint();
        return {
          current,
          point: point4
        };
      }
      pathL(ctx, boundingBox) {
        var {
          pathParser: pathParser2
        } = this;
        var {
          current,
          point: point4
        } = PathElement.pathL(pathParser2);
        var {
          x: x2,
          y: y3
        } = point4;
        pathParser2.addMarker(point4, current);
        boundingBox.addPoint(x2, y3);
        if (ctx) {
          ctx.lineTo(x2, y3);
        }
      }
      static pathH(pathParser2) {
        var {
          current,
          command
        } = pathParser2;
        var point4 = new Point2((command.relative ? current.x : 0) + command.x, current.y);
        pathParser2.current = point4;
        return {
          current,
          point: point4
        };
      }
      pathH(ctx, boundingBox) {
        var {
          pathParser: pathParser2
        } = this;
        var {
          current,
          point: point4
        } = PathElement.pathH(pathParser2);
        var {
          x: x2,
          y: y3
        } = point4;
        pathParser2.addMarker(point4, current);
        boundingBox.addPoint(x2, y3);
        if (ctx) {
          ctx.lineTo(x2, y3);
        }
      }
      static pathV(pathParser2) {
        var {
          current,
          command
        } = pathParser2;
        var point4 = new Point2(current.x, (command.relative ? current.y : 0) + command.y);
        pathParser2.current = point4;
        return {
          current,
          point: point4
        };
      }
      pathV(ctx, boundingBox) {
        var {
          pathParser: pathParser2
        } = this;
        var {
          current,
          point: point4
        } = PathElement.pathV(pathParser2);
        var {
          x: x2,
          y: y3
        } = point4;
        pathParser2.addMarker(point4, current);
        boundingBox.addPoint(x2, y3);
        if (ctx) {
          ctx.lineTo(x2, y3);
        }
      }
      static pathC(pathParser2) {
        var {
          current
        } = pathParser2;
        var point4 = pathParser2.getPoint("x1", "y1");
        var controlPoint = pathParser2.getAsControlPoint("x2", "y2");
        var currentPoint = pathParser2.getAsCurrentPoint();
        return {
          current,
          point: point4,
          controlPoint,
          currentPoint
        };
      }
      pathC(ctx, boundingBox) {
        var {
          pathParser: pathParser2
        } = this;
        var {
          current,
          point: point4,
          controlPoint,
          currentPoint
        } = PathElement.pathC(pathParser2);
        pathParser2.addMarker(currentPoint, controlPoint, point4);
        boundingBox.addBezierCurve(current.x, current.y, point4.x, point4.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);
        if (ctx) {
          ctx.bezierCurveTo(point4.x, point4.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);
        }
      }
      static pathS(pathParser2) {
        var {
          current
        } = pathParser2;
        var point4 = pathParser2.getReflectedControlPoint();
        var controlPoint = pathParser2.getAsControlPoint("x2", "y2");
        var currentPoint = pathParser2.getAsCurrentPoint();
        return {
          current,
          point: point4,
          controlPoint,
          currentPoint
        };
      }
      pathS(ctx, boundingBox) {
        var {
          pathParser: pathParser2
        } = this;
        var {
          current,
          point: point4,
          controlPoint,
          currentPoint
        } = PathElement.pathS(pathParser2);
        pathParser2.addMarker(currentPoint, controlPoint, point4);
        boundingBox.addBezierCurve(current.x, current.y, point4.x, point4.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);
        if (ctx) {
          ctx.bezierCurveTo(point4.x, point4.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);
        }
      }
      static pathQ(pathParser2) {
        var {
          current
        } = pathParser2;
        var controlPoint = pathParser2.getAsControlPoint("x1", "y1");
        var currentPoint = pathParser2.getAsCurrentPoint();
        return {
          current,
          controlPoint,
          currentPoint
        };
      }
      pathQ(ctx, boundingBox) {
        var {
          pathParser: pathParser2
        } = this;
        var {
          current,
          controlPoint,
          currentPoint
        } = PathElement.pathQ(pathParser2);
        pathParser2.addMarker(currentPoint, controlPoint, controlPoint);
        boundingBox.addQuadraticCurve(current.x, current.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);
        if (ctx) {
          ctx.quadraticCurveTo(controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);
        }
      }
      static pathT(pathParser2) {
        var {
          current
        } = pathParser2;
        var controlPoint = pathParser2.getReflectedControlPoint();
        pathParser2.control = controlPoint;
        var currentPoint = pathParser2.getAsCurrentPoint();
        return {
          current,
          controlPoint,
          currentPoint
        };
      }
      pathT(ctx, boundingBox) {
        var {
          pathParser: pathParser2
        } = this;
        var {
          current,
          controlPoint,
          currentPoint
        } = PathElement.pathT(pathParser2);
        pathParser2.addMarker(currentPoint, controlPoint, controlPoint);
        boundingBox.addQuadraticCurve(current.x, current.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);
        if (ctx) {
          ctx.quadraticCurveTo(controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);
        }
      }
      static pathA(pathParser2) {
        var {
          current,
          command
        } = pathParser2;
        var {
          rX,
          rY,
          xRot,
          lArcFlag,
          sweepFlag
        } = command;
        var xAxisRotation = xRot * (Math.PI / 180);
        var currentPoint = pathParser2.getAsCurrentPoint();
        var currp = new Point2(Math.cos(xAxisRotation) * (current.x - currentPoint.x) / 2 + Math.sin(xAxisRotation) * (current.y - currentPoint.y) / 2, -Math.sin(xAxisRotation) * (current.x - currentPoint.x) / 2 + Math.cos(xAxisRotation) * (current.y - currentPoint.y) / 2);
        var l2 = Math.pow(currp.x, 2) / Math.pow(rX, 2) + Math.pow(currp.y, 2) / Math.pow(rY, 2);
        if (l2 > 1) {
          rX *= Math.sqrt(l2);
          rY *= Math.sqrt(l2);
        }
        var s2 = (lArcFlag === sweepFlag ? -1 : 1) * Math.sqrt((Math.pow(rX, 2) * Math.pow(rY, 2) - Math.pow(rX, 2) * Math.pow(currp.y, 2) - Math.pow(rY, 2) * Math.pow(currp.x, 2)) / (Math.pow(rX, 2) * Math.pow(currp.y, 2) + Math.pow(rY, 2) * Math.pow(currp.x, 2)));
        if (isNaN(s2)) {
          s2 = 0;
        }
        var cpp = new Point2(s2 * rX * currp.y / rY, s2 * -rY * currp.x / rX);
        var centp = new Point2((current.x + currentPoint.x) / 2 + Math.cos(xAxisRotation) * cpp.x - Math.sin(xAxisRotation) * cpp.y, (current.y + currentPoint.y) / 2 + Math.sin(xAxisRotation) * cpp.x + Math.cos(xAxisRotation) * cpp.y);
        var a1 = vectorsAngle([1, 0], [(currp.x - cpp.x) / rX, (currp.y - cpp.y) / rY]);
        var u2 = [(currp.x - cpp.x) / rX, (currp.y - cpp.y) / rY];
        var v2 = [(-currp.x - cpp.x) / rX, (-currp.y - cpp.y) / rY];
        var ad = vectorsAngle(u2, v2);
        if (vectorsRatio(u2, v2) <= -1) {
          ad = Math.PI;
        }
        if (vectorsRatio(u2, v2) >= 1) {
          ad = 0;
        }
        return {
          currentPoint,
          rX,
          rY,
          sweepFlag,
          xAxisRotation,
          centp,
          a1,
          ad
        };
      }
      pathA(ctx, boundingBox) {
        var {
          pathParser: pathParser2
        } = this;
        var {
          currentPoint,
          rX,
          rY,
          sweepFlag,
          xAxisRotation,
          centp,
          a1,
          ad
        } = PathElement.pathA(pathParser2);
        var dir = 1 - sweepFlag ? 1 : -1;
        var ah = a1 + dir * (ad / 2);
        var halfWay = new Point2(centp.x + rX * Math.cos(ah), centp.y + rY * Math.sin(ah));
        pathParser2.addMarkerAngle(halfWay, ah - dir * Math.PI / 2);
        pathParser2.addMarkerAngle(currentPoint, ah - dir * Math.PI);
        boundingBox.addPoint(currentPoint.x, currentPoint.y);
        if (ctx && !isNaN(a1) && !isNaN(ad)) {
          var r2 = rX > rY ? rX : rY;
          var sx = rX > rY ? 1 : rX / rY;
          var sy = rX > rY ? rY / rX : 1;
          ctx.translate(centp.x, centp.y);
          ctx.rotate(xAxisRotation);
          ctx.scale(sx, sy);
          ctx.arc(0, 0, r2, a1, a1 + ad, Boolean(1 - sweepFlag));
          ctx.scale(1 / sx, 1 / sy);
          ctx.rotate(-xAxisRotation);
          ctx.translate(-centp.x, -centp.y);
        }
      }
      static pathZ(pathParser2) {
        pathParser2.current = pathParser2.start;
      }
      pathZ(ctx, boundingBox) {
        PathElement.pathZ(this.pathParser);
        if (ctx) {
          if (boundingBox.x1 !== boundingBox.x2 && boundingBox.y1 !== boundingBox.y2) {
            ctx.closePath();
          }
        }
      }
    };
    GlyphElement = class extends PathElement {
      constructor(document4, node3, captureTextNodes) {
        super(document4, node3, captureTextNodes);
        this.type = "glyph";
        this.horizAdvX = this.getAttribute("horiz-adv-x").getNumber();
        this.unicode = this.getAttribute("unicode").getString();
        this.arabicForm = this.getAttribute("arabic-form").getString();
      }
    };
    TextElement = class extends RenderedElement {
      constructor(document4, node3, captureTextNodes) {
        super(document4, node3, new.target === TextElement ? true : captureTextNodes);
        this.type = "text";
        this.x = 0;
        this.y = 0;
        this.measureCache = -1;
      }
      setContext(ctx) {
        var fromMeasure = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        super.setContext(ctx, fromMeasure);
        var textBaseline = this.getStyle("dominant-baseline").getTextBaseline() || this.getStyle("alignment-baseline").getTextBaseline();
        if (textBaseline) {
          ctx.textBaseline = textBaseline;
        }
      }
      initializeCoordinates() {
        this.x = 0;
        this.y = 0;
        this.leafTexts = [];
        this.textChunkStart = 0;
        this.minX = Number.POSITIVE_INFINITY;
        this.maxX = Number.NEGATIVE_INFINITY;
      }
      getBoundingBox(ctx) {
        if (this.type !== "text") {
          return this.getTElementBoundingBox(ctx);
        }
        this.initializeCoordinates();
        this.adjustChildCoordinatesRecursive(ctx);
        var boundingBox = null;
        this.children.forEach((_2, i2) => {
          var childBoundingBox = this.getChildBoundingBox(ctx, this, this, i2);
          if (!boundingBox) {
            boundingBox = childBoundingBox;
          } else {
            boundingBox.addBoundingBox(childBoundingBox);
          }
        });
        return boundingBox;
      }
      getFontSize() {
        var {
          document: document4,
          parent
        } = this;
        var inheritFontSize = Font.parse(document4.ctx.font).fontSize;
        var fontSize = parent.getStyle("font-size").getNumber(inheritFontSize);
        return fontSize;
      }
      getTElementBoundingBox(ctx) {
        var fontSize = this.getFontSize();
        return new BoundingBox(this.x, this.y - fontSize, this.x + this.measureText(ctx), this.y);
      }
      getGlyph(font, text4, i2) {
        var char = text4[i2];
        var glyph = null;
        if (font.isArabic) {
          var len = text4.length;
          var prevChar = text4[i2 - 1];
          var nextChar = text4[i2 + 1];
          var arabicForm = "isolated";
          if ((i2 === 0 || prevChar === " ") && i2 < len - 1 && nextChar !== " ") {
            arabicForm = "terminal";
          }
          if (i2 > 0 && prevChar !== " " && i2 < len - 1 && nextChar !== " ") {
            arabicForm = "medial";
          }
          if (i2 > 0 && prevChar !== " " && (i2 === len - 1 || nextChar === " ")) {
            arabicForm = "initial";
          }
          if (typeof font.glyphs[char] !== "undefined") {
            var maybeGlyph = font.glyphs[char];
            glyph = maybeGlyph instanceof GlyphElement ? maybeGlyph : maybeGlyph[arabicForm];
          }
        } else {
          glyph = font.glyphs[char];
        }
        if (!glyph) {
          glyph = font.missingGlyph;
        }
        return glyph;
      }
      getText() {
        return "";
      }
      getTextFromNode(node3) {
        var textNode = node3 || this.node;
        var childNodes = Array.from(textNode.parentNode.childNodes);
        var index3 = childNodes.indexOf(textNode);
        var lastIndex = childNodes.length - 1;
        var text4 = compressSpaces(
          // textNode.value
          // || textNode.text
          textNode.textContent || ""
        );
        if (index3 === 0) {
          text4 = trimLeft(text4);
        }
        if (index3 === lastIndex) {
          text4 = trimRight(text4);
        }
        return text4;
      }
      renderChildren(ctx) {
        if (this.type !== "text") {
          this.renderTElementChildren(ctx);
          return;
        }
        this.initializeCoordinates();
        this.adjustChildCoordinatesRecursive(ctx);
        this.children.forEach((_2, i2) => {
          this.renderChild(ctx, this, this, i2);
        });
        var {
          mouse
        } = this.document.screen;
        if (mouse.isWorking()) {
          mouse.checkBoundingBox(this, this.getBoundingBox(ctx));
        }
      }
      renderTElementChildren(ctx) {
        var {
          document: document4,
          parent
        } = this;
        var renderText2 = this.getText();
        var customFont = parent.getStyle("font-family").getDefinition();
        if (customFont) {
          var {
            unitsPerEm
          } = customFont.fontFace;
          var ctxFont = Font.parse(document4.ctx.font);
          var fontSize = parent.getStyle("font-size").getNumber(ctxFont.fontSize);
          var fontStyle = parent.getStyle("font-style").getString(ctxFont.fontStyle);
          var scale3 = fontSize / unitsPerEm;
          var text4 = customFont.isRTL ? renderText2.split("").reverse().join("") : renderText2;
          var dx2 = toNumbers(parent.getAttribute("dx").getString());
          var len = text4.length;
          for (var i2 = 0; i2 < len; i2++) {
            var glyph = this.getGlyph(customFont, text4, i2);
            ctx.translate(this.x, this.y);
            ctx.scale(scale3, -scale3);
            var lw = ctx.lineWidth;
            ctx.lineWidth = ctx.lineWidth * unitsPerEm / fontSize;
            if (fontStyle === "italic") {
              ctx.transform(1, 0, 0.4, 1, 0, 0);
            }
            glyph.render(ctx);
            if (fontStyle === "italic") {
              ctx.transform(1, 0, -0.4, 1, 0, 0);
            }
            ctx.lineWidth = lw;
            ctx.scale(1 / scale3, -1 / scale3);
            ctx.translate(-this.x, -this.y);
            this.x += fontSize * (glyph.horizAdvX || customFont.horizAdvX) / unitsPerEm;
            if (typeof dx2[i2] !== "undefined" && !isNaN(dx2[i2])) {
              this.x += dx2[i2];
            }
          }
          return;
        }
        var {
          x: x2,
          y: y3
        } = this;
        if (ctx.fillStyle) {
          ctx.fillText(renderText2, x2, y3);
        }
        if (ctx.strokeStyle) {
          ctx.strokeText(renderText2, x2, y3);
        }
      }
      applyAnchoring() {
        if (this.textChunkStart >= this.leafTexts.length) {
          return;
        }
        var firstElement = this.leafTexts[this.textChunkStart];
        var textAnchor = firstElement.getStyle("text-anchor").getString("start");
        var isRTL = false;
        var shift = 0;
        if (textAnchor === "start" && !isRTL || textAnchor === "end" && isRTL) {
          shift = firstElement.x - this.minX;
        } else if (textAnchor === "end" && !isRTL || textAnchor === "start" && isRTL) {
          shift = firstElement.x - this.maxX;
        } else {
          shift = firstElement.x - (this.minX + this.maxX) / 2;
        }
        for (var i2 = this.textChunkStart; i2 < this.leafTexts.length; i2++) {
          this.leafTexts[i2].x += shift;
        }
        this.minX = Number.POSITIVE_INFINITY;
        this.maxX = Number.NEGATIVE_INFINITY;
        this.textChunkStart = this.leafTexts.length;
      }
      adjustChildCoordinatesRecursive(ctx) {
        this.children.forEach((_2, i2) => {
          this.adjustChildCoordinatesRecursiveCore(ctx, this, this, i2);
        });
        this.applyAnchoring();
      }
      adjustChildCoordinatesRecursiveCore(ctx, textParent, parent, i2) {
        var child = parent.children[i2];
        if (child.children.length > 0) {
          child.children.forEach((_2, i3) => {
            textParent.adjustChildCoordinatesRecursiveCore(ctx, textParent, child, i3);
          });
        } else {
          this.adjustChildCoordinates(ctx, textParent, parent, i2);
        }
      }
      adjustChildCoordinates(ctx, textParent, parent, i2) {
        var child = parent.children[i2];
        if (typeof child.measureText !== "function") {
          return child;
        }
        ctx.save();
        child.setContext(ctx, true);
        var xAttr = child.getAttribute("x");
        var yAttr = child.getAttribute("y");
        var dxAttr = child.getAttribute("dx");
        var dyAttr = child.getAttribute("dy");
        var customFont = child.getStyle("font-family").getDefinition();
        var isRTL = Boolean(customFont) && customFont.isRTL;
        if (i2 === 0) {
          if (!xAttr.hasValue()) {
            xAttr.setValue(child.getInheritedAttribute("x"));
          }
          if (!yAttr.hasValue()) {
            yAttr.setValue(child.getInheritedAttribute("y"));
          }
          if (!dxAttr.hasValue()) {
            dxAttr.setValue(child.getInheritedAttribute("dx"));
          }
          if (!dyAttr.hasValue()) {
            dyAttr.setValue(child.getInheritedAttribute("dy"));
          }
        }
        var width2 = child.measureText(ctx);
        if (isRTL) {
          textParent.x -= width2;
        }
        if (xAttr.hasValue()) {
          textParent.applyAnchoring();
          child.x = xAttr.getPixels("x");
          if (dxAttr.hasValue()) {
            child.x += dxAttr.getPixels("x");
          }
        } else {
          if (dxAttr.hasValue()) {
            textParent.x += dxAttr.getPixels("x");
          }
          child.x = textParent.x;
        }
        textParent.x = child.x;
        if (!isRTL) {
          textParent.x += width2;
        }
        if (yAttr.hasValue()) {
          child.y = yAttr.getPixels("y");
          if (dyAttr.hasValue()) {
            child.y += dyAttr.getPixels("y");
          }
        } else {
          if (dyAttr.hasValue()) {
            textParent.y += dyAttr.getPixels("y");
          }
          child.y = textParent.y;
        }
        textParent.y = child.y;
        textParent.leafTexts.push(child);
        textParent.minX = Math.min(textParent.minX, child.x, child.x + width2);
        textParent.maxX = Math.max(textParent.maxX, child.x, child.x + width2);
        child.clearContext(ctx);
        ctx.restore();
        return child;
      }
      getChildBoundingBox(ctx, textParent, parent, i2) {
        var child = parent.children[i2];
        if (typeof child.getBoundingBox !== "function") {
          return null;
        }
        var boundingBox = child.getBoundingBox(ctx);
        if (!boundingBox) {
          return null;
        }
        child.children.forEach((_2, i3) => {
          var childBoundingBox = textParent.getChildBoundingBox(ctx, textParent, child, i3);
          boundingBox.addBoundingBox(childBoundingBox);
        });
        return boundingBox;
      }
      renderChild(ctx, textParent, parent, i2) {
        var child = parent.children[i2];
        child.render(ctx);
        child.children.forEach((_2, i3) => {
          textParent.renderChild(ctx, textParent, child, i3);
        });
      }
      measureText(ctx) {
        var {
          measureCache
        } = this;
        if (~measureCache) {
          return measureCache;
        }
        var renderText2 = this.getText();
        var measure = this.measureTargetText(ctx, renderText2);
        this.measureCache = measure;
        return measure;
      }
      measureTargetText(ctx, targetText) {
        if (!targetText.length) {
          return 0;
        }
        var {
          parent
        } = this;
        var customFont = parent.getStyle("font-family").getDefinition();
        if (customFont) {
          var fontSize = this.getFontSize();
          var text4 = customFont.isRTL ? targetText.split("").reverse().join("") : targetText;
          var dx2 = toNumbers(parent.getAttribute("dx").getString());
          var len = text4.length;
          var _measure = 0;
          for (var i2 = 0; i2 < len; i2++) {
            var glyph = this.getGlyph(customFont, text4, i2);
            _measure += (glyph.horizAdvX || customFont.horizAdvX) * fontSize / customFont.fontFace.unitsPerEm;
            if (typeof dx2[i2] !== "undefined" && !isNaN(dx2[i2])) {
              _measure += dx2[i2];
            }
          }
          return _measure;
        }
        if (!ctx.measureText) {
          return targetText.length * 10;
        }
        ctx.save();
        this.setContext(ctx, true);
        var {
          width: measure
        } = ctx.measureText(targetText);
        this.clearContext(ctx);
        ctx.restore();
        return measure;
      }
      /**
       * Inherits positional attributes from {@link TextElement} parent(s). Attributes
       * are only inherited from a parent to its first child.
       * @param name - The attribute name.
       * @returns The attribute value or null.
       */
      getInheritedAttribute(name) {
        var current = this;
        while (current instanceof TextElement && current.isFirstChild()) {
          var parentAttr = current.parent.getAttribute(name);
          if (parentAttr.hasValue(true)) {
            return parentAttr.getValue("0");
          }
          current = current.parent;
        }
        return null;
      }
    };
    TSpanElement = class extends TextElement {
      constructor(document4, node3, captureTextNodes) {
        super(document4, node3, new.target === TSpanElement ? true : captureTextNodes);
        this.type = "tspan";
        this.text = this.children.length > 0 ? "" : this.getTextFromNode();
      }
      getText() {
        return this.text;
      }
    };
    TextNode = class extends TSpanElement {
      constructor() {
        super(...arguments);
        this.type = "textNode";
      }
    };
    SVGElement = class extends RenderedElement {
      constructor() {
        super(...arguments);
        this.type = "svg";
        this.root = false;
      }
      setContext(ctx) {
        var _this$node$parentNode;
        var {
          document: document4
        } = this;
        var {
          screen,
          window: window2
        } = document4;
        var canvas = ctx.canvas;
        screen.setDefaults(ctx);
        if (canvas.style && typeof ctx.font !== "undefined" && window2 && typeof window2.getComputedStyle !== "undefined") {
          ctx.font = window2.getComputedStyle(canvas).getPropertyValue("font");
          var fontSizeProp = new Property(document4, "fontSize", Font.parse(ctx.font).fontSize);
          if (fontSizeProp.hasValue()) {
            document4.rootEmSize = fontSizeProp.getPixels("y");
            document4.emSize = document4.rootEmSize;
          }
        }
        if (!this.getAttribute("x").hasValue()) {
          this.getAttribute("x", true).setValue(0);
        }
        if (!this.getAttribute("y").hasValue()) {
          this.getAttribute("y", true).setValue(0);
        }
        var {
          width: width2,
          height: height2
        } = screen.viewPort;
        if (!this.getStyle("width").hasValue()) {
          this.getStyle("width", true).setValue("100%");
        }
        if (!this.getStyle("height").hasValue()) {
          this.getStyle("height", true).setValue("100%");
        }
        if (!this.getStyle("color").hasValue()) {
          this.getStyle("color", true).setValue("black");
        }
        var refXAttr = this.getAttribute("refX");
        var refYAttr = this.getAttribute("refY");
        var viewBoxAttr = this.getAttribute("viewBox");
        var viewBox = viewBoxAttr.hasValue() ? toNumbers(viewBoxAttr.getString()) : null;
        var clip = !this.root && this.getStyle("overflow").getValue("hidden") !== "visible";
        var minX = 0;
        var minY = 0;
        var clipX = 0;
        var clipY = 0;
        if (viewBox) {
          minX = viewBox[0];
          minY = viewBox[1];
        }
        if (!this.root) {
          width2 = this.getStyle("width").getPixels("x");
          height2 = this.getStyle("height").getPixels("y");
          if (this.type === "marker") {
            clipX = minX;
            clipY = minY;
            minX = 0;
            minY = 0;
          }
        }
        screen.viewPort.setCurrent(width2, height2);
        if (this.node && (!this.parent || ((_this$node$parentNode = this.node.parentNode) === null || _this$node$parentNode === void 0 ? void 0 : _this$node$parentNode.nodeName) === "foreignObject") && this.getStyle("transform", false, true).hasValue() && !this.getStyle("transform-origin", false, true).hasValue()) {
          this.getStyle("transform-origin", true, true).setValue("50% 50%");
        }
        super.setContext(ctx);
        ctx.translate(this.getAttribute("x").getPixels("x"), this.getAttribute("y").getPixels("y"));
        if (viewBox) {
          width2 = viewBox[2];
          height2 = viewBox[3];
        }
        document4.setViewBox({
          ctx,
          aspectRatio: this.getAttribute("preserveAspectRatio").getString(),
          width: screen.viewPort.width,
          desiredWidth: width2,
          height: screen.viewPort.height,
          desiredHeight: height2,
          minX,
          minY,
          refX: refXAttr.getValue(),
          refY: refYAttr.getValue(),
          clip,
          clipX,
          clipY
        });
        if (viewBox) {
          screen.viewPort.removeCurrent();
          screen.viewPort.setCurrent(width2, height2);
        }
      }
      clearContext(ctx) {
        super.clearContext(ctx);
        this.document.screen.viewPort.removeCurrent();
      }
      /**
       * Resize SVG to fit in given size.
       * @param width
       * @param height
       * @param preserveAspectRatio
       */
      resize(width2) {
        var height2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : width2;
        var preserveAspectRatio = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
        var widthAttr = this.getAttribute("width", true);
        var heightAttr = this.getAttribute("height", true);
        var viewBoxAttr = this.getAttribute("viewBox");
        var styleAttr = this.getAttribute("style");
        var originWidth = widthAttr.getNumber(0);
        var originHeight = heightAttr.getNumber(0);
        if (preserveAspectRatio) {
          if (typeof preserveAspectRatio === "string") {
            this.getAttribute("preserveAspectRatio", true).setValue(preserveAspectRatio);
          } else {
            var preserveAspectRatioAttr = this.getAttribute("preserveAspectRatio");
            if (preserveAspectRatioAttr.hasValue()) {
              preserveAspectRatioAttr.setValue(preserveAspectRatioAttr.getString().replace(/^\s*(\S.*\S)\s*$/, "$1"));
            }
          }
        }
        widthAttr.setValue(width2);
        heightAttr.setValue(height2);
        if (!viewBoxAttr.hasValue()) {
          viewBoxAttr.setValue("0 0 ".concat(originWidth || width2, " ").concat(originHeight || height2));
        }
        if (styleAttr.hasValue()) {
          var widthStyle = this.getStyle("width");
          var heightStyle = this.getStyle("height");
          if (widthStyle.hasValue()) {
            widthStyle.setValue("".concat(width2, "px"));
          }
          if (heightStyle.hasValue()) {
            heightStyle.setValue("".concat(height2, "px"));
          }
        }
      }
    };
    RectElement = class extends PathElement {
      constructor() {
        super(...arguments);
        this.type = "rect";
      }
      path(ctx) {
        var x2 = this.getAttribute("x").getPixels("x");
        var y3 = this.getAttribute("y").getPixels("y");
        var width2 = this.getStyle("width", false, true).getPixels("x");
        var height2 = this.getStyle("height", false, true).getPixels("y");
        var rxAttr = this.getAttribute("rx");
        var ryAttr = this.getAttribute("ry");
        var rx2 = rxAttr.getPixels("x");
        var ry2 = ryAttr.getPixels("y");
        if (rxAttr.hasValue() && !ryAttr.hasValue()) {
          ry2 = rx2;
        }
        if (ryAttr.hasValue() && !rxAttr.hasValue()) {
          rx2 = ry2;
        }
        rx2 = Math.min(rx2, width2 / 2);
        ry2 = Math.min(ry2, height2 / 2);
        if (ctx) {
          var KAPPA = 4 * ((Math.sqrt(2) - 1) / 3);
          ctx.beginPath();
          if (height2 > 0 && width2 > 0) {
            ctx.moveTo(x2 + rx2, y3);
            ctx.lineTo(x2 + width2 - rx2, y3);
            ctx.bezierCurveTo(x2 + width2 - rx2 + KAPPA * rx2, y3, x2 + width2, y3 + ry2 - KAPPA * ry2, x2 + width2, y3 + ry2);
            ctx.lineTo(x2 + width2, y3 + height2 - ry2);
            ctx.bezierCurveTo(x2 + width2, y3 + height2 - ry2 + KAPPA * ry2, x2 + width2 - rx2 + KAPPA * rx2, y3 + height2, x2 + width2 - rx2, y3 + height2);
            ctx.lineTo(x2 + rx2, y3 + height2);
            ctx.bezierCurveTo(x2 + rx2 - KAPPA * rx2, y3 + height2, x2, y3 + height2 - ry2 + KAPPA * ry2, x2, y3 + height2 - ry2);
            ctx.lineTo(x2, y3 + ry2);
            ctx.bezierCurveTo(x2, y3 + ry2 - KAPPA * ry2, x2 + rx2 - KAPPA * rx2, y3, x2 + rx2, y3);
            ctx.closePath();
          }
        }
        return new BoundingBox(x2, y3, x2 + width2, y3 + height2);
      }
      getMarkers() {
        return null;
      }
    };
    CircleElement = class extends PathElement {
      constructor() {
        super(...arguments);
        this.type = "circle";
      }
      path(ctx) {
        var cx2 = this.getAttribute("cx").getPixels("x");
        var cy2 = this.getAttribute("cy").getPixels("y");
        var r2 = this.getAttribute("r").getPixels();
        if (ctx && r2 > 0) {
          ctx.beginPath();
          ctx.arc(cx2, cy2, r2, 0, Math.PI * 2, false);
          ctx.closePath();
        }
        return new BoundingBox(cx2 - r2, cy2 - r2, cx2 + r2, cy2 + r2);
      }
      getMarkers() {
        return null;
      }
    };
    EllipseElement = class extends PathElement {
      constructor() {
        super(...arguments);
        this.type = "ellipse";
      }
      path(ctx) {
        var KAPPA = 4 * ((Math.sqrt(2) - 1) / 3);
        var rx2 = this.getAttribute("rx").getPixels("x");
        var ry2 = this.getAttribute("ry").getPixels("y");
        var cx2 = this.getAttribute("cx").getPixels("x");
        var cy2 = this.getAttribute("cy").getPixels("y");
        if (ctx && rx2 > 0 && ry2 > 0) {
          ctx.beginPath();
          ctx.moveTo(cx2 + rx2, cy2);
          ctx.bezierCurveTo(cx2 + rx2, cy2 + KAPPA * ry2, cx2 + KAPPA * rx2, cy2 + ry2, cx2, cy2 + ry2);
          ctx.bezierCurveTo(cx2 - KAPPA * rx2, cy2 + ry2, cx2 - rx2, cy2 + KAPPA * ry2, cx2 - rx2, cy2);
          ctx.bezierCurveTo(cx2 - rx2, cy2 - KAPPA * ry2, cx2 - KAPPA * rx2, cy2 - ry2, cx2, cy2 - ry2);
          ctx.bezierCurveTo(cx2 + KAPPA * rx2, cy2 - ry2, cx2 + rx2, cy2 - KAPPA * ry2, cx2 + rx2, cy2);
          ctx.closePath();
        }
        return new BoundingBox(cx2 - rx2, cy2 - ry2, cx2 + rx2, cy2 + ry2);
      }
      getMarkers() {
        return null;
      }
    };
    LineElement = class extends PathElement {
      constructor() {
        super(...arguments);
        this.type = "line";
      }
      getPoints() {
        return [new Point2(this.getAttribute("x1").getPixels("x"), this.getAttribute("y1").getPixels("y")), new Point2(this.getAttribute("x2").getPixels("x"), this.getAttribute("y2").getPixels("y"))];
      }
      path(ctx) {
        var [{
          x: x0,
          y: y0
        }, {
          x: x1,
          y: y1
        }] = this.getPoints();
        if (ctx) {
          ctx.beginPath();
          ctx.moveTo(x0, y0);
          ctx.lineTo(x1, y1);
        }
        return new BoundingBox(x0, y0, x1, y1);
      }
      getMarkers() {
        var [p0, p1] = this.getPoints();
        var a2 = p0.angleTo(p1);
        return [[p0, a2], [p1, a2]];
      }
    };
    PolylineElement = class extends PathElement {
      constructor(document4, node3, captureTextNodes) {
        super(document4, node3, captureTextNodes);
        this.type = "polyline";
        this.points = [];
        this.points = Point2.parsePath(this.getAttribute("points").getString());
      }
      path(ctx) {
        var {
          points
        } = this;
        var [{
          x: x0,
          y: y0
        }] = points;
        var boundingBox = new BoundingBox(x0, y0);
        if (ctx) {
          ctx.beginPath();
          ctx.moveTo(x0, y0);
        }
        points.forEach((_ref) => {
          var {
            x: x2,
            y: y3
          } = _ref;
          boundingBox.addPoint(x2, y3);
          if (ctx) {
            ctx.lineTo(x2, y3);
          }
        });
        return boundingBox;
      }
      getMarkers() {
        var {
          points
        } = this;
        var lastIndex = points.length - 1;
        var markers = [];
        points.forEach((point4, i2) => {
          if (i2 === lastIndex) {
            return;
          }
          markers.push([point4, point4.angleTo(points[i2 + 1])]);
        });
        if (markers.length > 0) {
          markers.push([points[points.length - 1], markers[markers.length - 1][1]]);
        }
        return markers;
      }
    };
    PolygonElement = class extends PolylineElement {
      constructor() {
        super(...arguments);
        this.type = "polygon";
      }
      path(ctx) {
        var boundingBox = super.path(ctx);
        var [{
          x: x2,
          y: y3
        }] = this.points;
        if (ctx) {
          ctx.lineTo(x2, y3);
          ctx.closePath();
        }
        return boundingBox;
      }
    };
    PatternElement = class extends Element2 {
      constructor() {
        super(...arguments);
        this.type = "pattern";
      }
      createPattern(ctx, _2, parentOpacityProp) {
        var width2 = this.getStyle("width").getPixels("x", true);
        var height2 = this.getStyle("height").getPixels("y", true);
        var patternSvg = new SVGElement(this.document, null);
        patternSvg.attributes.viewBox = new Property(this.document, "viewBox", this.getAttribute("viewBox").getValue());
        patternSvg.attributes.width = new Property(this.document, "width", "".concat(width2, "px"));
        patternSvg.attributes.height = new Property(this.document, "height", "".concat(height2, "px"));
        patternSvg.attributes.transform = new Property(this.document, "transform", this.getAttribute("patternTransform").getValue());
        patternSvg.children = this.children;
        var patternCanvas = this.document.createCanvas(width2, height2);
        var patternCtx = patternCanvas.getContext("2d");
        var xAttr = this.getAttribute("x");
        var yAttr = this.getAttribute("y");
        if (xAttr.hasValue() && yAttr.hasValue()) {
          patternCtx.translate(xAttr.getPixels("x", true), yAttr.getPixels("y", true));
        }
        if (parentOpacityProp.hasValue()) {
          this.styles["fill-opacity"] = parentOpacityProp;
        } else {
          Reflect.deleteProperty(this.styles, "fill-opacity");
        }
        for (var x2 = -1; x2 <= 1; x2++) {
          for (var y3 = -1; y3 <= 1; y3++) {
            patternCtx.save();
            patternSvg.attributes.x = new Property(this.document, "x", x2 * patternCanvas.width);
            patternSvg.attributes.y = new Property(this.document, "y", y3 * patternCanvas.height);
            patternSvg.render(patternCtx);
            patternCtx.restore();
          }
        }
        var pattern = ctx.createPattern(patternCanvas, "repeat");
        return pattern;
      }
    };
    MarkerElement = class extends Element2 {
      constructor() {
        super(...arguments);
        this.type = "marker";
      }
      render(ctx, point4, angle) {
        if (!point4) {
          return;
        }
        var {
          x: x2,
          y: y3
        } = point4;
        var orient = this.getAttribute("orient").getString("auto");
        var markerUnits = this.getAttribute("markerUnits").getString("strokeWidth");
        ctx.translate(x2, y3);
        if (orient === "auto") {
          ctx.rotate(angle);
        }
        if (markerUnits === "strokeWidth") {
          ctx.scale(ctx.lineWidth, ctx.lineWidth);
        }
        ctx.save();
        var markerSvg = new SVGElement(this.document, null);
        markerSvg.type = this.type;
        markerSvg.attributes.viewBox = new Property(this.document, "viewBox", this.getAttribute("viewBox").getValue());
        markerSvg.attributes.refX = new Property(this.document, "refX", this.getAttribute("refX").getValue());
        markerSvg.attributes.refY = new Property(this.document, "refY", this.getAttribute("refY").getValue());
        markerSvg.attributes.width = new Property(this.document, "width", this.getAttribute("markerWidth").getValue());
        markerSvg.attributes.height = new Property(this.document, "height", this.getAttribute("markerHeight").getValue());
        markerSvg.attributes.overflow = new Property(this.document, "overflow", this.getAttribute("overflow").getValue());
        markerSvg.attributes.fill = new Property(this.document, "fill", this.getAttribute("fill").getColor("black"));
        markerSvg.attributes.stroke = new Property(this.document, "stroke", this.getAttribute("stroke").getValue("none"));
        markerSvg.children = this.children;
        markerSvg.render(ctx);
        ctx.restore();
        if (markerUnits === "strokeWidth") {
          ctx.scale(1 / ctx.lineWidth, 1 / ctx.lineWidth);
        }
        if (orient === "auto") {
          ctx.rotate(-angle);
        }
        ctx.translate(-x2, -y3);
      }
    };
    DefsElement = class extends Element2 {
      constructor() {
        super(...arguments);
        this.type = "defs";
      }
      render() {
      }
    };
    GElement = class extends RenderedElement {
      constructor() {
        super(...arguments);
        this.type = "g";
      }
      getBoundingBox(ctx) {
        var boundingBox = new BoundingBox();
        this.children.forEach((child) => {
          boundingBox.addBoundingBox(child.getBoundingBox(ctx));
        });
        return boundingBox;
      }
    };
    GradientElement = class extends Element2 {
      constructor(document4, node3, captureTextNodes) {
        super(document4, node3, captureTextNodes);
        this.attributesToInherit = ["gradientUnits"];
        this.stops = [];
        var {
          stops,
          children
        } = this;
        children.forEach((child) => {
          if (child.type === "stop") {
            stops.push(child);
          }
        });
      }
      getGradientUnits() {
        return this.getAttribute("gradientUnits").getString("objectBoundingBox");
      }
      createGradient(ctx, element2, parentOpacityProp) {
        var stopsContainer = this;
        if (this.getHrefAttribute().hasValue()) {
          stopsContainer = this.getHrefAttribute().getDefinition();
          this.inheritStopContainer(stopsContainer);
        }
        var {
          stops
        } = stopsContainer;
        var gradient = this.getGradient(ctx, element2);
        if (!gradient) {
          return this.addParentOpacity(parentOpacityProp, stops[stops.length - 1].color);
        }
        stops.forEach((stop) => {
          gradient.addColorStop(stop.offset, this.addParentOpacity(parentOpacityProp, stop.color));
        });
        if (this.getAttribute("gradientTransform").hasValue()) {
          var {
            document: document4
          } = this;
          var {
            MAX_VIRTUAL_PIXELS,
            viewPort
          } = document4.screen;
          var [rootView] = viewPort.viewPorts;
          var rect = new RectElement(document4, null);
          rect.attributes.x = new Property(document4, "x", -MAX_VIRTUAL_PIXELS / 3);
          rect.attributes.y = new Property(document4, "y", -MAX_VIRTUAL_PIXELS / 3);
          rect.attributes.width = new Property(document4, "width", MAX_VIRTUAL_PIXELS);
          rect.attributes.height = new Property(document4, "height", MAX_VIRTUAL_PIXELS);
          var group = new GElement(document4, null);
          group.attributes.transform = new Property(document4, "transform", this.getAttribute("gradientTransform").getValue());
          group.children = [rect];
          var patternSvg = new SVGElement(document4, null);
          patternSvg.attributes.x = new Property(document4, "x", 0);
          patternSvg.attributes.y = new Property(document4, "y", 0);
          patternSvg.attributes.width = new Property(document4, "width", rootView.width);
          patternSvg.attributes.height = new Property(document4, "height", rootView.height);
          patternSvg.children = [group];
          var patternCanvas = document4.createCanvas(rootView.width, rootView.height);
          var patternCtx = patternCanvas.getContext("2d");
          patternCtx.fillStyle = gradient;
          patternSvg.render(patternCtx);
          return patternCtx.createPattern(patternCanvas, "no-repeat");
        }
        return gradient;
      }
      inheritStopContainer(stopsContainer) {
        this.attributesToInherit.forEach((attributeToInherit) => {
          if (!this.getAttribute(attributeToInherit).hasValue() && stopsContainer.getAttribute(attributeToInherit).hasValue()) {
            this.getAttribute(attributeToInherit, true).setValue(stopsContainer.getAttribute(attributeToInherit).getValue());
          }
        });
      }
      addParentOpacity(parentOpacityProp, color) {
        if (parentOpacityProp.hasValue()) {
          var colorProp = new Property(this.document, "color", color);
          return colorProp.addOpacity(parentOpacityProp).getColor();
        }
        return color;
      }
    };
    LinearGradientElement = class extends GradientElement {
      constructor(document4, node3, captureTextNodes) {
        super(document4, node3, captureTextNodes);
        this.type = "linearGradient";
        this.attributesToInherit.push("x1", "y1", "x2", "y2");
      }
      getGradient(ctx, element2) {
        var isBoundingBoxUnits = this.getGradientUnits() === "objectBoundingBox";
        var boundingBox = isBoundingBoxUnits ? element2.getBoundingBox(ctx) : null;
        if (isBoundingBoxUnits && !boundingBox) {
          return null;
        }
        if (!this.getAttribute("x1").hasValue() && !this.getAttribute("y1").hasValue() && !this.getAttribute("x2").hasValue() && !this.getAttribute("y2").hasValue()) {
          this.getAttribute("x1", true).setValue(0);
          this.getAttribute("y1", true).setValue(0);
          this.getAttribute("x2", true).setValue(1);
          this.getAttribute("y2", true).setValue(0);
        }
        var x1 = isBoundingBoxUnits ? boundingBox.x + boundingBox.width * this.getAttribute("x1").getNumber() : this.getAttribute("x1").getPixels("x");
        var y1 = isBoundingBoxUnits ? boundingBox.y + boundingBox.height * this.getAttribute("y1").getNumber() : this.getAttribute("y1").getPixels("y");
        var x2 = isBoundingBoxUnits ? boundingBox.x + boundingBox.width * this.getAttribute("x2").getNumber() : this.getAttribute("x2").getPixels("x");
        var y22 = isBoundingBoxUnits ? boundingBox.y + boundingBox.height * this.getAttribute("y2").getNumber() : this.getAttribute("y2").getPixels("y");
        if (x1 === x2 && y1 === y22) {
          return null;
        }
        return ctx.createLinearGradient(x1, y1, x2, y22);
      }
    };
    RadialGradientElement = class extends GradientElement {
      constructor(document4, node3, captureTextNodes) {
        super(document4, node3, captureTextNodes);
        this.type = "radialGradient";
        this.attributesToInherit.push("cx", "cy", "r", "fx", "fy", "fr");
      }
      getGradient(ctx, element2) {
        var isBoundingBoxUnits = this.getGradientUnits() === "objectBoundingBox";
        var boundingBox = element2.getBoundingBox(ctx);
        if (isBoundingBoxUnits && !boundingBox) {
          return null;
        }
        if (!this.getAttribute("cx").hasValue()) {
          this.getAttribute("cx", true).setValue("50%");
        }
        if (!this.getAttribute("cy").hasValue()) {
          this.getAttribute("cy", true).setValue("50%");
        }
        if (!this.getAttribute("r").hasValue()) {
          this.getAttribute("r", true).setValue("50%");
        }
        var cx2 = isBoundingBoxUnits ? boundingBox.x + boundingBox.width * this.getAttribute("cx").getNumber() : this.getAttribute("cx").getPixels("x");
        var cy2 = isBoundingBoxUnits ? boundingBox.y + boundingBox.height * this.getAttribute("cy").getNumber() : this.getAttribute("cy").getPixels("y");
        var fx = cx2;
        var fy = cy2;
        if (this.getAttribute("fx").hasValue()) {
          fx = isBoundingBoxUnits ? boundingBox.x + boundingBox.width * this.getAttribute("fx").getNumber() : this.getAttribute("fx").getPixels("x");
        }
        if (this.getAttribute("fy").hasValue()) {
          fy = isBoundingBoxUnits ? boundingBox.y + boundingBox.height * this.getAttribute("fy").getNumber() : this.getAttribute("fy").getPixels("y");
        }
        var r2 = isBoundingBoxUnits ? (boundingBox.width + boundingBox.height) / 2 * this.getAttribute("r").getNumber() : this.getAttribute("r").getPixels();
        var fr = this.getAttribute("fr").getPixels();
        return ctx.createRadialGradient(fx, fy, fr, cx2, cy2, r2);
      }
    };
    StopElement = class extends Element2 {
      constructor(document4, node3, captureTextNodes) {
        super(document4, node3, captureTextNodes);
        this.type = "stop";
        var offset = Math.max(0, Math.min(1, this.getAttribute("offset").getNumber()));
        var stopOpacity = this.getStyle("stop-opacity");
        var stopColor = this.getStyle("stop-color", true);
        if (stopColor.getString() === "") {
          stopColor.setValue("#000");
        }
        if (stopOpacity.hasValue()) {
          stopColor = stopColor.addOpacity(stopOpacity);
        }
        this.offset = offset;
        this.color = stopColor.getColor();
      }
    };
    AnimateElement = class extends Element2 {
      constructor(document4, node3, captureTextNodes) {
        super(document4, node3, captureTextNodes);
        this.type = "animate";
        this.duration = 0;
        this.initialValue = null;
        this.initialUnits = "";
        this.removed = false;
        this.frozen = false;
        document4.screen.animations.push(this);
        this.begin = this.getAttribute("begin").getMilliseconds();
        this.maxDuration = this.begin + this.getAttribute("dur").getMilliseconds();
        this.from = this.getAttribute("from");
        this.to = this.getAttribute("to");
        this.values = new Property(document4, "values", null);
        var valuesAttr = this.getAttribute("values");
        if (valuesAttr.hasValue()) {
          this.values.setValue(valuesAttr.getString().split(";"));
        }
      }
      getProperty() {
        var attributeType = this.getAttribute("attributeType").getString();
        var attributeName = this.getAttribute("attributeName").getString();
        if (attributeType === "CSS") {
          return this.parent.getStyle(attributeName, true);
        }
        return this.parent.getAttribute(attributeName, true);
      }
      calcValue() {
        var {
          initialUnits
        } = this;
        var {
          progress,
          from: from2,
          to: to2
        } = this.getProgress();
        var newValue = from2.getNumber() + (to2.getNumber() - from2.getNumber()) * progress;
        if (initialUnits === "%") {
          newValue *= 100;
        }
        return "".concat(newValue).concat(initialUnits);
      }
      update(delta) {
        var {
          parent
        } = this;
        var prop = this.getProperty();
        if (!this.initialValue) {
          this.initialValue = prop.getString();
          this.initialUnits = prop.getUnits();
        }
        if (this.duration > this.maxDuration) {
          var fill = this.getAttribute("fill").getString("remove");
          if (this.getAttribute("repeatCount").getString() === "indefinite" || this.getAttribute("repeatDur").getString() === "indefinite") {
            this.duration = 0;
          } else if (fill === "freeze" && !this.frozen) {
            this.frozen = true;
            parent.animationFrozen = true;
            parent.animationFrozenValue = prop.getString();
          } else if (fill === "remove" && !this.removed) {
            this.removed = true;
            prop.setValue(parent.animationFrozen ? parent.animationFrozenValue : this.initialValue);
            return true;
          }
          return false;
        }
        this.duration += delta;
        var updated = false;
        if (this.begin < this.duration) {
          var newValue = this.calcValue();
          var typeAttr = this.getAttribute("type");
          if (typeAttr.hasValue()) {
            var type = typeAttr.getString();
            newValue = "".concat(type, "(").concat(newValue, ")");
          }
          prop.setValue(newValue);
          updated = true;
        }
        return updated;
      }
      getProgress() {
        var {
          document: document4,
          values
        } = this;
        var result = {
          progress: (this.duration - this.begin) / (this.maxDuration - this.begin)
        };
        if (values.hasValue()) {
          var p2 = result.progress * (values.getValue().length - 1);
          var lb = Math.floor(p2);
          var ub = Math.ceil(p2);
          result.from = new Property(document4, "from", parseFloat(values.getValue()[lb]));
          result.to = new Property(document4, "to", parseFloat(values.getValue()[ub]));
          result.progress = (p2 - lb) / (ub - lb);
        } else {
          result.from = this.from;
          result.to = this.to;
        }
        return result;
      }
    };
    AnimateColorElement = class extends AnimateElement {
      constructor() {
        super(...arguments);
        this.type = "animateColor";
      }
      calcValue() {
        var {
          progress,
          from: from2,
          to: to2
        } = this.getProgress();
        var colorFrom = new import_rgbcolor.default(from2.getColor());
        var colorTo = new import_rgbcolor.default(to2.getColor());
        if (colorFrom.ok && colorTo.ok) {
          var r2 = colorFrom.r + (colorTo.r - colorFrom.r) * progress;
          var g = colorFrom.g + (colorTo.g - colorFrom.g) * progress;
          var b = colorFrom.b + (colorTo.b - colorFrom.b) * progress;
          return "rgb(".concat(Math.floor(r2), ", ").concat(Math.floor(g), ", ").concat(Math.floor(b), ")");
        }
        return this.getAttribute("from").getColor();
      }
    };
    AnimateTransformElement = class extends AnimateElement {
      constructor() {
        super(...arguments);
        this.type = "animateTransform";
      }
      calcValue() {
        var {
          progress,
          from: from2,
          to: to2
        } = this.getProgress();
        var transformFrom = toNumbers(from2.getString());
        var transformTo = toNumbers(to2.getString());
        var newValue = transformFrom.map((from3, i2) => {
          var to3 = transformTo[i2];
          return from3 + (to3 - from3) * progress;
        }).join(" ");
        return newValue;
      }
    };
    FontElement = class extends Element2 {
      constructor(document4, node3, captureTextNodes) {
        super(document4, node3, captureTextNodes);
        this.type = "font";
        this.glyphs = {};
        this.horizAdvX = this.getAttribute("horiz-adv-x").getNumber();
        var {
          definitions
        } = document4;
        var {
          children
        } = this;
        for (var child of children) {
          switch (child.type) {
            case "font-face": {
              this.fontFace = child;
              var fontFamilyStyle = child.getStyle("font-family");
              if (fontFamilyStyle.hasValue()) {
                definitions[fontFamilyStyle.getString()] = this;
              }
              break;
            }
            case "missing-glyph":
              this.missingGlyph = child;
              break;
            case "glyph": {
              var glyph = child;
              if (glyph.arabicForm) {
                this.isRTL = true;
                this.isArabic = true;
                if (typeof this.glyphs[glyph.unicode] === "undefined") {
                  this.glyphs[glyph.unicode] = {};
                }
                this.glyphs[glyph.unicode][glyph.arabicForm] = glyph;
              } else {
                this.glyphs[glyph.unicode] = glyph;
              }
              break;
            }
          }
        }
      }
      render() {
      }
    };
    FontFaceElement = class extends Element2 {
      constructor(document4, node3, captureTextNodes) {
        super(document4, node3, captureTextNodes);
        this.type = "font-face";
        this.ascent = this.getAttribute("ascent").getNumber();
        this.descent = this.getAttribute("descent").getNumber();
        this.unitsPerEm = this.getAttribute("units-per-em").getNumber();
      }
    };
    MissingGlyphElement = class extends PathElement {
      constructor() {
        super(...arguments);
        this.type = "missing-glyph";
        this.horizAdvX = 0;
      }
    };
    TRefElement = class extends TextElement {
      constructor() {
        super(...arguments);
        this.type = "tref";
      }
      getText() {
        var element2 = this.getHrefAttribute().getDefinition();
        if (element2) {
          var firstChild = element2.children[0];
          if (firstChild) {
            return firstChild.getText();
          }
        }
        return "";
      }
    };
    AElement = class extends TextElement {
      constructor(document4, node3, captureTextNodes) {
        super(document4, node3, captureTextNodes);
        this.type = "a";
        var {
          childNodes
        } = node3;
        var firstChild = childNodes[0];
        var hasText = childNodes.length > 0 && Array.from(childNodes).every((node4) => node4.nodeType === 3);
        this.hasText = hasText;
        this.text = hasText ? this.getTextFromNode(firstChild) : "";
      }
      getText() {
        return this.text;
      }
      renderChildren(ctx) {
        if (this.hasText) {
          super.renderChildren(ctx);
          var {
            document: document4,
            x: x2,
            y: y3
          } = this;
          var {
            mouse
          } = document4.screen;
          var fontSize = new Property(document4, "fontSize", Font.parse(document4.ctx.font).fontSize);
          if (mouse.isWorking()) {
            mouse.checkBoundingBox(this, new BoundingBox(x2, y3 - fontSize.getPixels("y"), x2 + this.measureText(ctx), y3));
          }
        } else if (this.children.length > 0) {
          var g = new GElement(this.document, null);
          g.children = this.children;
          g.parent = this;
          g.render(ctx);
        }
      }
      onClick() {
        var {
          window: window2
        } = this.document;
        if (window2) {
          window2.open(this.getHrefAttribute().getString());
        }
      }
      onMouseMove() {
        var ctx = this.document.ctx;
        ctx.canvas.style.cursor = "pointer";
      }
    };
    TextPathElement = class extends TextElement {
      constructor(document4, node3, captureTextNodes) {
        super(document4, node3, captureTextNodes);
        this.type = "textPath";
        this.textWidth = 0;
        this.textHeight = 0;
        this.pathLength = -1;
        this.glyphInfo = null;
        this.letterSpacingCache = [];
        this.measuresCache = /* @__PURE__ */ new Map([["", 0]]);
        var pathElement = this.getHrefAttribute().getDefinition();
        this.text = this.getTextFromNode();
        this.dataArray = this.parsePathData(pathElement);
      }
      getText() {
        return this.text;
      }
      path(ctx) {
        var {
          dataArray
        } = this;
        if (ctx) {
          ctx.beginPath();
        }
        dataArray.forEach((_ref) => {
          var {
            type,
            points
          } = _ref;
          switch (type) {
            case PathParser.LINE_TO:
              if (ctx) {
                ctx.lineTo(points[0], points[1]);
              }
              break;
            case PathParser.MOVE_TO:
              if (ctx) {
                ctx.moveTo(points[0], points[1]);
              }
              break;
            case PathParser.CURVE_TO:
              if (ctx) {
                ctx.bezierCurveTo(points[0], points[1], points[2], points[3], points[4], points[5]);
              }
              break;
            case PathParser.QUAD_TO:
              if (ctx) {
                ctx.quadraticCurveTo(points[0], points[1], points[2], points[3]);
              }
              break;
            case PathParser.ARC: {
              var [cx2, cy2, rx2, ry2, theta, dTheta, psi, fs] = points;
              var r2 = rx2 > ry2 ? rx2 : ry2;
              var scaleX = rx2 > ry2 ? 1 : rx2 / ry2;
              var scaleY = rx2 > ry2 ? ry2 / rx2 : 1;
              if (ctx) {
                ctx.translate(cx2, cy2);
                ctx.rotate(psi);
                ctx.scale(scaleX, scaleY);
                ctx.arc(0, 0, r2, theta, theta + dTheta, Boolean(1 - fs));
                ctx.scale(1 / scaleX, 1 / scaleY);
                ctx.rotate(-psi);
                ctx.translate(-cx2, -cy2);
              }
              break;
            }
            case PathParser.CLOSE_PATH:
              if (ctx) {
                ctx.closePath();
              }
              break;
          }
        });
      }
      renderChildren(ctx) {
        this.setTextData(ctx);
        ctx.save();
        var textDecoration = this.parent.getStyle("text-decoration").getString();
        var fontSize = this.getFontSize();
        var {
          glyphInfo
        } = this;
        var fill = ctx.fillStyle;
        if (textDecoration === "underline") {
          ctx.beginPath();
        }
        glyphInfo.forEach((glyph, i2) => {
          var {
            p0,
            p1,
            rotation,
            text: partialText
          } = glyph;
          ctx.save();
          ctx.translate(p0.x, p0.y);
          ctx.rotate(rotation);
          if (ctx.fillStyle) {
            ctx.fillText(partialText, 0, 0);
          }
          if (ctx.strokeStyle) {
            ctx.strokeText(partialText, 0, 0);
          }
          ctx.restore();
          if (textDecoration === "underline") {
            if (i2 === 0) {
              ctx.moveTo(p0.x, p0.y + fontSize / 8);
            }
            ctx.lineTo(p1.x, p1.y + fontSize / 5);
          }
        });
        if (textDecoration === "underline") {
          ctx.lineWidth = fontSize / 20;
          ctx.strokeStyle = fill;
          ctx.stroke();
          ctx.closePath();
        }
        ctx.restore();
      }
      getLetterSpacingAt() {
        var idx = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
        return this.letterSpacingCache[idx] || 0;
      }
      findSegmentToFitChar(ctx, anchor, textFullWidth, fullPathWidth, spacesNumber, inputOffset, dy2, c3, charI) {
        var offset = inputOffset;
        var glyphWidth = this.measureText(ctx, c3);
        if (c3 === " " && anchor === "justify" && textFullWidth < fullPathWidth) {
          glyphWidth += (fullPathWidth - textFullWidth) / spacesNumber;
        }
        if (charI > -1) {
          offset += this.getLetterSpacingAt(charI);
        }
        var splineStep = this.textHeight / 20;
        var p0 = this.getEquidistantPointOnPath(offset, splineStep, 0);
        var p1 = this.getEquidistantPointOnPath(offset + glyphWidth, splineStep, 0);
        var segment = {
          p0,
          p1
        };
        var rotation = p0 && p1 ? Math.atan2(p1.y - p0.y, p1.x - p0.x) : 0;
        if (dy2) {
          var dyX = Math.cos(Math.PI / 2 + rotation) * dy2;
          var dyY = Math.cos(-rotation) * dy2;
          segment.p0 = _objectSpread$2(_objectSpread$2({}, p0), {}, {
            x: p0.x + dyX,
            y: p0.y + dyY
          });
          segment.p1 = _objectSpread$2(_objectSpread$2({}, p1), {}, {
            x: p1.x + dyX,
            y: p1.y + dyY
          });
        }
        offset += glyphWidth;
        return {
          offset,
          segment,
          rotation
        };
      }
      measureText(ctx, text4) {
        var {
          measuresCache
        } = this;
        var targetText = text4 || this.getText();
        if (measuresCache.has(targetText)) {
          return measuresCache.get(targetText);
        }
        var measure = this.measureTargetText(ctx, targetText);
        measuresCache.set(targetText, measure);
        return measure;
      }
      // This method supposes what all custom fonts already loaded.
      // If some font will be loaded after this method call, <textPath> will not be rendered correctly.
      // You need to call this method manually to update glyphs cache.
      setTextData(ctx) {
        if (this.glyphInfo) {
          return;
        }
        var renderText2 = this.getText();
        var chars = renderText2.split("");
        var spacesNumber = renderText2.split(" ").length - 1;
        var dx2 = this.parent.getAttribute("dx").split().map((_2) => _2.getPixels("x"));
        var dy2 = this.parent.getAttribute("dy").getPixels("y");
        var anchor = this.parent.getStyle("text-anchor").getString("start");
        var thisSpacing = this.getStyle("letter-spacing");
        var parentSpacing = this.parent.getStyle("letter-spacing");
        var letterSpacing = 0;
        if (!thisSpacing.hasValue() || thisSpacing.getValue() === "inherit") {
          letterSpacing = parentSpacing.getPixels();
        } else if (thisSpacing.hasValue()) {
          if (thisSpacing.getValue() !== "initial" && thisSpacing.getValue() !== "unset") {
            letterSpacing = thisSpacing.getPixels();
          }
        }
        var letterSpacingCache = [];
        var textLen = renderText2.length;
        this.letterSpacingCache = letterSpacingCache;
        for (var i2 = 0; i2 < textLen; i2++) {
          letterSpacingCache.push(typeof dx2[i2] !== "undefined" ? dx2[i2] : letterSpacing);
        }
        var dxSum = letterSpacingCache.reduce((acc, cur, i3) => i3 === 0 ? 0 : acc + cur || 0, 0);
        var textWidth = this.measureText(ctx);
        var textFullWidth = Math.max(textWidth + dxSum, 0);
        this.textWidth = textWidth;
        this.textHeight = this.getFontSize();
        this.glyphInfo = [];
        var fullPathWidth = this.getPathLength();
        var startOffset = this.getStyle("startOffset").getNumber(0) * fullPathWidth;
        var offset = 0;
        if (anchor === "middle" || anchor === "center") {
          offset = -textFullWidth / 2;
        }
        if (anchor === "end" || anchor === "right") {
          offset = -textFullWidth;
        }
        offset += startOffset;
        chars.forEach((char, i3) => {
          var {
            offset: nextOffset,
            segment,
            rotation
          } = this.findSegmentToFitChar(ctx, anchor, textFullWidth, fullPathWidth, spacesNumber, offset, dy2, char, i3);
          offset = nextOffset;
          if (!segment.p0 || !segment.p1) {
            return;
          }
          this.glyphInfo.push({
            // transposeX: midpoint.x,
            // transposeY: midpoint.y,
            text: chars[i3],
            p0: segment.p0,
            p1: segment.p1,
            rotation
          });
        });
      }
      parsePathData(path2) {
        this.pathLength = -1;
        if (!path2) {
          return [];
        }
        var pathCommands = [];
        var {
          pathParser: pathParser2
        } = path2;
        pathParser2.reset();
        while (!pathParser2.isEnd()) {
          var {
            current
          } = pathParser2;
          var startX = current ? current.x : 0;
          var startY = current ? current.y : 0;
          var command = pathParser2.next();
          var nextCommandType = command.type;
          var points = [];
          switch (command.type) {
            case PathParser.MOVE_TO:
              this.pathM(pathParser2, points);
              break;
            case PathParser.LINE_TO:
              nextCommandType = this.pathL(pathParser2, points);
              break;
            case PathParser.HORIZ_LINE_TO:
              nextCommandType = this.pathH(pathParser2, points);
              break;
            case PathParser.VERT_LINE_TO:
              nextCommandType = this.pathV(pathParser2, points);
              break;
            case PathParser.CURVE_TO:
              this.pathC(pathParser2, points);
              break;
            case PathParser.SMOOTH_CURVE_TO:
              nextCommandType = this.pathS(pathParser2, points);
              break;
            case PathParser.QUAD_TO:
              this.pathQ(pathParser2, points);
              break;
            case PathParser.SMOOTH_QUAD_TO:
              nextCommandType = this.pathT(pathParser2, points);
              break;
            case PathParser.ARC:
              points = this.pathA(pathParser2);
              break;
            case PathParser.CLOSE_PATH:
              PathElement.pathZ(pathParser2);
              break;
          }
          if (command.type !== PathParser.CLOSE_PATH) {
            pathCommands.push({
              type: nextCommandType,
              points,
              start: {
                x: startX,
                y: startY
              },
              pathLength: this.calcLength(startX, startY, nextCommandType, points)
            });
          } else {
            pathCommands.push({
              type: PathParser.CLOSE_PATH,
              points: [],
              pathLength: 0
            });
          }
        }
        return pathCommands;
      }
      pathM(pathParser2, points) {
        var {
          x: x2,
          y: y3
        } = PathElement.pathM(pathParser2).point;
        points.push(x2, y3);
      }
      pathL(pathParser2, points) {
        var {
          x: x2,
          y: y3
        } = PathElement.pathL(pathParser2).point;
        points.push(x2, y3);
        return PathParser.LINE_TO;
      }
      pathH(pathParser2, points) {
        var {
          x: x2,
          y: y3
        } = PathElement.pathH(pathParser2).point;
        points.push(x2, y3);
        return PathParser.LINE_TO;
      }
      pathV(pathParser2, points) {
        var {
          x: x2,
          y: y3
        } = PathElement.pathV(pathParser2).point;
        points.push(x2, y3);
        return PathParser.LINE_TO;
      }
      pathC(pathParser2, points) {
        var {
          point: point4,
          controlPoint,
          currentPoint
        } = PathElement.pathC(pathParser2);
        points.push(point4.x, point4.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);
      }
      pathS(pathParser2, points) {
        var {
          point: point4,
          controlPoint,
          currentPoint
        } = PathElement.pathS(pathParser2);
        points.push(point4.x, point4.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);
        return PathParser.CURVE_TO;
      }
      pathQ(pathParser2, points) {
        var {
          controlPoint,
          currentPoint
        } = PathElement.pathQ(pathParser2);
        points.push(controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);
      }
      pathT(pathParser2, points) {
        var {
          controlPoint,
          currentPoint
        } = PathElement.pathT(pathParser2);
        points.push(controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);
        return PathParser.QUAD_TO;
      }
      pathA(pathParser2) {
        var {
          rX,
          rY,
          sweepFlag,
          xAxisRotation,
          centp,
          a1,
          ad
        } = PathElement.pathA(pathParser2);
        if (sweepFlag === 0 && ad > 0) {
          ad -= 2 * Math.PI;
        }
        if (sweepFlag === 1 && ad < 0) {
          ad += 2 * Math.PI;
        }
        return [centp.x, centp.y, rX, rY, a1, ad, xAxisRotation, sweepFlag];
      }
      calcLength(x2, y3, commandType, points) {
        var len = 0;
        var p1 = null;
        var p2 = null;
        var t2 = 0;
        switch (commandType) {
          case PathParser.LINE_TO:
            return this.getLineLength(x2, y3, points[0], points[1]);
          case PathParser.CURVE_TO:
            len = 0;
            p1 = this.getPointOnCubicBezier(0, x2, y3, points[0], points[1], points[2], points[3], points[4], points[5]);
            for (t2 = 0.01; t2 <= 1; t2 += 0.01) {
              p2 = this.getPointOnCubicBezier(t2, x2, y3, points[0], points[1], points[2], points[3], points[4], points[5]);
              len += this.getLineLength(p1.x, p1.y, p2.x, p2.y);
              p1 = p2;
            }
            return len;
          case PathParser.QUAD_TO:
            len = 0;
            p1 = this.getPointOnQuadraticBezier(0, x2, y3, points[0], points[1], points[2], points[3]);
            for (t2 = 0.01; t2 <= 1; t2 += 0.01) {
              p2 = this.getPointOnQuadraticBezier(t2, x2, y3, points[0], points[1], points[2], points[3]);
              len += this.getLineLength(p1.x, p1.y, p2.x, p2.y);
              p1 = p2;
            }
            return len;
          case PathParser.ARC: {
            len = 0;
            var start = points[4];
            var dTheta = points[5];
            var end = points[4] + dTheta;
            var inc = Math.PI / 180;
            if (Math.abs(start - end) < inc) {
              inc = Math.abs(start - end);
            }
            p1 = this.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], start, 0);
            if (dTheta < 0) {
              for (t2 = start - inc; t2 > end; t2 -= inc) {
                p2 = this.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], t2, 0);
                len += this.getLineLength(p1.x, p1.y, p2.x, p2.y);
                p1 = p2;
              }
            } else {
              for (t2 = start + inc; t2 < end; t2 += inc) {
                p2 = this.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], t2, 0);
                len += this.getLineLength(p1.x, p1.y, p2.x, p2.y);
                p1 = p2;
              }
            }
            p2 = this.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], end, 0);
            len += this.getLineLength(p1.x, p1.y, p2.x, p2.y);
            return len;
          }
        }
        return 0;
      }
      getPointOnLine(dist, p1x, p1y, p2x, p2y) {
        var fromX = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : p1x;
        var fromY = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : p1y;
        var m3 = (p2y - p1y) / (p2x - p1x + PSEUDO_ZERO);
        var run = Math.sqrt(dist * dist / (1 + m3 * m3));
        if (p2x < p1x) {
          run *= -1;
        }
        var rise = m3 * run;
        var pt = null;
        if (p2x === p1x) {
          pt = {
            x: fromX,
            y: fromY + rise
          };
        } else if ((fromY - p1y) / (fromX - p1x + PSEUDO_ZERO) === m3) {
          pt = {
            x: fromX + run,
            y: fromY + rise
          };
        } else {
          var ix = 0;
          var iy = 0;
          var len = this.getLineLength(p1x, p1y, p2x, p2y);
          if (len < PSEUDO_ZERO) {
            return null;
          }
          var u2 = (fromX - p1x) * (p2x - p1x) + (fromY - p1y) * (p2y - p1y);
          u2 /= len * len;
          ix = p1x + u2 * (p2x - p1x);
          iy = p1y + u2 * (p2y - p1y);
          var pRise = this.getLineLength(fromX, fromY, ix, iy);
          var pRun = Math.sqrt(dist * dist - pRise * pRise);
          run = Math.sqrt(pRun * pRun / (1 + m3 * m3));
          if (p2x < p1x) {
            run *= -1;
          }
          rise = m3 * run;
          pt = {
            x: ix + run,
            y: iy + rise
          };
        }
        return pt;
      }
      getPointOnPath(distance) {
        var fullLen = this.getPathLength();
        var cumulativePathLength = 0;
        var p2 = null;
        if (distance < -5e-5 || distance - 5e-5 > fullLen) {
          return null;
        }
        var {
          dataArray
        } = this;
        for (var command of dataArray) {
          if (command && (command.pathLength < 5e-5 || cumulativePathLength + command.pathLength + 5e-5 < distance)) {
            cumulativePathLength += command.pathLength;
            continue;
          }
          var delta = distance - cumulativePathLength;
          var currentT = 0;
          switch (command.type) {
            case PathParser.LINE_TO:
              p2 = this.getPointOnLine(delta, command.start.x, command.start.y, command.points[0], command.points[1], command.start.x, command.start.y);
              break;
            case PathParser.ARC: {
              var start = command.points[4];
              var dTheta = command.points[5];
              var end = command.points[4] + dTheta;
              currentT = start + delta / command.pathLength * dTheta;
              if (dTheta < 0 && currentT < end || dTheta >= 0 && currentT > end) {
                break;
              }
              p2 = this.getPointOnEllipticalArc(command.points[0], command.points[1], command.points[2], command.points[3], currentT, command.points[6]);
              break;
            }
            case PathParser.CURVE_TO:
              currentT = delta / command.pathLength;
              if (currentT > 1) {
                currentT = 1;
              }
              p2 = this.getPointOnCubicBezier(currentT, command.start.x, command.start.y, command.points[0], command.points[1], command.points[2], command.points[3], command.points[4], command.points[5]);
              break;
            case PathParser.QUAD_TO:
              currentT = delta / command.pathLength;
              if (currentT > 1) {
                currentT = 1;
              }
              p2 = this.getPointOnQuadraticBezier(currentT, command.start.x, command.start.y, command.points[0], command.points[1], command.points[2], command.points[3]);
              break;
          }
          if (p2) {
            return p2;
          }
          break;
        }
        return null;
      }
      getLineLength(x1, y1, x2, y22) {
        return Math.sqrt((x2 - x1) * (x2 - x1) + (y22 - y1) * (y22 - y1));
      }
      getPathLength() {
        if (this.pathLength === -1) {
          this.pathLength = this.dataArray.reduce((length2, command) => command.pathLength > 0 ? length2 + command.pathLength : length2, 0);
        }
        return this.pathLength;
      }
      getPointOnCubicBezier(pct, p1x, p1y, p2x, p2y, p3x, p3y, p4x, p4y) {
        var x2 = p4x * CB1(pct) + p3x * CB2(pct) + p2x * CB3(pct) + p1x * CB4(pct);
        var y3 = p4y * CB1(pct) + p3y * CB2(pct) + p2y * CB3(pct) + p1y * CB4(pct);
        return {
          x: x2,
          y: y3
        };
      }
      getPointOnQuadraticBezier(pct, p1x, p1y, p2x, p2y, p3x, p3y) {
        var x2 = p3x * QB1(pct) + p2x * QB2(pct) + p1x * QB3(pct);
        var y3 = p3y * QB1(pct) + p2y * QB2(pct) + p1y * QB3(pct);
        return {
          x: x2,
          y: y3
        };
      }
      getPointOnEllipticalArc(cx2, cy2, rx2, ry2, theta, psi) {
        var cosPsi = Math.cos(psi);
        var sinPsi = Math.sin(psi);
        var pt = {
          x: rx2 * Math.cos(theta),
          y: ry2 * Math.sin(theta)
        };
        return {
          x: cx2 + (pt.x * cosPsi - pt.y * sinPsi),
          y: cy2 + (pt.x * sinPsi + pt.y * cosPsi)
        };
      }
      // TODO need some optimisations. possibly build cache only for curved segments?
      buildEquidistantCache(inputStep, inputPrecision) {
        var fullLen = this.getPathLength();
        var precision = inputPrecision || 0.25;
        var step = inputStep || fullLen / 100;
        if (!this.equidistantCache || this.equidistantCache.step !== step || this.equidistantCache.precision !== precision) {
          this.equidistantCache = {
            step,
            precision,
            points: []
          };
          var s2 = 0;
          for (var l2 = 0; l2 <= fullLen; l2 += precision) {
            var p0 = this.getPointOnPath(l2);
            var p1 = this.getPointOnPath(l2 + precision);
            if (!p0 || !p1) {
              continue;
            }
            s2 += this.getLineLength(p0.x, p0.y, p1.x, p1.y);
            if (s2 >= step) {
              this.equidistantCache.points.push({
                x: p0.x,
                y: p0.y,
                distance: l2
              });
              s2 -= step;
            }
          }
        }
      }
      getEquidistantPointOnPath(targetDistance, step, precision) {
        this.buildEquidistantCache(step, precision);
        if (targetDistance < 0 || targetDistance - this.getPathLength() > 5e-5) {
          return null;
        }
        var idx = Math.round(targetDistance / this.getPathLength() * (this.equidistantCache.points.length - 1));
        return this.equidistantCache.points[idx] || null;
      }
    };
    dataUriRegex = /^\s*data:(([^/,;]+\/[^/,;]+)(?:;([^,;=]+=[^,;=]+))?)?(?:;(base64))?,(.*)$/i;
    ImageElement = class extends RenderedElement {
      constructor(document4, node3, captureTextNodes) {
        super(document4, node3, captureTextNodes);
        this.type = "image";
        this.loaded = false;
        var href = this.getHrefAttribute().getString();
        if (!href) {
          return;
        }
        var isSvg = href.endsWith(".svg") || /^\s*data:image\/svg\+xml/i.test(href);
        document4.images.push(this);
        if (!isSvg) {
          void this.loadImage(href);
        } else {
          void this.loadSvg(href);
        }
        this.isSvg = isSvg;
      }
      loadImage(href) {
        var _this = this;
        return _asyncToGenerator(function* () {
          try {
            var image = yield _this.document.createImage(href);
            _this.image = image;
          } catch (err) {
            console.error('Error while loading image "'.concat(href, '":'), err);
          }
          _this.loaded = true;
        })();
      }
      loadSvg(href) {
        var _this2 = this;
        return _asyncToGenerator(function* () {
          var match = dataUriRegex.exec(href);
          if (match) {
            var data2 = match[5];
            if (match[4] === "base64") {
              _this2.image = atob(data2);
            } else {
              _this2.image = decodeURIComponent(data2);
            }
          } else {
            try {
              var response = yield _this2.document.fetch(href);
              var svg2 = yield response.text();
              _this2.image = svg2;
            } catch (err) {
              console.error('Error while loading image "'.concat(href, '":'), err);
            }
          }
          _this2.loaded = true;
        })();
      }
      renderChildren(ctx) {
        var {
          document: document4,
          image,
          loaded
        } = this;
        var x2 = this.getAttribute("x").getPixels("x");
        var y3 = this.getAttribute("y").getPixels("y");
        var width2 = this.getStyle("width").getPixels("x");
        var height2 = this.getStyle("height").getPixels("y");
        if (!loaded || !image || !width2 || !height2) {
          return;
        }
        ctx.save();
        ctx.translate(x2, y3);
        if (this.isSvg) {
          var subDocument = document4.canvg.forkString(ctx, this.image, {
            ignoreMouse: true,
            ignoreAnimation: true,
            ignoreDimensions: true,
            ignoreClear: true,
            offsetX: 0,
            offsetY: 0,
            scaleWidth: width2,
            scaleHeight: height2
          });
          subDocument.document.documentElement.parent = this;
          void subDocument.render();
        } else {
          var _image = this.image;
          document4.setViewBox({
            ctx,
            aspectRatio: this.getAttribute("preserveAspectRatio").getString(),
            width: width2,
            desiredWidth: _image.width,
            height: height2,
            desiredHeight: _image.height
          });
          if (this.loaded) {
            if (typeof _image.complete === "undefined" || _image.complete) {
              ctx.drawImage(_image, 0, 0);
            }
          }
        }
        ctx.restore();
      }
      getBoundingBox() {
        var x2 = this.getAttribute("x").getPixels("x");
        var y3 = this.getAttribute("y").getPixels("y");
        var width2 = this.getStyle("width").getPixels("x");
        var height2 = this.getStyle("height").getPixels("y");
        return new BoundingBox(x2, y3, x2 + width2, y3 + height2);
      }
    };
    SymbolElement = class extends RenderedElement {
      constructor() {
        super(...arguments);
        this.type = "symbol";
      }
      render(_2) {
      }
    };
    SVGFontLoader = class {
      constructor(document4) {
        this.document = document4;
        this.loaded = false;
        document4.fonts.push(this);
      }
      load(fontFamily, url) {
        var _this = this;
        return _asyncToGenerator(function* () {
          try {
            var {
              document: document4
            } = _this;
            var svgDocument = yield document4.canvg.parser.load(url);
            var fonts = svgDocument.getElementsByTagName("font");
            Array.from(fonts).forEach((fontNode) => {
              var font = document4.createElement(fontNode);
              document4.definitions[fontFamily] = font;
            });
          } catch (err) {
            console.error('Error while loading font "'.concat(url, '":'), err);
          }
          _this.loaded = true;
        })();
      }
    };
    StyleElement = class extends Element2 {
      constructor(document4, node3, captureTextNodes) {
        super(document4, node3, captureTextNodes);
        this.type = "style";
        var css2 = compressSpaces(
          Array.from(node3.childNodes).map((_2) => _2.textContent).join("").replace(/(\/\*([^*]|[\r\n]|(\*+([^*/]|[\r\n])))*\*+\/)|(^[\s]*\/\/.*)/gm, "").replace(/@import.*;/g, "")
          // remove imports
        );
        var cssDefs = css2.split("}");
        cssDefs.forEach((_2) => {
          var def = _2.trim();
          if (!def) {
            return;
          }
          var cssParts = def.split("{");
          var cssClasses = cssParts[0].split(",");
          var cssProps = cssParts[1].split(";");
          cssClasses.forEach((_3) => {
            var cssClass = _3.trim();
            if (!cssClass) {
              return;
            }
            var props = document4.styles[cssClass] || {};
            cssProps.forEach((cssProp) => {
              var prop = cssProp.indexOf(":");
              var name = cssProp.substr(0, prop).trim();
              var value = cssProp.substr(prop + 1, cssProp.length - prop).trim();
              if (name && value) {
                props[name] = new Property(document4, name, value);
              }
            });
            document4.styles[cssClass] = props;
            document4.stylesSpecificity[cssClass] = getSelectorSpecificity(cssClass);
            if (cssClass === "@font-face") {
              var fontFamily = props["font-family"].getString().replace(/"|'/g, "");
              var srcs = props.src.getString().split(",");
              srcs.forEach((src) => {
                if (src.indexOf('format("svg")') > 0) {
                  var url = parseExternalUrl(src);
                  if (url) {
                    void new SVGFontLoader(document4).load(fontFamily, url);
                  }
                }
              });
            }
          });
        });
      }
    };
    StyleElement.parseExternalUrl = parseExternalUrl;
    UseElement = class extends RenderedElement {
      constructor() {
        super(...arguments);
        this.type = "use";
      }
      setContext(ctx) {
        super.setContext(ctx);
        var xAttr = this.getAttribute("x");
        var yAttr = this.getAttribute("y");
        if (xAttr.hasValue()) {
          ctx.translate(xAttr.getPixels("x"), 0);
        }
        if (yAttr.hasValue()) {
          ctx.translate(0, yAttr.getPixels("y"));
        }
      }
      path(ctx) {
        var {
          element: element2
        } = this;
        if (element2) {
          element2.path(ctx);
        }
      }
      renderChildren(ctx) {
        var {
          document: document4,
          element: element2
        } = this;
        if (element2) {
          var tempSvg = element2;
          if (element2.type === "symbol") {
            tempSvg = new SVGElement(document4, null);
            tempSvg.attributes.viewBox = new Property(document4, "viewBox", element2.getAttribute("viewBox").getString());
            tempSvg.attributes.preserveAspectRatio = new Property(document4, "preserveAspectRatio", element2.getAttribute("preserveAspectRatio").getString());
            tempSvg.attributes.overflow = new Property(document4, "overflow", element2.getAttribute("overflow").getString());
            tempSvg.children = element2.children;
            element2.styles.opacity = new Property(document4, "opacity", this.calculateOpacity());
          }
          if (tempSvg.type === "svg") {
            var widthStyle = this.getStyle("width", false, true);
            var heightStyle = this.getStyle("height", false, true);
            if (widthStyle.hasValue()) {
              tempSvg.attributes.width = new Property(document4, "width", widthStyle.getString());
            }
            if (heightStyle.hasValue()) {
              tempSvg.attributes.height = new Property(document4, "height", heightStyle.getString());
            }
          }
          var oldParent = tempSvg.parent;
          tempSvg.parent = this;
          tempSvg.render(ctx);
          tempSvg.parent = oldParent;
        }
      }
      getBoundingBox(ctx) {
        var {
          element: element2
        } = this;
        if (element2) {
          return element2.getBoundingBox(ctx);
        }
        return null;
      }
      elementTransform() {
        var {
          document: document4,
          element: element2
        } = this;
        return Transform.fromElement(document4, element2);
      }
      get element() {
        if (!this.cachedElement) {
          this.cachedElement = this.getHrefAttribute().getDefinition();
        }
        return this.cachedElement;
      }
    };
    FeColorMatrixElement = class extends Element2 {
      constructor(document4, node3, captureTextNodes) {
        super(document4, node3, captureTextNodes);
        this.type = "feColorMatrix";
        var matrix = toNumbers(this.getAttribute("values").getString());
        switch (this.getAttribute("type").getString("matrix")) {
          case "saturate": {
            var s2 = matrix[0];
            matrix = [0.213 + 0.787 * s2, 0.715 - 0.715 * s2, 0.072 - 0.072 * s2, 0, 0, 0.213 - 0.213 * s2, 0.715 + 0.285 * s2, 0.072 - 0.072 * s2, 0, 0, 0.213 - 0.213 * s2, 0.715 - 0.715 * s2, 0.072 + 0.928 * s2, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1];
            break;
          }
          case "hueRotate": {
            var a2 = matrix[0] * Math.PI / 180;
            matrix = [c2(a2, 0.213, 0.787, -0.213), c2(a2, 0.715, -0.715, -0.715), c2(a2, 0.072, -0.072, 0.928), 0, 0, c2(a2, 0.213, -0.213, 0.143), c2(a2, 0.715, 0.285, 0.14), c2(a2, 0.072, -0.072, -0.283), 0, 0, c2(a2, 0.213, -0.213, -0.787), c2(a2, 0.715, -0.715, 0.715), c2(a2, 0.072, 0.928, 0.072), 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1];
            break;
          }
          case "luminanceToAlpha":
            matrix = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.2125, 0.7154, 0.0721, 0, 0, 0, 0, 0, 0, 1];
            break;
        }
        this.matrix = matrix;
        this.includeOpacity = this.getAttribute("includeOpacity").hasValue();
      }
      apply(ctx, _x, _y, width2, height2) {
        var {
          includeOpacity,
          matrix
        } = this;
        var srcData = ctx.getImageData(0, 0, width2, height2);
        for (var y3 = 0; y3 < height2; y3++) {
          for (var x2 = 0; x2 < width2; x2++) {
            var r2 = imGet(srcData.data, x2, y3, width2, height2, 0);
            var g = imGet(srcData.data, x2, y3, width2, height2, 1);
            var b = imGet(srcData.data, x2, y3, width2, height2, 2);
            var a2 = imGet(srcData.data, x2, y3, width2, height2, 3);
            var nr = m2(matrix, 0, r2) + m2(matrix, 1, g) + m2(matrix, 2, b) + m2(matrix, 3, a2) + m2(matrix, 4, 1);
            var ng = m2(matrix, 5, r2) + m2(matrix, 6, g) + m2(matrix, 7, b) + m2(matrix, 8, a2) + m2(matrix, 9, 1);
            var nb = m2(matrix, 10, r2) + m2(matrix, 11, g) + m2(matrix, 12, b) + m2(matrix, 13, a2) + m2(matrix, 14, 1);
            var na = m2(matrix, 15, r2) + m2(matrix, 16, g) + m2(matrix, 17, b) + m2(matrix, 18, a2) + m2(matrix, 19, 1);
            if (includeOpacity) {
              nr = 0;
              ng = 0;
              nb = 0;
              na *= a2 / 255;
            }
            imSet(srcData.data, x2, y3, width2, height2, 0, nr);
            imSet(srcData.data, x2, y3, width2, height2, 1, ng);
            imSet(srcData.data, x2, y3, width2, height2, 2, nb);
            imSet(srcData.data, x2, y3, width2, height2, 3, na);
          }
        }
        ctx.clearRect(0, 0, width2, height2);
        ctx.putImageData(srcData, 0, 0);
      }
    };
    MaskElement = class extends Element2 {
      constructor() {
        super(...arguments);
        this.type = "mask";
      }
      apply(ctx, element2) {
        var {
          document: document4
        } = this;
        var x2 = this.getAttribute("x").getPixels("x");
        var y3 = this.getAttribute("y").getPixels("y");
        var width2 = this.getStyle("width").getPixels("x");
        var height2 = this.getStyle("height").getPixels("y");
        if (!width2 && !height2) {
          var boundingBox = new BoundingBox();
          this.children.forEach((child) => {
            boundingBox.addBoundingBox(child.getBoundingBox(ctx));
          });
          x2 = Math.floor(boundingBox.x1);
          y3 = Math.floor(boundingBox.y1);
          width2 = Math.floor(boundingBox.width);
          height2 = Math.floor(boundingBox.height);
        }
        var ignoredStyles = this.removeStyles(element2, MaskElement.ignoreStyles);
        var maskCanvas = document4.createCanvas(x2 + width2, y3 + height2);
        var maskCtx = maskCanvas.getContext("2d");
        document4.screen.setDefaults(maskCtx);
        this.renderChildren(maskCtx);
        new FeColorMatrixElement(document4, {
          nodeType: 1,
          childNodes: [],
          attributes: [{
            nodeName: "type",
            value: "luminanceToAlpha"
          }, {
            nodeName: "includeOpacity",
            value: "true"
          }]
        }).apply(maskCtx, 0, 0, x2 + width2, y3 + height2);
        var tmpCanvas = document4.createCanvas(x2 + width2, y3 + height2);
        var tmpCtx = tmpCanvas.getContext("2d");
        document4.screen.setDefaults(tmpCtx);
        element2.render(tmpCtx);
        tmpCtx.globalCompositeOperation = "destination-in";
        tmpCtx.fillStyle = maskCtx.createPattern(maskCanvas, "no-repeat");
        tmpCtx.fillRect(0, 0, x2 + width2, y3 + height2);
        ctx.fillStyle = tmpCtx.createPattern(tmpCanvas, "no-repeat");
        ctx.fillRect(0, 0, x2 + width2, y3 + height2);
        this.restoreStyles(element2, ignoredStyles);
      }
      render(_2) {
      }
    };
    MaskElement.ignoreStyles = ["mask", "transform", "clip-path"];
    noop2 = () => {
    };
    ClipPathElement = class extends Element2 {
      constructor() {
        super(...arguments);
        this.type = "clipPath";
      }
      apply(ctx) {
        var {
          document: document4
        } = this;
        var contextProto = Reflect.getPrototypeOf(ctx);
        var {
          beginPath,
          closePath
        } = ctx;
        if (contextProto) {
          contextProto.beginPath = noop2;
          contextProto.closePath = noop2;
        }
        Reflect.apply(beginPath, ctx, []);
        this.children.forEach((child) => {
          if (typeof child.path === "undefined") {
            return;
          }
          var transform2 = typeof child.elementTransform !== "undefined" ? child.elementTransform() : null;
          if (!transform2) {
            transform2 = Transform.fromElement(document4, child);
          }
          if (transform2) {
            transform2.apply(ctx);
          }
          child.path(ctx);
          if (contextProto) {
            contextProto.closePath = closePath;
          }
          if (transform2) {
            transform2.unapply(ctx);
          }
        });
        Reflect.apply(closePath, ctx, []);
        ctx.clip();
        if (contextProto) {
          contextProto.beginPath = beginPath;
          contextProto.closePath = closePath;
        }
      }
      render(_2) {
      }
    };
    FilterElement = class extends Element2 {
      constructor() {
        super(...arguments);
        this.type = "filter";
      }
      apply(ctx, element2) {
        var {
          document: document4,
          children
        } = this;
        var boundingBox = element2.getBoundingBox(ctx);
        if (!boundingBox) {
          return;
        }
        var px = 0;
        var py = 0;
        children.forEach((child) => {
          var efd = child.extraFilterDistance || 0;
          px = Math.max(px, efd);
          py = Math.max(py, efd);
        });
        var width2 = Math.floor(boundingBox.width);
        var height2 = Math.floor(boundingBox.height);
        var tmpCanvasWidth = width2 + 2 * px;
        var tmpCanvasHeight = height2 + 2 * py;
        if (tmpCanvasWidth < 1 || tmpCanvasHeight < 1) {
          return;
        }
        var x2 = Math.floor(boundingBox.x);
        var y3 = Math.floor(boundingBox.y);
        var ignoredStyles = this.removeStyles(element2, FilterElement.ignoreStyles);
        var tmpCanvas = document4.createCanvas(tmpCanvasWidth, tmpCanvasHeight);
        var tmpCtx = tmpCanvas.getContext("2d");
        document4.screen.setDefaults(tmpCtx);
        tmpCtx.translate(-x2 + px, -y3 + py);
        element2.render(tmpCtx);
        children.forEach((child) => {
          if (typeof child.apply === "function") {
            child.apply(tmpCtx, 0, 0, tmpCanvasWidth, tmpCanvasHeight);
          }
        });
        ctx.drawImage(tmpCanvas, 0, 0, tmpCanvasWidth, tmpCanvasHeight, x2 - px, y3 - py, tmpCanvasWidth, tmpCanvasHeight);
        this.restoreStyles(element2, ignoredStyles);
      }
      render(_2) {
      }
    };
    FilterElement.ignoreStyles = ["filter", "transform", "clip-path"];
    FeDropShadowElement = class extends Element2 {
      constructor(document4, node3, captureTextNodes) {
        super(document4, node3, captureTextNodes);
        this.type = "feDropShadow";
        this.addStylesFromStyleDefinition();
      }
      apply(_2, _x, _y, _width, _height) {
      }
    };
    FeMorphologyElement = class extends Element2 {
      constructor() {
        super(...arguments);
        this.type = "feMorphology";
      }
      apply(_2, _x, _y, _width, _height) {
      }
    };
    FeCompositeElement = class extends Element2 {
      constructor() {
        super(...arguments);
        this.type = "feComposite";
      }
      apply(_2, _x, _y, _width, _height) {
      }
    };
    FeGaussianBlurElement = class extends Element2 {
      constructor(document4, node3, captureTextNodes) {
        super(document4, node3, captureTextNodes);
        this.type = "feGaussianBlur";
        this.blurRadius = Math.floor(this.getAttribute("stdDeviation").getNumber());
        this.extraFilterDistance = this.blurRadius;
      }
      apply(ctx, x2, y3, width2, height2) {
        var {
          document: document4,
          blurRadius
        } = this;
        var body = document4.window ? document4.window.document.body : null;
        var canvas = ctx.canvas;
        canvas.id = document4.getUniqueId();
        if (body) {
          canvas.style.display = "none";
          body.appendChild(canvas);
        }
        processCanvasRGBA(canvas, x2, y3, width2, height2, blurRadius);
        if (body) {
          body.removeChild(canvas);
        }
      }
    };
    TitleElement = class extends Element2 {
      constructor() {
        super(...arguments);
        this.type = "title";
      }
    };
    DescElement = class extends Element2 {
      constructor() {
        super(...arguments);
        this.type = "desc";
      }
    };
    elements2 = {
      "svg": SVGElement,
      "rect": RectElement,
      "circle": CircleElement,
      "ellipse": EllipseElement,
      "line": LineElement,
      "polyline": PolylineElement,
      "polygon": PolygonElement,
      "path": PathElement,
      "pattern": PatternElement,
      "marker": MarkerElement,
      "defs": DefsElement,
      "linearGradient": LinearGradientElement,
      "radialGradient": RadialGradientElement,
      "stop": StopElement,
      "animate": AnimateElement,
      "animateColor": AnimateColorElement,
      "animateTransform": AnimateTransformElement,
      "font": FontElement,
      "font-face": FontFaceElement,
      "missing-glyph": MissingGlyphElement,
      "glyph": GlyphElement,
      "text": TextElement,
      "tspan": TSpanElement,
      "tref": TRefElement,
      "a": AElement,
      "textPath": TextPathElement,
      "image": ImageElement,
      "g": GElement,
      "symbol": SymbolElement,
      "style": StyleElement,
      "use": UseElement,
      "mask": MaskElement,
      "clipPath": ClipPathElement,
      "filter": FilterElement,
      "feDropShadow": FeDropShadowElement,
      "feMorphology": FeMorphologyElement,
      "feComposite": FeCompositeElement,
      "feColorMatrix": FeColorMatrixElement,
      "feGaussianBlur": FeGaussianBlurElement,
      "title": TitleElement,
      "desc": DescElement
    };
    Document = class {
      constructor(canvg) {
        var {
          rootEmSize = 12,
          emSize = 12,
          createCanvas: createCanvas2 = Document.createCanvas,
          createImage: createImage2 = Document.createImage,
          anonymousCrossOrigin
        } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        this.canvg = canvg;
        this.definitions = {};
        this.styles = {};
        this.stylesSpecificity = {};
        this.images = [];
        this.fonts = [];
        this.emSizeStack = [];
        this.uniqueId = 0;
        this.screen = canvg.screen;
        this.rootEmSize = rootEmSize;
        this.emSize = emSize;
        this.createCanvas = createCanvas2;
        this.createImage = this.bindCreateImage(createImage2, anonymousCrossOrigin);
        this.screen.wait(this.isImagesLoaded.bind(this));
        this.screen.wait(this.isFontsLoaded.bind(this));
      }
      bindCreateImage(createImage2, anonymousCrossOrigin) {
        if (typeof anonymousCrossOrigin === "boolean") {
          return (source, forceAnonymousCrossOrigin) => createImage2(source, typeof forceAnonymousCrossOrigin === "boolean" ? forceAnonymousCrossOrigin : anonymousCrossOrigin);
        }
        return createImage2;
      }
      get window() {
        return this.screen.window;
      }
      get fetch() {
        return this.screen.fetch;
      }
      get ctx() {
        return this.screen.ctx;
      }
      get emSize() {
        var {
          emSizeStack
        } = this;
        return emSizeStack[emSizeStack.length - 1];
      }
      set emSize(value) {
        var {
          emSizeStack
        } = this;
        emSizeStack.push(value);
      }
      popEmSize() {
        var {
          emSizeStack
        } = this;
        emSizeStack.pop();
      }
      getUniqueId() {
        return "canvg".concat(++this.uniqueId);
      }
      isImagesLoaded() {
        return this.images.every((_2) => _2.loaded);
      }
      isFontsLoaded() {
        return this.fonts.every((_2) => _2.loaded);
      }
      createDocumentElement(document4) {
        var documentElement = this.createElement(document4.documentElement);
        documentElement.root = true;
        documentElement.addStylesFromStyleDefinition();
        this.documentElement = documentElement;
        return documentElement;
      }
      createElement(node3) {
        var elementType = node3.nodeName.replace(/^[^:]+:/, "");
        var ElementType = Document.elementTypes[elementType];
        if (typeof ElementType !== "undefined") {
          return new ElementType(this, node3);
        }
        return new UnknownElement(this, node3);
      }
      createTextNode(node3) {
        return new TextNode(this, node3);
      }
      setViewBox(config) {
        this.screen.setViewBox(_objectSpread$1({
          document: this
        }, config));
      }
    };
    Document.createCanvas = createCanvas;
    Document.createImage = createImage;
    Document.elementTypes = elements2;
    Canvg = class {
      /**
       * Main constructor.
       * @param ctx - Rendering context.
       * @param svg - SVG Document.
       * @param options - Rendering options.
       */
      constructor(ctx, svg2) {
        var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        this.parser = new Parser(options);
        this.screen = new Screen(ctx, options);
        this.options = options;
        var document4 = new Document(this, options);
        var documentElement = document4.createDocumentElement(svg2);
        this.document = document4;
        this.documentElement = documentElement;
      }
      /**
       * Create Canvg instance from SVG source string or URL.
       * @param ctx - Rendering context.
       * @param svg - SVG source string or URL.
       * @param options - Rendering options.
       * @returns Canvg instance.
       */
      static from(ctx, svg2) {
        var _arguments = arguments;
        return _asyncToGenerator(function* () {
          var options = _arguments.length > 2 && _arguments[2] !== void 0 ? _arguments[2] : {};
          var parser2 = new Parser(options);
          var svgDocument = yield parser2.parse(svg2);
          return new Canvg(ctx, svgDocument, options);
        })();
      }
      /**
       * Create Canvg instance from SVG source string.
       * @param ctx - Rendering context.
       * @param svg - SVG source string.
       * @param options - Rendering options.
       * @returns Canvg instance.
       */
      static fromString(ctx, svg2) {
        var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        var parser2 = new Parser(options);
        var svgDocument = parser2.parseFromString(svg2);
        return new Canvg(ctx, svgDocument, options);
      }
      /**
       * Create new Canvg instance with inherited options.
       * @param ctx - Rendering context.
       * @param svg - SVG source string or URL.
       * @param options - Rendering options.
       * @returns Canvg instance.
       */
      fork(ctx, svg2) {
        var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        return Canvg.from(ctx, svg2, _objectSpread(_objectSpread({}, this.options), options));
      }
      /**
       * Create new Canvg instance with inherited options.
       * @param ctx - Rendering context.
       * @param svg - SVG source string.
       * @param options - Rendering options.
       * @returns Canvg instance.
       */
      forkString(ctx, svg2) {
        var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        return Canvg.fromString(ctx, svg2, _objectSpread(_objectSpread({}, this.options), options));
      }
      /**
       * Document is ready promise.
       * @returns Ready promise.
       */
      ready() {
        return this.screen.ready();
      }
      /**
       * Document is ready value.
       * @returns Is ready or not.
       */
      isReady() {
        return this.screen.isReady();
      }
      /**
       * Render only first frame, ignoring animations and mouse.
       * @param options - Rendering options.
       */
      render() {
        var _arguments2 = arguments, _this = this;
        return _asyncToGenerator(function* () {
          var options = _arguments2.length > 0 && _arguments2[0] !== void 0 ? _arguments2[0] : {};
          _this.start(_objectSpread({
            enableRedraw: true,
            ignoreAnimation: true,
            ignoreMouse: true
          }, options));
          yield _this.ready();
          _this.stop();
        })();
      }
      /**
       * Start rendering.
       * @param options - Render options.
       */
      start() {
        var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        var {
          documentElement,
          screen,
          options: baseOptions
        } = this;
        screen.start(documentElement, _objectSpread(_objectSpread({
          enableRedraw: true
        }, baseOptions), options));
      }
      /**
       * Stop rendering.
       */
      stop() {
        this.screen.stop();
      }
      /**
       * Resize SVG to fit in given size.
       * @param width
       * @param height
       * @param preserveAspectRatio
       */
      resize(width2) {
        var height2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : width2;
        var preserveAspectRatio = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
        this.documentElement.resize(width2, height2, preserveAspectRatio);
      }
    };
  }
});

// ../simple-mind-map/node_modules/quill/dist/quill.js
var require_quill = __commonJS({
  "../simple-mind-map/node_modules/quill/dist/quill.js"(exports, module) {
    (function webpackUniversalModuleDefinition(root2, factory) {
      if (typeof exports === "object" && typeof module === "object")
        module.exports = factory();
      else if (typeof define === "function" && define.amd)
        define([], factory);
      else if (typeof exports === "object")
        exports["Quill"] = factory();
      else
        root2["Quill"] = factory();
    })(typeof self !== "undefined" ? self : exports, function() {
      return (
        /******/
        function(modules) {
          var installedModules = {};
          function __webpack_require__(moduleId) {
            if (installedModules[moduleId]) {
              return installedModules[moduleId].exports;
            }
            var module2 = installedModules[moduleId] = {
              /******/
              i: moduleId,
              /******/
              l: false,
              /******/
              exports: {}
              /******/
            };
            modules[moduleId].call(module2.exports, module2, module2.exports, __webpack_require__);
            module2.l = true;
            return module2.exports;
          }
          __webpack_require__.m = modules;
          __webpack_require__.c = installedModules;
          __webpack_require__.d = function(exports2, name, getter) {
            if (!__webpack_require__.o(exports2, name)) {
              Object.defineProperty(exports2, name, {
                /******/
                configurable: false,
                /******/
                enumerable: true,
                /******/
                get: getter
                /******/
              });
            }
          };
          __webpack_require__.n = function(module2) {
            var getter = module2 && module2.__esModule ? (
              /******/
              function getDefault() {
                return module2["default"];
              }
            ) : (
              /******/
              function getModuleExports() {
                return module2;
              }
            );
            __webpack_require__.d(getter, "a", getter);
            return getter;
          };
          __webpack_require__.o = function(object, property) {
            return Object.prototype.hasOwnProperty.call(object, property);
          };
          __webpack_require__.p = "";
          return __webpack_require__(__webpack_require__.s = 109);
        }([
          /* 0 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            var container_1 = __webpack_require__(17);
            var format_1 = __webpack_require__(18);
            var leaf_1 = __webpack_require__(19);
            var scroll_1 = __webpack_require__(45);
            var inline_1 = __webpack_require__(46);
            var block_1 = __webpack_require__(47);
            var embed_1 = __webpack_require__(48);
            var text_1 = __webpack_require__(49);
            var attributor_1 = __webpack_require__(12);
            var class_1 = __webpack_require__(32);
            var style_1 = __webpack_require__(33);
            var store_1 = __webpack_require__(31);
            var Registry = __webpack_require__(1);
            var Parchment = {
              Scope: Registry.Scope,
              create: Registry.create,
              find: Registry.find,
              query: Registry.query,
              register: Registry.register,
              Container: container_1.default,
              Format: format_1.default,
              Leaf: leaf_1.default,
              Embed: embed_1.default,
              Scroll: scroll_1.default,
              Block: block_1.default,
              Inline: inline_1.default,
              Text: text_1.default,
              Attributor: {
                Attribute: attributor_1.default,
                Class: class_1.default,
                Style: style_1.default,
                Store: store_1.default
              }
            };
            exports2.default = Parchment;
          },
          /* 1 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            var __extends3 = this && this.__extends || function() {
              var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
                d.__proto__ = b;
              } || function(d, b) {
                for (var p2 in b)
                  if (b.hasOwnProperty(p2))
                    d[p2] = b[p2];
              };
              return function(d, b) {
                extendStatics(d, b);
                function __() {
                  this.constructor = d;
                }
                d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
              };
            }();
            Object.defineProperty(exports2, "__esModule", { value: true });
            var ParchmentError = (
              /** @class */
              function(_super) {
                __extends3(ParchmentError2, _super);
                function ParchmentError2(message) {
                  var _this = this;
                  message = "[Parchment] " + message;
                  _this = _super.call(this, message) || this;
                  _this.message = message;
                  _this.name = _this.constructor.name;
                  return _this;
                }
                return ParchmentError2;
              }(Error)
            );
            exports2.ParchmentError = ParchmentError;
            var attributes = {};
            var classes2 = {};
            var tags = {};
            var types = {};
            exports2.DATA_KEY = "__blot";
            var Scope;
            (function(Scope2) {
              Scope2[Scope2["TYPE"] = 3] = "TYPE";
              Scope2[Scope2["LEVEL"] = 12] = "LEVEL";
              Scope2[Scope2["ATTRIBUTE"] = 13] = "ATTRIBUTE";
              Scope2[Scope2["BLOT"] = 14] = "BLOT";
              Scope2[Scope2["INLINE"] = 7] = "INLINE";
              Scope2[Scope2["BLOCK"] = 11] = "BLOCK";
              Scope2[Scope2["BLOCK_BLOT"] = 10] = "BLOCK_BLOT";
              Scope2[Scope2["INLINE_BLOT"] = 6] = "INLINE_BLOT";
              Scope2[Scope2["BLOCK_ATTRIBUTE"] = 9] = "BLOCK_ATTRIBUTE";
              Scope2[Scope2["INLINE_ATTRIBUTE"] = 5] = "INLINE_ATTRIBUTE";
              Scope2[Scope2["ANY"] = 15] = "ANY";
            })(Scope = exports2.Scope || (exports2.Scope = {}));
            function create2(input, value) {
              var match = query(input);
              if (match == null) {
                throw new ParchmentError("Unable to create " + input + " blot");
              }
              var BlotClass = match;
              var node3 = (
                // @ts-ignore
                input instanceof Node || input["nodeType"] === Node.TEXT_NODE ? input : BlotClass.create(value)
              );
              return new BlotClass(node3, value);
            }
            exports2.create = create2;
            function find2(node3, bubble) {
              if (bubble === void 0) {
                bubble = false;
              }
              if (node3 == null)
                return null;
              if (node3[exports2.DATA_KEY] != null)
                return node3[exports2.DATA_KEY].blot;
              if (bubble)
                return find2(node3.parentNode, bubble);
              return null;
            }
            exports2.find = find2;
            function query(query2, scope) {
              if (scope === void 0) {
                scope = Scope.ANY;
              }
              var match;
              if (typeof query2 === "string") {
                match = types[query2] || attributes[query2];
              } else if (query2 instanceof Text || query2["nodeType"] === Node.TEXT_NODE) {
                match = types["text"];
              } else if (typeof query2 === "number") {
                if (query2 & Scope.LEVEL & Scope.BLOCK) {
                  match = types["block"];
                } else if (query2 & Scope.LEVEL & Scope.INLINE) {
                  match = types["inline"];
                }
              } else if (query2 instanceof HTMLElement) {
                var names2 = (query2.getAttribute("class") || "").split(/\s+/);
                for (var i2 in names2) {
                  match = classes2[names2[i2]];
                  if (match)
                    break;
                }
                match = match || tags[query2.tagName];
              }
              if (match == null)
                return null;
              if (scope & Scope.LEVEL & match.scope && scope & Scope.TYPE & match.scope)
                return match;
              return null;
            }
            exports2.query = query;
            function register2() {
              var Definitions = [];
              for (var _i = 0; _i < arguments.length; _i++) {
                Definitions[_i] = arguments[_i];
              }
              if (Definitions.length > 1) {
                return Definitions.map(function(d) {
                  return register2(d);
                });
              }
              var Definition = Definitions[0];
              if (typeof Definition.blotName !== "string" && typeof Definition.attrName !== "string") {
                throw new ParchmentError("Invalid definition");
              } else if (Definition.blotName === "abstract") {
                throw new ParchmentError("Cannot register abstract class");
              }
              types[Definition.blotName || Definition.attrName] = Definition;
              if (typeof Definition.keyName === "string") {
                attributes[Definition.keyName] = Definition;
              } else {
                if (Definition.className != null) {
                  classes2[Definition.className] = Definition;
                }
                if (Definition.tagName != null) {
                  if (Array.isArray(Definition.tagName)) {
                    Definition.tagName = Definition.tagName.map(function(tagName) {
                      return tagName.toUpperCase();
                    });
                  } else {
                    Definition.tagName = Definition.tagName.toUpperCase();
                  }
                  var tagNames = Array.isArray(Definition.tagName) ? Definition.tagName : [Definition.tagName];
                  tagNames.forEach(function(tag) {
                    if (tags[tag] == null || Definition.className == null) {
                      tags[tag] = Definition;
                    }
                  });
                }
              }
              return Definition;
            }
            exports2.register = register2;
          },
          /* 2 */
          /***/
          function(module2, exports2, __webpack_require__) {
            var diff = __webpack_require__(51);
            var equal = __webpack_require__(11);
            var extend2 = __webpack_require__(3);
            var op2 = __webpack_require__(20);
            var NULL_CHARACTER = String.fromCharCode(0);
            var Delta2 = function(ops) {
              if (Array.isArray(ops)) {
                this.ops = ops;
              } else if (ops != null && Array.isArray(ops.ops)) {
                this.ops = ops.ops;
              } else {
                this.ops = [];
              }
            };
            Delta2.prototype.insert = function(text4, attributes) {
              var newOp = {};
              if (text4.length === 0)
                return this;
              newOp.insert = text4;
              if (attributes != null && typeof attributes === "object" && Object.keys(attributes).length > 0) {
                newOp.attributes = attributes;
              }
              return this.push(newOp);
            };
            Delta2.prototype["delete"] = function(length2) {
              if (length2 <= 0)
                return this;
              return this.push({ "delete": length2 });
            };
            Delta2.prototype.retain = function(length2, attributes) {
              if (length2 <= 0)
                return this;
              var newOp = { retain: length2 };
              if (attributes != null && typeof attributes === "object" && Object.keys(attributes).length > 0) {
                newOp.attributes = attributes;
              }
              return this.push(newOp);
            };
            Delta2.prototype.push = function(newOp) {
              var index3 = this.ops.length;
              var lastOp = this.ops[index3 - 1];
              newOp = extend2(true, {}, newOp);
              if (typeof lastOp === "object") {
                if (typeof newOp["delete"] === "number" && typeof lastOp["delete"] === "number") {
                  this.ops[index3 - 1] = { "delete": lastOp["delete"] + newOp["delete"] };
                  return this;
                }
                if (typeof lastOp["delete"] === "number" && newOp.insert != null) {
                  index3 -= 1;
                  lastOp = this.ops[index3 - 1];
                  if (typeof lastOp !== "object") {
                    this.ops.unshift(newOp);
                    return this;
                  }
                }
                if (equal(newOp.attributes, lastOp.attributes)) {
                  if (typeof newOp.insert === "string" && typeof lastOp.insert === "string") {
                    this.ops[index3 - 1] = { insert: lastOp.insert + newOp.insert };
                    if (typeof newOp.attributes === "object")
                      this.ops[index3 - 1].attributes = newOp.attributes;
                    return this;
                  } else if (typeof newOp.retain === "number" && typeof lastOp.retain === "number") {
                    this.ops[index3 - 1] = { retain: lastOp.retain + newOp.retain };
                    if (typeof newOp.attributes === "object")
                      this.ops[index3 - 1].attributes = newOp.attributes;
                    return this;
                  }
                }
              }
              if (index3 === this.ops.length) {
                this.ops.push(newOp);
              } else {
                this.ops.splice(index3, 0, newOp);
              }
              return this;
            };
            Delta2.prototype.chop = function() {
              var lastOp = this.ops[this.ops.length - 1];
              if (lastOp && lastOp.retain && !lastOp.attributes) {
                this.ops.pop();
              }
              return this;
            };
            Delta2.prototype.filter = function(predicate) {
              return this.ops.filter(predicate);
            };
            Delta2.prototype.forEach = function(predicate) {
              this.ops.forEach(predicate);
            };
            Delta2.prototype.map = function(predicate) {
              return this.ops.map(predicate);
            };
            Delta2.prototype.partition = function(predicate) {
              var passed = [], failed = [];
              this.forEach(function(op3) {
                var target = predicate(op3) ? passed : failed;
                target.push(op3);
              });
              return [passed, failed];
            };
            Delta2.prototype.reduce = function(predicate, initial) {
              return this.ops.reduce(predicate, initial);
            };
            Delta2.prototype.changeLength = function() {
              return this.reduce(function(length2, elem) {
                if (elem.insert) {
                  return length2 + op2.length(elem);
                } else if (elem.delete) {
                  return length2 - elem.delete;
                }
                return length2;
              }, 0);
            };
            Delta2.prototype.length = function() {
              return this.reduce(function(length2, elem) {
                return length2 + op2.length(elem);
              }, 0);
            };
            Delta2.prototype.slice = function(start, end) {
              start = start || 0;
              if (typeof end !== "number")
                end = Infinity;
              var ops = [];
              var iter = op2.iterator(this.ops);
              var index3 = 0;
              while (index3 < end && iter.hasNext()) {
                var nextOp;
                if (index3 < start) {
                  nextOp = iter.next(start - index3);
                } else {
                  nextOp = iter.next(end - index3);
                  ops.push(nextOp);
                }
                index3 += op2.length(nextOp);
              }
              return new Delta2(ops);
            };
            Delta2.prototype.compose = function(other) {
              var thisIter = op2.iterator(this.ops);
              var otherIter = op2.iterator(other.ops);
              var delta = new Delta2();
              while (thisIter.hasNext() || otherIter.hasNext()) {
                if (otherIter.peekType() === "insert") {
                  delta.push(otherIter.next());
                } else if (thisIter.peekType() === "delete") {
                  delta.push(thisIter.next());
                } else {
                  var length2 = Math.min(thisIter.peekLength(), otherIter.peekLength());
                  var thisOp = thisIter.next(length2);
                  var otherOp = otherIter.next(length2);
                  if (typeof otherOp.retain === "number") {
                    var newOp = {};
                    if (typeof thisOp.retain === "number") {
                      newOp.retain = length2;
                    } else {
                      newOp.insert = thisOp.insert;
                    }
                    var attributes = op2.attributes.compose(thisOp.attributes, otherOp.attributes, typeof thisOp.retain === "number");
                    if (attributes)
                      newOp.attributes = attributes;
                    delta.push(newOp);
                  } else if (typeof otherOp["delete"] === "number" && typeof thisOp.retain === "number") {
                    delta.push(otherOp);
                  }
                }
              }
              return delta.chop();
            };
            Delta2.prototype.concat = function(other) {
              var delta = new Delta2(this.ops.slice());
              if (other.ops.length > 0) {
                delta.push(other.ops[0]);
                delta.ops = delta.ops.concat(other.ops.slice(1));
              }
              return delta;
            };
            Delta2.prototype.diff = function(other, index3) {
              if (this.ops === other.ops) {
                return new Delta2();
              }
              var strings = [this, other].map(function(delta2) {
                return delta2.map(function(op3) {
                  if (op3.insert != null) {
                    return typeof op3.insert === "string" ? op3.insert : NULL_CHARACTER;
                  }
                  var prep = delta2 === other ? "on" : "with";
                  throw new Error("diff() called " + prep + " non-document");
                }).join("");
              });
              var delta = new Delta2();
              var diffResult = diff(strings[0], strings[1], index3);
              var thisIter = op2.iterator(this.ops);
              var otherIter = op2.iterator(other.ops);
              diffResult.forEach(function(component) {
                var length2 = component[1].length;
                while (length2 > 0) {
                  var opLength = 0;
                  switch (component[0]) {
                    case diff.INSERT:
                      opLength = Math.min(otherIter.peekLength(), length2);
                      delta.push(otherIter.next(opLength));
                      break;
                    case diff.DELETE:
                      opLength = Math.min(length2, thisIter.peekLength());
                      thisIter.next(opLength);
                      delta["delete"](opLength);
                      break;
                    case diff.EQUAL:
                      opLength = Math.min(thisIter.peekLength(), otherIter.peekLength(), length2);
                      var thisOp = thisIter.next(opLength);
                      var otherOp = otherIter.next(opLength);
                      if (equal(thisOp.insert, otherOp.insert)) {
                        delta.retain(opLength, op2.attributes.diff(thisOp.attributes, otherOp.attributes));
                      } else {
                        delta.push(otherOp)["delete"](opLength);
                      }
                      break;
                  }
                  length2 -= opLength;
                }
              });
              return delta.chop();
            };
            Delta2.prototype.eachLine = function(predicate, newline) {
              newline = newline || "\n";
              var iter = op2.iterator(this.ops);
              var line = new Delta2();
              var i2 = 0;
              while (iter.hasNext()) {
                if (iter.peekType() !== "insert")
                  return;
                var thisOp = iter.peek();
                var start = op2.length(thisOp) - iter.peekLength();
                var index3 = typeof thisOp.insert === "string" ? thisOp.insert.indexOf(newline, start) - start : -1;
                if (index3 < 0) {
                  line.push(iter.next());
                } else if (index3 > 0) {
                  line.push(iter.next(index3));
                } else {
                  if (predicate(line, iter.next(1).attributes || {}, i2) === false) {
                    return;
                  }
                  i2 += 1;
                  line = new Delta2();
                }
              }
              if (line.length() > 0) {
                predicate(line, {}, i2);
              }
            };
            Delta2.prototype.transform = function(other, priority) {
              priority = !!priority;
              if (typeof other === "number") {
                return this.transformPosition(other, priority);
              }
              var thisIter = op2.iterator(this.ops);
              var otherIter = op2.iterator(other.ops);
              var delta = new Delta2();
              while (thisIter.hasNext() || otherIter.hasNext()) {
                if (thisIter.peekType() === "insert" && (priority || otherIter.peekType() !== "insert")) {
                  delta.retain(op2.length(thisIter.next()));
                } else if (otherIter.peekType() === "insert") {
                  delta.push(otherIter.next());
                } else {
                  var length2 = Math.min(thisIter.peekLength(), otherIter.peekLength());
                  var thisOp = thisIter.next(length2);
                  var otherOp = otherIter.next(length2);
                  if (thisOp["delete"]) {
                    continue;
                  } else if (otherOp["delete"]) {
                    delta.push(otherOp);
                  } else {
                    delta.retain(length2, op2.attributes.transform(thisOp.attributes, otherOp.attributes, priority));
                  }
                }
              }
              return delta.chop();
            };
            Delta2.prototype.transformPosition = function(index3, priority) {
              priority = !!priority;
              var thisIter = op2.iterator(this.ops);
              var offset = 0;
              while (thisIter.hasNext() && offset <= index3) {
                var length2 = thisIter.peekLength();
                var nextType = thisIter.peekType();
                thisIter.next();
                if (nextType === "delete") {
                  index3 -= Math.min(length2, index3 - offset);
                  continue;
                } else if (nextType === "insert" && (offset < index3 || !priority)) {
                  index3 += length2;
                }
                offset += length2;
              }
              return index3;
            };
            module2.exports = Delta2;
          },
          /* 3 */
          /***/
          function(module2, exports2) {
            "use strict";
            var hasOwn = Object.prototype.hasOwnProperty;
            var toStr = Object.prototype.toString;
            var isArray = function isArray2(arr) {
              if (typeof Array.isArray === "function") {
                return Array.isArray(arr);
              }
              return toStr.call(arr) === "[object Array]";
            };
            var isPlainObject = function isPlainObject2(obj) {
              if (!obj || toStr.call(obj) !== "[object Object]") {
                return false;
              }
              var hasOwnConstructor = hasOwn.call(obj, "constructor");
              var hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, "isPrototypeOf");
              if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {
                return false;
              }
              var key;
              for (key in obj) {
              }
              return typeof key === "undefined" || hasOwn.call(obj, key);
            };
            module2.exports = function extend2() {
              var options, name, src, copy, copyIsArray, clone;
              var target = arguments[0];
              var i2 = 1;
              var length2 = arguments.length;
              var deep = false;
              if (typeof target === "boolean") {
                deep = target;
                target = arguments[1] || {};
                i2 = 2;
              }
              if (target == null || typeof target !== "object" && typeof target !== "function") {
                target = {};
              }
              for (; i2 < length2; ++i2) {
                options = arguments[i2];
                if (options != null) {
                  for (name in options) {
                    src = target[name];
                    copy = options[name];
                    if (target !== copy) {
                      if (deep && copy && (isPlainObject(copy) || (copyIsArray = isArray(copy)))) {
                        if (copyIsArray) {
                          copyIsArray = false;
                          clone = src && isArray(src) ? src : [];
                        } else {
                          clone = src && isPlainObject(src) ? src : {};
                        }
                        target[name] = extend2(deep, clone, copy);
                      } else if (typeof copy !== "undefined") {
                        target[name] = copy;
                      }
                    }
                  }
                }
              }
              return target;
            };
          },
          /* 4 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.default = exports2.BlockEmbed = exports2.bubbleFormats = void 0;
            var _createClass = function() {
              function defineProperties(target, props) {
                for (var i2 = 0; i2 < props.length; i2++) {
                  var descriptor = props[i2];
                  descriptor.enumerable = descriptor.enumerable || false;
                  descriptor.configurable = true;
                  if ("value" in descriptor)
                    descriptor.writable = true;
                  Object.defineProperty(target, descriptor.key, descriptor);
                }
              }
              return function(Constructor, protoProps, staticProps) {
                if (protoProps)
                  defineProperties(Constructor.prototype, protoProps);
                if (staticProps)
                  defineProperties(Constructor, staticProps);
                return Constructor;
              };
            }();
            var _get = function get(object, property, receiver) {
              if (object === null)
                object = Function.prototype;
              var desc = Object.getOwnPropertyDescriptor(object, property);
              if (desc === void 0) {
                var parent = Object.getPrototypeOf(object);
                if (parent === null) {
                  return void 0;
                } else {
                  return get(parent, property, receiver);
                }
              } else if ("value" in desc) {
                return desc.value;
              } else {
                var getter = desc.get;
                if (getter === void 0) {
                  return void 0;
                }
                return getter.call(receiver);
              }
            };
            var _extend = __webpack_require__(3);
            var _extend2 = _interopRequireDefault(_extend);
            var _quillDelta = __webpack_require__(2);
            var _quillDelta2 = _interopRequireDefault(_quillDelta);
            var _parchment = __webpack_require__(0);
            var _parchment2 = _interopRequireDefault(_parchment);
            var _break = __webpack_require__(16);
            var _break2 = _interopRequireDefault(_break);
            var _inline = __webpack_require__(6);
            var _inline2 = _interopRequireDefault(_inline);
            var _text = __webpack_require__(7);
            var _text2 = _interopRequireDefault(_text);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { default: obj };
            }
            function _classCallCheck2(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function _possibleConstructorReturn(self2, call) {
              if (!self2) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return call && (typeof call === "object" || typeof call === "function") ? call : self2;
            }
            function _inherits(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
              }
              subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
              if (superClass)
                Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
            }
            var NEWLINE_LENGTH = 1;
            var BlockEmbed = function(_Parchment$Embed) {
              _inherits(BlockEmbed2, _Parchment$Embed);
              function BlockEmbed2() {
                _classCallCheck2(this, BlockEmbed2);
                return _possibleConstructorReturn(this, (BlockEmbed2.__proto__ || Object.getPrototypeOf(BlockEmbed2)).apply(this, arguments));
              }
              _createClass(BlockEmbed2, [{
                key: "attach",
                value: function attach() {
                  _get(BlockEmbed2.prototype.__proto__ || Object.getPrototypeOf(BlockEmbed2.prototype), "attach", this).call(this);
                  this.attributes = new _parchment2.default.Attributor.Store(this.domNode);
                }
              }, {
                key: "delta",
                value: function delta() {
                  return new _quillDelta2.default().insert(this.value(), (0, _extend2.default)(this.formats(), this.attributes.values()));
                }
              }, {
                key: "format",
                value: function format(name, value) {
                  var attribute = _parchment2.default.query(name, _parchment2.default.Scope.BLOCK_ATTRIBUTE);
                  if (attribute != null) {
                    this.attributes.attribute(attribute, value);
                  }
                }
              }, {
                key: "formatAt",
                value: function formatAt(index3, length2, name, value) {
                  this.format(name, value);
                }
              }, {
                key: "insertAt",
                value: function insertAt(index3, value, def) {
                  if (typeof value === "string" && value.endsWith("\n")) {
                    var block = _parchment2.default.create(Block.blotName);
                    this.parent.insertBefore(block, index3 === 0 ? this : this.next);
                    block.insertAt(0, value.slice(0, -1));
                  } else {
                    _get(BlockEmbed2.prototype.__proto__ || Object.getPrototypeOf(BlockEmbed2.prototype), "insertAt", this).call(this, index3, value, def);
                  }
                }
              }]);
              return BlockEmbed2;
            }(_parchment2.default.Embed);
            BlockEmbed.scope = _parchment2.default.Scope.BLOCK_BLOT;
            var Block = function(_Parchment$Block) {
              _inherits(Block2, _Parchment$Block);
              function Block2(domNode) {
                _classCallCheck2(this, Block2);
                var _this2 = _possibleConstructorReturn(this, (Block2.__proto__ || Object.getPrototypeOf(Block2)).call(this, domNode));
                _this2.cache = {};
                return _this2;
              }
              _createClass(Block2, [{
                key: "delta",
                value: function delta() {
                  if (this.cache.delta == null) {
                    this.cache.delta = this.descendants(_parchment2.default.Leaf).reduce(function(delta2, leaf) {
                      if (leaf.length() === 0) {
                        return delta2;
                      } else {
                        return delta2.insert(leaf.value(), bubbleFormats(leaf));
                      }
                    }, new _quillDelta2.default()).insert("\n", bubbleFormats(this));
                  }
                  return this.cache.delta;
                }
              }, {
                key: "deleteAt",
                value: function deleteAt(index3, length2) {
                  _get(Block2.prototype.__proto__ || Object.getPrototypeOf(Block2.prototype), "deleteAt", this).call(this, index3, length2);
                  this.cache = {};
                }
              }, {
                key: "formatAt",
                value: function formatAt(index3, length2, name, value) {
                  if (length2 <= 0)
                    return;
                  if (_parchment2.default.query(name, _parchment2.default.Scope.BLOCK)) {
                    if (index3 + length2 === this.length()) {
                      this.format(name, value);
                    }
                  } else {
                    _get(Block2.prototype.__proto__ || Object.getPrototypeOf(Block2.prototype), "formatAt", this).call(this, index3, Math.min(length2, this.length() - index3 - 1), name, value);
                  }
                  this.cache = {};
                }
              }, {
                key: "insertAt",
                value: function insertAt(index3, value, def) {
                  if (def != null)
                    return _get(Block2.prototype.__proto__ || Object.getPrototypeOf(Block2.prototype), "insertAt", this).call(this, index3, value, def);
                  if (value.length === 0)
                    return;
                  var lines = value.split("\n");
                  var text4 = lines.shift();
                  if (text4.length > 0) {
                    if (index3 < this.length() - 1 || this.children.tail == null) {
                      _get(Block2.prototype.__proto__ || Object.getPrototypeOf(Block2.prototype), "insertAt", this).call(this, Math.min(index3, this.length() - 1), text4);
                    } else {
                      this.children.tail.insertAt(this.children.tail.length(), text4);
                    }
                    this.cache = {};
                  }
                  var block = this;
                  lines.reduce(function(index4, line) {
                    block = block.split(index4, true);
                    block.insertAt(0, line);
                    return line.length;
                  }, index3 + text4.length);
                }
              }, {
                key: "insertBefore",
                value: function insertBefore2(blot, ref) {
                  var head = this.children.head;
                  _get(Block2.prototype.__proto__ || Object.getPrototypeOf(Block2.prototype), "insertBefore", this).call(this, blot, ref);
                  if (head instanceof _break2.default) {
                    head.remove();
                  }
                  this.cache = {};
                }
              }, {
                key: "length",
                value: function length2() {
                  if (this.cache.length == null) {
                    this.cache.length = _get(Block2.prototype.__proto__ || Object.getPrototypeOf(Block2.prototype), "length", this).call(this) + NEWLINE_LENGTH;
                  }
                  return this.cache.length;
                }
              }, {
                key: "moveChildren",
                value: function moveChildren(target, ref) {
                  _get(Block2.prototype.__proto__ || Object.getPrototypeOf(Block2.prototype), "moveChildren", this).call(this, target, ref);
                  this.cache = {};
                }
              }, {
                key: "optimize",
                value: function optimize(context) {
                  _get(Block2.prototype.__proto__ || Object.getPrototypeOf(Block2.prototype), "optimize", this).call(this, context);
                  this.cache = {};
                }
              }, {
                key: "path",
                value: function path2(index3) {
                  return _get(Block2.prototype.__proto__ || Object.getPrototypeOf(Block2.prototype), "path", this).call(this, index3, true);
                }
              }, {
                key: "removeChild",
                value: function removeChild(child) {
                  _get(Block2.prototype.__proto__ || Object.getPrototypeOf(Block2.prototype), "removeChild", this).call(this, child);
                  this.cache = {};
                }
              }, {
                key: "split",
                value: function split(index3) {
                  var force = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
                  if (force && (index3 === 0 || index3 >= this.length() - NEWLINE_LENGTH)) {
                    var clone = this.clone();
                    if (index3 === 0) {
                      this.parent.insertBefore(clone, this);
                      return this;
                    } else {
                      this.parent.insertBefore(clone, this.next);
                      return clone;
                    }
                  } else {
                    var next2 = _get(Block2.prototype.__proto__ || Object.getPrototypeOf(Block2.prototype), "split", this).call(this, index3, force);
                    this.cache = {};
                    return next2;
                  }
                }
              }]);
              return Block2;
            }(_parchment2.default.Block);
            Block.blotName = "block";
            Block.tagName = "P";
            Block.defaultChild = "break";
            Block.allowedChildren = [_inline2.default, _parchment2.default.Embed, _text2.default];
            function bubbleFormats(blot) {
              var formats = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
              if (blot == null)
                return formats;
              if (typeof blot.formats === "function") {
                formats = (0, _extend2.default)(formats, blot.formats());
              }
              if (blot.parent == null || blot.parent.blotName == "scroll" || blot.parent.statics.scope !== blot.statics.scope) {
                return formats;
              }
              return bubbleFormats(blot.parent, formats);
            }
            exports2.bubbleFormats = bubbleFormats;
            exports2.BlockEmbed = BlockEmbed;
            exports2.default = Block;
          },
          /* 5 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.default = exports2.overload = exports2.expandConfig = void 0;
            var _typeof3 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
              return typeof obj;
            } : function(obj) {
              return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
            };
            var _slicedToArray = function() {
              function sliceIterator(arr, i2) {
                var _arr = [];
                var _n = true;
                var _d = false;
                var _e = void 0;
                try {
                  for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                    _arr.push(_s.value);
                    if (i2 && _arr.length === i2)
                      break;
                  }
                } catch (err) {
                  _d = true;
                  _e = err;
                } finally {
                  try {
                    if (!_n && _i["return"])
                      _i["return"]();
                  } finally {
                    if (_d)
                      throw _e;
                  }
                }
                return _arr;
              }
              return function(arr, i2) {
                if (Array.isArray(arr)) {
                  return arr;
                } else if (Symbol.iterator in Object(arr)) {
                  return sliceIterator(arr, i2);
                } else {
                  throw new TypeError("Invalid attempt to destructure non-iterable instance");
                }
              };
            }();
            var _createClass = function() {
              function defineProperties(target, props) {
                for (var i2 = 0; i2 < props.length; i2++) {
                  var descriptor = props[i2];
                  descriptor.enumerable = descriptor.enumerable || false;
                  descriptor.configurable = true;
                  if ("value" in descriptor)
                    descriptor.writable = true;
                  Object.defineProperty(target, descriptor.key, descriptor);
                }
              }
              return function(Constructor, protoProps, staticProps) {
                if (protoProps)
                  defineProperties(Constructor.prototype, protoProps);
                if (staticProps)
                  defineProperties(Constructor, staticProps);
                return Constructor;
              };
            }();
            __webpack_require__(50);
            var _quillDelta = __webpack_require__(2);
            var _quillDelta2 = _interopRequireDefault(_quillDelta);
            var _editor = __webpack_require__(14);
            var _editor2 = _interopRequireDefault(_editor);
            var _emitter3 = __webpack_require__(8);
            var _emitter4 = _interopRequireDefault(_emitter3);
            var _module = __webpack_require__(9);
            var _module2 = _interopRequireDefault(_module);
            var _parchment = __webpack_require__(0);
            var _parchment2 = _interopRequireDefault(_parchment);
            var _selection = __webpack_require__(15);
            var _selection2 = _interopRequireDefault(_selection);
            var _extend = __webpack_require__(3);
            var _extend2 = _interopRequireDefault(_extend);
            var _logger = __webpack_require__(10);
            var _logger2 = _interopRequireDefault(_logger);
            var _theme = __webpack_require__(34);
            var _theme2 = _interopRequireDefault(_theme);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { default: obj };
            }
            function _defineProperty2(obj, key, value) {
              if (key in obj) {
                Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
              } else {
                obj[key] = value;
              }
              return obj;
            }
            function _classCallCheck2(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            var debug = (0, _logger2.default)("quill");
            var Quill3 = function() {
              _createClass(Quill4, null, [{
                key: "debug",
                value: function debug2(limit) {
                  if (limit === true) {
                    limit = "log";
                  }
                  _logger2.default.level(limit);
                }
              }, {
                key: "find",
                value: function find2(node3) {
                  return node3.__quill || _parchment2.default.find(node3);
                }
              }, {
                key: "import",
                value: function _import(name) {
                  if (this.imports[name] == null) {
                    debug.error("Cannot import " + name + ". Are you sure it was registered?");
                  }
                  return this.imports[name];
                }
              }, {
                key: "register",
                value: function register2(path2, target) {
                  var _this = this;
                  var overwrite = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
                  if (typeof path2 !== "string") {
                    var name = path2.attrName || path2.blotName;
                    if (typeof name === "string") {
                      this.register("formats/" + name, path2, target);
                    } else {
                      Object.keys(path2).forEach(function(key) {
                        _this.register(key, path2[key], target);
                      });
                    }
                  } else {
                    if (this.imports[path2] != null && !overwrite) {
                      debug.warn("Overwriting " + path2 + " with", target);
                    }
                    this.imports[path2] = target;
                    if ((path2.startsWith("blots/") || path2.startsWith("formats/")) && target.blotName !== "abstract") {
                      _parchment2.default.register(target);
                    } else if (path2.startsWith("modules") && typeof target.register === "function") {
                      target.register();
                    }
                  }
                }
              }]);
              function Quill4(container) {
                var _this2 = this;
                var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
                _classCallCheck2(this, Quill4);
                this.options = expandConfig(container, options);
                this.container = this.options.container;
                if (this.container == null) {
                  return debug.error("Invalid Quill container", container);
                }
                if (this.options.debug) {
                  Quill4.debug(this.options.debug);
                }
                var html2 = this.container.innerHTML.trim();
                this.container.classList.add("ql-container");
                this.container.innerHTML = "";
                this.container.__quill = this;
                this.root = this.addContainer("ql-editor");
                this.root.classList.add("ql-blank");
                this.root.setAttribute("data-gramm", false);
                this.scrollingContainer = this.options.scrollingContainer || this.root;
                this.emitter = new _emitter4.default();
                this.scroll = _parchment2.default.create(this.root, {
                  emitter: this.emitter,
                  whitelist: this.options.formats
                });
                this.editor = new _editor2.default(this.scroll);
                this.selection = new _selection2.default(this.scroll, this.emitter);
                this.theme = new this.options.theme(this, this.options);
                this.keyboard = this.theme.addModule("keyboard");
                this.clipboard = this.theme.addModule("clipboard");
                this.history = this.theme.addModule("history");
                this.theme.init();
                this.emitter.on(_emitter4.default.events.EDITOR_CHANGE, function(type) {
                  if (type === _emitter4.default.events.TEXT_CHANGE) {
                    _this2.root.classList.toggle("ql-blank", _this2.editor.isBlank());
                  }
                });
                this.emitter.on(_emitter4.default.events.SCROLL_UPDATE, function(source, mutations) {
                  var range = _this2.selection.lastRange;
                  var index3 = range && range.length === 0 ? range.index : void 0;
                  modify.call(_this2, function() {
                    return _this2.editor.update(null, mutations, index3);
                  }, source);
                });
                var contents = this.clipboard.convert(`<div class='ql-editor' style="white-space: normal;">` + html2 + "<p><br></p></div>");
                this.setContents(contents);
                this.history.clear();
                if (this.options.placeholder) {
                  this.root.setAttribute("data-placeholder", this.options.placeholder);
                }
                if (this.options.readOnly) {
                  this.disable();
                }
              }
              _createClass(Quill4, [{
                key: "addContainer",
                value: function addContainer(container) {
                  var refNode = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
                  if (typeof container === "string") {
                    var className = container;
                    container = document.createElement("div");
                    container.classList.add(className);
                  }
                  this.container.insertBefore(container, refNode);
                  return container;
                }
              }, {
                key: "blur",
                value: function blur() {
                  this.selection.setRange(null);
                }
              }, {
                key: "deleteText",
                value: function deleteText(index3, length2, source) {
                  var _this3 = this;
                  var _overload = overload(index3, length2, source);
                  var _overload2 = _slicedToArray(_overload, 4);
                  index3 = _overload2[0];
                  length2 = _overload2[1];
                  source = _overload2[3];
                  return modify.call(this, function() {
                    return _this3.editor.deleteText(index3, length2);
                  }, source, index3, -1 * length2);
                }
              }, {
                key: "disable",
                value: function disable2() {
                  this.enable(false);
                }
              }, {
                key: "enable",
                value: function enable() {
                  var enabled = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
                  this.scroll.enable(enabled);
                  this.container.classList.toggle("ql-disabled", !enabled);
                }
              }, {
                key: "focus",
                value: function focus() {
                  var scrollTop = this.scrollingContainer.scrollTop;
                  this.selection.focus();
                  this.scrollingContainer.scrollTop = scrollTop;
                  this.scrollIntoView();
                }
              }, {
                key: "format",
                value: function format(name, value) {
                  var _this4 = this;
                  var source = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : _emitter4.default.sources.API;
                  return modify.call(this, function() {
                    var range = _this4.getSelection(true);
                    var change = new _quillDelta2.default();
                    if (range == null) {
                      return change;
                    } else if (_parchment2.default.query(name, _parchment2.default.Scope.BLOCK)) {
                      change = _this4.editor.formatLine(range.index, range.length, _defineProperty2({}, name, value));
                    } else if (range.length === 0) {
                      _this4.selection.format(name, value);
                      return change;
                    } else {
                      change = _this4.editor.formatText(range.index, range.length, _defineProperty2({}, name, value));
                    }
                    _this4.setSelection(range, _emitter4.default.sources.SILENT);
                    return change;
                  }, source);
                }
              }, {
                key: "formatLine",
                value: function formatLine(index3, length2, name, value, source) {
                  var _this5 = this;
                  var formats = void 0;
                  var _overload3 = overload(index3, length2, name, value, source);
                  var _overload4 = _slicedToArray(_overload3, 4);
                  index3 = _overload4[0];
                  length2 = _overload4[1];
                  formats = _overload4[2];
                  source = _overload4[3];
                  return modify.call(this, function() {
                    return _this5.editor.formatLine(index3, length2, formats);
                  }, source, index3, 0);
                }
              }, {
                key: "formatText",
                value: function formatText(index3, length2, name, value, source) {
                  var _this6 = this;
                  var formats = void 0;
                  var _overload5 = overload(index3, length2, name, value, source);
                  var _overload6 = _slicedToArray(_overload5, 4);
                  index3 = _overload6[0];
                  length2 = _overload6[1];
                  formats = _overload6[2];
                  source = _overload6[3];
                  return modify.call(this, function() {
                    return _this6.editor.formatText(index3, length2, formats);
                  }, source, index3, 0);
                }
              }, {
                key: "getBounds",
                value: function getBounds(index3) {
                  var length2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
                  var bounds = void 0;
                  if (typeof index3 === "number") {
                    bounds = this.selection.getBounds(index3, length2);
                  } else {
                    bounds = this.selection.getBounds(index3.index, index3.length);
                  }
                  var containerBounds = this.container.getBoundingClientRect();
                  return {
                    bottom: bounds.bottom - containerBounds.top,
                    height: bounds.height,
                    left: bounds.left - containerBounds.left,
                    right: bounds.right - containerBounds.left,
                    top: bounds.top - containerBounds.top,
                    width: bounds.width
                  };
                }
              }, {
                key: "getContents",
                value: function getContents() {
                  var index3 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
                  var length2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.getLength() - index3;
                  var _overload7 = overload(index3, length2);
                  var _overload8 = _slicedToArray(_overload7, 2);
                  index3 = _overload8[0];
                  length2 = _overload8[1];
                  return this.editor.getContents(index3, length2);
                }
              }, {
                key: "getFormat",
                value: function getFormat() {
                  var index3 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.getSelection(true);
                  var length2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
                  if (typeof index3 === "number") {
                    return this.editor.getFormat(index3, length2);
                  } else {
                    return this.editor.getFormat(index3.index, index3.length);
                  }
                }
              }, {
                key: "getIndex",
                value: function getIndex(blot) {
                  return blot.offset(this.scroll);
                }
              }, {
                key: "getLength",
                value: function getLength() {
                  return this.scroll.length();
                }
              }, {
                key: "getLeaf",
                value: function getLeaf(index3) {
                  return this.scroll.leaf(index3);
                }
              }, {
                key: "getLine",
                value: function getLine(index3) {
                  return this.scroll.line(index3);
                }
              }, {
                key: "getLines",
                value: function getLines() {
                  var index3 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
                  var length2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Number.MAX_VALUE;
                  if (typeof index3 !== "number") {
                    return this.scroll.lines(index3.index, index3.length);
                  } else {
                    return this.scroll.lines(index3, length2);
                  }
                }
              }, {
                key: "getModule",
                value: function getModule(name) {
                  return this.theme.modules[name];
                }
              }, {
                key: "getSelection",
                value: function getSelection() {
                  var focus = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
                  if (focus)
                    this.focus();
                  this.update();
                  return this.selection.getRange()[0];
                }
              }, {
                key: "getText",
                value: function getText3() {
                  var index3 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
                  var length2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.getLength() - index3;
                  var _overload9 = overload(index3, length2);
                  var _overload10 = _slicedToArray(_overload9, 2);
                  index3 = _overload10[0];
                  length2 = _overload10[1];
                  return this.editor.getText(index3, length2);
                }
              }, {
                key: "hasFocus",
                value: function hasFocus() {
                  return this.selection.hasFocus();
                }
              }, {
                key: "insertEmbed",
                value: function insertEmbed(index3, embed, value) {
                  var _this7 = this;
                  var source = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : Quill4.sources.API;
                  return modify.call(this, function() {
                    return _this7.editor.insertEmbed(index3, embed, value);
                  }, source, index3);
                }
              }, {
                key: "insertText",
                value: function insertText(index3, text4, name, value, source) {
                  var _this8 = this;
                  var formats = void 0;
                  var _overload11 = overload(index3, 0, name, value, source);
                  var _overload12 = _slicedToArray(_overload11, 4);
                  index3 = _overload12[0];
                  formats = _overload12[2];
                  source = _overload12[3];
                  return modify.call(this, function() {
                    return _this8.editor.insertText(index3, text4, formats);
                  }, source, index3, text4.length);
                }
              }, {
                key: "isEnabled",
                value: function isEnabled() {
                  return !this.container.classList.contains("ql-disabled");
                }
              }, {
                key: "off",
                value: function off2() {
                  return this.emitter.off.apply(this.emitter, arguments);
                }
              }, {
                key: "on",
                value: function on2() {
                  return this.emitter.on.apply(this.emitter, arguments);
                }
              }, {
                key: "once",
                value: function once() {
                  return this.emitter.once.apply(this.emitter, arguments);
                }
              }, {
                key: "pasteHTML",
                value: function pasteHTML(index3, html2, source) {
                  this.clipboard.dangerouslyPasteHTML(index3, html2, source);
                }
              }, {
                key: "removeFormat",
                value: function removeFormat(index3, length2, source) {
                  var _this9 = this;
                  var _overload13 = overload(index3, length2, source);
                  var _overload14 = _slicedToArray(_overload13, 4);
                  index3 = _overload14[0];
                  length2 = _overload14[1];
                  source = _overload14[3];
                  return modify.call(this, function() {
                    return _this9.editor.removeFormat(index3, length2);
                  }, source, index3);
                }
              }, {
                key: "scrollIntoView",
                value: function scrollIntoView() {
                  this.selection.scrollIntoView(this.scrollingContainer);
                }
              }, {
                key: "setContents",
                value: function setContents(delta) {
                  var _this10 = this;
                  var source = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _emitter4.default.sources.API;
                  return modify.call(this, function() {
                    delta = new _quillDelta2.default(delta);
                    var length2 = _this10.getLength();
                    var deleted = _this10.editor.deleteText(0, length2);
                    var applied = _this10.editor.applyDelta(delta);
                    var lastOp = applied.ops[applied.ops.length - 1];
                    if (lastOp != null && typeof lastOp.insert === "string" && lastOp.insert[lastOp.insert.length - 1] === "\n") {
                      _this10.editor.deleteText(_this10.getLength() - 1, 1);
                      applied.delete(1);
                    }
                    var ret = deleted.compose(applied);
                    return ret;
                  }, source);
                }
              }, {
                key: "setSelection",
                value: function setSelection(index3, length2, source) {
                  if (index3 == null) {
                    this.selection.setRange(null, length2 || Quill4.sources.API);
                  } else {
                    var _overload15 = overload(index3, length2, source);
                    var _overload16 = _slicedToArray(_overload15, 4);
                    index3 = _overload16[0];
                    length2 = _overload16[1];
                    source = _overload16[3];
                    this.selection.setRange(new _selection.Range(index3, length2), source);
                    if (source !== _emitter4.default.sources.SILENT) {
                      this.selection.scrollIntoView(this.scrollingContainer);
                    }
                  }
                }
              }, {
                key: "setText",
                value: function setText2(text4) {
                  var source = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _emitter4.default.sources.API;
                  var delta = new _quillDelta2.default().insert(text4);
                  return this.setContents(delta, source);
                }
              }, {
                key: "update",
                value: function update() {
                  var source = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : _emitter4.default.sources.USER;
                  var change = this.scroll.update(source);
                  this.selection.update(source);
                  return change;
                }
              }, {
                key: "updateContents",
                value: function updateContents(delta) {
                  var _this11 = this;
                  var source = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _emitter4.default.sources.API;
                  return modify.call(this, function() {
                    delta = new _quillDelta2.default(delta);
                    return _this11.editor.applyDelta(delta, source);
                  }, source, true);
                }
              }]);
              return Quill4;
            }();
            Quill3.DEFAULTS = {
              bounds: null,
              formats: null,
              modules: {},
              placeholder: "",
              readOnly: false,
              scrollingContainer: null,
              strict: true,
              theme: "default"
            };
            Quill3.events = _emitter4.default.events;
            Quill3.sources = _emitter4.default.sources;
            Quill3.version = false ? "dev" : "1.3.6";
            Quill3.imports = {
              "delta": _quillDelta2.default,
              "parchment": _parchment2.default,
              "core/module": _module2.default,
              "core/theme": _theme2.default
            };
            function expandConfig(container, userConfig) {
              userConfig = (0, _extend2.default)(true, {
                container,
                modules: {
                  clipboard: true,
                  keyboard: true,
                  history: true
                }
              }, userConfig);
              if (!userConfig.theme || userConfig.theme === Quill3.DEFAULTS.theme) {
                userConfig.theme = _theme2.default;
              } else {
                userConfig.theme = Quill3.import("themes/" + userConfig.theme);
                if (userConfig.theme == null) {
                  throw new Error("Invalid theme " + userConfig.theme + ". Did you register it?");
                }
              }
              var themeConfig = (0, _extend2.default)(true, {}, userConfig.theme.DEFAULTS);
              [themeConfig, userConfig].forEach(function(config) {
                config.modules = config.modules || {};
                Object.keys(config.modules).forEach(function(module3) {
                  if (config.modules[module3] === true) {
                    config.modules[module3] = {};
                  }
                });
              });
              var moduleNames = Object.keys(themeConfig.modules).concat(Object.keys(userConfig.modules));
              var moduleConfig = moduleNames.reduce(function(config, name) {
                var moduleClass = Quill3.import("modules/" + name);
                if (moduleClass == null) {
                  debug.error("Cannot load " + name + " module. Are you sure you registered it?");
                } else {
                  config[name] = moduleClass.DEFAULTS || {};
                }
                return config;
              }, {});
              if (userConfig.modules != null && userConfig.modules.toolbar && userConfig.modules.toolbar.constructor !== Object) {
                userConfig.modules.toolbar = {
                  container: userConfig.modules.toolbar
                };
              }
              userConfig = (0, _extend2.default)(true, {}, Quill3.DEFAULTS, { modules: moduleConfig }, themeConfig, userConfig);
              ["bounds", "container", "scrollingContainer"].forEach(function(key) {
                if (typeof userConfig[key] === "string") {
                  userConfig[key] = document.querySelector(userConfig[key]);
                }
              });
              userConfig.modules = Object.keys(userConfig.modules).reduce(function(config, name) {
                if (userConfig.modules[name]) {
                  config[name] = userConfig.modules[name];
                }
                return config;
              }, {});
              return userConfig;
            }
            function modify(modifier, source, index3, shift) {
              if (this.options.strict && !this.isEnabled() && source === _emitter4.default.sources.USER) {
                return new _quillDelta2.default();
              }
              var range = index3 == null ? null : this.getSelection();
              var oldDelta = this.editor.delta;
              var change = modifier();
              if (range != null) {
                if (index3 === true)
                  index3 = range.index;
                if (shift == null) {
                  range = shiftRange(range, change, source);
                } else if (shift !== 0) {
                  range = shiftRange(range, index3, shift, source);
                }
                this.setSelection(range, _emitter4.default.sources.SILENT);
              }
              if (change.length() > 0) {
                var _emitter;
                var args = [_emitter4.default.events.TEXT_CHANGE, change, oldDelta, source];
                (_emitter = this.emitter).emit.apply(_emitter, [_emitter4.default.events.EDITOR_CHANGE].concat(args));
                if (source !== _emitter4.default.sources.SILENT) {
                  var _emitter2;
                  (_emitter2 = this.emitter).emit.apply(_emitter2, args);
                }
              }
              return change;
            }
            function overload(index3, length2, name, value, source) {
              var formats = {};
              if (typeof index3.index === "number" && typeof index3.length === "number") {
                if (typeof length2 !== "number") {
                  source = value, value = name, name = length2, length2 = index3.length, index3 = index3.index;
                } else {
                  length2 = index3.length, index3 = index3.index;
                }
              } else if (typeof length2 !== "number") {
                source = value, value = name, name = length2, length2 = 0;
              }
              if ((typeof name === "undefined" ? "undefined" : _typeof3(name)) === "object") {
                formats = name;
                source = value;
              } else if (typeof name === "string") {
                if (value != null) {
                  formats[name] = value;
                } else {
                  source = name;
                }
              }
              source = source || _emitter4.default.sources.API;
              return [index3, length2, formats, source];
            }
            function shiftRange(range, index3, length2, source) {
              if (range == null)
                return null;
              var start = void 0, end = void 0;
              if (index3 instanceof _quillDelta2.default) {
                var _map = [range.index, range.index + range.length].map(function(pos) {
                  return index3.transformPosition(pos, source !== _emitter4.default.sources.USER);
                });
                var _map2 = _slicedToArray(_map, 2);
                start = _map2[0];
                end = _map2[1];
              } else {
                var _map3 = [range.index, range.index + range.length].map(function(pos) {
                  if (pos < index3 || pos === index3 && source === _emitter4.default.sources.USER)
                    return pos;
                  if (length2 >= 0) {
                    return pos + length2;
                  } else {
                    return Math.max(index3, pos + length2);
                  }
                });
                var _map4 = _slicedToArray(_map3, 2);
                start = _map4[0];
                end = _map4[1];
              }
              return new _selection.Range(start, end - start);
            }
            exports2.expandConfig = expandConfig;
            exports2.overload = overload;
            exports2.default = Quill3;
          },
          /* 6 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _createClass = function() {
              function defineProperties(target, props) {
                for (var i2 = 0; i2 < props.length; i2++) {
                  var descriptor = props[i2];
                  descriptor.enumerable = descriptor.enumerable || false;
                  descriptor.configurable = true;
                  if ("value" in descriptor)
                    descriptor.writable = true;
                  Object.defineProperty(target, descriptor.key, descriptor);
                }
              }
              return function(Constructor, protoProps, staticProps) {
                if (protoProps)
                  defineProperties(Constructor.prototype, protoProps);
                if (staticProps)
                  defineProperties(Constructor, staticProps);
                return Constructor;
              };
            }();
            var _get = function get(object, property, receiver) {
              if (object === null)
                object = Function.prototype;
              var desc = Object.getOwnPropertyDescriptor(object, property);
              if (desc === void 0) {
                var parent = Object.getPrototypeOf(object);
                if (parent === null) {
                  return void 0;
                } else {
                  return get(parent, property, receiver);
                }
              } else if ("value" in desc) {
                return desc.value;
              } else {
                var getter = desc.get;
                if (getter === void 0) {
                  return void 0;
                }
                return getter.call(receiver);
              }
            };
            var _text = __webpack_require__(7);
            var _text2 = _interopRequireDefault(_text);
            var _parchment = __webpack_require__(0);
            var _parchment2 = _interopRequireDefault(_parchment);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { default: obj };
            }
            function _classCallCheck2(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function _possibleConstructorReturn(self2, call) {
              if (!self2) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return call && (typeof call === "object" || typeof call === "function") ? call : self2;
            }
            function _inherits(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
              }
              subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
              if (superClass)
                Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
            }
            var Inline = function(_Parchment$Inline) {
              _inherits(Inline2, _Parchment$Inline);
              function Inline2() {
                _classCallCheck2(this, Inline2);
                return _possibleConstructorReturn(this, (Inline2.__proto__ || Object.getPrototypeOf(Inline2)).apply(this, arguments));
              }
              _createClass(Inline2, [{
                key: "formatAt",
                value: function formatAt(index3, length2, name, value) {
                  if (Inline2.compare(this.statics.blotName, name) < 0 && _parchment2.default.query(name, _parchment2.default.Scope.BLOT)) {
                    var blot = this.isolate(index3, length2);
                    if (value) {
                      blot.wrap(name, value);
                    }
                  } else {
                    _get(Inline2.prototype.__proto__ || Object.getPrototypeOf(Inline2.prototype), "formatAt", this).call(this, index3, length2, name, value);
                  }
                }
              }, {
                key: "optimize",
                value: function optimize(context) {
                  _get(Inline2.prototype.__proto__ || Object.getPrototypeOf(Inline2.prototype), "optimize", this).call(this, context);
                  if (this.parent instanceof Inline2 && Inline2.compare(this.statics.blotName, this.parent.statics.blotName) > 0) {
                    var parent = this.parent.isolate(this.offset(), this.length());
                    this.moveChildren(parent);
                    parent.wrap(this);
                  }
                }
              }], [{
                key: "compare",
                value: function compare(self2, other) {
                  var selfIndex = Inline2.order.indexOf(self2);
                  var otherIndex = Inline2.order.indexOf(other);
                  if (selfIndex >= 0 || otherIndex >= 0) {
                    return selfIndex - otherIndex;
                  } else if (self2 === other) {
                    return 0;
                  } else if (self2 < other) {
                    return -1;
                  } else {
                    return 1;
                  }
                }
              }]);
              return Inline2;
            }(_parchment2.default.Inline);
            Inline.allowedChildren = [Inline, _parchment2.default.Embed, _text2.default];
            Inline.order = [
              "cursor",
              "inline",
              // Must be lower
              "underline",
              "strike",
              "italic",
              "bold",
              "script",
              "link",
              "code"
              // Must be higher
            ];
            exports2.default = Inline;
          },
          /* 7 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _parchment = __webpack_require__(0);
            var _parchment2 = _interopRequireDefault(_parchment);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { default: obj };
            }
            function _classCallCheck2(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function _possibleConstructorReturn(self2, call) {
              if (!self2) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return call && (typeof call === "object" || typeof call === "function") ? call : self2;
            }
            function _inherits(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
              }
              subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
              if (superClass)
                Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
            }
            var TextBlot = function(_Parchment$Text) {
              _inherits(TextBlot2, _Parchment$Text);
              function TextBlot2() {
                _classCallCheck2(this, TextBlot2);
                return _possibleConstructorReturn(this, (TextBlot2.__proto__ || Object.getPrototypeOf(TextBlot2)).apply(this, arguments));
              }
              return TextBlot2;
            }(_parchment2.default.Text);
            exports2.default = TextBlot;
          },
          /* 8 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _createClass = function() {
              function defineProperties(target, props) {
                for (var i2 = 0; i2 < props.length; i2++) {
                  var descriptor = props[i2];
                  descriptor.enumerable = descriptor.enumerable || false;
                  descriptor.configurable = true;
                  if ("value" in descriptor)
                    descriptor.writable = true;
                  Object.defineProperty(target, descriptor.key, descriptor);
                }
              }
              return function(Constructor, protoProps, staticProps) {
                if (protoProps)
                  defineProperties(Constructor.prototype, protoProps);
                if (staticProps)
                  defineProperties(Constructor, staticProps);
                return Constructor;
              };
            }();
            var _get = function get(object, property, receiver) {
              if (object === null)
                object = Function.prototype;
              var desc = Object.getOwnPropertyDescriptor(object, property);
              if (desc === void 0) {
                var parent = Object.getPrototypeOf(object);
                if (parent === null) {
                  return void 0;
                } else {
                  return get(parent, property, receiver);
                }
              } else if ("value" in desc) {
                return desc.value;
              } else {
                var getter = desc.get;
                if (getter === void 0) {
                  return void 0;
                }
                return getter.call(receiver);
              }
            };
            var _eventemitter = __webpack_require__(54);
            var _eventemitter2 = _interopRequireDefault(_eventemitter);
            var _logger = __webpack_require__(10);
            var _logger2 = _interopRequireDefault(_logger);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { default: obj };
            }
            function _classCallCheck2(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function _possibleConstructorReturn(self2, call) {
              if (!self2) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return call && (typeof call === "object" || typeof call === "function") ? call : self2;
            }
            function _inherits(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
              }
              subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
              if (superClass)
                Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
            }
            var debug = (0, _logger2.default)("quill:events");
            var EVENTS = ["selectionchange", "mousedown", "mouseup", "click"];
            EVENTS.forEach(function(eventName) {
              document.addEventListener(eventName, function() {
                for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }
                [].slice.call(document.querySelectorAll(".ql-container")).forEach(function(node3) {
                  if (node3.__quill && node3.__quill.emitter) {
                    var _node$__quill$emitter;
                    (_node$__quill$emitter = node3.__quill.emitter).handleDOM.apply(_node$__quill$emitter, args);
                  }
                });
              });
            });
            var Emitter = function(_EventEmitter) {
              _inherits(Emitter2, _EventEmitter);
              function Emitter2() {
                _classCallCheck2(this, Emitter2);
                var _this = _possibleConstructorReturn(this, (Emitter2.__proto__ || Object.getPrototypeOf(Emitter2)).call(this));
                _this.listeners = {};
                _this.on("error", debug.error);
                return _this;
              }
              _createClass(Emitter2, [{
                key: "emit",
                value: function emit() {
                  debug.log.apply(debug, arguments);
                  _get(Emitter2.prototype.__proto__ || Object.getPrototypeOf(Emitter2.prototype), "emit", this).apply(this, arguments);
                }
              }, {
                key: "handleDOM",
                value: function handleDOM(event) {
                  for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                    args[_key2 - 1] = arguments[_key2];
                  }
                  (this.listeners[event.type] || []).forEach(function(_ref) {
                    var node3 = _ref.node, handler = _ref.handler;
                    if (event.target === node3 || node3.contains(event.target)) {
                      handler.apply(void 0, [event].concat(args));
                    }
                  });
                }
              }, {
                key: "listenDOM",
                value: function listenDOM(eventName, node3, handler) {
                  if (!this.listeners[eventName]) {
                    this.listeners[eventName] = [];
                  }
                  this.listeners[eventName].push({ node: node3, handler });
                }
              }]);
              return Emitter2;
            }(_eventemitter2.default);
            Emitter.events = {
              EDITOR_CHANGE: "editor-change",
              SCROLL_BEFORE_UPDATE: "scroll-before-update",
              SCROLL_OPTIMIZE: "scroll-optimize",
              SCROLL_UPDATE: "scroll-update",
              SELECTION_CHANGE: "selection-change",
              TEXT_CHANGE: "text-change"
            };
            Emitter.sources = {
              API: "api",
              SILENT: "silent",
              USER: "user"
            };
            exports2.default = Emitter;
          },
          /* 9 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            function _classCallCheck2(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            var Module = function Module2(quill) {
              var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
              _classCallCheck2(this, Module2);
              this.quill = quill;
              this.options = options;
            };
            Module.DEFAULTS = {};
            exports2.default = Module;
          },
          /* 10 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var levels = ["error", "warn", "log", "info"];
            var level = "warn";
            function debug(method) {
              if (levels.indexOf(method) <= levels.indexOf(level)) {
                var _console;
                for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                  args[_key - 1] = arguments[_key];
                }
                (_console = console)[method].apply(_console, args);
              }
            }
            function namespace(ns) {
              return levels.reduce(function(logger, method) {
                logger[method] = debug.bind(console, method, ns);
                return logger;
              }, {});
            }
            debug.level = namespace.level = function(newLevel) {
              level = newLevel;
            };
            exports2.default = namespace;
          },
          /* 11 */
          /***/
          function(module2, exports2, __webpack_require__) {
            var pSlice = Array.prototype.slice;
            var objectKeys = __webpack_require__(52);
            var isArguments = __webpack_require__(53);
            var deepEqual = module2.exports = function(actual, expected, opts) {
              if (!opts)
                opts = {};
              if (actual === expected) {
                return true;
              } else if (actual instanceof Date && expected instanceof Date) {
                return actual.getTime() === expected.getTime();
              } else if (!actual || !expected || typeof actual != "object" && typeof expected != "object") {
                return opts.strict ? actual === expected : actual == expected;
              } else {
                return objEquiv(actual, expected, opts);
              }
            };
            function isUndefinedOrNull(value) {
              return value === null || value === void 0;
            }
            function isBuffer(x2) {
              if (!x2 || typeof x2 !== "object" || typeof x2.length !== "number")
                return false;
              if (typeof x2.copy !== "function" || typeof x2.slice !== "function") {
                return false;
              }
              if (x2.length > 0 && typeof x2[0] !== "number")
                return false;
              return true;
            }
            function objEquiv(a2, b, opts) {
              var i2, key;
              if (isUndefinedOrNull(a2) || isUndefinedOrNull(b))
                return false;
              if (a2.prototype !== b.prototype)
                return false;
              if (isArguments(a2)) {
                if (!isArguments(b)) {
                  return false;
                }
                a2 = pSlice.call(a2);
                b = pSlice.call(b);
                return deepEqual(a2, b, opts);
              }
              if (isBuffer(a2)) {
                if (!isBuffer(b)) {
                  return false;
                }
                if (a2.length !== b.length)
                  return false;
                for (i2 = 0; i2 < a2.length; i2++) {
                  if (a2[i2] !== b[i2])
                    return false;
                }
                return true;
              }
              try {
                var ka = objectKeys(a2), kb = objectKeys(b);
              } catch (e2) {
                return false;
              }
              if (ka.length != kb.length)
                return false;
              ka.sort();
              kb.sort();
              for (i2 = ka.length - 1; i2 >= 0; i2--) {
                if (ka[i2] != kb[i2])
                  return false;
              }
              for (i2 = ka.length - 1; i2 >= 0; i2--) {
                key = ka[i2];
                if (!deepEqual(a2[key], b[key], opts))
                  return false;
              }
              return typeof a2 === typeof b;
            }
          },
          /* 12 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            var Registry = __webpack_require__(1);
            var Attributor = (
              /** @class */
              function() {
                function Attributor2(attrName, keyName, options) {
                  if (options === void 0) {
                    options = {};
                  }
                  this.attrName = attrName;
                  this.keyName = keyName;
                  var attributeBit = Registry.Scope.TYPE & Registry.Scope.ATTRIBUTE;
                  if (options.scope != null) {
                    this.scope = options.scope & Registry.Scope.LEVEL | attributeBit;
                  } else {
                    this.scope = Registry.Scope.ATTRIBUTE;
                  }
                  if (options.whitelist != null)
                    this.whitelist = options.whitelist;
                }
                Attributor2.keys = function(node3) {
                  return [].map.call(node3.attributes, function(item) {
                    return item.name;
                  });
                };
                Attributor2.prototype.add = function(node3, value) {
                  if (!this.canAdd(node3, value))
                    return false;
                  node3.setAttribute(this.keyName, value);
                  return true;
                };
                Attributor2.prototype.canAdd = function(node3, value) {
                  var match = Registry.query(node3, Registry.Scope.BLOT & (this.scope | Registry.Scope.TYPE));
                  if (match == null)
                    return false;
                  if (this.whitelist == null)
                    return true;
                  if (typeof value === "string") {
                    return this.whitelist.indexOf(value.replace(/["']/g, "")) > -1;
                  } else {
                    return this.whitelist.indexOf(value) > -1;
                  }
                };
                Attributor2.prototype.remove = function(node3) {
                  node3.removeAttribute(this.keyName);
                };
                Attributor2.prototype.value = function(node3) {
                  var value = node3.getAttribute(this.keyName);
                  if (this.canAdd(node3, value) && value) {
                    return value;
                  }
                  return "";
                };
                return Attributor2;
              }()
            );
            exports2.default = Attributor;
          },
          /* 13 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.default = exports2.Code = void 0;
            var _slicedToArray = function() {
              function sliceIterator(arr, i2) {
                var _arr = [];
                var _n = true;
                var _d = false;
                var _e = void 0;
                try {
                  for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                    _arr.push(_s.value);
                    if (i2 && _arr.length === i2)
                      break;
                  }
                } catch (err) {
                  _d = true;
                  _e = err;
                } finally {
                  try {
                    if (!_n && _i["return"])
                      _i["return"]();
                  } finally {
                    if (_d)
                      throw _e;
                  }
                }
                return _arr;
              }
              return function(arr, i2) {
                if (Array.isArray(arr)) {
                  return arr;
                } else if (Symbol.iterator in Object(arr)) {
                  return sliceIterator(arr, i2);
                } else {
                  throw new TypeError("Invalid attempt to destructure non-iterable instance");
                }
              };
            }();
            var _createClass = function() {
              function defineProperties(target, props) {
                for (var i2 = 0; i2 < props.length; i2++) {
                  var descriptor = props[i2];
                  descriptor.enumerable = descriptor.enumerable || false;
                  descriptor.configurable = true;
                  if ("value" in descriptor)
                    descriptor.writable = true;
                  Object.defineProperty(target, descriptor.key, descriptor);
                }
              }
              return function(Constructor, protoProps, staticProps) {
                if (protoProps)
                  defineProperties(Constructor.prototype, protoProps);
                if (staticProps)
                  defineProperties(Constructor, staticProps);
                return Constructor;
              };
            }();
            var _get = function get(object, property, receiver) {
              if (object === null)
                object = Function.prototype;
              var desc = Object.getOwnPropertyDescriptor(object, property);
              if (desc === void 0) {
                var parent = Object.getPrototypeOf(object);
                if (parent === null) {
                  return void 0;
                } else {
                  return get(parent, property, receiver);
                }
              } else if ("value" in desc) {
                return desc.value;
              } else {
                var getter = desc.get;
                if (getter === void 0) {
                  return void 0;
                }
                return getter.call(receiver);
              }
            };
            var _quillDelta = __webpack_require__(2);
            var _quillDelta2 = _interopRequireDefault(_quillDelta);
            var _parchment = __webpack_require__(0);
            var _parchment2 = _interopRequireDefault(_parchment);
            var _block = __webpack_require__(4);
            var _block2 = _interopRequireDefault(_block);
            var _inline = __webpack_require__(6);
            var _inline2 = _interopRequireDefault(_inline);
            var _text = __webpack_require__(7);
            var _text2 = _interopRequireDefault(_text);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { default: obj };
            }
            function _classCallCheck2(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function _possibleConstructorReturn(self2, call) {
              if (!self2) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return call && (typeof call === "object" || typeof call === "function") ? call : self2;
            }
            function _inherits(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
              }
              subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
              if (superClass)
                Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
            }
            var Code = function(_Inline) {
              _inherits(Code2, _Inline);
              function Code2() {
                _classCallCheck2(this, Code2);
                return _possibleConstructorReturn(this, (Code2.__proto__ || Object.getPrototypeOf(Code2)).apply(this, arguments));
              }
              return Code2;
            }(_inline2.default);
            Code.blotName = "code";
            Code.tagName = "CODE";
            var CodeBlock = function(_Block) {
              _inherits(CodeBlock2, _Block);
              function CodeBlock2() {
                _classCallCheck2(this, CodeBlock2);
                return _possibleConstructorReturn(this, (CodeBlock2.__proto__ || Object.getPrototypeOf(CodeBlock2)).apply(this, arguments));
              }
              _createClass(CodeBlock2, [{
                key: "delta",
                value: function delta() {
                  var _this3 = this;
                  var text4 = this.domNode.textContent;
                  if (text4.endsWith("\n")) {
                    text4 = text4.slice(0, -1);
                  }
                  return text4.split("\n").reduce(function(delta2, frag) {
                    return delta2.insert(frag).insert("\n", _this3.formats());
                  }, new _quillDelta2.default());
                }
              }, {
                key: "format",
                value: function format(name, value) {
                  if (name === this.statics.blotName && value)
                    return;
                  var _descendant = this.descendant(_text2.default, this.length() - 1), _descendant2 = _slicedToArray(_descendant, 1), text4 = _descendant2[0];
                  if (text4 != null) {
                    text4.deleteAt(text4.length() - 1, 1);
                  }
                  _get(CodeBlock2.prototype.__proto__ || Object.getPrototypeOf(CodeBlock2.prototype), "format", this).call(this, name, value);
                }
              }, {
                key: "formatAt",
                value: function formatAt(index3, length2, name, value) {
                  if (length2 === 0)
                    return;
                  if (_parchment2.default.query(name, _parchment2.default.Scope.BLOCK) == null || name === this.statics.blotName && value === this.statics.formats(this.domNode)) {
                    return;
                  }
                  var nextNewline = this.newlineIndex(index3);
                  if (nextNewline < 0 || nextNewline >= index3 + length2)
                    return;
                  var prevNewline = this.newlineIndex(index3, true) + 1;
                  var isolateLength = nextNewline - prevNewline + 1;
                  var blot = this.isolate(prevNewline, isolateLength);
                  var next2 = blot.next;
                  blot.format(name, value);
                  if (next2 instanceof CodeBlock2) {
                    next2.formatAt(0, index3 - prevNewline + length2 - isolateLength, name, value);
                  }
                }
              }, {
                key: "insertAt",
                value: function insertAt(index3, value, def) {
                  if (def != null)
                    return;
                  var _descendant3 = this.descendant(_text2.default, index3), _descendant4 = _slicedToArray(_descendant3, 2), text4 = _descendant4[0], offset = _descendant4[1];
                  text4.insertAt(offset, value);
                }
              }, {
                key: "length",
                value: function length2() {
                  var length3 = this.domNode.textContent.length;
                  if (!this.domNode.textContent.endsWith("\n")) {
                    return length3 + 1;
                  }
                  return length3;
                }
              }, {
                key: "newlineIndex",
                value: function newlineIndex(searchIndex) {
                  var reverse = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
                  if (!reverse) {
                    var offset = this.domNode.textContent.slice(searchIndex).indexOf("\n");
                    return offset > -1 ? searchIndex + offset : -1;
                  } else {
                    return this.domNode.textContent.slice(0, searchIndex).lastIndexOf("\n");
                  }
                }
              }, {
                key: "optimize",
                value: function optimize(context) {
                  if (!this.domNode.textContent.endsWith("\n")) {
                    this.appendChild(_parchment2.default.create("text", "\n"));
                  }
                  _get(CodeBlock2.prototype.__proto__ || Object.getPrototypeOf(CodeBlock2.prototype), "optimize", this).call(this, context);
                  var next2 = this.next;
                  if (next2 != null && next2.prev === this && next2.statics.blotName === this.statics.blotName && this.statics.formats(this.domNode) === next2.statics.formats(next2.domNode)) {
                    next2.optimize(context);
                    next2.moveChildren(this);
                    next2.remove();
                  }
                }
              }, {
                key: "replace",
                value: function replace(target) {
                  _get(CodeBlock2.prototype.__proto__ || Object.getPrototypeOf(CodeBlock2.prototype), "replace", this).call(this, target);
                  [].slice.call(this.domNode.querySelectorAll("*")).forEach(function(node3) {
                    var blot = _parchment2.default.find(node3);
                    if (blot == null) {
                      node3.parentNode.removeChild(node3);
                    } else if (blot instanceof _parchment2.default.Embed) {
                      blot.remove();
                    } else {
                      blot.unwrap();
                    }
                  });
                }
              }], [{
                key: "create",
                value: function create2(value) {
                  var domNode = _get(CodeBlock2.__proto__ || Object.getPrototypeOf(CodeBlock2), "create", this).call(this, value);
                  domNode.setAttribute("spellcheck", false);
                  return domNode;
                }
              }, {
                key: "formats",
                value: function formats() {
                  return true;
                }
              }]);
              return CodeBlock2;
            }(_block2.default);
            CodeBlock.blotName = "code-block";
            CodeBlock.tagName = "PRE";
            CodeBlock.TAB = "  ";
            exports2.Code = Code;
            exports2.default = CodeBlock;
          },
          /* 14 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _typeof3 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
              return typeof obj;
            } : function(obj) {
              return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
            };
            var _slicedToArray = function() {
              function sliceIterator(arr, i2) {
                var _arr = [];
                var _n = true;
                var _d = false;
                var _e = void 0;
                try {
                  for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                    _arr.push(_s.value);
                    if (i2 && _arr.length === i2)
                      break;
                  }
                } catch (err) {
                  _d = true;
                  _e = err;
                } finally {
                  try {
                    if (!_n && _i["return"])
                      _i["return"]();
                  } finally {
                    if (_d)
                      throw _e;
                  }
                }
                return _arr;
              }
              return function(arr, i2) {
                if (Array.isArray(arr)) {
                  return arr;
                } else if (Symbol.iterator in Object(arr)) {
                  return sliceIterator(arr, i2);
                } else {
                  throw new TypeError("Invalid attempt to destructure non-iterable instance");
                }
              };
            }();
            var _createClass = function() {
              function defineProperties(target, props) {
                for (var i2 = 0; i2 < props.length; i2++) {
                  var descriptor = props[i2];
                  descriptor.enumerable = descriptor.enumerable || false;
                  descriptor.configurable = true;
                  if ("value" in descriptor)
                    descriptor.writable = true;
                  Object.defineProperty(target, descriptor.key, descriptor);
                }
              }
              return function(Constructor, protoProps, staticProps) {
                if (protoProps)
                  defineProperties(Constructor.prototype, protoProps);
                if (staticProps)
                  defineProperties(Constructor, staticProps);
                return Constructor;
              };
            }();
            var _quillDelta = __webpack_require__(2);
            var _quillDelta2 = _interopRequireDefault(_quillDelta);
            var _op = __webpack_require__(20);
            var _op2 = _interopRequireDefault(_op);
            var _parchment = __webpack_require__(0);
            var _parchment2 = _interopRequireDefault(_parchment);
            var _code = __webpack_require__(13);
            var _code2 = _interopRequireDefault(_code);
            var _cursor = __webpack_require__(24);
            var _cursor2 = _interopRequireDefault(_cursor);
            var _block = __webpack_require__(4);
            var _block2 = _interopRequireDefault(_block);
            var _break = __webpack_require__(16);
            var _break2 = _interopRequireDefault(_break);
            var _clone = __webpack_require__(21);
            var _clone2 = _interopRequireDefault(_clone);
            var _deepEqual = __webpack_require__(11);
            var _deepEqual2 = _interopRequireDefault(_deepEqual);
            var _extend = __webpack_require__(3);
            var _extend2 = _interopRequireDefault(_extend);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { default: obj };
            }
            function _defineProperty2(obj, key, value) {
              if (key in obj) {
                Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
              } else {
                obj[key] = value;
              }
              return obj;
            }
            function _classCallCheck2(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            var ASCII = /^[ -~]*$/;
            var Editor = function() {
              function Editor2(scroll) {
                _classCallCheck2(this, Editor2);
                this.scroll = scroll;
                this.delta = this.getDelta();
              }
              _createClass(Editor2, [{
                key: "applyDelta",
                value: function applyDelta(delta) {
                  var _this = this;
                  var consumeNextNewline = false;
                  this.scroll.update();
                  var scrollLength = this.scroll.length();
                  this.scroll.batchStart();
                  delta = normalizeDelta(delta);
                  delta.reduce(function(index3, op2) {
                    var length2 = op2.retain || op2.delete || op2.insert.length || 1;
                    var attributes = op2.attributes || {};
                    if (op2.insert != null) {
                      if (typeof op2.insert === "string") {
                        var text4 = op2.insert;
                        if (text4.endsWith("\n") && consumeNextNewline) {
                          consumeNextNewline = false;
                          text4 = text4.slice(0, -1);
                        }
                        if (index3 >= scrollLength && !text4.endsWith("\n")) {
                          consumeNextNewline = true;
                        }
                        _this.scroll.insertAt(index3, text4);
                        var _scroll$line = _this.scroll.line(index3), _scroll$line2 = _slicedToArray(_scroll$line, 2), line = _scroll$line2[0], offset = _scroll$line2[1];
                        var formats = (0, _extend2.default)({}, (0, _block.bubbleFormats)(line));
                        if (line instanceof _block2.default) {
                          var _line$descendant = line.descendant(_parchment2.default.Leaf, offset), _line$descendant2 = _slicedToArray(_line$descendant, 1), leaf = _line$descendant2[0];
                          formats = (0, _extend2.default)(formats, (0, _block.bubbleFormats)(leaf));
                        }
                        attributes = _op2.default.attributes.diff(formats, attributes) || {};
                      } else if (_typeof3(op2.insert) === "object") {
                        var key = Object.keys(op2.insert)[0];
                        if (key == null)
                          return index3;
                        _this.scroll.insertAt(index3, key, op2.insert[key]);
                      }
                      scrollLength += length2;
                    }
                    Object.keys(attributes).forEach(function(name) {
                      _this.scroll.formatAt(index3, length2, name, attributes[name]);
                    });
                    return index3 + length2;
                  }, 0);
                  delta.reduce(function(index3, op2) {
                    if (typeof op2.delete === "number") {
                      _this.scroll.deleteAt(index3, op2.delete);
                      return index3;
                    }
                    return index3 + (op2.retain || op2.insert.length || 1);
                  }, 0);
                  this.scroll.batchEnd();
                  return this.update(delta);
                }
              }, {
                key: "deleteText",
                value: function deleteText(index3, length2) {
                  this.scroll.deleteAt(index3, length2);
                  return this.update(new _quillDelta2.default().retain(index3).delete(length2));
                }
              }, {
                key: "formatLine",
                value: function formatLine(index3, length2) {
                  var _this2 = this;
                  var formats = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
                  this.scroll.update();
                  Object.keys(formats).forEach(function(format) {
                    if (_this2.scroll.whitelist != null && !_this2.scroll.whitelist[format])
                      return;
                    var lines = _this2.scroll.lines(index3, Math.max(length2, 1));
                    var lengthRemaining = length2;
                    lines.forEach(function(line) {
                      var lineLength = line.length();
                      if (!(line instanceof _code2.default)) {
                        line.format(format, formats[format]);
                      } else {
                        var codeIndex = index3 - line.offset(_this2.scroll);
                        var codeLength = line.newlineIndex(codeIndex + lengthRemaining) - codeIndex + 1;
                        line.formatAt(codeIndex, codeLength, format, formats[format]);
                      }
                      lengthRemaining -= lineLength;
                    });
                  });
                  this.scroll.optimize();
                  return this.update(new _quillDelta2.default().retain(index3).retain(length2, (0, _clone2.default)(formats)));
                }
              }, {
                key: "formatText",
                value: function formatText(index3, length2) {
                  var _this3 = this;
                  var formats = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
                  Object.keys(formats).forEach(function(format) {
                    _this3.scroll.formatAt(index3, length2, format, formats[format]);
                  });
                  return this.update(new _quillDelta2.default().retain(index3).retain(length2, (0, _clone2.default)(formats)));
                }
              }, {
                key: "getContents",
                value: function getContents(index3, length2) {
                  return this.delta.slice(index3, index3 + length2);
                }
              }, {
                key: "getDelta",
                value: function getDelta() {
                  return this.scroll.lines().reduce(function(delta, line) {
                    return delta.concat(line.delta());
                  }, new _quillDelta2.default());
                }
              }, {
                key: "getFormat",
                value: function getFormat(index3) {
                  var length2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
                  var lines = [], leaves = [];
                  if (length2 === 0) {
                    this.scroll.path(index3).forEach(function(path2) {
                      var _path = _slicedToArray(path2, 1), blot = _path[0];
                      if (blot instanceof _block2.default) {
                        lines.push(blot);
                      } else if (blot instanceof _parchment2.default.Leaf) {
                        leaves.push(blot);
                      }
                    });
                  } else {
                    lines = this.scroll.lines(index3, length2);
                    leaves = this.scroll.descendants(_parchment2.default.Leaf, index3, length2);
                  }
                  var formatsArr = [lines, leaves].map(function(blots) {
                    if (blots.length === 0)
                      return {};
                    var formats = (0, _block.bubbleFormats)(blots.shift());
                    while (Object.keys(formats).length > 0) {
                      var blot = blots.shift();
                      if (blot == null)
                        return formats;
                      formats = combineFormats((0, _block.bubbleFormats)(blot), formats);
                    }
                    return formats;
                  });
                  return _extend2.default.apply(_extend2.default, formatsArr);
                }
              }, {
                key: "getText",
                value: function getText3(index3, length2) {
                  return this.getContents(index3, length2).filter(function(op2) {
                    return typeof op2.insert === "string";
                  }).map(function(op2) {
                    return op2.insert;
                  }).join("");
                }
              }, {
                key: "insertEmbed",
                value: function insertEmbed(index3, embed, value) {
                  this.scroll.insertAt(index3, embed, value);
                  return this.update(new _quillDelta2.default().retain(index3).insert(_defineProperty2({}, embed, value)));
                }
              }, {
                key: "insertText",
                value: function insertText(index3, text4) {
                  var _this4 = this;
                  var formats = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
                  text4 = text4.replace(/\r\n/g, "\n").replace(/\r/g, "\n");
                  this.scroll.insertAt(index3, text4);
                  Object.keys(formats).forEach(function(format) {
                    _this4.scroll.formatAt(index3, text4.length, format, formats[format]);
                  });
                  return this.update(new _quillDelta2.default().retain(index3).insert(text4, (0, _clone2.default)(formats)));
                }
              }, {
                key: "isBlank",
                value: function isBlank2() {
                  if (this.scroll.children.length == 0)
                    return true;
                  if (this.scroll.children.length > 1)
                    return false;
                  var block = this.scroll.children.head;
                  if (block.statics.blotName !== _block2.default.blotName)
                    return false;
                  if (block.children.length > 1)
                    return false;
                  return block.children.head instanceof _break2.default;
                }
              }, {
                key: "removeFormat",
                value: function removeFormat(index3, length2) {
                  var text4 = this.getText(index3, length2);
                  var _scroll$line3 = this.scroll.line(index3 + length2), _scroll$line4 = _slicedToArray(_scroll$line3, 2), line = _scroll$line4[0], offset = _scroll$line4[1];
                  var suffixLength = 0, suffix = new _quillDelta2.default();
                  if (line != null) {
                    if (!(line instanceof _code2.default)) {
                      suffixLength = line.length() - offset;
                    } else {
                      suffixLength = line.newlineIndex(offset) - offset + 1;
                    }
                    suffix = line.delta().slice(offset, offset + suffixLength - 1).insert("\n");
                  }
                  var contents = this.getContents(index3, length2 + suffixLength);
                  var diff = contents.diff(new _quillDelta2.default().insert(text4).concat(suffix));
                  var delta = new _quillDelta2.default().retain(index3).concat(diff);
                  return this.applyDelta(delta);
                }
              }, {
                key: "update",
                value: function update(change) {
                  var mutations = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
                  var cursorIndex = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : void 0;
                  var oldDelta = this.delta;
                  if (mutations.length === 1 && mutations[0].type === "characterData" && mutations[0].target.data.match(ASCII) && _parchment2.default.find(mutations[0].target)) {
                    var textBlot = _parchment2.default.find(mutations[0].target);
                    var formats = (0, _block.bubbleFormats)(textBlot);
                    var index3 = textBlot.offset(this.scroll);
                    var oldValue = mutations[0].oldValue.replace(_cursor2.default.CONTENTS, "");
                    var oldText = new _quillDelta2.default().insert(oldValue);
                    var newText = new _quillDelta2.default().insert(textBlot.value());
                    var diffDelta = new _quillDelta2.default().retain(index3).concat(oldText.diff(newText, cursorIndex));
                    change = diffDelta.reduce(function(delta, op2) {
                      if (op2.insert) {
                        return delta.insert(op2.insert, formats);
                      } else {
                        return delta.push(op2);
                      }
                    }, new _quillDelta2.default());
                    this.delta = oldDelta.compose(change);
                  } else {
                    this.delta = this.getDelta();
                    if (!change || !(0, _deepEqual2.default)(oldDelta.compose(change), this.delta)) {
                      change = oldDelta.diff(this.delta, cursorIndex);
                    }
                  }
                  return change;
                }
              }]);
              return Editor2;
            }();
            function combineFormats(formats, combined) {
              return Object.keys(combined).reduce(function(merged, name) {
                if (formats[name] == null)
                  return merged;
                if (combined[name] === formats[name]) {
                  merged[name] = combined[name];
                } else if (Array.isArray(combined[name])) {
                  if (combined[name].indexOf(formats[name]) < 0) {
                    merged[name] = combined[name].concat([formats[name]]);
                  }
                } else {
                  merged[name] = [combined[name], formats[name]];
                }
                return merged;
              }, {});
            }
            function normalizeDelta(delta) {
              return delta.reduce(function(delta2, op2) {
                if (op2.insert === 1) {
                  var attributes = (0, _clone2.default)(op2.attributes);
                  delete attributes["image"];
                  return delta2.insert({ image: op2.attributes.image }, attributes);
                }
                if (op2.attributes != null && (op2.attributes.list === true || op2.attributes.bullet === true)) {
                  op2 = (0, _clone2.default)(op2);
                  if (op2.attributes.list) {
                    op2.attributes.list = "ordered";
                  } else {
                    op2.attributes.list = "bullet";
                    delete op2.attributes.bullet;
                  }
                }
                if (typeof op2.insert === "string") {
                  var text4 = op2.insert.replace(/\r\n/g, "\n").replace(/\r/g, "\n");
                  return delta2.insert(text4, op2.attributes);
                }
                return delta2.push(op2);
              }, new _quillDelta2.default());
            }
            exports2.default = Editor;
          },
          /* 15 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.default = exports2.Range = void 0;
            var _slicedToArray = function() {
              function sliceIterator(arr, i2) {
                var _arr = [];
                var _n = true;
                var _d = false;
                var _e = void 0;
                try {
                  for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                    _arr.push(_s.value);
                    if (i2 && _arr.length === i2)
                      break;
                  }
                } catch (err) {
                  _d = true;
                  _e = err;
                } finally {
                  try {
                    if (!_n && _i["return"])
                      _i["return"]();
                  } finally {
                    if (_d)
                      throw _e;
                  }
                }
                return _arr;
              }
              return function(arr, i2) {
                if (Array.isArray(arr)) {
                  return arr;
                } else if (Symbol.iterator in Object(arr)) {
                  return sliceIterator(arr, i2);
                } else {
                  throw new TypeError("Invalid attempt to destructure non-iterable instance");
                }
              };
            }();
            var _createClass = function() {
              function defineProperties(target, props) {
                for (var i2 = 0; i2 < props.length; i2++) {
                  var descriptor = props[i2];
                  descriptor.enumerable = descriptor.enumerable || false;
                  descriptor.configurable = true;
                  if ("value" in descriptor)
                    descriptor.writable = true;
                  Object.defineProperty(target, descriptor.key, descriptor);
                }
              }
              return function(Constructor, protoProps, staticProps) {
                if (protoProps)
                  defineProperties(Constructor.prototype, protoProps);
                if (staticProps)
                  defineProperties(Constructor, staticProps);
                return Constructor;
              };
            }();
            var _parchment = __webpack_require__(0);
            var _parchment2 = _interopRequireDefault(_parchment);
            var _clone = __webpack_require__(21);
            var _clone2 = _interopRequireDefault(_clone);
            var _deepEqual = __webpack_require__(11);
            var _deepEqual2 = _interopRequireDefault(_deepEqual);
            var _emitter3 = __webpack_require__(8);
            var _emitter4 = _interopRequireDefault(_emitter3);
            var _logger = __webpack_require__(10);
            var _logger2 = _interopRequireDefault(_logger);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { default: obj };
            }
            function _toConsumableArray(arr) {
              if (Array.isArray(arr)) {
                for (var i2 = 0, arr2 = Array(arr.length); i2 < arr.length; i2++) {
                  arr2[i2] = arr[i2];
                }
                return arr2;
              } else {
                return Array.from(arr);
              }
            }
            function _classCallCheck2(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            var debug = (0, _logger2.default)("quill:selection");
            var Range = function Range2(index3) {
              var length2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
              _classCallCheck2(this, Range2);
              this.index = index3;
              this.length = length2;
            };
            var Selection = function() {
              function Selection2(scroll, emitter) {
                var _this = this;
                _classCallCheck2(this, Selection2);
                this.emitter = emitter;
                this.scroll = scroll;
                this.composing = false;
                this.mouseDown = false;
                this.root = this.scroll.domNode;
                this.cursor = _parchment2.default.create("cursor", this);
                this.lastRange = this.savedRange = new Range(0, 0);
                this.handleComposition();
                this.handleDragging();
                this.emitter.listenDOM("selectionchange", document, function() {
                  if (!_this.mouseDown) {
                    setTimeout(_this.update.bind(_this, _emitter4.default.sources.USER), 1);
                  }
                });
                this.emitter.on(_emitter4.default.events.EDITOR_CHANGE, function(type, delta) {
                  if (type === _emitter4.default.events.TEXT_CHANGE && delta.length() > 0) {
                    _this.update(_emitter4.default.sources.SILENT);
                  }
                });
                this.emitter.on(_emitter4.default.events.SCROLL_BEFORE_UPDATE, function() {
                  if (!_this.hasFocus())
                    return;
                  var native = _this.getNativeRange();
                  if (native == null)
                    return;
                  if (native.start.node === _this.cursor.textNode)
                    return;
                  _this.emitter.once(_emitter4.default.events.SCROLL_UPDATE, function() {
                    try {
                      _this.setNativeRange(native.start.node, native.start.offset, native.end.node, native.end.offset);
                    } catch (ignored) {
                    }
                  });
                });
                this.emitter.on(_emitter4.default.events.SCROLL_OPTIMIZE, function(mutations, context) {
                  if (context.range) {
                    var _context$range = context.range, startNode = _context$range.startNode, startOffset = _context$range.startOffset, endNode = _context$range.endNode, endOffset = _context$range.endOffset;
                    _this.setNativeRange(startNode, startOffset, endNode, endOffset);
                  }
                });
                this.update(_emitter4.default.sources.SILENT);
              }
              _createClass(Selection2, [{
                key: "handleComposition",
                value: function handleComposition() {
                  var _this2 = this;
                  this.root.addEventListener("compositionstart", function() {
                    _this2.composing = true;
                  });
                  this.root.addEventListener("compositionend", function() {
                    _this2.composing = false;
                    if (_this2.cursor.parent) {
                      var range = _this2.cursor.restore();
                      if (!range)
                        return;
                      setTimeout(function() {
                        _this2.setNativeRange(range.startNode, range.startOffset, range.endNode, range.endOffset);
                      }, 1);
                    }
                  });
                }
              }, {
                key: "handleDragging",
                value: function handleDragging() {
                  var _this3 = this;
                  this.emitter.listenDOM("mousedown", document.body, function() {
                    _this3.mouseDown = true;
                  });
                  this.emitter.listenDOM("mouseup", document.body, function() {
                    _this3.mouseDown = false;
                    _this3.update(_emitter4.default.sources.USER);
                  });
                }
              }, {
                key: "focus",
                value: function focus() {
                  if (this.hasFocus())
                    return;
                  this.root.focus();
                  this.setRange(this.savedRange);
                }
              }, {
                key: "format",
                value: function format(_format, value) {
                  if (this.scroll.whitelist != null && !this.scroll.whitelist[_format])
                    return;
                  this.scroll.update();
                  var nativeRange = this.getNativeRange();
                  if (nativeRange == null || !nativeRange.native.collapsed || _parchment2.default.query(_format, _parchment2.default.Scope.BLOCK))
                    return;
                  if (nativeRange.start.node !== this.cursor.textNode) {
                    var blot = _parchment2.default.find(nativeRange.start.node, false);
                    if (blot == null)
                      return;
                    if (blot instanceof _parchment2.default.Leaf) {
                      var after2 = blot.split(nativeRange.start.offset);
                      blot.parent.insertBefore(this.cursor, after2);
                    } else {
                      blot.insertBefore(this.cursor, nativeRange.start.node);
                    }
                    this.cursor.attach();
                  }
                  this.cursor.format(_format, value);
                  this.scroll.optimize();
                  this.setNativeRange(this.cursor.textNode, this.cursor.textNode.data.length);
                  this.update();
                }
              }, {
                key: "getBounds",
                value: function getBounds(index3) {
                  var length2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
                  var scrollLength = this.scroll.length();
                  index3 = Math.min(index3, scrollLength - 1);
                  length2 = Math.min(index3 + length2, scrollLength - 1) - index3;
                  var node3 = void 0, _scroll$leaf = this.scroll.leaf(index3), _scroll$leaf2 = _slicedToArray(_scroll$leaf, 2), leaf = _scroll$leaf2[0], offset = _scroll$leaf2[1];
                  if (leaf == null)
                    return null;
                  var _leaf$position = leaf.position(offset, true);
                  var _leaf$position2 = _slicedToArray(_leaf$position, 2);
                  node3 = _leaf$position2[0];
                  offset = _leaf$position2[1];
                  var range = document.createRange();
                  if (length2 > 0) {
                    range.setStart(node3, offset);
                    var _scroll$leaf3 = this.scroll.leaf(index3 + length2);
                    var _scroll$leaf4 = _slicedToArray(_scroll$leaf3, 2);
                    leaf = _scroll$leaf4[0];
                    offset = _scroll$leaf4[1];
                    if (leaf == null)
                      return null;
                    var _leaf$position3 = leaf.position(offset, true);
                    var _leaf$position4 = _slicedToArray(_leaf$position3, 2);
                    node3 = _leaf$position4[0];
                    offset = _leaf$position4[1];
                    range.setEnd(node3, offset);
                    return range.getBoundingClientRect();
                  } else {
                    var side = "left";
                    var rect = void 0;
                    if (node3 instanceof Text) {
                      if (offset < node3.data.length) {
                        range.setStart(node3, offset);
                        range.setEnd(node3, offset + 1);
                      } else {
                        range.setStart(node3, offset - 1);
                        range.setEnd(node3, offset);
                        side = "right";
                      }
                      rect = range.getBoundingClientRect();
                    } else {
                      rect = leaf.domNode.getBoundingClientRect();
                      if (offset > 0)
                        side = "right";
                    }
                    return {
                      bottom: rect.top + rect.height,
                      height: rect.height,
                      left: rect[side],
                      right: rect[side],
                      top: rect.top,
                      width: 0
                    };
                  }
                }
              }, {
                key: "getNativeRange",
                value: function getNativeRange() {
                  var selection = document.getSelection();
                  if (selection == null || selection.rangeCount <= 0)
                    return null;
                  var nativeRange = selection.getRangeAt(0);
                  if (nativeRange == null)
                    return null;
                  var range = this.normalizeNative(nativeRange);
                  debug.info("getNativeRange", range);
                  return range;
                }
              }, {
                key: "getRange",
                value: function getRange() {
                  var normalized = this.getNativeRange();
                  if (normalized == null)
                    return [null, null];
                  var range = this.normalizedToRange(normalized);
                  return [range, normalized];
                }
              }, {
                key: "hasFocus",
                value: function hasFocus() {
                  return document.activeElement === this.root;
                }
              }, {
                key: "normalizedToRange",
                value: function normalizedToRange(range) {
                  var _this4 = this;
                  var positions = [[range.start.node, range.start.offset]];
                  if (!range.native.collapsed) {
                    positions.push([range.end.node, range.end.offset]);
                  }
                  var indexes = positions.map(function(position3) {
                    var _position = _slicedToArray(position3, 2), node3 = _position[0], offset = _position[1];
                    var blot = _parchment2.default.find(node3, true);
                    var index3 = blot.offset(_this4.scroll);
                    if (offset === 0) {
                      return index3;
                    } else if (blot instanceof _parchment2.default.Container) {
                      return index3 + blot.length();
                    } else {
                      return index3 + blot.index(node3, offset);
                    }
                  });
                  var end = Math.min(Math.max.apply(Math, _toConsumableArray(indexes)), this.scroll.length() - 1);
                  var start = Math.min.apply(Math, [end].concat(_toConsumableArray(indexes)));
                  return new Range(start, end - start);
                }
              }, {
                key: "normalizeNative",
                value: function normalizeNative(nativeRange) {
                  if (!contains3(this.root, nativeRange.startContainer) || !nativeRange.collapsed && !contains3(this.root, nativeRange.endContainer)) {
                    return null;
                  }
                  var range = {
                    start: { node: nativeRange.startContainer, offset: nativeRange.startOffset },
                    end: { node: nativeRange.endContainer, offset: nativeRange.endOffset },
                    native: nativeRange
                  };
                  [range.start, range.end].forEach(function(position3) {
                    var node3 = position3.node, offset = position3.offset;
                    while (!(node3 instanceof Text) && node3.childNodes.length > 0) {
                      if (node3.childNodes.length > offset) {
                        node3 = node3.childNodes[offset];
                        offset = 0;
                      } else if (node3.childNodes.length === offset) {
                        node3 = node3.lastChild;
                        offset = node3 instanceof Text ? node3.data.length : node3.childNodes.length + 1;
                      } else {
                        break;
                      }
                    }
                    position3.node = node3, position3.offset = offset;
                  });
                  return range;
                }
              }, {
                key: "rangeToNative",
                value: function rangeToNative(range) {
                  var _this5 = this;
                  var indexes = range.collapsed ? [range.index] : [range.index, range.index + range.length];
                  var args = [];
                  var scrollLength = this.scroll.length();
                  indexes.forEach(function(index3, i2) {
                    index3 = Math.min(scrollLength - 1, index3);
                    var node3 = void 0, _scroll$leaf5 = _this5.scroll.leaf(index3), _scroll$leaf6 = _slicedToArray(_scroll$leaf5, 2), leaf = _scroll$leaf6[0], offset = _scroll$leaf6[1];
                    var _leaf$position5 = leaf.position(offset, i2 !== 0);
                    var _leaf$position6 = _slicedToArray(_leaf$position5, 2);
                    node3 = _leaf$position6[0];
                    offset = _leaf$position6[1];
                    args.push(node3, offset);
                  });
                  if (args.length < 2) {
                    args = args.concat(args);
                  }
                  return args;
                }
              }, {
                key: "scrollIntoView",
                value: function scrollIntoView(scrollingContainer) {
                  var range = this.lastRange;
                  if (range == null)
                    return;
                  var bounds = this.getBounds(range.index, range.length);
                  if (bounds == null)
                    return;
                  var limit = this.scroll.length() - 1;
                  var _scroll$line = this.scroll.line(Math.min(range.index, limit)), _scroll$line2 = _slicedToArray(_scroll$line, 1), first = _scroll$line2[0];
                  var last = first;
                  if (range.length > 0) {
                    var _scroll$line3 = this.scroll.line(Math.min(range.index + range.length, limit));
                    var _scroll$line4 = _slicedToArray(_scroll$line3, 1);
                    last = _scroll$line4[0];
                  }
                  if (first == null || last == null)
                    return;
                  var scrollBounds = scrollingContainer.getBoundingClientRect();
                  if (bounds.top < scrollBounds.top) {
                    scrollingContainer.scrollTop -= scrollBounds.top - bounds.top;
                  } else if (bounds.bottom > scrollBounds.bottom) {
                    scrollingContainer.scrollTop += bounds.bottom - scrollBounds.bottom;
                  }
                }
              }, {
                key: "setNativeRange",
                value: function setNativeRange(startNode, startOffset) {
                  var endNode = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : startNode;
                  var endOffset = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : startOffset;
                  var force = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : false;
                  debug.info("setNativeRange", startNode, startOffset, endNode, endOffset);
                  if (startNode != null && (this.root.parentNode == null || startNode.parentNode == null || endNode.parentNode == null)) {
                    return;
                  }
                  var selection = document.getSelection();
                  if (selection == null)
                    return;
                  if (startNode != null) {
                    if (!this.hasFocus())
                      this.root.focus();
                    var native = (this.getNativeRange() || {}).native;
                    if (native == null || force || startNode !== native.startContainer || startOffset !== native.startOffset || endNode !== native.endContainer || endOffset !== native.endOffset) {
                      if (startNode.tagName == "BR") {
                        startOffset = [].indexOf.call(startNode.parentNode.childNodes, startNode);
                        startNode = startNode.parentNode;
                      }
                      if (endNode.tagName == "BR") {
                        endOffset = [].indexOf.call(endNode.parentNode.childNodes, endNode);
                        endNode = endNode.parentNode;
                      }
                      var range = document.createRange();
                      range.setStart(startNode, startOffset);
                      range.setEnd(endNode, endOffset);
                      selection.removeAllRanges();
                      selection.addRange(range);
                    }
                  } else {
                    selection.removeAllRanges();
                    this.root.blur();
                    document.body.focus();
                  }
                }
              }, {
                key: "setRange",
                value: function setRange(range) {
                  var force = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
                  var source = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : _emitter4.default.sources.API;
                  if (typeof force === "string") {
                    source = force;
                    force = false;
                  }
                  debug.info("setRange", range);
                  if (range != null) {
                    var args = this.rangeToNative(range);
                    this.setNativeRange.apply(this, _toConsumableArray(args).concat([force]));
                  } else {
                    this.setNativeRange(null);
                  }
                  this.update(source);
                }
              }, {
                key: "update",
                value: function update() {
                  var source = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : _emitter4.default.sources.USER;
                  var oldRange = this.lastRange;
                  var _getRange = this.getRange(), _getRange2 = _slicedToArray(_getRange, 2), lastRange = _getRange2[0], nativeRange = _getRange2[1];
                  this.lastRange = lastRange;
                  if (this.lastRange != null) {
                    this.savedRange = this.lastRange;
                  }
                  if (!(0, _deepEqual2.default)(oldRange, this.lastRange)) {
                    var _emitter;
                    if (!this.composing && nativeRange != null && nativeRange.native.collapsed && nativeRange.start.node !== this.cursor.textNode) {
                      this.cursor.restore();
                    }
                    var args = [_emitter4.default.events.SELECTION_CHANGE, (0, _clone2.default)(this.lastRange), (0, _clone2.default)(oldRange), source];
                    (_emitter = this.emitter).emit.apply(_emitter, [_emitter4.default.events.EDITOR_CHANGE].concat(args));
                    if (source !== _emitter4.default.sources.SILENT) {
                      var _emitter2;
                      (_emitter2 = this.emitter).emit.apply(_emitter2, args);
                    }
                  }
                }
              }]);
              return Selection2;
            }();
            function contains3(parent, descendant) {
              try {
                descendant.parentNode;
              } catch (e2) {
                return false;
              }
              if (descendant instanceof Text) {
                descendant = descendant.parentNode;
              }
              return parent.contains(descendant);
            }
            exports2.Range = Range;
            exports2.default = Selection;
          },
          /* 16 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _createClass = function() {
              function defineProperties(target, props) {
                for (var i2 = 0; i2 < props.length; i2++) {
                  var descriptor = props[i2];
                  descriptor.enumerable = descriptor.enumerable || false;
                  descriptor.configurable = true;
                  if ("value" in descriptor)
                    descriptor.writable = true;
                  Object.defineProperty(target, descriptor.key, descriptor);
                }
              }
              return function(Constructor, protoProps, staticProps) {
                if (protoProps)
                  defineProperties(Constructor.prototype, protoProps);
                if (staticProps)
                  defineProperties(Constructor, staticProps);
                return Constructor;
              };
            }();
            var _get = function get(object, property, receiver) {
              if (object === null)
                object = Function.prototype;
              var desc = Object.getOwnPropertyDescriptor(object, property);
              if (desc === void 0) {
                var parent = Object.getPrototypeOf(object);
                if (parent === null) {
                  return void 0;
                } else {
                  return get(parent, property, receiver);
                }
              } else if ("value" in desc) {
                return desc.value;
              } else {
                var getter = desc.get;
                if (getter === void 0) {
                  return void 0;
                }
                return getter.call(receiver);
              }
            };
            var _parchment = __webpack_require__(0);
            var _parchment2 = _interopRequireDefault(_parchment);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { default: obj };
            }
            function _classCallCheck2(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function _possibleConstructorReturn(self2, call) {
              if (!self2) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return call && (typeof call === "object" || typeof call === "function") ? call : self2;
            }
            function _inherits(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
              }
              subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
              if (superClass)
                Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
            }
            var Break = function(_Parchment$Embed) {
              _inherits(Break2, _Parchment$Embed);
              function Break2() {
                _classCallCheck2(this, Break2);
                return _possibleConstructorReturn(this, (Break2.__proto__ || Object.getPrototypeOf(Break2)).apply(this, arguments));
              }
              _createClass(Break2, [{
                key: "insertInto",
                value: function insertInto(parent, ref) {
                  if (parent.children.length === 0) {
                    _get(Break2.prototype.__proto__ || Object.getPrototypeOf(Break2.prototype), "insertInto", this).call(this, parent, ref);
                  } else {
                    this.remove();
                  }
                }
              }, {
                key: "length",
                value: function length2() {
                  return 0;
                }
              }, {
                key: "value",
                value: function value() {
                  return "";
                }
              }], [{
                key: "value",
                value: function value() {
                  return void 0;
                }
              }]);
              return Break2;
            }(_parchment2.default.Embed);
            Break.blotName = "break";
            Break.tagName = "BR";
            exports2.default = Break;
          },
          /* 17 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            var __extends3 = this && this.__extends || function() {
              var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
                d.__proto__ = b;
              } || function(d, b) {
                for (var p2 in b)
                  if (b.hasOwnProperty(p2))
                    d[p2] = b[p2];
              };
              return function(d, b) {
                extendStatics(d, b);
                function __() {
                  this.constructor = d;
                }
                d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
              };
            }();
            Object.defineProperty(exports2, "__esModule", { value: true });
            var linked_list_1 = __webpack_require__(44);
            var shadow_1 = __webpack_require__(30);
            var Registry = __webpack_require__(1);
            var ContainerBlot = (
              /** @class */
              function(_super) {
                __extends3(ContainerBlot2, _super);
                function ContainerBlot2(domNode) {
                  var _this = _super.call(this, domNode) || this;
                  _this.build();
                  return _this;
                }
                ContainerBlot2.prototype.appendChild = function(other) {
                  this.insertBefore(other);
                };
                ContainerBlot2.prototype.attach = function() {
                  _super.prototype.attach.call(this);
                  this.children.forEach(function(child) {
                    child.attach();
                  });
                };
                ContainerBlot2.prototype.build = function() {
                  var _this = this;
                  this.children = new linked_list_1.default();
                  [].slice.call(this.domNode.childNodes).reverse().forEach(function(node3) {
                    try {
                      var child = makeBlot(node3);
                      _this.insertBefore(child, _this.children.head || void 0);
                    } catch (err) {
                      if (err instanceof Registry.ParchmentError)
                        return;
                      else
                        throw err;
                    }
                  });
                };
                ContainerBlot2.prototype.deleteAt = function(index3, length2) {
                  if (index3 === 0 && length2 === this.length()) {
                    return this.remove();
                  }
                  this.children.forEachAt(index3, length2, function(child, offset, length3) {
                    child.deleteAt(offset, length3);
                  });
                };
                ContainerBlot2.prototype.descendant = function(criteria, index3) {
                  var _a2 = this.children.find(index3), child = _a2[0], offset = _a2[1];
                  if (criteria.blotName == null && criteria(child) || criteria.blotName != null && child instanceof criteria) {
                    return [child, offset];
                  } else if (child instanceof ContainerBlot2) {
                    return child.descendant(criteria, offset);
                  } else {
                    return [null, -1];
                  }
                };
                ContainerBlot2.prototype.descendants = function(criteria, index3, length2) {
                  if (index3 === void 0) {
                    index3 = 0;
                  }
                  if (length2 === void 0) {
                    length2 = Number.MAX_VALUE;
                  }
                  var descendants = [];
                  var lengthLeft = length2;
                  this.children.forEachAt(index3, length2, function(child, index4, length3) {
                    if (criteria.blotName == null && criteria(child) || criteria.blotName != null && child instanceof criteria) {
                      descendants.push(child);
                    }
                    if (child instanceof ContainerBlot2) {
                      descendants = descendants.concat(child.descendants(criteria, index4, lengthLeft));
                    }
                    lengthLeft -= length3;
                  });
                  return descendants;
                };
                ContainerBlot2.prototype.detach = function() {
                  this.children.forEach(function(child) {
                    child.detach();
                  });
                  _super.prototype.detach.call(this);
                };
                ContainerBlot2.prototype.formatAt = function(index3, length2, name, value) {
                  this.children.forEachAt(index3, length2, function(child, offset, length3) {
                    child.formatAt(offset, length3, name, value);
                  });
                };
                ContainerBlot2.prototype.insertAt = function(index3, value, def) {
                  var _a2 = this.children.find(index3), child = _a2[0], offset = _a2[1];
                  if (child) {
                    child.insertAt(offset, value, def);
                  } else {
                    var blot = def == null ? Registry.create("text", value) : Registry.create(value, def);
                    this.appendChild(blot);
                  }
                };
                ContainerBlot2.prototype.insertBefore = function(childBlot, refBlot) {
                  if (this.statics.allowedChildren != null && !this.statics.allowedChildren.some(function(child) {
                    return childBlot instanceof child;
                  })) {
                    throw new Registry.ParchmentError("Cannot insert " + childBlot.statics.blotName + " into " + this.statics.blotName);
                  }
                  childBlot.insertInto(this, refBlot);
                };
                ContainerBlot2.prototype.length = function() {
                  return this.children.reduce(function(memo, child) {
                    return memo + child.length();
                  }, 0);
                };
                ContainerBlot2.prototype.moveChildren = function(targetParent, refNode) {
                  this.children.forEach(function(child) {
                    targetParent.insertBefore(child, refNode);
                  });
                };
                ContainerBlot2.prototype.optimize = function(context) {
                  _super.prototype.optimize.call(this, context);
                  if (this.children.length === 0) {
                    if (this.statics.defaultChild != null) {
                      var child = Registry.create(this.statics.defaultChild);
                      this.appendChild(child);
                      child.optimize(context);
                    } else {
                      this.remove();
                    }
                  }
                };
                ContainerBlot2.prototype.path = function(index3, inclusive) {
                  if (inclusive === void 0) {
                    inclusive = false;
                  }
                  var _a2 = this.children.find(index3, inclusive), child = _a2[0], offset = _a2[1];
                  var position3 = [[this, index3]];
                  if (child instanceof ContainerBlot2) {
                    return position3.concat(child.path(offset, inclusive));
                  } else if (child != null) {
                    position3.push([child, offset]);
                  }
                  return position3;
                };
                ContainerBlot2.prototype.removeChild = function(child) {
                  this.children.remove(child);
                };
                ContainerBlot2.prototype.replace = function(target) {
                  if (target instanceof ContainerBlot2) {
                    target.moveChildren(this);
                  }
                  _super.prototype.replace.call(this, target);
                };
                ContainerBlot2.prototype.split = function(index3, force) {
                  if (force === void 0) {
                    force = false;
                  }
                  if (!force) {
                    if (index3 === 0)
                      return this;
                    if (index3 === this.length())
                      return this.next;
                  }
                  var after2 = this.clone();
                  this.parent.insertBefore(after2, this.next);
                  this.children.forEachAt(index3, this.length(), function(child, offset, length2) {
                    child = child.split(offset, force);
                    after2.appendChild(child);
                  });
                  return after2;
                };
                ContainerBlot2.prototype.unwrap = function() {
                  this.moveChildren(this.parent, this.next);
                  this.remove();
                };
                ContainerBlot2.prototype.update = function(mutations, context) {
                  var _this = this;
                  var addedNodes = [];
                  var removedNodes = [];
                  mutations.forEach(function(mutation) {
                    if (mutation.target === _this.domNode && mutation.type === "childList") {
                      addedNodes.push.apply(addedNodes, mutation.addedNodes);
                      removedNodes.push.apply(removedNodes, mutation.removedNodes);
                    }
                  });
                  removedNodes.forEach(function(node3) {
                    if (node3.parentNode != null && // @ts-ignore
                    node3.tagName !== "IFRAME" && document.body.compareDocumentPosition(node3) & Node.DOCUMENT_POSITION_CONTAINED_BY) {
                      return;
                    }
                    var blot = Registry.find(node3);
                    if (blot == null)
                      return;
                    if (blot.domNode.parentNode == null || blot.domNode.parentNode === _this.domNode) {
                      blot.detach();
                    }
                  });
                  addedNodes.filter(function(node3) {
                    return node3.parentNode == _this.domNode;
                  }).sort(function(a2, b) {
                    if (a2 === b)
                      return 0;
                    if (a2.compareDocumentPosition(b) & Node.DOCUMENT_POSITION_FOLLOWING) {
                      return 1;
                    }
                    return -1;
                  }).forEach(function(node3) {
                    var refBlot = null;
                    if (node3.nextSibling != null) {
                      refBlot = Registry.find(node3.nextSibling);
                    }
                    var blot = makeBlot(node3);
                    if (blot.next != refBlot || blot.next == null) {
                      if (blot.parent != null) {
                        blot.parent.removeChild(_this);
                      }
                      _this.insertBefore(blot, refBlot || void 0);
                    }
                  });
                };
                return ContainerBlot2;
              }(shadow_1.default)
            );
            function makeBlot(node3) {
              var blot = Registry.find(node3);
              if (blot == null) {
                try {
                  blot = Registry.create(node3);
                } catch (e2) {
                  blot = Registry.create(Registry.Scope.INLINE);
                  [].slice.call(node3.childNodes).forEach(function(child) {
                    blot.domNode.appendChild(child);
                  });
                  if (node3.parentNode) {
                    node3.parentNode.replaceChild(blot.domNode, node3);
                  }
                  blot.attach();
                }
              }
              return blot;
            }
            exports2.default = ContainerBlot;
          },
          /* 18 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            var __extends3 = this && this.__extends || function() {
              var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
                d.__proto__ = b;
              } || function(d, b) {
                for (var p2 in b)
                  if (b.hasOwnProperty(p2))
                    d[p2] = b[p2];
              };
              return function(d, b) {
                extendStatics(d, b);
                function __() {
                  this.constructor = d;
                }
                d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
              };
            }();
            Object.defineProperty(exports2, "__esModule", { value: true });
            var attributor_1 = __webpack_require__(12);
            var store_1 = __webpack_require__(31);
            var container_1 = __webpack_require__(17);
            var Registry = __webpack_require__(1);
            var FormatBlot = (
              /** @class */
              function(_super) {
                __extends3(FormatBlot2, _super);
                function FormatBlot2(domNode) {
                  var _this = _super.call(this, domNode) || this;
                  _this.attributes = new store_1.default(_this.domNode);
                  return _this;
                }
                FormatBlot2.formats = function(domNode) {
                  if (typeof this.tagName === "string") {
                    return true;
                  } else if (Array.isArray(this.tagName)) {
                    return domNode.tagName.toLowerCase();
                  }
                  return void 0;
                };
                FormatBlot2.prototype.format = function(name, value) {
                  var format = Registry.query(name);
                  if (format instanceof attributor_1.default) {
                    this.attributes.attribute(format, value);
                  } else if (value) {
                    if (format != null && (name !== this.statics.blotName || this.formats()[name] !== value)) {
                      this.replaceWith(name, value);
                    }
                  }
                };
                FormatBlot2.prototype.formats = function() {
                  var formats = this.attributes.values();
                  var format = this.statics.formats(this.domNode);
                  if (format != null) {
                    formats[this.statics.blotName] = format;
                  }
                  return formats;
                };
                FormatBlot2.prototype.replaceWith = function(name, value) {
                  var replacement = _super.prototype.replaceWith.call(this, name, value);
                  this.attributes.copy(replacement);
                  return replacement;
                };
                FormatBlot2.prototype.update = function(mutations, context) {
                  var _this = this;
                  _super.prototype.update.call(this, mutations, context);
                  if (mutations.some(function(mutation) {
                    return mutation.target === _this.domNode && mutation.type === "attributes";
                  })) {
                    this.attributes.build();
                  }
                };
                FormatBlot2.prototype.wrap = function(name, value) {
                  var wrapper = _super.prototype.wrap.call(this, name, value);
                  if (wrapper instanceof FormatBlot2 && wrapper.statics.scope === this.statics.scope) {
                    this.attributes.move(wrapper);
                  }
                  return wrapper;
                };
                return FormatBlot2;
              }(container_1.default)
            );
            exports2.default = FormatBlot;
          },
          /* 19 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            var __extends3 = this && this.__extends || function() {
              var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
                d.__proto__ = b;
              } || function(d, b) {
                for (var p2 in b)
                  if (b.hasOwnProperty(p2))
                    d[p2] = b[p2];
              };
              return function(d, b) {
                extendStatics(d, b);
                function __() {
                  this.constructor = d;
                }
                d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
              };
            }();
            Object.defineProperty(exports2, "__esModule", { value: true });
            var shadow_1 = __webpack_require__(30);
            var Registry = __webpack_require__(1);
            var LeafBlot = (
              /** @class */
              function(_super) {
                __extends3(LeafBlot2, _super);
                function LeafBlot2() {
                  return _super !== null && _super.apply(this, arguments) || this;
                }
                LeafBlot2.value = function(domNode) {
                  return true;
                };
                LeafBlot2.prototype.index = function(node3, offset) {
                  if (this.domNode === node3 || this.domNode.compareDocumentPosition(node3) & Node.DOCUMENT_POSITION_CONTAINED_BY) {
                    return Math.min(offset, 1);
                  }
                  return -1;
                };
                LeafBlot2.prototype.position = function(index3, inclusive) {
                  var offset = [].indexOf.call(this.parent.domNode.childNodes, this.domNode);
                  if (index3 > 0)
                    offset += 1;
                  return [this.parent.domNode, offset];
                };
                LeafBlot2.prototype.value = function() {
                  return _a2 = {}, _a2[this.statics.blotName] = this.statics.value(this.domNode) || true, _a2;
                  var _a2;
                };
                LeafBlot2.scope = Registry.Scope.INLINE_BLOT;
                return LeafBlot2;
              }(shadow_1.default)
            );
            exports2.default = LeafBlot;
          },
          /* 20 */
          /***/
          function(module2, exports2, __webpack_require__) {
            var equal = __webpack_require__(11);
            var extend2 = __webpack_require__(3);
            var lib = {
              attributes: {
                compose: function(a2, b, keepNull) {
                  if (typeof a2 !== "object")
                    a2 = {};
                  if (typeof b !== "object")
                    b = {};
                  var attributes = extend2(true, {}, b);
                  if (!keepNull) {
                    attributes = Object.keys(attributes).reduce(function(copy, key2) {
                      if (attributes[key2] != null) {
                        copy[key2] = attributes[key2];
                      }
                      return copy;
                    }, {});
                  }
                  for (var key in a2) {
                    if (a2[key] !== void 0 && b[key] === void 0) {
                      attributes[key] = a2[key];
                    }
                  }
                  return Object.keys(attributes).length > 0 ? attributes : void 0;
                },
                diff: function(a2, b) {
                  if (typeof a2 !== "object")
                    a2 = {};
                  if (typeof b !== "object")
                    b = {};
                  var attributes = Object.keys(a2).concat(Object.keys(b)).reduce(function(attributes2, key) {
                    if (!equal(a2[key], b[key])) {
                      attributes2[key] = b[key] === void 0 ? null : b[key];
                    }
                    return attributes2;
                  }, {});
                  return Object.keys(attributes).length > 0 ? attributes : void 0;
                },
                transform: function(a2, b, priority) {
                  if (typeof a2 !== "object")
                    return b;
                  if (typeof b !== "object")
                    return void 0;
                  if (!priority)
                    return b;
                  var attributes = Object.keys(b).reduce(function(attributes2, key) {
                    if (a2[key] === void 0)
                      attributes2[key] = b[key];
                    return attributes2;
                  }, {});
                  return Object.keys(attributes).length > 0 ? attributes : void 0;
                }
              },
              iterator: function(ops) {
                return new Iterator(ops);
              },
              length: function(op2) {
                if (typeof op2["delete"] === "number") {
                  return op2["delete"];
                } else if (typeof op2.retain === "number") {
                  return op2.retain;
                } else {
                  return typeof op2.insert === "string" ? op2.insert.length : 1;
                }
              }
            };
            function Iterator(ops) {
              this.ops = ops;
              this.index = 0;
              this.offset = 0;
            }
            ;
            Iterator.prototype.hasNext = function() {
              return this.peekLength() < Infinity;
            };
            Iterator.prototype.next = function(length2) {
              if (!length2)
                length2 = Infinity;
              var nextOp = this.ops[this.index];
              if (nextOp) {
                var offset = this.offset;
                var opLength = lib.length(nextOp);
                if (length2 >= opLength - offset) {
                  length2 = opLength - offset;
                  this.index += 1;
                  this.offset = 0;
                } else {
                  this.offset += length2;
                }
                if (typeof nextOp["delete"] === "number") {
                  return { "delete": length2 };
                } else {
                  var retOp = {};
                  if (nextOp.attributes) {
                    retOp.attributes = nextOp.attributes;
                  }
                  if (typeof nextOp.retain === "number") {
                    retOp.retain = length2;
                  } else if (typeof nextOp.insert === "string") {
                    retOp.insert = nextOp.insert.substr(offset, length2);
                  } else {
                    retOp.insert = nextOp.insert;
                  }
                  return retOp;
                }
              } else {
                return { retain: Infinity };
              }
            };
            Iterator.prototype.peek = function() {
              return this.ops[this.index];
            };
            Iterator.prototype.peekLength = function() {
              if (this.ops[this.index]) {
                return lib.length(this.ops[this.index]) - this.offset;
              } else {
                return Infinity;
              }
            };
            Iterator.prototype.peekType = function() {
              if (this.ops[this.index]) {
                if (typeof this.ops[this.index]["delete"] === "number") {
                  return "delete";
                } else if (typeof this.ops[this.index].retain === "number") {
                  return "retain";
                } else {
                  return "insert";
                }
              }
              return "retain";
            };
            module2.exports = lib;
          },
          /* 21 */
          /***/
          function(module2, exports2) {
            var clone = function() {
              "use strict";
              function _instanceof(obj, type) {
                return type != null && obj instanceof type;
              }
              var nativeMap;
              try {
                nativeMap = Map;
              } catch (_2) {
                nativeMap = function() {
                };
              }
              var nativeSet;
              try {
                nativeSet = Set;
              } catch (_2) {
                nativeSet = function() {
                };
              }
              var nativePromise;
              try {
                nativePromise = Promise;
              } catch (_2) {
                nativePromise = function() {
                };
              }
              function clone2(parent, circular, depth, prototype, includeNonEnumerable) {
                if (typeof circular === "object") {
                  depth = circular.depth;
                  prototype = circular.prototype;
                  includeNonEnumerable = circular.includeNonEnumerable;
                  circular = circular.circular;
                }
                var allParents = [];
                var allChildren = [];
                var useBuffer = typeof Buffer != "undefined";
                if (typeof circular == "undefined")
                  circular = true;
                if (typeof depth == "undefined")
                  depth = Infinity;
                function _clone(parent2, depth2) {
                  if (parent2 === null)
                    return null;
                  if (depth2 === 0)
                    return parent2;
                  var child;
                  var proto;
                  if (typeof parent2 != "object") {
                    return parent2;
                  }
                  if (_instanceof(parent2, nativeMap)) {
                    child = new nativeMap();
                  } else if (_instanceof(parent2, nativeSet)) {
                    child = new nativeSet();
                  } else if (_instanceof(parent2, nativePromise)) {
                    child = new nativePromise(function(resolve, reject) {
                      parent2.then(function(value) {
                        resolve(_clone(value, depth2 - 1));
                      }, function(err) {
                        reject(_clone(err, depth2 - 1));
                      });
                    });
                  } else if (clone2.__isArray(parent2)) {
                    child = [];
                  } else if (clone2.__isRegExp(parent2)) {
                    child = new RegExp(parent2.source, __getRegExpFlags(parent2));
                    if (parent2.lastIndex)
                      child.lastIndex = parent2.lastIndex;
                  } else if (clone2.__isDate(parent2)) {
                    child = new Date(parent2.getTime());
                  } else if (useBuffer && Buffer.isBuffer(parent2)) {
                    child = new Buffer(parent2.length);
                    parent2.copy(child);
                    return child;
                  } else if (_instanceof(parent2, Error)) {
                    child = Object.create(parent2);
                  } else {
                    if (typeof prototype == "undefined") {
                      proto = Object.getPrototypeOf(parent2);
                      child = Object.create(proto);
                    } else {
                      child = Object.create(prototype);
                      proto = prototype;
                    }
                  }
                  if (circular) {
                    var index3 = allParents.indexOf(parent2);
                    if (index3 != -1) {
                      return allChildren[index3];
                    }
                    allParents.push(parent2);
                    allChildren.push(child);
                  }
                  if (_instanceof(parent2, nativeMap)) {
                    parent2.forEach(function(value, key) {
                      var keyChild = _clone(key, depth2 - 1);
                      var valueChild = _clone(value, depth2 - 1);
                      child.set(keyChild, valueChild);
                    });
                  }
                  if (_instanceof(parent2, nativeSet)) {
                    parent2.forEach(function(value) {
                      var entryChild = _clone(value, depth2 - 1);
                      child.add(entryChild);
                    });
                  }
                  for (var i2 in parent2) {
                    var attrs2;
                    if (proto) {
                      attrs2 = Object.getOwnPropertyDescriptor(proto, i2);
                    }
                    if (attrs2 && attrs2.set == null) {
                      continue;
                    }
                    child[i2] = _clone(parent2[i2], depth2 - 1);
                  }
                  if (Object.getOwnPropertySymbols) {
                    var symbols2 = Object.getOwnPropertySymbols(parent2);
                    for (var i2 = 0; i2 < symbols2.length; i2++) {
                      var symbol = symbols2[i2];
                      var descriptor = Object.getOwnPropertyDescriptor(parent2, symbol);
                      if (descriptor && !descriptor.enumerable && !includeNonEnumerable) {
                        continue;
                      }
                      child[symbol] = _clone(parent2[symbol], depth2 - 1);
                      if (!descriptor.enumerable) {
                        Object.defineProperty(child, symbol, {
                          enumerable: false
                        });
                      }
                    }
                  }
                  if (includeNonEnumerable) {
                    var allPropertyNames = Object.getOwnPropertyNames(parent2);
                    for (var i2 = 0; i2 < allPropertyNames.length; i2++) {
                      var propertyName = allPropertyNames[i2];
                      var descriptor = Object.getOwnPropertyDescriptor(parent2, propertyName);
                      if (descriptor && descriptor.enumerable) {
                        continue;
                      }
                      child[propertyName] = _clone(parent2[propertyName], depth2 - 1);
                      Object.defineProperty(child, propertyName, {
                        enumerable: false
                      });
                    }
                  }
                  return child;
                }
                return _clone(parent, depth);
              }
              clone2.clonePrototype = function clonePrototype(parent) {
                if (parent === null)
                  return null;
                var c3 = function() {
                };
                c3.prototype = parent;
                return new c3();
              };
              function __objToStr(o2) {
                return Object.prototype.toString.call(o2);
              }
              clone2.__objToStr = __objToStr;
              function __isDate(o2) {
                return typeof o2 === "object" && __objToStr(o2) === "[object Date]";
              }
              clone2.__isDate = __isDate;
              function __isArray(o2) {
                return typeof o2 === "object" && __objToStr(o2) === "[object Array]";
              }
              clone2.__isArray = __isArray;
              function __isRegExp(o2) {
                return typeof o2 === "object" && __objToStr(o2) === "[object RegExp]";
              }
              clone2.__isRegExp = __isRegExp;
              function __getRegExpFlags(re) {
                var flags = "";
                if (re.global)
                  flags += "g";
                if (re.ignoreCase)
                  flags += "i";
                if (re.multiline)
                  flags += "m";
                return flags;
              }
              clone2.__getRegExpFlags = __getRegExpFlags;
              return clone2;
            }();
            if (typeof module2 === "object" && module2.exports) {
              module2.exports = clone;
            }
          },
          /* 22 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _slicedToArray = function() {
              function sliceIterator(arr, i2) {
                var _arr = [];
                var _n = true;
                var _d = false;
                var _e = void 0;
                try {
                  for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                    _arr.push(_s.value);
                    if (i2 && _arr.length === i2)
                      break;
                  }
                } catch (err) {
                  _d = true;
                  _e = err;
                } finally {
                  try {
                    if (!_n && _i["return"])
                      _i["return"]();
                  } finally {
                    if (_d)
                      throw _e;
                  }
                }
                return _arr;
              }
              return function(arr, i2) {
                if (Array.isArray(arr)) {
                  return arr;
                } else if (Symbol.iterator in Object(arr)) {
                  return sliceIterator(arr, i2);
                } else {
                  throw new TypeError("Invalid attempt to destructure non-iterable instance");
                }
              };
            }();
            var _createClass = function() {
              function defineProperties(target, props) {
                for (var i2 = 0; i2 < props.length; i2++) {
                  var descriptor = props[i2];
                  descriptor.enumerable = descriptor.enumerable || false;
                  descriptor.configurable = true;
                  if ("value" in descriptor)
                    descriptor.writable = true;
                  Object.defineProperty(target, descriptor.key, descriptor);
                }
              }
              return function(Constructor, protoProps, staticProps) {
                if (protoProps)
                  defineProperties(Constructor.prototype, protoProps);
                if (staticProps)
                  defineProperties(Constructor, staticProps);
                return Constructor;
              };
            }();
            var _get = function get(object, property, receiver) {
              if (object === null)
                object = Function.prototype;
              var desc = Object.getOwnPropertyDescriptor(object, property);
              if (desc === void 0) {
                var parent = Object.getPrototypeOf(object);
                if (parent === null) {
                  return void 0;
                } else {
                  return get(parent, property, receiver);
                }
              } else if ("value" in desc) {
                return desc.value;
              } else {
                var getter = desc.get;
                if (getter === void 0) {
                  return void 0;
                }
                return getter.call(receiver);
              }
            };
            var _parchment = __webpack_require__(0);
            var _parchment2 = _interopRequireDefault(_parchment);
            var _emitter = __webpack_require__(8);
            var _emitter2 = _interopRequireDefault(_emitter);
            var _block = __webpack_require__(4);
            var _block2 = _interopRequireDefault(_block);
            var _break = __webpack_require__(16);
            var _break2 = _interopRequireDefault(_break);
            var _code = __webpack_require__(13);
            var _code2 = _interopRequireDefault(_code);
            var _container = __webpack_require__(25);
            var _container2 = _interopRequireDefault(_container);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { default: obj };
            }
            function _classCallCheck2(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function _possibleConstructorReturn(self2, call) {
              if (!self2) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return call && (typeof call === "object" || typeof call === "function") ? call : self2;
            }
            function _inherits(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
              }
              subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
              if (superClass)
                Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
            }
            function isLine(blot) {
              return blot instanceof _block2.default || blot instanceof _block.BlockEmbed;
            }
            var Scroll = function(_Parchment$Scroll) {
              _inherits(Scroll2, _Parchment$Scroll);
              function Scroll2(domNode, config) {
                _classCallCheck2(this, Scroll2);
                var _this = _possibleConstructorReturn(this, (Scroll2.__proto__ || Object.getPrototypeOf(Scroll2)).call(this, domNode));
                _this.emitter = config.emitter;
                if (Array.isArray(config.whitelist)) {
                  _this.whitelist = config.whitelist.reduce(function(whitelist, format) {
                    whitelist[format] = true;
                    return whitelist;
                  }, {});
                }
                _this.domNode.addEventListener("DOMNodeInserted", function() {
                });
                _this.optimize();
                _this.enable();
                return _this;
              }
              _createClass(Scroll2, [{
                key: "batchStart",
                value: function batchStart() {
                  this.batch = true;
                }
              }, {
                key: "batchEnd",
                value: function batchEnd() {
                  this.batch = false;
                  this.optimize();
                }
              }, {
                key: "deleteAt",
                value: function deleteAt(index3, length2) {
                  var _line = this.line(index3), _line2 = _slicedToArray(_line, 2), first = _line2[0], offset = _line2[1];
                  var _line3 = this.line(index3 + length2), _line4 = _slicedToArray(_line3, 1), last = _line4[0];
                  _get(Scroll2.prototype.__proto__ || Object.getPrototypeOf(Scroll2.prototype), "deleteAt", this).call(this, index3, length2);
                  if (last != null && first !== last && offset > 0) {
                    if (first instanceof _block.BlockEmbed || last instanceof _block.BlockEmbed) {
                      this.optimize();
                      return;
                    }
                    if (first instanceof _code2.default) {
                      var newlineIndex = first.newlineIndex(first.length(), true);
                      if (newlineIndex > -1) {
                        first = first.split(newlineIndex + 1);
                        if (first === last) {
                          this.optimize();
                          return;
                        }
                      }
                    } else if (last instanceof _code2.default) {
                      var _newlineIndex = last.newlineIndex(0);
                      if (_newlineIndex > -1) {
                        last.split(_newlineIndex + 1);
                      }
                    }
                    var ref = last.children.head instanceof _break2.default ? null : last.children.head;
                    first.moveChildren(last, ref);
                    first.remove();
                  }
                  this.optimize();
                }
              }, {
                key: "enable",
                value: function enable() {
                  var enabled = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
                  this.domNode.setAttribute("contenteditable", enabled);
                }
              }, {
                key: "formatAt",
                value: function formatAt(index3, length2, format, value) {
                  if (this.whitelist != null && !this.whitelist[format])
                    return;
                  _get(Scroll2.prototype.__proto__ || Object.getPrototypeOf(Scroll2.prototype), "formatAt", this).call(this, index3, length2, format, value);
                  this.optimize();
                }
              }, {
                key: "insertAt",
                value: function insertAt(index3, value, def) {
                  if (def != null && this.whitelist != null && !this.whitelist[value])
                    return;
                  if (index3 >= this.length()) {
                    if (def == null || _parchment2.default.query(value, _parchment2.default.Scope.BLOCK) == null) {
                      var blot = _parchment2.default.create(this.statics.defaultChild);
                      this.appendChild(blot);
                      if (def == null && value.endsWith("\n")) {
                        value = value.slice(0, -1);
                      }
                      blot.insertAt(0, value, def);
                    } else {
                      var embed = _parchment2.default.create(value, def);
                      this.appendChild(embed);
                    }
                  } else {
                    _get(Scroll2.prototype.__proto__ || Object.getPrototypeOf(Scroll2.prototype), "insertAt", this).call(this, index3, value, def);
                  }
                  this.optimize();
                }
              }, {
                key: "insertBefore",
                value: function insertBefore2(blot, ref) {
                  if (blot.statics.scope === _parchment2.default.Scope.INLINE_BLOT) {
                    var wrapper = _parchment2.default.create(this.statics.defaultChild);
                    wrapper.appendChild(blot);
                    blot = wrapper;
                  }
                  _get(Scroll2.prototype.__proto__ || Object.getPrototypeOf(Scroll2.prototype), "insertBefore", this).call(this, blot, ref);
                }
              }, {
                key: "leaf",
                value: function leaf(index3) {
                  return this.path(index3).pop() || [null, -1];
                }
              }, {
                key: "line",
                value: function line(index3) {
                  if (index3 === this.length()) {
                    return this.line(index3 - 1);
                  }
                  return this.descendant(isLine, index3);
                }
              }, {
                key: "lines",
                value: function lines() {
                  var index3 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
                  var length2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Number.MAX_VALUE;
                  var getLines = function getLines2(blot, index4, length3) {
                    var lines2 = [], lengthLeft = length3;
                    blot.children.forEachAt(index4, length3, function(child, index5, length4) {
                      if (isLine(child)) {
                        lines2.push(child);
                      } else if (child instanceof _parchment2.default.Container) {
                        lines2 = lines2.concat(getLines2(child, index5, lengthLeft));
                      }
                      lengthLeft -= length4;
                    });
                    return lines2;
                  };
                  return getLines(this, index3, length2);
                }
              }, {
                key: "optimize",
                value: function optimize() {
                  var mutations = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
                  var context = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
                  if (this.batch === true)
                    return;
                  _get(Scroll2.prototype.__proto__ || Object.getPrototypeOf(Scroll2.prototype), "optimize", this).call(this, mutations, context);
                  if (mutations.length > 0) {
                    this.emitter.emit(_emitter2.default.events.SCROLL_OPTIMIZE, mutations, context);
                  }
                }
              }, {
                key: "path",
                value: function path2(index3) {
                  return _get(Scroll2.prototype.__proto__ || Object.getPrototypeOf(Scroll2.prototype), "path", this).call(this, index3).slice(1);
                }
              }, {
                key: "update",
                value: function update(mutations) {
                  if (this.batch === true)
                    return;
                  var source = _emitter2.default.sources.USER;
                  if (typeof mutations === "string") {
                    source = mutations;
                  }
                  if (!Array.isArray(mutations)) {
                    mutations = this.observer.takeRecords();
                  }
                  if (mutations.length > 0) {
                    this.emitter.emit(_emitter2.default.events.SCROLL_BEFORE_UPDATE, source, mutations);
                  }
                  _get(Scroll2.prototype.__proto__ || Object.getPrototypeOf(Scroll2.prototype), "update", this).call(this, mutations.concat([]));
                  if (mutations.length > 0) {
                    this.emitter.emit(_emitter2.default.events.SCROLL_UPDATE, source, mutations);
                  }
                }
              }]);
              return Scroll2;
            }(_parchment2.default.Scroll);
            Scroll.blotName = "scroll";
            Scroll.className = "ql-editor";
            Scroll.tagName = "DIV";
            Scroll.defaultChild = "block";
            Scroll.allowedChildren = [_block2.default, _block.BlockEmbed, _container2.default];
            exports2.default = Scroll;
          },
          /* 23 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.SHORTKEY = exports2.default = void 0;
            var _typeof3 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
              return typeof obj;
            } : function(obj) {
              return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
            };
            var _slicedToArray = function() {
              function sliceIterator(arr, i2) {
                var _arr = [];
                var _n = true;
                var _d = false;
                var _e = void 0;
                try {
                  for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                    _arr.push(_s.value);
                    if (i2 && _arr.length === i2)
                      break;
                  }
                } catch (err) {
                  _d = true;
                  _e = err;
                } finally {
                  try {
                    if (!_n && _i["return"])
                      _i["return"]();
                  } finally {
                    if (_d)
                      throw _e;
                  }
                }
                return _arr;
              }
              return function(arr, i2) {
                if (Array.isArray(arr)) {
                  return arr;
                } else if (Symbol.iterator in Object(arr)) {
                  return sliceIterator(arr, i2);
                } else {
                  throw new TypeError("Invalid attempt to destructure non-iterable instance");
                }
              };
            }();
            var _createClass = function() {
              function defineProperties(target, props) {
                for (var i2 = 0; i2 < props.length; i2++) {
                  var descriptor = props[i2];
                  descriptor.enumerable = descriptor.enumerable || false;
                  descriptor.configurable = true;
                  if ("value" in descriptor)
                    descriptor.writable = true;
                  Object.defineProperty(target, descriptor.key, descriptor);
                }
              }
              return function(Constructor, protoProps, staticProps) {
                if (protoProps)
                  defineProperties(Constructor.prototype, protoProps);
                if (staticProps)
                  defineProperties(Constructor, staticProps);
                return Constructor;
              };
            }();
            var _clone = __webpack_require__(21);
            var _clone2 = _interopRequireDefault(_clone);
            var _deepEqual = __webpack_require__(11);
            var _deepEqual2 = _interopRequireDefault(_deepEqual);
            var _extend = __webpack_require__(3);
            var _extend2 = _interopRequireDefault(_extend);
            var _quillDelta = __webpack_require__(2);
            var _quillDelta2 = _interopRequireDefault(_quillDelta);
            var _op = __webpack_require__(20);
            var _op2 = _interopRequireDefault(_op);
            var _parchment = __webpack_require__(0);
            var _parchment2 = _interopRequireDefault(_parchment);
            var _quill = __webpack_require__(5);
            var _quill2 = _interopRequireDefault(_quill);
            var _logger = __webpack_require__(10);
            var _logger2 = _interopRequireDefault(_logger);
            var _module = __webpack_require__(9);
            var _module2 = _interopRequireDefault(_module);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { default: obj };
            }
            function _defineProperty2(obj, key, value) {
              if (key in obj) {
                Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
              } else {
                obj[key] = value;
              }
              return obj;
            }
            function _classCallCheck2(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function _possibleConstructorReturn(self2, call) {
              if (!self2) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return call && (typeof call === "object" || typeof call === "function") ? call : self2;
            }
            function _inherits(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
              }
              subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
              if (superClass)
                Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
            }
            var debug = (0, _logger2.default)("quill:keyboard");
            var SHORTKEY = /Mac/i.test(navigator.platform) ? "metaKey" : "ctrlKey";
            var Keyboard = function(_Module) {
              _inherits(Keyboard2, _Module);
              _createClass(Keyboard2, null, [{
                key: "match",
                value: function match(evt, binding) {
                  binding = normalize(binding);
                  if (["altKey", "ctrlKey", "metaKey", "shiftKey"].some(function(key) {
                    return !!binding[key] !== evt[key] && binding[key] !== null;
                  })) {
                    return false;
                  }
                  return binding.key === (evt.which || evt.keyCode);
                }
              }]);
              function Keyboard2(quill, options) {
                _classCallCheck2(this, Keyboard2);
                var _this = _possibleConstructorReturn(this, (Keyboard2.__proto__ || Object.getPrototypeOf(Keyboard2)).call(this, quill, options));
                _this.bindings = {};
                Object.keys(_this.options.bindings).forEach(function(name) {
                  if (name === "list autofill" && quill.scroll.whitelist != null && !quill.scroll.whitelist["list"]) {
                    return;
                  }
                  if (_this.options.bindings[name]) {
                    _this.addBinding(_this.options.bindings[name]);
                  }
                });
                _this.addBinding({ key: Keyboard2.keys.ENTER, shiftKey: null }, handleEnter);
                _this.addBinding({ key: Keyboard2.keys.ENTER, metaKey: null, ctrlKey: null, altKey: null }, function() {
                });
                if (/Firefox/i.test(navigator.userAgent)) {
                  _this.addBinding({ key: Keyboard2.keys.BACKSPACE }, { collapsed: true }, handleBackspace);
                  _this.addBinding({ key: Keyboard2.keys.DELETE }, { collapsed: true }, handleDelete);
                } else {
                  _this.addBinding({ key: Keyboard2.keys.BACKSPACE }, { collapsed: true, prefix: /^.?$/ }, handleBackspace);
                  _this.addBinding({ key: Keyboard2.keys.DELETE }, { collapsed: true, suffix: /^.?$/ }, handleDelete);
                }
                _this.addBinding({ key: Keyboard2.keys.BACKSPACE }, { collapsed: false }, handleDeleteRange);
                _this.addBinding({ key: Keyboard2.keys.DELETE }, { collapsed: false }, handleDeleteRange);
                _this.addBinding({ key: Keyboard2.keys.BACKSPACE, altKey: null, ctrlKey: null, metaKey: null, shiftKey: null }, { collapsed: true, offset: 0 }, handleBackspace);
                _this.listen();
                return _this;
              }
              _createClass(Keyboard2, [{
                key: "addBinding",
                value: function addBinding(key) {
                  var context = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
                  var handler = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
                  var binding = normalize(key);
                  if (binding == null || binding.key == null) {
                    return debug.warn("Attempted to add invalid keyboard binding", binding);
                  }
                  if (typeof context === "function") {
                    context = { handler: context };
                  }
                  if (typeof handler === "function") {
                    handler = { handler };
                  }
                  binding = (0, _extend2.default)(binding, context, handler);
                  this.bindings[binding.key] = this.bindings[binding.key] || [];
                  this.bindings[binding.key].push(binding);
                }
              }, {
                key: "listen",
                value: function listen() {
                  var _this2 = this;
                  this.quill.root.addEventListener("keydown", function(evt) {
                    if (evt.defaultPrevented)
                      return;
                    var which = evt.which || evt.keyCode;
                    var bindings = (_this2.bindings[which] || []).filter(function(binding) {
                      return Keyboard2.match(evt, binding);
                    });
                    if (bindings.length === 0)
                      return;
                    var range = _this2.quill.getSelection();
                    if (range == null || !_this2.quill.hasFocus())
                      return;
                    var _quill$getLine = _this2.quill.getLine(range.index), _quill$getLine2 = _slicedToArray(_quill$getLine, 2), line = _quill$getLine2[0], offset = _quill$getLine2[1];
                    var _quill$getLeaf = _this2.quill.getLeaf(range.index), _quill$getLeaf2 = _slicedToArray(_quill$getLeaf, 2), leafStart = _quill$getLeaf2[0], offsetStart = _quill$getLeaf2[1];
                    var _ref = range.length === 0 ? [leafStart, offsetStart] : _this2.quill.getLeaf(range.index + range.length), _ref2 = _slicedToArray(_ref, 2), leafEnd = _ref2[0], offsetEnd = _ref2[1];
                    var prefixText = leafStart instanceof _parchment2.default.Text ? leafStart.value().slice(0, offsetStart) : "";
                    var suffixText = leafEnd instanceof _parchment2.default.Text ? leafEnd.value().slice(offsetEnd) : "";
                    var curContext = {
                      collapsed: range.length === 0,
                      empty: range.length === 0 && line.length() <= 1,
                      format: _this2.quill.getFormat(range),
                      offset,
                      prefix: prefixText,
                      suffix: suffixText
                    };
                    var prevented = bindings.some(function(binding) {
                      if (binding.collapsed != null && binding.collapsed !== curContext.collapsed)
                        return false;
                      if (binding.empty != null && binding.empty !== curContext.empty)
                        return false;
                      if (binding.offset != null && binding.offset !== curContext.offset)
                        return false;
                      if (Array.isArray(binding.format)) {
                        if (binding.format.every(function(name) {
                          return curContext.format[name] == null;
                        })) {
                          return false;
                        }
                      } else if (_typeof3(binding.format) === "object") {
                        if (!Object.keys(binding.format).every(function(name) {
                          if (binding.format[name] === true)
                            return curContext.format[name] != null;
                          if (binding.format[name] === false)
                            return curContext.format[name] == null;
                          return (0, _deepEqual2.default)(binding.format[name], curContext.format[name]);
                        })) {
                          return false;
                        }
                      }
                      if (binding.prefix != null && !binding.prefix.test(curContext.prefix))
                        return false;
                      if (binding.suffix != null && !binding.suffix.test(curContext.suffix))
                        return false;
                      return binding.handler.call(_this2, range, curContext) !== true;
                    });
                    if (prevented) {
                      evt.preventDefault();
                    }
                  });
                }
              }]);
              return Keyboard2;
            }(_module2.default);
            Keyboard.keys = {
              BACKSPACE: 8,
              TAB: 9,
              ENTER: 13,
              ESCAPE: 27,
              LEFT: 37,
              UP: 38,
              RIGHT: 39,
              DOWN: 40,
              DELETE: 46
            };
            Keyboard.DEFAULTS = {
              bindings: {
                "bold": makeFormatHandler("bold"),
                "italic": makeFormatHandler("italic"),
                "underline": makeFormatHandler("underline"),
                "indent": {
                  // highlight tab or tab at beginning of list, indent or blockquote
                  key: Keyboard.keys.TAB,
                  format: ["blockquote", "indent", "list"],
                  handler: function handler(range, context) {
                    if (context.collapsed && context.offset !== 0)
                      return true;
                    this.quill.format("indent", "+1", _quill2.default.sources.USER);
                  }
                },
                "outdent": {
                  key: Keyboard.keys.TAB,
                  shiftKey: true,
                  format: ["blockquote", "indent", "list"],
                  // highlight tab or tab at beginning of list, indent or blockquote
                  handler: function handler(range, context) {
                    if (context.collapsed && context.offset !== 0)
                      return true;
                    this.quill.format("indent", "-1", _quill2.default.sources.USER);
                  }
                },
                "outdent backspace": {
                  key: Keyboard.keys.BACKSPACE,
                  collapsed: true,
                  shiftKey: null,
                  metaKey: null,
                  ctrlKey: null,
                  altKey: null,
                  format: ["indent", "list"],
                  offset: 0,
                  handler: function handler(range, context) {
                    if (context.format.indent != null) {
                      this.quill.format("indent", "-1", _quill2.default.sources.USER);
                    } else if (context.format.list != null) {
                      this.quill.format("list", false, _quill2.default.sources.USER);
                    }
                  }
                },
                "indent code-block": makeCodeBlockHandler(true),
                "outdent code-block": makeCodeBlockHandler(false),
                "remove tab": {
                  key: Keyboard.keys.TAB,
                  shiftKey: true,
                  collapsed: true,
                  prefix: /\t$/,
                  handler: function handler(range) {
                    this.quill.deleteText(range.index - 1, 1, _quill2.default.sources.USER);
                  }
                },
                "tab": {
                  key: Keyboard.keys.TAB,
                  handler: function handler(range) {
                    this.quill.history.cutoff();
                    var delta = new _quillDelta2.default().retain(range.index).delete(range.length).insert("	");
                    this.quill.updateContents(delta, _quill2.default.sources.USER);
                    this.quill.history.cutoff();
                    this.quill.setSelection(range.index + 1, _quill2.default.sources.SILENT);
                  }
                },
                "list empty enter": {
                  key: Keyboard.keys.ENTER,
                  collapsed: true,
                  format: ["list"],
                  empty: true,
                  handler: function handler(range, context) {
                    this.quill.format("list", false, _quill2.default.sources.USER);
                    if (context.format.indent) {
                      this.quill.format("indent", false, _quill2.default.sources.USER);
                    }
                  }
                },
                "checklist enter": {
                  key: Keyboard.keys.ENTER,
                  collapsed: true,
                  format: { list: "checked" },
                  handler: function handler(range) {
                    var _quill$getLine3 = this.quill.getLine(range.index), _quill$getLine4 = _slicedToArray(_quill$getLine3, 2), line = _quill$getLine4[0], offset = _quill$getLine4[1];
                    var formats = (0, _extend2.default)({}, line.formats(), { list: "checked" });
                    var delta = new _quillDelta2.default().retain(range.index).insert("\n", formats).retain(line.length() - offset - 1).retain(1, { list: "unchecked" });
                    this.quill.updateContents(delta, _quill2.default.sources.USER);
                    this.quill.setSelection(range.index + 1, _quill2.default.sources.SILENT);
                    this.quill.scrollIntoView();
                  }
                },
                "header enter": {
                  key: Keyboard.keys.ENTER,
                  collapsed: true,
                  format: ["header"],
                  suffix: /^$/,
                  handler: function handler(range, context) {
                    var _quill$getLine5 = this.quill.getLine(range.index), _quill$getLine6 = _slicedToArray(_quill$getLine5, 2), line = _quill$getLine6[0], offset = _quill$getLine6[1];
                    var delta = new _quillDelta2.default().retain(range.index).insert("\n", context.format).retain(line.length() - offset - 1).retain(1, { header: null });
                    this.quill.updateContents(delta, _quill2.default.sources.USER);
                    this.quill.setSelection(range.index + 1, _quill2.default.sources.SILENT);
                    this.quill.scrollIntoView();
                  }
                },
                "list autofill": {
                  key: " ",
                  collapsed: true,
                  format: { list: false },
                  prefix: /^\s*?(\d+\.|-|\*|\[ ?\]|\[x\])$/,
                  handler: function handler(range, context) {
                    var length2 = context.prefix.length;
                    var _quill$getLine7 = this.quill.getLine(range.index), _quill$getLine8 = _slicedToArray(_quill$getLine7, 2), line = _quill$getLine8[0], offset = _quill$getLine8[1];
                    if (offset > length2)
                      return true;
                    var value = void 0;
                    switch (context.prefix.trim()) {
                      case "[]":
                      case "[ ]":
                        value = "unchecked";
                        break;
                      case "[x]":
                        value = "checked";
                        break;
                      case "-":
                      case "*":
                        value = "bullet";
                        break;
                      default:
                        value = "ordered";
                    }
                    this.quill.insertText(range.index, " ", _quill2.default.sources.USER);
                    this.quill.history.cutoff();
                    var delta = new _quillDelta2.default().retain(range.index - offset).delete(length2 + 1).retain(line.length() - 2 - offset).retain(1, { list: value });
                    this.quill.updateContents(delta, _quill2.default.sources.USER);
                    this.quill.history.cutoff();
                    this.quill.setSelection(range.index - length2, _quill2.default.sources.SILENT);
                  }
                },
                "code exit": {
                  key: Keyboard.keys.ENTER,
                  collapsed: true,
                  format: ["code-block"],
                  prefix: /\n\n$/,
                  suffix: /^\s+$/,
                  handler: function handler(range) {
                    var _quill$getLine9 = this.quill.getLine(range.index), _quill$getLine10 = _slicedToArray(_quill$getLine9, 2), line = _quill$getLine10[0], offset = _quill$getLine10[1];
                    var delta = new _quillDelta2.default().retain(range.index + line.length() - offset - 2).retain(1, { "code-block": null }).delete(1);
                    this.quill.updateContents(delta, _quill2.default.sources.USER);
                  }
                },
                "embed left": makeEmbedArrowHandler(Keyboard.keys.LEFT, false),
                "embed left shift": makeEmbedArrowHandler(Keyboard.keys.LEFT, true),
                "embed right": makeEmbedArrowHandler(Keyboard.keys.RIGHT, false),
                "embed right shift": makeEmbedArrowHandler(Keyboard.keys.RIGHT, true)
              }
            };
            function makeEmbedArrowHandler(key, shiftKey) {
              var _ref3;
              var where = key === Keyboard.keys.LEFT ? "prefix" : "suffix";
              return _ref3 = {
                key,
                shiftKey,
                altKey: null
              }, _defineProperty2(_ref3, where, /^$/), _defineProperty2(_ref3, "handler", function handler(range) {
                var index3 = range.index;
                if (key === Keyboard.keys.RIGHT) {
                  index3 += range.length + 1;
                }
                var _quill$getLeaf3 = this.quill.getLeaf(index3), _quill$getLeaf4 = _slicedToArray(_quill$getLeaf3, 1), leaf = _quill$getLeaf4[0];
                if (!(leaf instanceof _parchment2.default.Embed))
                  return true;
                if (key === Keyboard.keys.LEFT) {
                  if (shiftKey) {
                    this.quill.setSelection(range.index - 1, range.length + 1, _quill2.default.sources.USER);
                  } else {
                    this.quill.setSelection(range.index - 1, _quill2.default.sources.USER);
                  }
                } else {
                  if (shiftKey) {
                    this.quill.setSelection(range.index, range.length + 1, _quill2.default.sources.USER);
                  } else {
                    this.quill.setSelection(range.index + range.length + 1, _quill2.default.sources.USER);
                  }
                }
                return false;
              }), _ref3;
            }
            function handleBackspace(range, context) {
              if (range.index === 0 || this.quill.getLength() <= 1)
                return;
              var _quill$getLine11 = this.quill.getLine(range.index), _quill$getLine12 = _slicedToArray(_quill$getLine11, 1), line = _quill$getLine12[0];
              var formats = {};
              if (context.offset === 0) {
                var _quill$getLine13 = this.quill.getLine(range.index - 1), _quill$getLine14 = _slicedToArray(_quill$getLine13, 1), prev2 = _quill$getLine14[0];
                if (prev2 != null && prev2.length() > 1) {
                  var curFormats = line.formats();
                  var prevFormats = this.quill.getFormat(range.index - 1, 1);
                  formats = _op2.default.attributes.diff(curFormats, prevFormats) || {};
                }
              }
              var length2 = /[\uD800-\uDBFF][\uDC00-\uDFFF]$/.test(context.prefix) ? 2 : 1;
              this.quill.deleteText(range.index - length2, length2, _quill2.default.sources.USER);
              if (Object.keys(formats).length > 0) {
                this.quill.formatLine(range.index - length2, length2, formats, _quill2.default.sources.USER);
              }
              this.quill.focus();
            }
            function handleDelete(range, context) {
              var length2 = /^[\uD800-\uDBFF][\uDC00-\uDFFF]/.test(context.suffix) ? 2 : 1;
              if (range.index >= this.quill.getLength() - length2)
                return;
              var formats = {}, nextLength = 0;
              var _quill$getLine15 = this.quill.getLine(range.index), _quill$getLine16 = _slicedToArray(_quill$getLine15, 1), line = _quill$getLine16[0];
              if (context.offset >= line.length() - 1) {
                var _quill$getLine17 = this.quill.getLine(range.index + 1), _quill$getLine18 = _slicedToArray(_quill$getLine17, 1), next2 = _quill$getLine18[0];
                if (next2) {
                  var curFormats = line.formats();
                  var nextFormats = this.quill.getFormat(range.index, 1);
                  formats = _op2.default.attributes.diff(curFormats, nextFormats) || {};
                  nextLength = next2.length();
                }
              }
              this.quill.deleteText(range.index, length2, _quill2.default.sources.USER);
              if (Object.keys(formats).length > 0) {
                this.quill.formatLine(range.index + nextLength - 1, length2, formats, _quill2.default.sources.USER);
              }
            }
            function handleDeleteRange(range) {
              var lines = this.quill.getLines(range);
              var formats = {};
              if (lines.length > 1) {
                var firstFormats = lines[0].formats();
                var lastFormats = lines[lines.length - 1].formats();
                formats = _op2.default.attributes.diff(lastFormats, firstFormats) || {};
              }
              this.quill.deleteText(range, _quill2.default.sources.USER);
              if (Object.keys(formats).length > 0) {
                this.quill.formatLine(range.index, 1, formats, _quill2.default.sources.USER);
              }
              this.quill.setSelection(range.index, _quill2.default.sources.SILENT);
              this.quill.focus();
            }
            function handleEnter(range, context) {
              var _this3 = this;
              if (range.length > 0) {
                this.quill.scroll.deleteAt(range.index, range.length);
              }
              var lineFormats = Object.keys(context.format).reduce(function(lineFormats2, format) {
                if (_parchment2.default.query(format, _parchment2.default.Scope.BLOCK) && !Array.isArray(context.format[format])) {
                  lineFormats2[format] = context.format[format];
                }
                return lineFormats2;
              }, {});
              this.quill.insertText(range.index, "\n", lineFormats, _quill2.default.sources.USER);
              this.quill.setSelection(range.index + 1, _quill2.default.sources.SILENT);
              this.quill.focus();
              Object.keys(context.format).forEach(function(name) {
                if (lineFormats[name] != null)
                  return;
                if (Array.isArray(context.format[name]))
                  return;
                if (name === "link")
                  return;
                _this3.quill.format(name, context.format[name], _quill2.default.sources.USER);
              });
            }
            function makeCodeBlockHandler(indent) {
              return {
                key: Keyboard.keys.TAB,
                shiftKey: !indent,
                format: { "code-block": true },
                handler: function handler(range) {
                  var CodeBlock = _parchment2.default.query("code-block");
                  var index3 = range.index, length2 = range.length;
                  var _quill$scroll$descend = this.quill.scroll.descendant(CodeBlock, index3), _quill$scroll$descend2 = _slicedToArray(_quill$scroll$descend, 2), block = _quill$scroll$descend2[0], offset = _quill$scroll$descend2[1];
                  if (block == null)
                    return;
                  var scrollIndex = this.quill.getIndex(block);
                  var start = block.newlineIndex(offset, true) + 1;
                  var end = block.newlineIndex(scrollIndex + offset + length2);
                  var lines = block.domNode.textContent.slice(start, end).split("\n");
                  offset = 0;
                  lines.forEach(function(line, i2) {
                    if (indent) {
                      block.insertAt(start + offset, CodeBlock.TAB);
                      offset += CodeBlock.TAB.length;
                      if (i2 === 0) {
                        index3 += CodeBlock.TAB.length;
                      } else {
                        length2 += CodeBlock.TAB.length;
                      }
                    } else if (line.startsWith(CodeBlock.TAB)) {
                      block.deleteAt(start + offset, CodeBlock.TAB.length);
                      offset -= CodeBlock.TAB.length;
                      if (i2 === 0) {
                        index3 -= CodeBlock.TAB.length;
                      } else {
                        length2 -= CodeBlock.TAB.length;
                      }
                    }
                    offset += line.length + 1;
                  });
                  this.quill.update(_quill2.default.sources.USER);
                  this.quill.setSelection(index3, length2, _quill2.default.sources.SILENT);
                }
              };
            }
            function makeFormatHandler(format) {
              return {
                key: format[0].toUpperCase(),
                shortKey: true,
                handler: function handler(range, context) {
                  this.quill.format(format, !context.format[format], _quill2.default.sources.USER);
                }
              };
            }
            function normalize(binding) {
              if (typeof binding === "string" || typeof binding === "number") {
                return normalize({ key: binding });
              }
              if ((typeof binding === "undefined" ? "undefined" : _typeof3(binding)) === "object") {
                binding = (0, _clone2.default)(binding, false);
              }
              if (typeof binding.key === "string") {
                if (Keyboard.keys[binding.key.toUpperCase()] != null) {
                  binding.key = Keyboard.keys[binding.key.toUpperCase()];
                } else if (binding.key.length === 1) {
                  binding.key = binding.key.toUpperCase().charCodeAt(0);
                } else {
                  return null;
                }
              }
              if (binding.shortKey) {
                binding[SHORTKEY] = binding.shortKey;
                delete binding.shortKey;
              }
              return binding;
            }
            exports2.default = Keyboard;
            exports2.SHORTKEY = SHORTKEY;
          },
          /* 24 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _slicedToArray = function() {
              function sliceIterator(arr, i2) {
                var _arr = [];
                var _n = true;
                var _d = false;
                var _e = void 0;
                try {
                  for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                    _arr.push(_s.value);
                    if (i2 && _arr.length === i2)
                      break;
                  }
                } catch (err) {
                  _d = true;
                  _e = err;
                } finally {
                  try {
                    if (!_n && _i["return"])
                      _i["return"]();
                  } finally {
                    if (_d)
                      throw _e;
                  }
                }
                return _arr;
              }
              return function(arr, i2) {
                if (Array.isArray(arr)) {
                  return arr;
                } else if (Symbol.iterator in Object(arr)) {
                  return sliceIterator(arr, i2);
                } else {
                  throw new TypeError("Invalid attempt to destructure non-iterable instance");
                }
              };
            }();
            var _get = function get(object, property, receiver) {
              if (object === null)
                object = Function.prototype;
              var desc = Object.getOwnPropertyDescriptor(object, property);
              if (desc === void 0) {
                var parent = Object.getPrototypeOf(object);
                if (parent === null) {
                  return void 0;
                } else {
                  return get(parent, property, receiver);
                }
              } else if ("value" in desc) {
                return desc.value;
              } else {
                var getter = desc.get;
                if (getter === void 0) {
                  return void 0;
                }
                return getter.call(receiver);
              }
            };
            var _createClass = function() {
              function defineProperties(target, props) {
                for (var i2 = 0; i2 < props.length; i2++) {
                  var descriptor = props[i2];
                  descriptor.enumerable = descriptor.enumerable || false;
                  descriptor.configurable = true;
                  if ("value" in descriptor)
                    descriptor.writable = true;
                  Object.defineProperty(target, descriptor.key, descriptor);
                }
              }
              return function(Constructor, protoProps, staticProps) {
                if (protoProps)
                  defineProperties(Constructor.prototype, protoProps);
                if (staticProps)
                  defineProperties(Constructor, staticProps);
                return Constructor;
              };
            }();
            var _parchment = __webpack_require__(0);
            var _parchment2 = _interopRequireDefault(_parchment);
            var _text = __webpack_require__(7);
            var _text2 = _interopRequireDefault(_text);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { default: obj };
            }
            function _classCallCheck2(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function _possibleConstructorReturn(self2, call) {
              if (!self2) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return call && (typeof call === "object" || typeof call === "function") ? call : self2;
            }
            function _inherits(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
              }
              subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
              if (superClass)
                Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
            }
            var Cursor = function(_Parchment$Embed) {
              _inherits(Cursor2, _Parchment$Embed);
              _createClass(Cursor2, null, [{
                key: "value",
                value: function value() {
                  return void 0;
                }
              }]);
              function Cursor2(domNode, selection) {
                _classCallCheck2(this, Cursor2);
                var _this = _possibleConstructorReturn(this, (Cursor2.__proto__ || Object.getPrototypeOf(Cursor2)).call(this, domNode));
                _this.selection = selection;
                _this.textNode = document.createTextNode(Cursor2.CONTENTS);
                _this.domNode.appendChild(_this.textNode);
                _this._length = 0;
                return _this;
              }
              _createClass(Cursor2, [{
                key: "detach",
                value: function detach() {
                  if (this.parent != null)
                    this.parent.removeChild(this);
                }
              }, {
                key: "format",
                value: function format(name, value) {
                  if (this._length !== 0) {
                    return _get(Cursor2.prototype.__proto__ || Object.getPrototypeOf(Cursor2.prototype), "format", this).call(this, name, value);
                  }
                  var target = this, index3 = 0;
                  while (target != null && target.statics.scope !== _parchment2.default.Scope.BLOCK_BLOT) {
                    index3 += target.offset(target.parent);
                    target = target.parent;
                  }
                  if (target != null) {
                    this._length = Cursor2.CONTENTS.length;
                    target.optimize();
                    target.formatAt(index3, Cursor2.CONTENTS.length, name, value);
                    this._length = 0;
                  }
                }
              }, {
                key: "index",
                value: function index3(node3, offset) {
                  if (node3 === this.textNode)
                    return 0;
                  return _get(Cursor2.prototype.__proto__ || Object.getPrototypeOf(Cursor2.prototype), "index", this).call(this, node3, offset);
                }
              }, {
                key: "length",
                value: function length2() {
                  return this._length;
                }
              }, {
                key: "position",
                value: function position3() {
                  return [this.textNode, this.textNode.data.length];
                }
              }, {
                key: "remove",
                value: function remove2() {
                  _get(Cursor2.prototype.__proto__ || Object.getPrototypeOf(Cursor2.prototype), "remove", this).call(this);
                  this.parent = null;
                }
              }, {
                key: "restore",
                value: function restore() {
                  if (this.selection.composing || this.parent == null)
                    return;
                  var textNode = this.textNode;
                  var range = this.selection.getNativeRange();
                  var restoreText = void 0, start = void 0, end = void 0;
                  if (range != null && range.start.node === textNode && range.end.node === textNode) {
                    var _ref = [textNode, range.start.offset, range.end.offset];
                    restoreText = _ref[0];
                    start = _ref[1];
                    end = _ref[2];
                  }
                  while (this.domNode.lastChild != null && this.domNode.lastChild !== this.textNode) {
                    this.domNode.parentNode.insertBefore(this.domNode.lastChild, this.domNode);
                  }
                  if (this.textNode.data !== Cursor2.CONTENTS) {
                    var text4 = this.textNode.data.split(Cursor2.CONTENTS).join("");
                    if (this.next instanceof _text2.default) {
                      restoreText = this.next.domNode;
                      this.next.insertAt(0, text4);
                      this.textNode.data = Cursor2.CONTENTS;
                    } else {
                      this.textNode.data = text4;
                      this.parent.insertBefore(_parchment2.default.create(this.textNode), this);
                      this.textNode = document.createTextNode(Cursor2.CONTENTS);
                      this.domNode.appendChild(this.textNode);
                    }
                  }
                  this.remove();
                  if (start != null) {
                    var _map = [start, end].map(function(offset) {
                      return Math.max(0, Math.min(restoreText.data.length, offset - 1));
                    });
                    var _map2 = _slicedToArray(_map, 2);
                    start = _map2[0];
                    end = _map2[1];
                    return {
                      startNode: restoreText,
                      startOffset: start,
                      endNode: restoreText,
                      endOffset: end
                    };
                  }
                }
              }, {
                key: "update",
                value: function update(mutations, context) {
                  var _this2 = this;
                  if (mutations.some(function(mutation) {
                    return mutation.type === "characterData" && mutation.target === _this2.textNode;
                  })) {
                    var range = this.restore();
                    if (range)
                      context.range = range;
                  }
                }
              }, {
                key: "value",
                value: function value() {
                  return "";
                }
              }]);
              return Cursor2;
            }(_parchment2.default.Embed);
            Cursor.blotName = "cursor";
            Cursor.className = "ql-cursor";
            Cursor.tagName = "span";
            Cursor.CONTENTS = "\uFEFF";
            exports2.default = Cursor;
          },
          /* 25 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _parchment = __webpack_require__(0);
            var _parchment2 = _interopRequireDefault(_parchment);
            var _block = __webpack_require__(4);
            var _block2 = _interopRequireDefault(_block);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { default: obj };
            }
            function _classCallCheck2(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function _possibleConstructorReturn(self2, call) {
              if (!self2) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return call && (typeof call === "object" || typeof call === "function") ? call : self2;
            }
            function _inherits(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
              }
              subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
              if (superClass)
                Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
            }
            var Container2 = function(_Parchment$Container) {
              _inherits(Container3, _Parchment$Container);
              function Container3() {
                _classCallCheck2(this, Container3);
                return _possibleConstructorReturn(this, (Container3.__proto__ || Object.getPrototypeOf(Container3)).apply(this, arguments));
              }
              return Container3;
            }(_parchment2.default.Container);
            Container2.allowedChildren = [_block2.default, _block.BlockEmbed, Container2];
            exports2.default = Container2;
          },
          /* 26 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.ColorStyle = exports2.ColorClass = exports2.ColorAttributor = void 0;
            var _createClass = function() {
              function defineProperties(target, props) {
                for (var i2 = 0; i2 < props.length; i2++) {
                  var descriptor = props[i2];
                  descriptor.enumerable = descriptor.enumerable || false;
                  descriptor.configurable = true;
                  if ("value" in descriptor)
                    descriptor.writable = true;
                  Object.defineProperty(target, descriptor.key, descriptor);
                }
              }
              return function(Constructor, protoProps, staticProps) {
                if (protoProps)
                  defineProperties(Constructor.prototype, protoProps);
                if (staticProps)
                  defineProperties(Constructor, staticProps);
                return Constructor;
              };
            }();
            var _get = function get(object, property, receiver) {
              if (object === null)
                object = Function.prototype;
              var desc = Object.getOwnPropertyDescriptor(object, property);
              if (desc === void 0) {
                var parent = Object.getPrototypeOf(object);
                if (parent === null) {
                  return void 0;
                } else {
                  return get(parent, property, receiver);
                }
              } else if ("value" in desc) {
                return desc.value;
              } else {
                var getter = desc.get;
                if (getter === void 0) {
                  return void 0;
                }
                return getter.call(receiver);
              }
            };
            var _parchment = __webpack_require__(0);
            var _parchment2 = _interopRequireDefault(_parchment);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { default: obj };
            }
            function _classCallCheck2(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function _possibleConstructorReturn(self2, call) {
              if (!self2) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return call && (typeof call === "object" || typeof call === "function") ? call : self2;
            }
            function _inherits(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
              }
              subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
              if (superClass)
                Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
            }
            var ColorAttributor = function(_Parchment$Attributor) {
              _inherits(ColorAttributor2, _Parchment$Attributor);
              function ColorAttributor2() {
                _classCallCheck2(this, ColorAttributor2);
                return _possibleConstructorReturn(this, (ColorAttributor2.__proto__ || Object.getPrototypeOf(ColorAttributor2)).apply(this, arguments));
              }
              _createClass(ColorAttributor2, [{
                key: "value",
                value: function value(domNode) {
                  var value2 = _get(ColorAttributor2.prototype.__proto__ || Object.getPrototypeOf(ColorAttributor2.prototype), "value", this).call(this, domNode);
                  if (!value2.startsWith("rgb("))
                    return value2;
                  value2 = value2.replace(/^[^\d]+/, "").replace(/[^\d]+$/, "");
                  return "#" + value2.split(",").map(function(component) {
                    return ("00" + parseInt(component).toString(16)).slice(-2);
                  }).join("");
                }
              }]);
              return ColorAttributor2;
            }(_parchment2.default.Attributor.Style);
            var ColorClass = new _parchment2.default.Attributor.Class("color", "ql-color", {
              scope: _parchment2.default.Scope.INLINE
            });
            var ColorStyle = new ColorAttributor("color", "color", {
              scope: _parchment2.default.Scope.INLINE
            });
            exports2.ColorAttributor = ColorAttributor;
            exports2.ColorClass = ColorClass;
            exports2.ColorStyle = ColorStyle;
          },
          /* 27 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.sanitize = exports2.default = void 0;
            var _createClass = function() {
              function defineProperties(target, props) {
                for (var i2 = 0; i2 < props.length; i2++) {
                  var descriptor = props[i2];
                  descriptor.enumerable = descriptor.enumerable || false;
                  descriptor.configurable = true;
                  if ("value" in descriptor)
                    descriptor.writable = true;
                  Object.defineProperty(target, descriptor.key, descriptor);
                }
              }
              return function(Constructor, protoProps, staticProps) {
                if (protoProps)
                  defineProperties(Constructor.prototype, protoProps);
                if (staticProps)
                  defineProperties(Constructor, staticProps);
                return Constructor;
              };
            }();
            var _get = function get(object, property, receiver) {
              if (object === null)
                object = Function.prototype;
              var desc = Object.getOwnPropertyDescriptor(object, property);
              if (desc === void 0) {
                var parent = Object.getPrototypeOf(object);
                if (parent === null) {
                  return void 0;
                } else {
                  return get(parent, property, receiver);
                }
              } else if ("value" in desc) {
                return desc.value;
              } else {
                var getter = desc.get;
                if (getter === void 0) {
                  return void 0;
                }
                return getter.call(receiver);
              }
            };
            var _inline = __webpack_require__(6);
            var _inline2 = _interopRequireDefault(_inline);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { default: obj };
            }
            function _classCallCheck2(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function _possibleConstructorReturn(self2, call) {
              if (!self2) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return call && (typeof call === "object" || typeof call === "function") ? call : self2;
            }
            function _inherits(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
              }
              subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
              if (superClass)
                Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
            }
            var Link = function(_Inline) {
              _inherits(Link2, _Inline);
              function Link2() {
                _classCallCheck2(this, Link2);
                return _possibleConstructorReturn(this, (Link2.__proto__ || Object.getPrototypeOf(Link2)).apply(this, arguments));
              }
              _createClass(Link2, [{
                key: "format",
                value: function format(name, value) {
                  if (name !== this.statics.blotName || !value)
                    return _get(Link2.prototype.__proto__ || Object.getPrototypeOf(Link2.prototype), "format", this).call(this, name, value);
                  value = this.constructor.sanitize(value);
                  this.domNode.setAttribute("href", value);
                }
              }], [{
                key: "create",
                value: function create2(value) {
                  var node3 = _get(Link2.__proto__ || Object.getPrototypeOf(Link2), "create", this).call(this, value);
                  value = this.sanitize(value);
                  node3.setAttribute("href", value);
                  node3.setAttribute("target", "_blank");
                  return node3;
                }
              }, {
                key: "formats",
                value: function formats(domNode) {
                  return domNode.getAttribute("href");
                }
              }, {
                key: "sanitize",
                value: function sanitize(url) {
                  return _sanitize(url, this.PROTOCOL_WHITELIST) ? url : this.SANITIZED_URL;
                }
              }]);
              return Link2;
            }(_inline2.default);
            Link.blotName = "link";
            Link.tagName = "A";
            Link.SANITIZED_URL = "about:blank";
            Link.PROTOCOL_WHITELIST = ["http", "https", "mailto", "tel"];
            function _sanitize(url, protocols) {
              var anchor = document.createElement("a");
              anchor.href = url;
              var protocol = anchor.href.slice(0, anchor.href.indexOf(":"));
              return protocols.indexOf(protocol) > -1;
            }
            exports2.default = Link;
            exports2.sanitize = _sanitize;
          },
          /* 28 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _typeof3 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
              return typeof obj;
            } : function(obj) {
              return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
            };
            var _createClass = function() {
              function defineProperties(target, props) {
                for (var i2 = 0; i2 < props.length; i2++) {
                  var descriptor = props[i2];
                  descriptor.enumerable = descriptor.enumerable || false;
                  descriptor.configurable = true;
                  if ("value" in descriptor)
                    descriptor.writable = true;
                  Object.defineProperty(target, descriptor.key, descriptor);
                }
              }
              return function(Constructor, protoProps, staticProps) {
                if (protoProps)
                  defineProperties(Constructor.prototype, protoProps);
                if (staticProps)
                  defineProperties(Constructor, staticProps);
                return Constructor;
              };
            }();
            var _keyboard = __webpack_require__(23);
            var _keyboard2 = _interopRequireDefault(_keyboard);
            var _dropdown = __webpack_require__(107);
            var _dropdown2 = _interopRequireDefault(_dropdown);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { default: obj };
            }
            function _classCallCheck2(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            var optionsCounter = 0;
            function toggleAriaAttribute(element2, attribute) {
              element2.setAttribute(attribute, !(element2.getAttribute(attribute) === "true"));
            }
            var Picker = function() {
              function Picker2(select) {
                var _this = this;
                _classCallCheck2(this, Picker2);
                this.select = select;
                this.container = document.createElement("span");
                this.buildPicker();
                this.select.style.display = "none";
                this.select.parentNode.insertBefore(this.container, this.select);
                this.label.addEventListener("mousedown", function() {
                  _this.togglePicker();
                });
                this.label.addEventListener("keydown", function(event) {
                  switch (event.keyCode) {
                    case _keyboard2.default.keys.ENTER:
                      _this.togglePicker();
                      break;
                    case _keyboard2.default.keys.ESCAPE:
                      _this.escape();
                      event.preventDefault();
                      break;
                    default:
                  }
                });
                this.select.addEventListener("change", this.update.bind(this));
              }
              _createClass(Picker2, [{
                key: "togglePicker",
                value: function togglePicker() {
                  this.container.classList.toggle("ql-expanded");
                  toggleAriaAttribute(this.label, "aria-expanded");
                  toggleAriaAttribute(this.options, "aria-hidden");
                }
              }, {
                key: "buildItem",
                value: function buildItem(option) {
                  var _this2 = this;
                  var item = document.createElement("span");
                  item.tabIndex = "0";
                  item.setAttribute("role", "button");
                  item.classList.add("ql-picker-item");
                  if (option.hasAttribute("value")) {
                    item.setAttribute("data-value", option.getAttribute("value"));
                  }
                  if (option.textContent) {
                    item.setAttribute("data-label", option.textContent);
                  }
                  item.addEventListener("click", function() {
                    _this2.selectItem(item, true);
                  });
                  item.addEventListener("keydown", function(event) {
                    switch (event.keyCode) {
                      case _keyboard2.default.keys.ENTER:
                        _this2.selectItem(item, true);
                        event.preventDefault();
                        break;
                      case _keyboard2.default.keys.ESCAPE:
                        _this2.escape();
                        event.preventDefault();
                        break;
                      default:
                    }
                  });
                  return item;
                }
              }, {
                key: "buildLabel",
                value: function buildLabel() {
                  var label = document.createElement("span");
                  label.classList.add("ql-picker-label");
                  label.innerHTML = _dropdown2.default;
                  label.tabIndex = "0";
                  label.setAttribute("role", "button");
                  label.setAttribute("aria-expanded", "false");
                  this.container.appendChild(label);
                  return label;
                }
              }, {
                key: "buildOptions",
                value: function buildOptions() {
                  var _this3 = this;
                  var options = document.createElement("span");
                  options.classList.add("ql-picker-options");
                  options.setAttribute("aria-hidden", "true");
                  options.tabIndex = "-1";
                  options.id = "ql-picker-options-" + optionsCounter;
                  optionsCounter += 1;
                  this.label.setAttribute("aria-controls", options.id);
                  this.options = options;
                  [].slice.call(this.select.options).forEach(function(option) {
                    var item = _this3.buildItem(option);
                    options.appendChild(item);
                    if (option.selected === true) {
                      _this3.selectItem(item);
                    }
                  });
                  this.container.appendChild(options);
                }
              }, {
                key: "buildPicker",
                value: function buildPicker() {
                  var _this4 = this;
                  [].slice.call(this.select.attributes).forEach(function(item) {
                    _this4.container.setAttribute(item.name, item.value);
                  });
                  this.container.classList.add("ql-picker");
                  this.label = this.buildLabel();
                  this.buildOptions();
                }
              }, {
                key: "escape",
                value: function escape2() {
                  var _this5 = this;
                  this.close();
                  setTimeout(function() {
                    return _this5.label.focus();
                  }, 1);
                }
              }, {
                key: "close",
                value: function close3() {
                  this.container.classList.remove("ql-expanded");
                  this.label.setAttribute("aria-expanded", "false");
                  this.options.setAttribute("aria-hidden", "true");
                }
              }, {
                key: "selectItem",
                value: function selectItem(item) {
                  var trigger = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
                  var selected = this.container.querySelector(".ql-selected");
                  if (item === selected)
                    return;
                  if (selected != null) {
                    selected.classList.remove("ql-selected");
                  }
                  if (item == null)
                    return;
                  item.classList.add("ql-selected");
                  this.select.selectedIndex = [].indexOf.call(item.parentNode.children, item);
                  if (item.hasAttribute("data-value")) {
                    this.label.setAttribute("data-value", item.getAttribute("data-value"));
                  } else {
                    this.label.removeAttribute("data-value");
                  }
                  if (item.hasAttribute("data-label")) {
                    this.label.setAttribute("data-label", item.getAttribute("data-label"));
                  } else {
                    this.label.removeAttribute("data-label");
                  }
                  if (trigger) {
                    if (typeof Event === "function") {
                      this.select.dispatchEvent(new Event("change"));
                    } else if ((typeof Event === "undefined" ? "undefined" : _typeof3(Event)) === "object") {
                      var event = document.createEvent("Event");
                      event.initEvent("change", true, true);
                      this.select.dispatchEvent(event);
                    }
                    this.close();
                  }
                }
              }, {
                key: "update",
                value: function update() {
                  var option = void 0;
                  if (this.select.selectedIndex > -1) {
                    var item = this.container.querySelector(".ql-picker-options").children[this.select.selectedIndex];
                    option = this.select.options[this.select.selectedIndex];
                    this.selectItem(item);
                  } else {
                    this.selectItem(null);
                  }
                  var isActive = option != null && option !== this.select.querySelector("option[selected]");
                  this.label.classList.toggle("ql-active", isActive);
                }
              }]);
              return Picker2;
            }();
            exports2.default = Picker;
          },
          /* 29 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _parchment = __webpack_require__(0);
            var _parchment2 = _interopRequireDefault(_parchment);
            var _quill = __webpack_require__(5);
            var _quill2 = _interopRequireDefault(_quill);
            var _block = __webpack_require__(4);
            var _block2 = _interopRequireDefault(_block);
            var _break = __webpack_require__(16);
            var _break2 = _interopRequireDefault(_break);
            var _container = __webpack_require__(25);
            var _container2 = _interopRequireDefault(_container);
            var _cursor = __webpack_require__(24);
            var _cursor2 = _interopRequireDefault(_cursor);
            var _embed = __webpack_require__(35);
            var _embed2 = _interopRequireDefault(_embed);
            var _inline = __webpack_require__(6);
            var _inline2 = _interopRequireDefault(_inline);
            var _scroll = __webpack_require__(22);
            var _scroll2 = _interopRequireDefault(_scroll);
            var _text = __webpack_require__(7);
            var _text2 = _interopRequireDefault(_text);
            var _clipboard = __webpack_require__(55);
            var _clipboard2 = _interopRequireDefault(_clipboard);
            var _history = __webpack_require__(42);
            var _history2 = _interopRequireDefault(_history);
            var _keyboard = __webpack_require__(23);
            var _keyboard2 = _interopRequireDefault(_keyboard);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { default: obj };
            }
            _quill2.default.register({
              "blots/block": _block2.default,
              "blots/block/embed": _block.BlockEmbed,
              "blots/break": _break2.default,
              "blots/container": _container2.default,
              "blots/cursor": _cursor2.default,
              "blots/embed": _embed2.default,
              "blots/inline": _inline2.default,
              "blots/scroll": _scroll2.default,
              "blots/text": _text2.default,
              "modules/clipboard": _clipboard2.default,
              "modules/history": _history2.default,
              "modules/keyboard": _keyboard2.default
            });
            _parchment2.default.register(_block2.default, _break2.default, _cursor2.default, _inline2.default, _scroll2.default, _text2.default);
            exports2.default = _quill2.default;
          },
          /* 30 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            var Registry = __webpack_require__(1);
            var ShadowBlot = (
              /** @class */
              function() {
                function ShadowBlot2(domNode) {
                  this.domNode = domNode;
                  this.domNode[Registry.DATA_KEY] = { blot: this };
                }
                Object.defineProperty(ShadowBlot2.prototype, "statics", {
                  // Hack for accessing inherited static methods
                  get: function() {
                    return this.constructor;
                  },
                  enumerable: true,
                  configurable: true
                });
                ShadowBlot2.create = function(value) {
                  if (this.tagName == null) {
                    throw new Registry.ParchmentError("Blot definition missing tagName");
                  }
                  var node3;
                  if (Array.isArray(this.tagName)) {
                    if (typeof value === "string") {
                      value = value.toUpperCase();
                      if (parseInt(value).toString() === value) {
                        value = parseInt(value);
                      }
                    }
                    if (typeof value === "number") {
                      node3 = document.createElement(this.tagName[value - 1]);
                    } else if (this.tagName.indexOf(value) > -1) {
                      node3 = document.createElement(value);
                    } else {
                      node3 = document.createElement(this.tagName[0]);
                    }
                  } else {
                    node3 = document.createElement(this.tagName);
                  }
                  if (this.className) {
                    node3.classList.add(this.className);
                  }
                  return node3;
                };
                ShadowBlot2.prototype.attach = function() {
                  if (this.parent != null) {
                    this.scroll = this.parent.scroll;
                  }
                };
                ShadowBlot2.prototype.clone = function() {
                  var domNode = this.domNode.cloneNode(false);
                  return Registry.create(domNode);
                };
                ShadowBlot2.prototype.detach = function() {
                  if (this.parent != null)
                    this.parent.removeChild(this);
                  delete this.domNode[Registry.DATA_KEY];
                };
                ShadowBlot2.prototype.deleteAt = function(index3, length2) {
                  var blot = this.isolate(index3, length2);
                  blot.remove();
                };
                ShadowBlot2.prototype.formatAt = function(index3, length2, name, value) {
                  var blot = this.isolate(index3, length2);
                  if (Registry.query(name, Registry.Scope.BLOT) != null && value) {
                    blot.wrap(name, value);
                  } else if (Registry.query(name, Registry.Scope.ATTRIBUTE) != null) {
                    var parent = Registry.create(this.statics.scope);
                    blot.wrap(parent);
                    parent.format(name, value);
                  }
                };
                ShadowBlot2.prototype.insertAt = function(index3, value, def) {
                  var blot = def == null ? Registry.create("text", value) : Registry.create(value, def);
                  var ref = this.split(index3);
                  this.parent.insertBefore(blot, ref);
                };
                ShadowBlot2.prototype.insertInto = function(parentBlot, refBlot) {
                  if (refBlot === void 0) {
                    refBlot = null;
                  }
                  if (this.parent != null) {
                    this.parent.children.remove(this);
                  }
                  var refDomNode = null;
                  parentBlot.children.insertBefore(this, refBlot);
                  if (refBlot != null) {
                    refDomNode = refBlot.domNode;
                  }
                  if (this.domNode.parentNode != parentBlot.domNode || this.domNode.nextSibling != refDomNode) {
                    parentBlot.domNode.insertBefore(this.domNode, refDomNode);
                  }
                  this.parent = parentBlot;
                  this.attach();
                };
                ShadowBlot2.prototype.isolate = function(index3, length2) {
                  var target = this.split(index3);
                  target.split(length2);
                  return target;
                };
                ShadowBlot2.prototype.length = function() {
                  return 1;
                };
                ShadowBlot2.prototype.offset = function(root2) {
                  if (root2 === void 0) {
                    root2 = this.parent;
                  }
                  if (this.parent == null || this == root2)
                    return 0;
                  return this.parent.children.offset(this) + this.parent.offset(root2);
                };
                ShadowBlot2.prototype.optimize = function(context) {
                  if (this.domNode[Registry.DATA_KEY] != null) {
                    delete this.domNode[Registry.DATA_KEY].mutations;
                  }
                };
                ShadowBlot2.prototype.remove = function() {
                  if (this.domNode.parentNode != null) {
                    this.domNode.parentNode.removeChild(this.domNode);
                  }
                  this.detach();
                };
                ShadowBlot2.prototype.replace = function(target) {
                  if (target.parent == null)
                    return;
                  target.parent.insertBefore(this, target.next);
                  target.remove();
                };
                ShadowBlot2.prototype.replaceWith = function(name, value) {
                  var replacement = typeof name === "string" ? Registry.create(name, value) : name;
                  replacement.replace(this);
                  return replacement;
                };
                ShadowBlot2.prototype.split = function(index3, force) {
                  return index3 === 0 ? this : this.next;
                };
                ShadowBlot2.prototype.update = function(mutations, context) {
                };
                ShadowBlot2.prototype.wrap = function(name, value) {
                  var wrapper = typeof name === "string" ? Registry.create(name, value) : name;
                  if (this.parent != null) {
                    this.parent.insertBefore(wrapper, this.next);
                  }
                  wrapper.appendChild(this);
                  return wrapper;
                };
                ShadowBlot2.blotName = "abstract";
                return ShadowBlot2;
              }()
            );
            exports2.default = ShadowBlot;
          },
          /* 31 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            var attributor_1 = __webpack_require__(12);
            var class_1 = __webpack_require__(32);
            var style_1 = __webpack_require__(33);
            var Registry = __webpack_require__(1);
            var AttributorStore = (
              /** @class */
              function() {
                function AttributorStore2(domNode) {
                  this.attributes = {};
                  this.domNode = domNode;
                  this.build();
                }
                AttributorStore2.prototype.attribute = function(attribute, value) {
                  if (value) {
                    if (attribute.add(this.domNode, value)) {
                      if (attribute.value(this.domNode) != null) {
                        this.attributes[attribute.attrName] = attribute;
                      } else {
                        delete this.attributes[attribute.attrName];
                      }
                    }
                  } else {
                    attribute.remove(this.domNode);
                    delete this.attributes[attribute.attrName];
                  }
                };
                AttributorStore2.prototype.build = function() {
                  var _this = this;
                  this.attributes = {};
                  var attributes = attributor_1.default.keys(this.domNode);
                  var classes2 = class_1.default.keys(this.domNode);
                  var styles2 = style_1.default.keys(this.domNode);
                  attributes.concat(classes2).concat(styles2).forEach(function(name) {
                    var attr2 = Registry.query(name, Registry.Scope.ATTRIBUTE);
                    if (attr2 instanceof attributor_1.default) {
                      _this.attributes[attr2.attrName] = attr2;
                    }
                  });
                };
                AttributorStore2.prototype.copy = function(target) {
                  var _this = this;
                  Object.keys(this.attributes).forEach(function(key) {
                    var value = _this.attributes[key].value(_this.domNode);
                    target.format(key, value);
                  });
                };
                AttributorStore2.prototype.move = function(target) {
                  var _this = this;
                  this.copy(target);
                  Object.keys(this.attributes).forEach(function(key) {
                    _this.attributes[key].remove(_this.domNode);
                  });
                  this.attributes = {};
                };
                AttributorStore2.prototype.values = function() {
                  var _this = this;
                  return Object.keys(this.attributes).reduce(function(attributes, name) {
                    attributes[name] = _this.attributes[name].value(_this.domNode);
                    return attributes;
                  }, {});
                };
                return AttributorStore2;
              }()
            );
            exports2.default = AttributorStore;
          },
          /* 32 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            var __extends3 = this && this.__extends || function() {
              var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
                d.__proto__ = b;
              } || function(d, b) {
                for (var p2 in b)
                  if (b.hasOwnProperty(p2))
                    d[p2] = b[p2];
              };
              return function(d, b) {
                extendStatics(d, b);
                function __() {
                  this.constructor = d;
                }
                d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
              };
            }();
            Object.defineProperty(exports2, "__esModule", { value: true });
            var attributor_1 = __webpack_require__(12);
            function match(node3, prefix) {
              var className = node3.getAttribute("class") || "";
              return className.split(/\s+/).filter(function(name) {
                return name.indexOf(prefix + "-") === 0;
              });
            }
            var ClassAttributor = (
              /** @class */
              function(_super) {
                __extends3(ClassAttributor2, _super);
                function ClassAttributor2() {
                  return _super !== null && _super.apply(this, arguments) || this;
                }
                ClassAttributor2.keys = function(node3) {
                  return (node3.getAttribute("class") || "").split(/\s+/).map(function(name) {
                    return name.split("-").slice(0, -1).join("-");
                  });
                };
                ClassAttributor2.prototype.add = function(node3, value) {
                  if (!this.canAdd(node3, value))
                    return false;
                  this.remove(node3);
                  node3.classList.add(this.keyName + "-" + value);
                  return true;
                };
                ClassAttributor2.prototype.remove = function(node3) {
                  var matches = match(node3, this.keyName);
                  matches.forEach(function(name) {
                    node3.classList.remove(name);
                  });
                  if (node3.classList.length === 0) {
                    node3.removeAttribute("class");
                  }
                };
                ClassAttributor2.prototype.value = function(node3) {
                  var result = match(node3, this.keyName)[0] || "";
                  var value = result.slice(this.keyName.length + 1);
                  return this.canAdd(node3, value) ? value : "";
                };
                return ClassAttributor2;
              }(attributor_1.default)
            );
            exports2.default = ClassAttributor;
          },
          /* 33 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            var __extends3 = this && this.__extends || function() {
              var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
                d.__proto__ = b;
              } || function(d, b) {
                for (var p2 in b)
                  if (b.hasOwnProperty(p2))
                    d[p2] = b[p2];
              };
              return function(d, b) {
                extendStatics(d, b);
                function __() {
                  this.constructor = d;
                }
                d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
              };
            }();
            Object.defineProperty(exports2, "__esModule", { value: true });
            var attributor_1 = __webpack_require__(12);
            function camelize(name) {
              var parts = name.split("-");
              var rest = parts.slice(1).map(function(part) {
                return part[0].toUpperCase() + part.slice(1);
              }).join("");
              return parts[0] + rest;
            }
            var StyleAttributor = (
              /** @class */
              function(_super) {
                __extends3(StyleAttributor2, _super);
                function StyleAttributor2() {
                  return _super !== null && _super.apply(this, arguments) || this;
                }
                StyleAttributor2.keys = function(node3) {
                  return (node3.getAttribute("style") || "").split(";").map(function(value) {
                    var arr = value.split(":");
                    return arr[0].trim();
                  });
                };
                StyleAttributor2.prototype.add = function(node3, value) {
                  if (!this.canAdd(node3, value))
                    return false;
                  node3.style[camelize(this.keyName)] = value;
                  return true;
                };
                StyleAttributor2.prototype.remove = function(node3) {
                  node3.style[camelize(this.keyName)] = "";
                  if (!node3.getAttribute("style")) {
                    node3.removeAttribute("style");
                  }
                };
                StyleAttributor2.prototype.value = function(node3) {
                  var value = node3.style[camelize(this.keyName)];
                  return this.canAdd(node3, value) ? value : "";
                };
                return StyleAttributor2;
              }(attributor_1.default)
            );
            exports2.default = StyleAttributor;
          },
          /* 34 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _createClass = function() {
              function defineProperties(target, props) {
                for (var i2 = 0; i2 < props.length; i2++) {
                  var descriptor = props[i2];
                  descriptor.enumerable = descriptor.enumerable || false;
                  descriptor.configurable = true;
                  if ("value" in descriptor)
                    descriptor.writable = true;
                  Object.defineProperty(target, descriptor.key, descriptor);
                }
              }
              return function(Constructor, protoProps, staticProps) {
                if (protoProps)
                  defineProperties(Constructor.prototype, protoProps);
                if (staticProps)
                  defineProperties(Constructor, staticProps);
                return Constructor;
              };
            }();
            function _classCallCheck2(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            var Theme = function() {
              function Theme2(quill, options) {
                _classCallCheck2(this, Theme2);
                this.quill = quill;
                this.options = options;
                this.modules = {};
              }
              _createClass(Theme2, [{
                key: "init",
                value: function init() {
                  var _this = this;
                  Object.keys(this.options.modules).forEach(function(name) {
                    if (_this.modules[name] == null) {
                      _this.addModule(name);
                    }
                  });
                }
              }, {
                key: "addModule",
                value: function addModule(name) {
                  var moduleClass = this.quill.constructor.import("modules/" + name);
                  this.modules[name] = new moduleClass(this.quill, this.options.modules[name] || {});
                  return this.modules[name];
                }
              }]);
              return Theme2;
            }();
            Theme.DEFAULTS = {
              modules: {}
            };
            Theme.themes = {
              "default": Theme
            };
            exports2.default = Theme;
          },
          /* 35 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _createClass = function() {
              function defineProperties(target, props) {
                for (var i2 = 0; i2 < props.length; i2++) {
                  var descriptor = props[i2];
                  descriptor.enumerable = descriptor.enumerable || false;
                  descriptor.configurable = true;
                  if ("value" in descriptor)
                    descriptor.writable = true;
                  Object.defineProperty(target, descriptor.key, descriptor);
                }
              }
              return function(Constructor, protoProps, staticProps) {
                if (protoProps)
                  defineProperties(Constructor.prototype, protoProps);
                if (staticProps)
                  defineProperties(Constructor, staticProps);
                return Constructor;
              };
            }();
            var _get = function get(object, property, receiver) {
              if (object === null)
                object = Function.prototype;
              var desc = Object.getOwnPropertyDescriptor(object, property);
              if (desc === void 0) {
                var parent = Object.getPrototypeOf(object);
                if (parent === null) {
                  return void 0;
                } else {
                  return get(parent, property, receiver);
                }
              } else if ("value" in desc) {
                return desc.value;
              } else {
                var getter = desc.get;
                if (getter === void 0) {
                  return void 0;
                }
                return getter.call(receiver);
              }
            };
            var _parchment = __webpack_require__(0);
            var _parchment2 = _interopRequireDefault(_parchment);
            var _text = __webpack_require__(7);
            var _text2 = _interopRequireDefault(_text);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { default: obj };
            }
            function _classCallCheck2(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function _possibleConstructorReturn(self2, call) {
              if (!self2) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return call && (typeof call === "object" || typeof call === "function") ? call : self2;
            }
            function _inherits(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
              }
              subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
              if (superClass)
                Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
            }
            var GUARD_TEXT = "\uFEFF";
            var Embed = function(_Parchment$Embed) {
              _inherits(Embed2, _Parchment$Embed);
              function Embed2(node3) {
                _classCallCheck2(this, Embed2);
                var _this = _possibleConstructorReturn(this, (Embed2.__proto__ || Object.getPrototypeOf(Embed2)).call(this, node3));
                _this.contentNode = document.createElement("span");
                _this.contentNode.setAttribute("contenteditable", false);
                [].slice.call(_this.domNode.childNodes).forEach(function(childNode) {
                  _this.contentNode.appendChild(childNode);
                });
                _this.leftGuard = document.createTextNode(GUARD_TEXT);
                _this.rightGuard = document.createTextNode(GUARD_TEXT);
                _this.domNode.appendChild(_this.leftGuard);
                _this.domNode.appendChild(_this.contentNode);
                _this.domNode.appendChild(_this.rightGuard);
                return _this;
              }
              _createClass(Embed2, [{
                key: "index",
                value: function index3(node3, offset) {
                  if (node3 === this.leftGuard)
                    return 0;
                  if (node3 === this.rightGuard)
                    return 1;
                  return _get(Embed2.prototype.__proto__ || Object.getPrototypeOf(Embed2.prototype), "index", this).call(this, node3, offset);
                }
              }, {
                key: "restore",
                value: function restore(node3) {
                  var range = void 0, textNode = void 0;
                  var text4 = node3.data.split(GUARD_TEXT).join("");
                  if (node3 === this.leftGuard) {
                    if (this.prev instanceof _text2.default) {
                      var prevLength = this.prev.length();
                      this.prev.insertAt(prevLength, text4);
                      range = {
                        startNode: this.prev.domNode,
                        startOffset: prevLength + text4.length
                      };
                    } else {
                      textNode = document.createTextNode(text4);
                      this.parent.insertBefore(_parchment2.default.create(textNode), this);
                      range = {
                        startNode: textNode,
                        startOffset: text4.length
                      };
                    }
                  } else if (node3 === this.rightGuard) {
                    if (this.next instanceof _text2.default) {
                      this.next.insertAt(0, text4);
                      range = {
                        startNode: this.next.domNode,
                        startOffset: text4.length
                      };
                    } else {
                      textNode = document.createTextNode(text4);
                      this.parent.insertBefore(_parchment2.default.create(textNode), this.next);
                      range = {
                        startNode: textNode,
                        startOffset: text4.length
                      };
                    }
                  }
                  node3.data = GUARD_TEXT;
                  return range;
                }
              }, {
                key: "update",
                value: function update(mutations, context) {
                  var _this2 = this;
                  mutations.forEach(function(mutation) {
                    if (mutation.type === "characterData" && (mutation.target === _this2.leftGuard || mutation.target === _this2.rightGuard)) {
                      var range = _this2.restore(mutation.target);
                      if (range)
                        context.range = range;
                    }
                  });
                }
              }]);
              return Embed2;
            }(_parchment2.default.Embed);
            exports2.default = Embed;
          },
          /* 36 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.AlignStyle = exports2.AlignClass = exports2.AlignAttribute = void 0;
            var _parchment = __webpack_require__(0);
            var _parchment2 = _interopRequireDefault(_parchment);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { default: obj };
            }
            var config = {
              scope: _parchment2.default.Scope.BLOCK,
              whitelist: ["right", "center", "justify"]
            };
            var AlignAttribute = new _parchment2.default.Attributor.Attribute("align", "align", config);
            var AlignClass = new _parchment2.default.Attributor.Class("align", "ql-align", config);
            var AlignStyle = new _parchment2.default.Attributor.Style("align", "text-align", config);
            exports2.AlignAttribute = AlignAttribute;
            exports2.AlignClass = AlignClass;
            exports2.AlignStyle = AlignStyle;
          },
          /* 37 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.BackgroundStyle = exports2.BackgroundClass = void 0;
            var _parchment = __webpack_require__(0);
            var _parchment2 = _interopRequireDefault(_parchment);
            var _color = __webpack_require__(26);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { default: obj };
            }
            var BackgroundClass = new _parchment2.default.Attributor.Class("background", "ql-bg", {
              scope: _parchment2.default.Scope.INLINE
            });
            var BackgroundStyle = new _color.ColorAttributor("background", "background-color", {
              scope: _parchment2.default.Scope.INLINE
            });
            exports2.BackgroundClass = BackgroundClass;
            exports2.BackgroundStyle = BackgroundStyle;
          },
          /* 38 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.DirectionStyle = exports2.DirectionClass = exports2.DirectionAttribute = void 0;
            var _parchment = __webpack_require__(0);
            var _parchment2 = _interopRequireDefault(_parchment);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { default: obj };
            }
            var config = {
              scope: _parchment2.default.Scope.BLOCK,
              whitelist: ["rtl"]
            };
            var DirectionAttribute = new _parchment2.default.Attributor.Attribute("direction", "dir", config);
            var DirectionClass = new _parchment2.default.Attributor.Class("direction", "ql-direction", config);
            var DirectionStyle = new _parchment2.default.Attributor.Style("direction", "direction", config);
            exports2.DirectionAttribute = DirectionAttribute;
            exports2.DirectionClass = DirectionClass;
            exports2.DirectionStyle = DirectionStyle;
          },
          /* 39 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.FontClass = exports2.FontStyle = void 0;
            var _createClass = function() {
              function defineProperties(target, props) {
                for (var i2 = 0; i2 < props.length; i2++) {
                  var descriptor = props[i2];
                  descriptor.enumerable = descriptor.enumerable || false;
                  descriptor.configurable = true;
                  if ("value" in descriptor)
                    descriptor.writable = true;
                  Object.defineProperty(target, descriptor.key, descriptor);
                }
              }
              return function(Constructor, protoProps, staticProps) {
                if (protoProps)
                  defineProperties(Constructor.prototype, protoProps);
                if (staticProps)
                  defineProperties(Constructor, staticProps);
                return Constructor;
              };
            }();
            var _get = function get(object, property, receiver) {
              if (object === null)
                object = Function.prototype;
              var desc = Object.getOwnPropertyDescriptor(object, property);
              if (desc === void 0) {
                var parent = Object.getPrototypeOf(object);
                if (parent === null) {
                  return void 0;
                } else {
                  return get(parent, property, receiver);
                }
              } else if ("value" in desc) {
                return desc.value;
              } else {
                var getter = desc.get;
                if (getter === void 0) {
                  return void 0;
                }
                return getter.call(receiver);
              }
            };
            var _parchment = __webpack_require__(0);
            var _parchment2 = _interopRequireDefault(_parchment);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { default: obj };
            }
            function _classCallCheck2(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function _possibleConstructorReturn(self2, call) {
              if (!self2) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return call && (typeof call === "object" || typeof call === "function") ? call : self2;
            }
            function _inherits(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
              }
              subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
              if (superClass)
                Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
            }
            var config = {
              scope: _parchment2.default.Scope.INLINE,
              whitelist: ["serif", "monospace"]
            };
            var FontClass = new _parchment2.default.Attributor.Class("font", "ql-font", config);
            var FontStyleAttributor = function(_Parchment$Attributor) {
              _inherits(FontStyleAttributor2, _Parchment$Attributor);
              function FontStyleAttributor2() {
                _classCallCheck2(this, FontStyleAttributor2);
                return _possibleConstructorReturn(this, (FontStyleAttributor2.__proto__ || Object.getPrototypeOf(FontStyleAttributor2)).apply(this, arguments));
              }
              _createClass(FontStyleAttributor2, [{
                key: "value",
                value: function value(node3) {
                  return _get(FontStyleAttributor2.prototype.__proto__ || Object.getPrototypeOf(FontStyleAttributor2.prototype), "value", this).call(this, node3).replace(/["']/g, "");
                }
              }]);
              return FontStyleAttributor2;
            }(_parchment2.default.Attributor.Style);
            var FontStyle = new FontStyleAttributor("font", "font-family", config);
            exports2.FontStyle = FontStyle;
            exports2.FontClass = FontClass;
          },
          /* 40 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.SizeStyle = exports2.SizeClass = void 0;
            var _parchment = __webpack_require__(0);
            var _parchment2 = _interopRequireDefault(_parchment);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { default: obj };
            }
            var SizeClass = new _parchment2.default.Attributor.Class("size", "ql-size", {
              scope: _parchment2.default.Scope.INLINE,
              whitelist: ["small", "large", "huge"]
            });
            var SizeStyle = new _parchment2.default.Attributor.Style("size", "font-size", {
              scope: _parchment2.default.Scope.INLINE,
              whitelist: ["10px", "18px", "32px"]
            });
            exports2.SizeClass = SizeClass;
            exports2.SizeStyle = SizeStyle;
          },
          /* 41 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            module2.exports = {
              "align": {
                "": __webpack_require__(76),
                "center": __webpack_require__(77),
                "right": __webpack_require__(78),
                "justify": __webpack_require__(79)
              },
              "background": __webpack_require__(80),
              "blockquote": __webpack_require__(81),
              "bold": __webpack_require__(82),
              "clean": __webpack_require__(83),
              "code": __webpack_require__(58),
              "code-block": __webpack_require__(58),
              "color": __webpack_require__(84),
              "direction": {
                "": __webpack_require__(85),
                "rtl": __webpack_require__(86)
              },
              "float": {
                "center": __webpack_require__(87),
                "full": __webpack_require__(88),
                "left": __webpack_require__(89),
                "right": __webpack_require__(90)
              },
              "formula": __webpack_require__(91),
              "header": {
                "1": __webpack_require__(92),
                "2": __webpack_require__(93)
              },
              "italic": __webpack_require__(94),
              "image": __webpack_require__(95),
              "indent": {
                "+1": __webpack_require__(96),
                "-1": __webpack_require__(97)
              },
              "link": __webpack_require__(98),
              "list": {
                "ordered": __webpack_require__(99),
                "bullet": __webpack_require__(100),
                "check": __webpack_require__(101)
              },
              "script": {
                "sub": __webpack_require__(102),
                "super": __webpack_require__(103)
              },
              "strike": __webpack_require__(104),
              "underline": __webpack_require__(105),
              "video": __webpack_require__(106)
            };
          },
          /* 42 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.getLastChangeIndex = exports2.default = void 0;
            var _createClass = function() {
              function defineProperties(target, props) {
                for (var i2 = 0; i2 < props.length; i2++) {
                  var descriptor = props[i2];
                  descriptor.enumerable = descriptor.enumerable || false;
                  descriptor.configurable = true;
                  if ("value" in descriptor)
                    descriptor.writable = true;
                  Object.defineProperty(target, descriptor.key, descriptor);
                }
              }
              return function(Constructor, protoProps, staticProps) {
                if (protoProps)
                  defineProperties(Constructor.prototype, protoProps);
                if (staticProps)
                  defineProperties(Constructor, staticProps);
                return Constructor;
              };
            }();
            var _parchment = __webpack_require__(0);
            var _parchment2 = _interopRequireDefault(_parchment);
            var _quill = __webpack_require__(5);
            var _quill2 = _interopRequireDefault(_quill);
            var _module = __webpack_require__(9);
            var _module2 = _interopRequireDefault(_module);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { default: obj };
            }
            function _classCallCheck2(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function _possibleConstructorReturn(self2, call) {
              if (!self2) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return call && (typeof call === "object" || typeof call === "function") ? call : self2;
            }
            function _inherits(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
              }
              subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
              if (superClass)
                Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
            }
            var History = function(_Module) {
              _inherits(History2, _Module);
              function History2(quill, options) {
                _classCallCheck2(this, History2);
                var _this = _possibleConstructorReturn(this, (History2.__proto__ || Object.getPrototypeOf(History2)).call(this, quill, options));
                _this.lastRecorded = 0;
                _this.ignoreChange = false;
                _this.clear();
                _this.quill.on(_quill2.default.events.EDITOR_CHANGE, function(eventName, delta, oldDelta, source) {
                  if (eventName !== _quill2.default.events.TEXT_CHANGE || _this.ignoreChange)
                    return;
                  if (!_this.options.userOnly || source === _quill2.default.sources.USER) {
                    _this.record(delta, oldDelta);
                  } else {
                    _this.transform(delta);
                  }
                });
                _this.quill.keyboard.addBinding({ key: "Z", shortKey: true }, _this.undo.bind(_this));
                _this.quill.keyboard.addBinding({ key: "Z", shortKey: true, shiftKey: true }, _this.redo.bind(_this));
                if (/Win/i.test(navigator.platform)) {
                  _this.quill.keyboard.addBinding({ key: "Y", shortKey: true }, _this.redo.bind(_this));
                }
                return _this;
              }
              _createClass(History2, [{
                key: "change",
                value: function change(source, dest) {
                  if (this.stack[source].length === 0)
                    return;
                  var delta = this.stack[source].pop();
                  this.stack[dest].push(delta);
                  this.lastRecorded = 0;
                  this.ignoreChange = true;
                  this.quill.updateContents(delta[source], _quill2.default.sources.USER);
                  this.ignoreChange = false;
                  var index3 = getLastChangeIndex(delta[source]);
                  this.quill.setSelection(index3);
                }
              }, {
                key: "clear",
                value: function clear2() {
                  this.stack = { undo: [], redo: [] };
                }
              }, {
                key: "cutoff",
                value: function cutoff() {
                  this.lastRecorded = 0;
                }
              }, {
                key: "record",
                value: function record(changeDelta, oldDelta) {
                  if (changeDelta.ops.length === 0)
                    return;
                  this.stack.redo = [];
                  var undoDelta = this.quill.getContents().diff(oldDelta);
                  var timestamp = Date.now();
                  if (this.lastRecorded + this.options.delay > timestamp && this.stack.undo.length > 0) {
                    var delta = this.stack.undo.pop();
                    undoDelta = undoDelta.compose(delta.undo);
                    changeDelta = delta.redo.compose(changeDelta);
                  } else {
                    this.lastRecorded = timestamp;
                  }
                  this.stack.undo.push({
                    redo: changeDelta,
                    undo: undoDelta
                  });
                  if (this.stack.undo.length > this.options.maxStack) {
                    this.stack.undo.shift();
                  }
                }
              }, {
                key: "redo",
                value: function redo() {
                  this.change("redo", "undo");
                }
              }, {
                key: "transform",
                value: function transform2(delta) {
                  this.stack.undo.forEach(function(change) {
                    change.undo = delta.transform(change.undo, true);
                    change.redo = delta.transform(change.redo, true);
                  });
                  this.stack.redo.forEach(function(change) {
                    change.undo = delta.transform(change.undo, true);
                    change.redo = delta.transform(change.redo, true);
                  });
                }
              }, {
                key: "undo",
                value: function undo() {
                  this.change("undo", "redo");
                }
              }]);
              return History2;
            }(_module2.default);
            History.DEFAULTS = {
              delay: 1e3,
              maxStack: 100,
              userOnly: false
            };
            function endsWithNewlineChange(delta) {
              var lastOp = delta.ops[delta.ops.length - 1];
              if (lastOp == null)
                return false;
              if (lastOp.insert != null) {
                return typeof lastOp.insert === "string" && lastOp.insert.endsWith("\n");
              }
              if (lastOp.attributes != null) {
                return Object.keys(lastOp.attributes).some(function(attr2) {
                  return _parchment2.default.query(attr2, _parchment2.default.Scope.BLOCK) != null;
                });
              }
              return false;
            }
            function getLastChangeIndex(delta) {
              var deleteLength = delta.reduce(function(length2, op2) {
                length2 += op2.delete || 0;
                return length2;
              }, 0);
              var changeIndex = delta.length() - deleteLength;
              if (endsWithNewlineChange(delta)) {
                changeIndex -= 1;
              }
              return changeIndex;
            }
            exports2.default = History;
            exports2.getLastChangeIndex = getLastChangeIndex;
          },
          /* 43 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.default = exports2.BaseTooltip = void 0;
            var _createClass = function() {
              function defineProperties(target, props) {
                for (var i2 = 0; i2 < props.length; i2++) {
                  var descriptor = props[i2];
                  descriptor.enumerable = descriptor.enumerable || false;
                  descriptor.configurable = true;
                  if ("value" in descriptor)
                    descriptor.writable = true;
                  Object.defineProperty(target, descriptor.key, descriptor);
                }
              }
              return function(Constructor, protoProps, staticProps) {
                if (protoProps)
                  defineProperties(Constructor.prototype, protoProps);
                if (staticProps)
                  defineProperties(Constructor, staticProps);
                return Constructor;
              };
            }();
            var _get = function get(object, property, receiver) {
              if (object === null)
                object = Function.prototype;
              var desc = Object.getOwnPropertyDescriptor(object, property);
              if (desc === void 0) {
                var parent = Object.getPrototypeOf(object);
                if (parent === null) {
                  return void 0;
                } else {
                  return get(parent, property, receiver);
                }
              } else if ("value" in desc) {
                return desc.value;
              } else {
                var getter = desc.get;
                if (getter === void 0) {
                  return void 0;
                }
                return getter.call(receiver);
              }
            };
            var _extend = __webpack_require__(3);
            var _extend2 = _interopRequireDefault(_extend);
            var _quillDelta = __webpack_require__(2);
            var _quillDelta2 = _interopRequireDefault(_quillDelta);
            var _emitter = __webpack_require__(8);
            var _emitter2 = _interopRequireDefault(_emitter);
            var _keyboard = __webpack_require__(23);
            var _keyboard2 = _interopRequireDefault(_keyboard);
            var _theme = __webpack_require__(34);
            var _theme2 = _interopRequireDefault(_theme);
            var _colorPicker = __webpack_require__(59);
            var _colorPicker2 = _interopRequireDefault(_colorPicker);
            var _iconPicker = __webpack_require__(60);
            var _iconPicker2 = _interopRequireDefault(_iconPicker);
            var _picker = __webpack_require__(28);
            var _picker2 = _interopRequireDefault(_picker);
            var _tooltip = __webpack_require__(61);
            var _tooltip2 = _interopRequireDefault(_tooltip);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { default: obj };
            }
            function _classCallCheck2(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function _possibleConstructorReturn(self2, call) {
              if (!self2) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return call && (typeof call === "object" || typeof call === "function") ? call : self2;
            }
            function _inherits(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
              }
              subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
              if (superClass)
                Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
            }
            var ALIGNS = [false, "center", "right", "justify"];
            var COLORS = ["#000000", "#e60000", "#ff9900", "#ffff00", "#008a00", "#0066cc", "#9933ff", "#ffffff", "#facccc", "#ffebcc", "#ffffcc", "#cce8cc", "#cce0f5", "#ebd6ff", "#bbbbbb", "#f06666", "#ffc266", "#ffff66", "#66b966", "#66a3e0", "#c285ff", "#888888", "#a10000", "#b26b00", "#b2b200", "#006100", "#0047b2", "#6b24b2", "#444444", "#5c0000", "#663d00", "#666600", "#003700", "#002966", "#3d1466"];
            var FONTS = [false, "serif", "monospace"];
            var HEADERS = ["1", "2", "3", false];
            var SIZES = ["small", false, "large", "huge"];
            var BaseTheme = function(_Theme) {
              _inherits(BaseTheme2, _Theme);
              function BaseTheme2(quill, options) {
                _classCallCheck2(this, BaseTheme2);
                var _this = _possibleConstructorReturn(this, (BaseTheme2.__proto__ || Object.getPrototypeOf(BaseTheme2)).call(this, quill, options));
                var listener = function listener2(e2) {
                  if (!document.body.contains(quill.root)) {
                    return document.body.removeEventListener("click", listener2);
                  }
                  if (_this.tooltip != null && !_this.tooltip.root.contains(e2.target) && document.activeElement !== _this.tooltip.textbox && !_this.quill.hasFocus()) {
                    _this.tooltip.hide();
                  }
                  if (_this.pickers != null) {
                    _this.pickers.forEach(function(picker) {
                      if (!picker.container.contains(e2.target)) {
                        picker.close();
                      }
                    });
                  }
                };
                quill.emitter.listenDOM("click", document.body, listener);
                return _this;
              }
              _createClass(BaseTheme2, [{
                key: "addModule",
                value: function addModule(name) {
                  var module3 = _get(BaseTheme2.prototype.__proto__ || Object.getPrototypeOf(BaseTheme2.prototype), "addModule", this).call(this, name);
                  if (name === "toolbar") {
                    this.extendToolbar(module3);
                  }
                  return module3;
                }
              }, {
                key: "buildButtons",
                value: function buildButtons(buttons, icons) {
                  buttons.forEach(function(button) {
                    var className = button.getAttribute("class") || "";
                    className.split(/\s+/).forEach(function(name) {
                      if (!name.startsWith("ql-"))
                        return;
                      name = name.slice("ql-".length);
                      if (icons[name] == null)
                        return;
                      if (name === "direction") {
                        button.innerHTML = icons[name][""] + icons[name]["rtl"];
                      } else if (typeof icons[name] === "string") {
                        button.innerHTML = icons[name];
                      } else {
                        var value = button.value || "";
                        if (value != null && icons[name][value]) {
                          button.innerHTML = icons[name][value];
                        }
                      }
                    });
                  });
                }
              }, {
                key: "buildPickers",
                value: function buildPickers(selects, icons) {
                  var _this2 = this;
                  this.pickers = selects.map(function(select) {
                    if (select.classList.contains("ql-align")) {
                      if (select.querySelector("option") == null) {
                        fillSelect(select, ALIGNS);
                      }
                      return new _iconPicker2.default(select, icons.align);
                    } else if (select.classList.contains("ql-background") || select.classList.contains("ql-color")) {
                      var format = select.classList.contains("ql-background") ? "background" : "color";
                      if (select.querySelector("option") == null) {
                        fillSelect(select, COLORS, format === "background" ? "#ffffff" : "#000000");
                      }
                      return new _colorPicker2.default(select, icons[format]);
                    } else {
                      if (select.querySelector("option") == null) {
                        if (select.classList.contains("ql-font")) {
                          fillSelect(select, FONTS);
                        } else if (select.classList.contains("ql-header")) {
                          fillSelect(select, HEADERS);
                        } else if (select.classList.contains("ql-size")) {
                          fillSelect(select, SIZES);
                        }
                      }
                      return new _picker2.default(select);
                    }
                  });
                  var update = function update2() {
                    _this2.pickers.forEach(function(picker) {
                      picker.update();
                    });
                  };
                  this.quill.on(_emitter2.default.events.EDITOR_CHANGE, update);
                }
              }]);
              return BaseTheme2;
            }(_theme2.default);
            BaseTheme.DEFAULTS = (0, _extend2.default)(true, {}, _theme2.default.DEFAULTS, {
              modules: {
                toolbar: {
                  handlers: {
                    formula: function formula() {
                      this.quill.theme.tooltip.edit("formula");
                    },
                    image: function image() {
                      var _this3 = this;
                      var fileInput = this.container.querySelector("input.ql-image[type=file]");
                      if (fileInput == null) {
                        fileInput = document.createElement("input");
                        fileInput.setAttribute("type", "file");
                        fileInput.setAttribute("accept", "image/png, image/gif, image/jpeg, image/bmp, image/x-icon");
                        fileInput.classList.add("ql-image");
                        fileInput.addEventListener("change", function() {
                          if (fileInput.files != null && fileInput.files[0] != null) {
                            var reader = new FileReader();
                            reader.onload = function(e2) {
                              var range = _this3.quill.getSelection(true);
                              _this3.quill.updateContents(new _quillDelta2.default().retain(range.index).delete(range.length).insert({ image: e2.target.result }), _emitter2.default.sources.USER);
                              _this3.quill.setSelection(range.index + 1, _emitter2.default.sources.SILENT);
                              fileInput.value = "";
                            };
                            reader.readAsDataURL(fileInput.files[0]);
                          }
                        });
                        this.container.appendChild(fileInput);
                      }
                      fileInput.click();
                    },
                    video: function video() {
                      this.quill.theme.tooltip.edit("video");
                    }
                  }
                }
              }
            });
            var BaseTooltip = function(_Tooltip) {
              _inherits(BaseTooltip2, _Tooltip);
              function BaseTooltip2(quill, boundsContainer) {
                _classCallCheck2(this, BaseTooltip2);
                var _this4 = _possibleConstructorReturn(this, (BaseTooltip2.__proto__ || Object.getPrototypeOf(BaseTooltip2)).call(this, quill, boundsContainer));
                _this4.textbox = _this4.root.querySelector('input[type="text"]');
                _this4.listen();
                return _this4;
              }
              _createClass(BaseTooltip2, [{
                key: "listen",
                value: function listen() {
                  var _this5 = this;
                  this.textbox.addEventListener("keydown", function(event) {
                    if (_keyboard2.default.match(event, "enter")) {
                      _this5.save();
                      event.preventDefault();
                    } else if (_keyboard2.default.match(event, "escape")) {
                      _this5.cancel();
                      event.preventDefault();
                    }
                  });
                }
              }, {
                key: "cancel",
                value: function cancel() {
                  this.hide();
                }
              }, {
                key: "edit",
                value: function edit() {
                  var mode = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "link";
                  var preview = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
                  this.root.classList.remove("ql-hidden");
                  this.root.classList.add("ql-editing");
                  if (preview != null) {
                    this.textbox.value = preview;
                  } else if (mode !== this.root.getAttribute("data-mode")) {
                    this.textbox.value = "";
                  }
                  this.position(this.quill.getBounds(this.quill.selection.savedRange));
                  this.textbox.select();
                  this.textbox.setAttribute("placeholder", this.textbox.getAttribute("data-" + mode) || "");
                  this.root.setAttribute("data-mode", mode);
                }
              }, {
                key: "restoreFocus",
                value: function restoreFocus() {
                  var scrollTop = this.quill.scrollingContainer.scrollTop;
                  this.quill.focus();
                  this.quill.scrollingContainer.scrollTop = scrollTop;
                }
              }, {
                key: "save",
                value: function save() {
                  var value = this.textbox.value;
                  switch (this.root.getAttribute("data-mode")) {
                    case "link": {
                      var scrollTop = this.quill.root.scrollTop;
                      if (this.linkRange) {
                        this.quill.formatText(this.linkRange, "link", value, _emitter2.default.sources.USER);
                        delete this.linkRange;
                      } else {
                        this.restoreFocus();
                        this.quill.format("link", value, _emitter2.default.sources.USER);
                      }
                      this.quill.root.scrollTop = scrollTop;
                      break;
                    }
                    case "video": {
                      value = extractVideoUrl(value);
                    }
                    case "formula": {
                      if (!value)
                        break;
                      var range = this.quill.getSelection(true);
                      if (range != null) {
                        var index3 = range.index + range.length;
                        this.quill.insertEmbed(index3, this.root.getAttribute("data-mode"), value, _emitter2.default.sources.USER);
                        if (this.root.getAttribute("data-mode") === "formula") {
                          this.quill.insertText(index3 + 1, " ", _emitter2.default.sources.USER);
                        }
                        this.quill.setSelection(index3 + 2, _emitter2.default.sources.USER);
                      }
                      break;
                    }
                    default:
                  }
                  this.textbox.value = "";
                  this.hide();
                }
              }]);
              return BaseTooltip2;
            }(_tooltip2.default);
            function extractVideoUrl(url) {
              var match = url.match(/^(?:(https?):\/\/)?(?:(?:www|m)\.)?youtube\.com\/watch.*v=([a-zA-Z0-9_-]+)/) || url.match(/^(?:(https?):\/\/)?(?:(?:www|m)\.)?youtu\.be\/([a-zA-Z0-9_-]+)/);
              if (match) {
                return (match[1] || "https") + "://www.youtube.com/embed/" + match[2] + "?showinfo=0";
              }
              if (match = url.match(/^(?:(https?):\/\/)?(?:www\.)?vimeo\.com\/(\d+)/)) {
                return (match[1] || "https") + "://player.vimeo.com/video/" + match[2] + "/";
              }
              return url;
            }
            function fillSelect(select, values) {
              var defaultValue = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
              values.forEach(function(value) {
                var option = document.createElement("option");
                if (value === defaultValue) {
                  option.setAttribute("selected", "selected");
                } else {
                  option.setAttribute("value", value);
                }
                select.appendChild(option);
              });
            }
            exports2.BaseTooltip = BaseTooltip;
            exports2.default = BaseTheme;
          },
          /* 44 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            var LinkedList = (
              /** @class */
              function() {
                function LinkedList2() {
                  this.head = this.tail = null;
                  this.length = 0;
                }
                LinkedList2.prototype.append = function() {
                  var nodes = [];
                  for (var _i = 0; _i < arguments.length; _i++) {
                    nodes[_i] = arguments[_i];
                  }
                  this.insertBefore(nodes[0], null);
                  if (nodes.length > 1) {
                    this.append.apply(this, nodes.slice(1));
                  }
                };
                LinkedList2.prototype.contains = function(node3) {
                  var cur, next2 = this.iterator();
                  while (cur = next2()) {
                    if (cur === node3)
                      return true;
                  }
                  return false;
                };
                LinkedList2.prototype.insertBefore = function(node3, refNode) {
                  if (!node3)
                    return;
                  node3.next = refNode;
                  if (refNode != null) {
                    node3.prev = refNode.prev;
                    if (refNode.prev != null) {
                      refNode.prev.next = node3;
                    }
                    refNode.prev = node3;
                    if (refNode === this.head) {
                      this.head = node3;
                    }
                  } else if (this.tail != null) {
                    this.tail.next = node3;
                    node3.prev = this.tail;
                    this.tail = node3;
                  } else {
                    node3.prev = null;
                    this.head = this.tail = node3;
                  }
                  this.length += 1;
                };
                LinkedList2.prototype.offset = function(target) {
                  var index3 = 0, cur = this.head;
                  while (cur != null) {
                    if (cur === target)
                      return index3;
                    index3 += cur.length();
                    cur = cur.next;
                  }
                  return -1;
                };
                LinkedList2.prototype.remove = function(node3) {
                  if (!this.contains(node3))
                    return;
                  if (node3.prev != null)
                    node3.prev.next = node3.next;
                  if (node3.next != null)
                    node3.next.prev = node3.prev;
                  if (node3 === this.head)
                    this.head = node3.next;
                  if (node3 === this.tail)
                    this.tail = node3.prev;
                  this.length -= 1;
                };
                LinkedList2.prototype.iterator = function(curNode) {
                  if (curNode === void 0) {
                    curNode = this.head;
                  }
                  return function() {
                    var ret = curNode;
                    if (curNode != null)
                      curNode = curNode.next;
                    return ret;
                  };
                };
                LinkedList2.prototype.find = function(index3, inclusive) {
                  if (inclusive === void 0) {
                    inclusive = false;
                  }
                  var cur, next2 = this.iterator();
                  while (cur = next2()) {
                    var length2 = cur.length();
                    if (index3 < length2 || inclusive && index3 === length2 && (cur.next == null || cur.next.length() !== 0)) {
                      return [cur, index3];
                    }
                    index3 -= length2;
                  }
                  return [null, 0];
                };
                LinkedList2.prototype.forEach = function(callback) {
                  var cur, next2 = this.iterator();
                  while (cur = next2()) {
                    callback(cur);
                  }
                };
                LinkedList2.prototype.forEachAt = function(index3, length2, callback) {
                  if (length2 <= 0)
                    return;
                  var _a2 = this.find(index3), startNode = _a2[0], offset = _a2[1];
                  var cur, curIndex = index3 - offset, next2 = this.iterator(startNode);
                  while ((cur = next2()) && curIndex < index3 + length2) {
                    var curLength = cur.length();
                    if (index3 > curIndex) {
                      callback(cur, index3 - curIndex, Math.min(length2, curIndex + curLength - index3));
                    } else {
                      callback(cur, 0, Math.min(curLength, index3 + length2 - curIndex));
                    }
                    curIndex += curLength;
                  }
                };
                LinkedList2.prototype.map = function(callback) {
                  return this.reduce(function(memo, cur) {
                    memo.push(callback(cur));
                    return memo;
                  }, []);
                };
                LinkedList2.prototype.reduce = function(callback, memo) {
                  var cur, next2 = this.iterator();
                  while (cur = next2()) {
                    memo = callback(memo, cur);
                  }
                  return memo;
                };
                return LinkedList2;
              }()
            );
            exports2.default = LinkedList;
          },
          /* 45 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            var __extends3 = this && this.__extends || function() {
              var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
                d.__proto__ = b;
              } || function(d, b) {
                for (var p2 in b)
                  if (b.hasOwnProperty(p2))
                    d[p2] = b[p2];
              };
              return function(d, b) {
                extendStatics(d, b);
                function __() {
                  this.constructor = d;
                }
                d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
              };
            }();
            Object.defineProperty(exports2, "__esModule", { value: true });
            var container_1 = __webpack_require__(17);
            var Registry = __webpack_require__(1);
            var OBSERVER_CONFIG = {
              attributes: true,
              characterData: true,
              characterDataOldValue: true,
              childList: true,
              subtree: true
            };
            var MAX_OPTIMIZE_ITERATIONS = 100;
            var ScrollBlot = (
              /** @class */
              function(_super) {
                __extends3(ScrollBlot2, _super);
                function ScrollBlot2(node3) {
                  var _this = _super.call(this, node3) || this;
                  _this.scroll = _this;
                  _this.observer = new MutationObserver(function(mutations) {
                    _this.update(mutations);
                  });
                  _this.observer.observe(_this.domNode, OBSERVER_CONFIG);
                  _this.attach();
                  return _this;
                }
                ScrollBlot2.prototype.detach = function() {
                  _super.prototype.detach.call(this);
                  this.observer.disconnect();
                };
                ScrollBlot2.prototype.deleteAt = function(index3, length2) {
                  this.update();
                  if (index3 === 0 && length2 === this.length()) {
                    this.children.forEach(function(child) {
                      child.remove();
                    });
                  } else {
                    _super.prototype.deleteAt.call(this, index3, length2);
                  }
                };
                ScrollBlot2.prototype.formatAt = function(index3, length2, name, value) {
                  this.update();
                  _super.prototype.formatAt.call(this, index3, length2, name, value);
                };
                ScrollBlot2.prototype.insertAt = function(index3, value, def) {
                  this.update();
                  _super.prototype.insertAt.call(this, index3, value, def);
                };
                ScrollBlot2.prototype.optimize = function(mutations, context) {
                  var _this = this;
                  if (mutations === void 0) {
                    mutations = [];
                  }
                  if (context === void 0) {
                    context = {};
                  }
                  _super.prototype.optimize.call(this, context);
                  var records = [].slice.call(this.observer.takeRecords());
                  while (records.length > 0)
                    mutations.push(records.pop());
                  var mark = function(blot, markParent) {
                    if (markParent === void 0) {
                      markParent = true;
                    }
                    if (blot == null || blot === _this)
                      return;
                    if (blot.domNode.parentNode == null)
                      return;
                    if (blot.domNode[Registry.DATA_KEY].mutations == null) {
                      blot.domNode[Registry.DATA_KEY].mutations = [];
                    }
                    if (markParent)
                      mark(blot.parent);
                  };
                  var optimize = function(blot) {
                    if (
                      // @ts-ignore
                      blot.domNode[Registry.DATA_KEY] == null || // @ts-ignore
                      blot.domNode[Registry.DATA_KEY].mutations == null
                    ) {
                      return;
                    }
                    if (blot instanceof container_1.default) {
                      blot.children.forEach(optimize);
                    }
                    blot.optimize(context);
                  };
                  var remaining = mutations;
                  for (var i2 = 0; remaining.length > 0; i2 += 1) {
                    if (i2 >= MAX_OPTIMIZE_ITERATIONS) {
                      throw new Error("[Parchment] Maximum optimize iterations reached");
                    }
                    remaining.forEach(function(mutation) {
                      var blot = Registry.find(mutation.target, true);
                      if (blot == null)
                        return;
                      if (blot.domNode === mutation.target) {
                        if (mutation.type === "childList") {
                          mark(Registry.find(mutation.previousSibling, false));
                          [].forEach.call(mutation.addedNodes, function(node3) {
                            var child = Registry.find(node3, false);
                            mark(child, false);
                            if (child instanceof container_1.default) {
                              child.children.forEach(function(grandChild) {
                                mark(grandChild, false);
                              });
                            }
                          });
                        } else if (mutation.type === "attributes") {
                          mark(blot.prev);
                        }
                      }
                      mark(blot);
                    });
                    this.children.forEach(optimize);
                    remaining = [].slice.call(this.observer.takeRecords());
                    records = remaining.slice();
                    while (records.length > 0)
                      mutations.push(records.pop());
                  }
                };
                ScrollBlot2.prototype.update = function(mutations, context) {
                  var _this = this;
                  if (context === void 0) {
                    context = {};
                  }
                  mutations = mutations || this.observer.takeRecords();
                  mutations.map(function(mutation) {
                    var blot = Registry.find(mutation.target, true);
                    if (blot == null)
                      return null;
                    if (blot.domNode[Registry.DATA_KEY].mutations == null) {
                      blot.domNode[Registry.DATA_KEY].mutations = [mutation];
                      return blot;
                    } else {
                      blot.domNode[Registry.DATA_KEY].mutations.push(mutation);
                      return null;
                    }
                  }).forEach(function(blot) {
                    if (blot == null || blot === _this || //@ts-ignore
                    blot.domNode[Registry.DATA_KEY] == null)
                      return;
                    blot.update(blot.domNode[Registry.DATA_KEY].mutations || [], context);
                  });
                  if (this.domNode[Registry.DATA_KEY].mutations != null) {
                    _super.prototype.update.call(this, this.domNode[Registry.DATA_KEY].mutations, context);
                  }
                  this.optimize(mutations, context);
                };
                ScrollBlot2.blotName = "scroll";
                ScrollBlot2.defaultChild = "block";
                ScrollBlot2.scope = Registry.Scope.BLOCK_BLOT;
                ScrollBlot2.tagName = "DIV";
                return ScrollBlot2;
              }(container_1.default)
            );
            exports2.default = ScrollBlot;
          },
          /* 46 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            var __extends3 = this && this.__extends || function() {
              var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
                d.__proto__ = b;
              } || function(d, b) {
                for (var p2 in b)
                  if (b.hasOwnProperty(p2))
                    d[p2] = b[p2];
              };
              return function(d, b) {
                extendStatics(d, b);
                function __() {
                  this.constructor = d;
                }
                d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
              };
            }();
            Object.defineProperty(exports2, "__esModule", { value: true });
            var format_1 = __webpack_require__(18);
            var Registry = __webpack_require__(1);
            function isEqual(obj1, obj2) {
              if (Object.keys(obj1).length !== Object.keys(obj2).length)
                return false;
              for (var prop in obj1) {
                if (obj1[prop] !== obj2[prop])
                  return false;
              }
              return true;
            }
            var InlineBlot = (
              /** @class */
              function(_super) {
                __extends3(InlineBlot2, _super);
                function InlineBlot2() {
                  return _super !== null && _super.apply(this, arguments) || this;
                }
                InlineBlot2.formats = function(domNode) {
                  if (domNode.tagName === InlineBlot2.tagName)
                    return void 0;
                  return _super.formats.call(this, domNode);
                };
                InlineBlot2.prototype.format = function(name, value) {
                  var _this = this;
                  if (name === this.statics.blotName && !value) {
                    this.children.forEach(function(child) {
                      if (!(child instanceof format_1.default)) {
                        child = child.wrap(InlineBlot2.blotName, true);
                      }
                      _this.attributes.copy(child);
                    });
                    this.unwrap();
                  } else {
                    _super.prototype.format.call(this, name, value);
                  }
                };
                InlineBlot2.prototype.formatAt = function(index3, length2, name, value) {
                  if (this.formats()[name] != null || Registry.query(name, Registry.Scope.ATTRIBUTE)) {
                    var blot = this.isolate(index3, length2);
                    blot.format(name, value);
                  } else {
                    _super.prototype.formatAt.call(this, index3, length2, name, value);
                  }
                };
                InlineBlot2.prototype.optimize = function(context) {
                  _super.prototype.optimize.call(this, context);
                  var formats = this.formats();
                  if (Object.keys(formats).length === 0) {
                    return this.unwrap();
                  }
                  var next2 = this.next;
                  if (next2 instanceof InlineBlot2 && next2.prev === this && isEqual(formats, next2.formats())) {
                    next2.moveChildren(this);
                    next2.remove();
                  }
                };
                InlineBlot2.blotName = "inline";
                InlineBlot2.scope = Registry.Scope.INLINE_BLOT;
                InlineBlot2.tagName = "SPAN";
                return InlineBlot2;
              }(format_1.default)
            );
            exports2.default = InlineBlot;
          },
          /* 47 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            var __extends3 = this && this.__extends || function() {
              var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
                d.__proto__ = b;
              } || function(d, b) {
                for (var p2 in b)
                  if (b.hasOwnProperty(p2))
                    d[p2] = b[p2];
              };
              return function(d, b) {
                extendStatics(d, b);
                function __() {
                  this.constructor = d;
                }
                d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
              };
            }();
            Object.defineProperty(exports2, "__esModule", { value: true });
            var format_1 = __webpack_require__(18);
            var Registry = __webpack_require__(1);
            var BlockBlot = (
              /** @class */
              function(_super) {
                __extends3(BlockBlot2, _super);
                function BlockBlot2() {
                  return _super !== null && _super.apply(this, arguments) || this;
                }
                BlockBlot2.formats = function(domNode) {
                  var tagName = Registry.query(BlockBlot2.blotName).tagName;
                  if (domNode.tagName === tagName)
                    return void 0;
                  return _super.formats.call(this, domNode);
                };
                BlockBlot2.prototype.format = function(name, value) {
                  if (Registry.query(name, Registry.Scope.BLOCK) == null) {
                    return;
                  } else if (name === this.statics.blotName && !value) {
                    this.replaceWith(BlockBlot2.blotName);
                  } else {
                    _super.prototype.format.call(this, name, value);
                  }
                };
                BlockBlot2.prototype.formatAt = function(index3, length2, name, value) {
                  if (Registry.query(name, Registry.Scope.BLOCK) != null) {
                    this.format(name, value);
                  } else {
                    _super.prototype.formatAt.call(this, index3, length2, name, value);
                  }
                };
                BlockBlot2.prototype.insertAt = function(index3, value, def) {
                  if (def == null || Registry.query(value, Registry.Scope.INLINE) != null) {
                    _super.prototype.insertAt.call(this, index3, value, def);
                  } else {
                    var after2 = this.split(index3);
                    var blot = Registry.create(value, def);
                    after2.parent.insertBefore(blot, after2);
                  }
                };
                BlockBlot2.prototype.update = function(mutations, context) {
                  if (navigator.userAgent.match(/Trident/)) {
                    this.build();
                  } else {
                    _super.prototype.update.call(this, mutations, context);
                  }
                };
                BlockBlot2.blotName = "block";
                BlockBlot2.scope = Registry.Scope.BLOCK_BLOT;
                BlockBlot2.tagName = "P";
                return BlockBlot2;
              }(format_1.default)
            );
            exports2.default = BlockBlot;
          },
          /* 48 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            var __extends3 = this && this.__extends || function() {
              var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
                d.__proto__ = b;
              } || function(d, b) {
                for (var p2 in b)
                  if (b.hasOwnProperty(p2))
                    d[p2] = b[p2];
              };
              return function(d, b) {
                extendStatics(d, b);
                function __() {
                  this.constructor = d;
                }
                d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
              };
            }();
            Object.defineProperty(exports2, "__esModule", { value: true });
            var leaf_1 = __webpack_require__(19);
            var EmbedBlot = (
              /** @class */
              function(_super) {
                __extends3(EmbedBlot2, _super);
                function EmbedBlot2() {
                  return _super !== null && _super.apply(this, arguments) || this;
                }
                EmbedBlot2.formats = function(domNode) {
                  return void 0;
                };
                EmbedBlot2.prototype.format = function(name, value) {
                  _super.prototype.formatAt.call(this, 0, this.length(), name, value);
                };
                EmbedBlot2.prototype.formatAt = function(index3, length2, name, value) {
                  if (index3 === 0 && length2 === this.length()) {
                    this.format(name, value);
                  } else {
                    _super.prototype.formatAt.call(this, index3, length2, name, value);
                  }
                };
                EmbedBlot2.prototype.formats = function() {
                  return this.statics.formats(this.domNode);
                };
                return EmbedBlot2;
              }(leaf_1.default)
            );
            exports2.default = EmbedBlot;
          },
          /* 49 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            var __extends3 = this && this.__extends || function() {
              var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
                d.__proto__ = b;
              } || function(d, b) {
                for (var p2 in b)
                  if (b.hasOwnProperty(p2))
                    d[p2] = b[p2];
              };
              return function(d, b) {
                extendStatics(d, b);
                function __() {
                  this.constructor = d;
                }
                d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
              };
            }();
            Object.defineProperty(exports2, "__esModule", { value: true });
            var leaf_1 = __webpack_require__(19);
            var Registry = __webpack_require__(1);
            var TextBlot = (
              /** @class */
              function(_super) {
                __extends3(TextBlot2, _super);
                function TextBlot2(node3) {
                  var _this = _super.call(this, node3) || this;
                  _this.text = _this.statics.value(_this.domNode);
                  return _this;
                }
                TextBlot2.create = function(value) {
                  return document.createTextNode(value);
                };
                TextBlot2.value = function(domNode) {
                  var text4 = domNode.data;
                  if (text4["normalize"])
                    text4 = text4["normalize"]();
                  return text4;
                };
                TextBlot2.prototype.deleteAt = function(index3, length2) {
                  this.domNode.data = this.text = this.text.slice(0, index3) + this.text.slice(index3 + length2);
                };
                TextBlot2.prototype.index = function(node3, offset) {
                  if (this.domNode === node3) {
                    return offset;
                  }
                  return -1;
                };
                TextBlot2.prototype.insertAt = function(index3, value, def) {
                  if (def == null) {
                    this.text = this.text.slice(0, index3) + value + this.text.slice(index3);
                    this.domNode.data = this.text;
                  } else {
                    _super.prototype.insertAt.call(this, index3, value, def);
                  }
                };
                TextBlot2.prototype.length = function() {
                  return this.text.length;
                };
                TextBlot2.prototype.optimize = function(context) {
                  _super.prototype.optimize.call(this, context);
                  this.text = this.statics.value(this.domNode);
                  if (this.text.length === 0) {
                    this.remove();
                  } else if (this.next instanceof TextBlot2 && this.next.prev === this) {
                    this.insertAt(this.length(), this.next.value());
                    this.next.remove();
                  }
                };
                TextBlot2.prototype.position = function(index3, inclusive) {
                  if (inclusive === void 0) {
                    inclusive = false;
                  }
                  return [this.domNode, index3];
                };
                TextBlot2.prototype.split = function(index3, force) {
                  if (force === void 0) {
                    force = false;
                  }
                  if (!force) {
                    if (index3 === 0)
                      return this;
                    if (index3 === this.length())
                      return this.next;
                  }
                  var after2 = Registry.create(this.domNode.splitText(index3));
                  this.parent.insertBefore(after2, this.next);
                  this.text = this.statics.value(this.domNode);
                  return after2;
                };
                TextBlot2.prototype.update = function(mutations, context) {
                  var _this = this;
                  if (mutations.some(function(mutation) {
                    return mutation.type === "characterData" && mutation.target === _this.domNode;
                  })) {
                    this.text = this.statics.value(this.domNode);
                  }
                };
                TextBlot2.prototype.value = function() {
                  return this.text;
                };
                TextBlot2.blotName = "text";
                TextBlot2.scope = Registry.Scope.INLINE_BLOT;
                return TextBlot2;
              }(leaf_1.default)
            );
            exports2.default = TextBlot;
          },
          /* 50 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            var elem = document.createElement("div");
            elem.classList.toggle("test-class", false);
            if (elem.classList.contains("test-class")) {
              var _toggle = DOMTokenList.prototype.toggle;
              DOMTokenList.prototype.toggle = function(token, force) {
                if (arguments.length > 1 && !this.contains(token) === !force) {
                  return force;
                } else {
                  return _toggle.call(this, token);
                }
              };
            }
            if (!String.prototype.startsWith) {
              String.prototype.startsWith = function(searchString, position3) {
                position3 = position3 || 0;
                return this.substr(position3, searchString.length) === searchString;
              };
            }
            if (!String.prototype.endsWith) {
              String.prototype.endsWith = function(searchString, position3) {
                var subjectString = this.toString();
                if (typeof position3 !== "number" || !isFinite(position3) || Math.floor(position3) !== position3 || position3 > subjectString.length) {
                  position3 = subjectString.length;
                }
                position3 -= searchString.length;
                var lastIndex = subjectString.indexOf(searchString, position3);
                return lastIndex !== -1 && lastIndex === position3;
              };
            }
            if (!Array.prototype.find) {
              Object.defineProperty(Array.prototype, "find", {
                value: function value(predicate) {
                  if (this === null) {
                    throw new TypeError("Array.prototype.find called on null or undefined");
                  }
                  if (typeof predicate !== "function") {
                    throw new TypeError("predicate must be a function");
                  }
                  var list2 = Object(this);
                  var length2 = list2.length >>> 0;
                  var thisArg = arguments[1];
                  var value2;
                  for (var i2 = 0; i2 < length2; i2++) {
                    value2 = list2[i2];
                    if (predicate.call(thisArg, value2, i2, list2)) {
                      return value2;
                    }
                  }
                  return void 0;
                }
              });
            }
            document.addEventListener("DOMContentLoaded", function() {
              document.execCommand("enableObjectResizing", false, false);
              document.execCommand("autoUrlDetect", false, false);
            });
          },
          /* 51 */
          /***/
          function(module2, exports2) {
            var DIFF_DELETE = -1;
            var DIFF_INSERT = 1;
            var DIFF_EQUAL = 0;
            function diff_main(text1, text22, cursor_pos) {
              if (text1 == text22) {
                if (text1) {
                  return [[DIFF_EQUAL, text1]];
                }
                return [];
              }
              if (cursor_pos < 0 || text1.length < cursor_pos) {
                cursor_pos = null;
              }
              var commonlength = diff_commonPrefix(text1, text22);
              var commonprefix = text1.substring(0, commonlength);
              text1 = text1.substring(commonlength);
              text22 = text22.substring(commonlength);
              commonlength = diff_commonSuffix(text1, text22);
              var commonsuffix = text1.substring(text1.length - commonlength);
              text1 = text1.substring(0, text1.length - commonlength);
              text22 = text22.substring(0, text22.length - commonlength);
              var diffs = diff_compute_(text1, text22);
              if (commonprefix) {
                diffs.unshift([DIFF_EQUAL, commonprefix]);
              }
              if (commonsuffix) {
                diffs.push([DIFF_EQUAL, commonsuffix]);
              }
              diff_cleanupMerge(diffs);
              if (cursor_pos != null) {
                diffs = fix_cursor(diffs, cursor_pos);
              }
              diffs = fix_emoji(diffs);
              return diffs;
            }
            ;
            function diff_compute_(text1, text22) {
              var diffs;
              if (!text1) {
                return [[DIFF_INSERT, text22]];
              }
              if (!text22) {
                return [[DIFF_DELETE, text1]];
              }
              var longtext = text1.length > text22.length ? text1 : text22;
              var shorttext = text1.length > text22.length ? text22 : text1;
              var i2 = longtext.indexOf(shorttext);
              if (i2 != -1) {
                diffs = [
                  [DIFF_INSERT, longtext.substring(0, i2)],
                  [DIFF_EQUAL, shorttext],
                  [DIFF_INSERT, longtext.substring(i2 + shorttext.length)]
                ];
                if (text1.length > text22.length) {
                  diffs[0][0] = diffs[2][0] = DIFF_DELETE;
                }
                return diffs;
              }
              if (shorttext.length == 1) {
                return [[DIFF_DELETE, text1], [DIFF_INSERT, text22]];
              }
              var hm = diff_halfMatch_(text1, text22);
              if (hm) {
                var text1_a = hm[0];
                var text1_b = hm[1];
                var text2_a = hm[2];
                var text2_b = hm[3];
                var mid_common = hm[4];
                var diffs_a = diff_main(text1_a, text2_a);
                var diffs_b = diff_main(text1_b, text2_b);
                return diffs_a.concat([[DIFF_EQUAL, mid_common]], diffs_b);
              }
              return diff_bisect_(text1, text22);
            }
            ;
            function diff_bisect_(text1, text22) {
              var text1_length = text1.length;
              var text2_length = text22.length;
              var max_d = Math.ceil((text1_length + text2_length) / 2);
              var v_offset = max_d;
              var v_length = 2 * max_d;
              var v1 = new Array(v_length);
              var v2 = new Array(v_length);
              for (var x2 = 0; x2 < v_length; x2++) {
                v1[x2] = -1;
                v2[x2] = -1;
              }
              v1[v_offset + 1] = 0;
              v2[v_offset + 1] = 0;
              var delta = text1_length - text2_length;
              var front2 = delta % 2 != 0;
              var k1start = 0;
              var k1end = 0;
              var k2start = 0;
              var k2end = 0;
              for (var d = 0; d < max_d; d++) {
                for (var k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {
                  var k1_offset = v_offset + k1;
                  var x1;
                  if (k1 == -d || k1 != d && v1[k1_offset - 1] < v1[k1_offset + 1]) {
                    x1 = v1[k1_offset + 1];
                  } else {
                    x1 = v1[k1_offset - 1] + 1;
                  }
                  var y1 = x1 - k1;
                  while (x1 < text1_length && y1 < text2_length && text1.charAt(x1) == text22.charAt(y1)) {
                    x1++;
                    y1++;
                  }
                  v1[k1_offset] = x1;
                  if (x1 > text1_length) {
                    k1end += 2;
                  } else if (y1 > text2_length) {
                    k1start += 2;
                  } else if (front2) {
                    var k2_offset = v_offset + delta - k1;
                    if (k2_offset >= 0 && k2_offset < v_length && v2[k2_offset] != -1) {
                      var x22 = text1_length - v2[k2_offset];
                      if (x1 >= x22) {
                        return diff_bisectSplit_(text1, text22, x1, y1);
                      }
                    }
                  }
                }
                for (var k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {
                  var k2_offset = v_offset + k2;
                  var x22;
                  if (k2 == -d || k2 != d && v2[k2_offset - 1] < v2[k2_offset + 1]) {
                    x22 = v2[k2_offset + 1];
                  } else {
                    x22 = v2[k2_offset - 1] + 1;
                  }
                  var y22 = x22 - k2;
                  while (x22 < text1_length && y22 < text2_length && text1.charAt(text1_length - x22 - 1) == text22.charAt(text2_length - y22 - 1)) {
                    x22++;
                    y22++;
                  }
                  v2[k2_offset] = x22;
                  if (x22 > text1_length) {
                    k2end += 2;
                  } else if (y22 > text2_length) {
                    k2start += 2;
                  } else if (!front2) {
                    var k1_offset = v_offset + delta - k2;
                    if (k1_offset >= 0 && k1_offset < v_length && v1[k1_offset] != -1) {
                      var x1 = v1[k1_offset];
                      var y1 = v_offset + x1 - k1_offset;
                      x22 = text1_length - x22;
                      if (x1 >= x22) {
                        return diff_bisectSplit_(text1, text22, x1, y1);
                      }
                    }
                  }
                }
              }
              return [[DIFF_DELETE, text1], [DIFF_INSERT, text22]];
            }
            ;
            function diff_bisectSplit_(text1, text22, x2, y3) {
              var text1a = text1.substring(0, x2);
              var text2a = text22.substring(0, y3);
              var text1b = text1.substring(x2);
              var text2b = text22.substring(y3);
              var diffs = diff_main(text1a, text2a);
              var diffsb = diff_main(text1b, text2b);
              return diffs.concat(diffsb);
            }
            ;
            function diff_commonPrefix(text1, text22) {
              if (!text1 || !text22 || text1.charAt(0) != text22.charAt(0)) {
                return 0;
              }
              var pointermin = 0;
              var pointermax = Math.min(text1.length, text22.length);
              var pointermid = pointermax;
              var pointerstart = 0;
              while (pointermin < pointermid) {
                if (text1.substring(pointerstart, pointermid) == text22.substring(pointerstart, pointermid)) {
                  pointermin = pointermid;
                  pointerstart = pointermin;
                } else {
                  pointermax = pointermid;
                }
                pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
              }
              return pointermid;
            }
            ;
            function diff_commonSuffix(text1, text22) {
              if (!text1 || !text22 || text1.charAt(text1.length - 1) != text22.charAt(text22.length - 1)) {
                return 0;
              }
              var pointermin = 0;
              var pointermax = Math.min(text1.length, text22.length);
              var pointermid = pointermax;
              var pointerend = 0;
              while (pointermin < pointermid) {
                if (text1.substring(text1.length - pointermid, text1.length - pointerend) == text22.substring(text22.length - pointermid, text22.length - pointerend)) {
                  pointermin = pointermid;
                  pointerend = pointermin;
                } else {
                  pointermax = pointermid;
                }
                pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
              }
              return pointermid;
            }
            ;
            function diff_halfMatch_(text1, text22) {
              var longtext = text1.length > text22.length ? text1 : text22;
              var shorttext = text1.length > text22.length ? text22 : text1;
              if (longtext.length < 4 || shorttext.length * 2 < longtext.length) {
                return null;
              }
              function diff_halfMatchI_(longtext2, shorttext2, i2) {
                var seed = longtext2.substring(i2, i2 + Math.floor(longtext2.length / 4));
                var j = -1;
                var best_common = "";
                var best_longtext_a, best_longtext_b, best_shorttext_a, best_shorttext_b;
                while ((j = shorttext2.indexOf(seed, j + 1)) != -1) {
                  var prefixLength = diff_commonPrefix(
                    longtext2.substring(i2),
                    shorttext2.substring(j)
                  );
                  var suffixLength = diff_commonSuffix(
                    longtext2.substring(0, i2),
                    shorttext2.substring(0, j)
                  );
                  if (best_common.length < suffixLength + prefixLength) {
                    best_common = shorttext2.substring(j - suffixLength, j) + shorttext2.substring(j, j + prefixLength);
                    best_longtext_a = longtext2.substring(0, i2 - suffixLength);
                    best_longtext_b = longtext2.substring(i2 + prefixLength);
                    best_shorttext_a = shorttext2.substring(0, j - suffixLength);
                    best_shorttext_b = shorttext2.substring(j + prefixLength);
                  }
                }
                if (best_common.length * 2 >= longtext2.length) {
                  return [
                    best_longtext_a,
                    best_longtext_b,
                    best_shorttext_a,
                    best_shorttext_b,
                    best_common
                  ];
                } else {
                  return null;
                }
              }
              var hm1 = diff_halfMatchI_(
                longtext,
                shorttext,
                Math.ceil(longtext.length / 4)
              );
              var hm2 = diff_halfMatchI_(
                longtext,
                shorttext,
                Math.ceil(longtext.length / 2)
              );
              var hm;
              if (!hm1 && !hm2) {
                return null;
              } else if (!hm2) {
                hm = hm1;
              } else if (!hm1) {
                hm = hm2;
              } else {
                hm = hm1[4].length > hm2[4].length ? hm1 : hm2;
              }
              var text1_a, text1_b, text2_a, text2_b;
              if (text1.length > text22.length) {
                text1_a = hm[0];
                text1_b = hm[1];
                text2_a = hm[2];
                text2_b = hm[3];
              } else {
                text2_a = hm[0];
                text2_b = hm[1];
                text1_a = hm[2];
                text1_b = hm[3];
              }
              var mid_common = hm[4];
              return [text1_a, text1_b, text2_a, text2_b, mid_common];
            }
            ;
            function diff_cleanupMerge(diffs) {
              diffs.push([DIFF_EQUAL, ""]);
              var pointer = 0;
              var count_delete = 0;
              var count_insert = 0;
              var text_delete = "";
              var text_insert = "";
              var commonlength;
              while (pointer < diffs.length) {
                switch (diffs[pointer][0]) {
                  case DIFF_INSERT:
                    count_insert++;
                    text_insert += diffs[pointer][1];
                    pointer++;
                    break;
                  case DIFF_DELETE:
                    count_delete++;
                    text_delete += diffs[pointer][1];
                    pointer++;
                    break;
                  case DIFF_EQUAL:
                    if (count_delete + count_insert > 1) {
                      if (count_delete !== 0 && count_insert !== 0) {
                        commonlength = diff_commonPrefix(text_insert, text_delete);
                        if (commonlength !== 0) {
                          if (pointer - count_delete - count_insert > 0 && diffs[pointer - count_delete - count_insert - 1][0] == DIFF_EQUAL) {
                            diffs[pointer - count_delete - count_insert - 1][1] += text_insert.substring(0, commonlength);
                          } else {
                            diffs.splice(0, 0, [
                              DIFF_EQUAL,
                              text_insert.substring(0, commonlength)
                            ]);
                            pointer++;
                          }
                          text_insert = text_insert.substring(commonlength);
                          text_delete = text_delete.substring(commonlength);
                        }
                        commonlength = diff_commonSuffix(text_insert, text_delete);
                        if (commonlength !== 0) {
                          diffs[pointer][1] = text_insert.substring(text_insert.length - commonlength) + diffs[pointer][1];
                          text_insert = text_insert.substring(0, text_insert.length - commonlength);
                          text_delete = text_delete.substring(0, text_delete.length - commonlength);
                        }
                      }
                      if (count_delete === 0) {
                        diffs.splice(
                          pointer - count_insert,
                          count_delete + count_insert,
                          [DIFF_INSERT, text_insert]
                        );
                      } else if (count_insert === 0) {
                        diffs.splice(
                          pointer - count_delete,
                          count_delete + count_insert,
                          [DIFF_DELETE, text_delete]
                        );
                      } else {
                        diffs.splice(
                          pointer - count_delete - count_insert,
                          count_delete + count_insert,
                          [DIFF_DELETE, text_delete],
                          [DIFF_INSERT, text_insert]
                        );
                      }
                      pointer = pointer - count_delete - count_insert + (count_delete ? 1 : 0) + (count_insert ? 1 : 0) + 1;
                    } else if (pointer !== 0 && diffs[pointer - 1][0] == DIFF_EQUAL) {
                      diffs[pointer - 1][1] += diffs[pointer][1];
                      diffs.splice(pointer, 1);
                    } else {
                      pointer++;
                    }
                    count_insert = 0;
                    count_delete = 0;
                    text_delete = "";
                    text_insert = "";
                    break;
                }
              }
              if (diffs[diffs.length - 1][1] === "") {
                diffs.pop();
              }
              var changes = false;
              pointer = 1;
              while (pointer < diffs.length - 1) {
                if (diffs[pointer - 1][0] == DIFF_EQUAL && diffs[pointer + 1][0] == DIFF_EQUAL) {
                  if (diffs[pointer][1].substring(diffs[pointer][1].length - diffs[pointer - 1][1].length) == diffs[pointer - 1][1]) {
                    diffs[pointer][1] = diffs[pointer - 1][1] + diffs[pointer][1].substring(0, diffs[pointer][1].length - diffs[pointer - 1][1].length);
                    diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];
                    diffs.splice(pointer - 1, 1);
                    changes = true;
                  } else if (diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) == diffs[pointer + 1][1]) {
                    diffs[pointer - 1][1] += diffs[pointer + 1][1];
                    diffs[pointer][1] = diffs[pointer][1].substring(diffs[pointer + 1][1].length) + diffs[pointer + 1][1];
                    diffs.splice(pointer + 1, 1);
                    changes = true;
                  }
                }
                pointer++;
              }
              if (changes) {
                diff_cleanupMerge(diffs);
              }
            }
            ;
            var diff = diff_main;
            diff.INSERT = DIFF_INSERT;
            diff.DELETE = DIFF_DELETE;
            diff.EQUAL = DIFF_EQUAL;
            module2.exports = diff;
            function cursor_normalize_diff(diffs, cursor_pos) {
              if (cursor_pos === 0) {
                return [DIFF_EQUAL, diffs];
              }
              for (var current_pos = 0, i2 = 0; i2 < diffs.length; i2++) {
                var d = diffs[i2];
                if (d[0] === DIFF_DELETE || d[0] === DIFF_EQUAL) {
                  var next_pos = current_pos + d[1].length;
                  if (cursor_pos === next_pos) {
                    return [i2 + 1, diffs];
                  } else if (cursor_pos < next_pos) {
                    diffs = diffs.slice();
                    var split_pos = cursor_pos - current_pos;
                    var d_left = [d[0], d[1].slice(0, split_pos)];
                    var d_right = [d[0], d[1].slice(split_pos)];
                    diffs.splice(i2, 1, d_left, d_right);
                    return [i2 + 1, diffs];
                  } else {
                    current_pos = next_pos;
                  }
                }
              }
              throw new Error("cursor_pos is out of bounds!");
            }
            function fix_cursor(diffs, cursor_pos) {
              var norm = cursor_normalize_diff(diffs, cursor_pos);
              var ndiffs = norm[1];
              var cursor_pointer = norm[0];
              var d = ndiffs[cursor_pointer];
              var d_next = ndiffs[cursor_pointer + 1];
              if (d == null) {
                return diffs;
              } else if (d[0] !== DIFF_EQUAL) {
                return diffs;
              } else {
                if (d_next != null && d[1] + d_next[1] === d_next[1] + d[1]) {
                  ndiffs.splice(cursor_pointer, 2, d_next, d);
                  return merge_tuples(ndiffs, cursor_pointer, 2);
                } else if (d_next != null && d_next[1].indexOf(d[1]) === 0) {
                  ndiffs.splice(cursor_pointer, 2, [d_next[0], d[1]], [0, d[1]]);
                  var suffix = d_next[1].slice(d[1].length);
                  if (suffix.length > 0) {
                    ndiffs.splice(cursor_pointer + 2, 0, [d_next[0], suffix]);
                  }
                  return merge_tuples(ndiffs, cursor_pointer, 3);
                } else {
                  return diffs;
                }
              }
            }
            function fix_emoji(diffs) {
              var compact = false;
              var starts_with_pair_end = function(str) {
                return str.charCodeAt(0) >= 56320 && str.charCodeAt(0) <= 57343;
              };
              var ends_with_pair_start = function(str) {
                return str.charCodeAt(str.length - 1) >= 55296 && str.charCodeAt(str.length - 1) <= 56319;
              };
              for (var i2 = 2; i2 < diffs.length; i2 += 1) {
                if (diffs[i2 - 2][0] === DIFF_EQUAL && ends_with_pair_start(diffs[i2 - 2][1]) && diffs[i2 - 1][0] === DIFF_DELETE && starts_with_pair_end(diffs[i2 - 1][1]) && diffs[i2][0] === DIFF_INSERT && starts_with_pair_end(diffs[i2][1])) {
                  compact = true;
                  diffs[i2 - 1][1] = diffs[i2 - 2][1].slice(-1) + diffs[i2 - 1][1];
                  diffs[i2][1] = diffs[i2 - 2][1].slice(-1) + diffs[i2][1];
                  diffs[i2 - 2][1] = diffs[i2 - 2][1].slice(0, -1);
                }
              }
              if (!compact) {
                return diffs;
              }
              var fixed_diffs = [];
              for (var i2 = 0; i2 < diffs.length; i2 += 1) {
                if (diffs[i2][1].length > 0) {
                  fixed_diffs.push(diffs[i2]);
                }
              }
              return fixed_diffs;
            }
            function merge_tuples(diffs, start, length2) {
              for (var i2 = start + length2 - 1; i2 >= 0 && i2 >= start - 1; i2--) {
                if (i2 + 1 < diffs.length) {
                  var left_d = diffs[i2];
                  var right_d = diffs[i2 + 1];
                  if (left_d[0] === right_d[1]) {
                    diffs.splice(i2, 2, [left_d[0], left_d[1] + right_d[1]]);
                  }
                }
              }
              return diffs;
            }
          },
          /* 52 */
          /***/
          function(module2, exports2) {
            exports2 = module2.exports = typeof Object.keys === "function" ? Object.keys : shim;
            exports2.shim = shim;
            function shim(obj) {
              var keys = [];
              for (var key in obj)
                keys.push(key);
              return keys;
            }
          },
          /* 53 */
          /***/
          function(module2, exports2) {
            var supportsArgumentsClass = function() {
              return Object.prototype.toString.call(arguments);
            }() == "[object Arguments]";
            exports2 = module2.exports = supportsArgumentsClass ? supported : unsupported;
            exports2.supported = supported;
            function supported(object) {
              return Object.prototype.toString.call(object) == "[object Arguments]";
            }
            ;
            exports2.unsupported = unsupported;
            function unsupported(object) {
              return object && typeof object == "object" && typeof object.length == "number" && Object.prototype.hasOwnProperty.call(object, "callee") && !Object.prototype.propertyIsEnumerable.call(object, "callee") || false;
            }
            ;
          },
          /* 54 */
          /***/
          function(module2, exports2) {
            "use strict";
            var has = Object.prototype.hasOwnProperty, prefix = "~";
            function Events() {
            }
            if (Object.create) {
              Events.prototype = /* @__PURE__ */ Object.create(null);
              if (!new Events().__proto__)
                prefix = false;
            }
            function EE(fn, context, once) {
              this.fn = fn;
              this.context = context;
              this.once = once || false;
            }
            function EventEmitter2() {
              this._events = new Events();
              this._eventsCount = 0;
            }
            EventEmitter2.prototype.eventNames = function eventNames() {
              var names2 = [], events, name;
              if (this._eventsCount === 0)
                return names2;
              for (name in events = this._events) {
                if (has.call(events, name))
                  names2.push(prefix ? name.slice(1) : name);
              }
              if (Object.getOwnPropertySymbols) {
                return names2.concat(Object.getOwnPropertySymbols(events));
              }
              return names2;
            };
            EventEmitter2.prototype.listeners = function listeners(event, exists) {
              var evt = prefix ? prefix + event : event, available = this._events[evt];
              if (exists)
                return !!available;
              if (!available)
                return [];
              if (available.fn)
                return [available.fn];
              for (var i2 = 0, l2 = available.length, ee = new Array(l2); i2 < l2; i2++) {
                ee[i2] = available[i2].fn;
              }
              return ee;
            };
            EventEmitter2.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
              var evt = prefix ? prefix + event : event;
              if (!this._events[evt])
                return false;
              var listeners = this._events[evt], len = arguments.length, args, i2;
              if (listeners.fn) {
                if (listeners.once)
                  this.removeListener(event, listeners.fn, void 0, true);
                switch (len) {
                  case 1:
                    return listeners.fn.call(listeners.context), true;
                  case 2:
                    return listeners.fn.call(listeners.context, a1), true;
                  case 3:
                    return listeners.fn.call(listeners.context, a1, a2), true;
                  case 4:
                    return listeners.fn.call(listeners.context, a1, a2, a3), true;
                  case 5:
                    return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
                  case 6:
                    return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
                }
                for (i2 = 1, args = new Array(len - 1); i2 < len; i2++) {
                  args[i2 - 1] = arguments[i2];
                }
                listeners.fn.apply(listeners.context, args);
              } else {
                var length2 = listeners.length, j;
                for (i2 = 0; i2 < length2; i2++) {
                  if (listeners[i2].once)
                    this.removeListener(event, listeners[i2].fn, void 0, true);
                  switch (len) {
                    case 1:
                      listeners[i2].fn.call(listeners[i2].context);
                      break;
                    case 2:
                      listeners[i2].fn.call(listeners[i2].context, a1);
                      break;
                    case 3:
                      listeners[i2].fn.call(listeners[i2].context, a1, a2);
                      break;
                    case 4:
                      listeners[i2].fn.call(listeners[i2].context, a1, a2, a3);
                      break;
                    default:
                      if (!args)
                        for (j = 1, args = new Array(len - 1); j < len; j++) {
                          args[j - 1] = arguments[j];
                        }
                      listeners[i2].fn.apply(listeners[i2].context, args);
                  }
                }
              }
              return true;
            };
            EventEmitter2.prototype.on = function on2(event, fn, context) {
              var listener = new EE(fn, context || this), evt = prefix ? prefix + event : event;
              if (!this._events[evt])
                this._events[evt] = listener, this._eventsCount++;
              else if (!this._events[evt].fn)
                this._events[evt].push(listener);
              else
                this._events[evt] = [this._events[evt], listener];
              return this;
            };
            EventEmitter2.prototype.once = function once(event, fn, context) {
              var listener = new EE(fn, context || this, true), evt = prefix ? prefix + event : event;
              if (!this._events[evt])
                this._events[evt] = listener, this._eventsCount++;
              else if (!this._events[evt].fn)
                this._events[evt].push(listener);
              else
                this._events[evt] = [this._events[evt], listener];
              return this;
            };
            EventEmitter2.prototype.removeListener = function removeListener(event, fn, context, once) {
              var evt = prefix ? prefix + event : event;
              if (!this._events[evt])
                return this;
              if (!fn) {
                if (--this._eventsCount === 0)
                  this._events = new Events();
                else
                  delete this._events[evt];
                return this;
              }
              var listeners = this._events[evt];
              if (listeners.fn) {
                if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
                  if (--this._eventsCount === 0)
                    this._events = new Events();
                  else
                    delete this._events[evt];
                }
              } else {
                for (var i2 = 0, events = [], length2 = listeners.length; i2 < length2; i2++) {
                  if (listeners[i2].fn !== fn || once && !listeners[i2].once || context && listeners[i2].context !== context) {
                    events.push(listeners[i2]);
                  }
                }
                if (events.length)
                  this._events[evt] = events.length === 1 ? events[0] : events;
                else if (--this._eventsCount === 0)
                  this._events = new Events();
                else
                  delete this._events[evt];
              }
              return this;
            };
            EventEmitter2.prototype.removeAllListeners = function removeAllListeners(event) {
              var evt;
              if (event) {
                evt = prefix ? prefix + event : event;
                if (this._events[evt]) {
                  if (--this._eventsCount === 0)
                    this._events = new Events();
                  else
                    delete this._events[evt];
                }
              } else {
                this._events = new Events();
                this._eventsCount = 0;
              }
              return this;
            };
            EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
            EventEmitter2.prototype.addListener = EventEmitter2.prototype.on;
            EventEmitter2.prototype.setMaxListeners = function setMaxListeners() {
              return this;
            };
            EventEmitter2.prefixed = prefix;
            EventEmitter2.EventEmitter = EventEmitter2;
            if ("undefined" !== typeof module2) {
              module2.exports = EventEmitter2;
            }
          },
          /* 55 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.matchText = exports2.matchSpacing = exports2.matchNewline = exports2.matchBlot = exports2.matchAttributor = exports2.default = void 0;
            var _typeof3 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
              return typeof obj;
            } : function(obj) {
              return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
            };
            var _slicedToArray = function() {
              function sliceIterator(arr, i2) {
                var _arr = [];
                var _n = true;
                var _d = false;
                var _e = void 0;
                try {
                  for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                    _arr.push(_s.value);
                    if (i2 && _arr.length === i2)
                      break;
                  }
                } catch (err) {
                  _d = true;
                  _e = err;
                } finally {
                  try {
                    if (!_n && _i["return"])
                      _i["return"]();
                  } finally {
                    if (_d)
                      throw _e;
                  }
                }
                return _arr;
              }
              return function(arr, i2) {
                if (Array.isArray(arr)) {
                  return arr;
                } else if (Symbol.iterator in Object(arr)) {
                  return sliceIterator(arr, i2);
                } else {
                  throw new TypeError("Invalid attempt to destructure non-iterable instance");
                }
              };
            }();
            var _createClass = function() {
              function defineProperties(target, props) {
                for (var i2 = 0; i2 < props.length; i2++) {
                  var descriptor = props[i2];
                  descriptor.enumerable = descriptor.enumerable || false;
                  descriptor.configurable = true;
                  if ("value" in descriptor)
                    descriptor.writable = true;
                  Object.defineProperty(target, descriptor.key, descriptor);
                }
              }
              return function(Constructor, protoProps, staticProps) {
                if (protoProps)
                  defineProperties(Constructor.prototype, protoProps);
                if (staticProps)
                  defineProperties(Constructor, staticProps);
                return Constructor;
              };
            }();
            var _extend2 = __webpack_require__(3);
            var _extend3 = _interopRequireDefault(_extend2);
            var _quillDelta = __webpack_require__(2);
            var _quillDelta2 = _interopRequireDefault(_quillDelta);
            var _parchment = __webpack_require__(0);
            var _parchment2 = _interopRequireDefault(_parchment);
            var _quill = __webpack_require__(5);
            var _quill2 = _interopRequireDefault(_quill);
            var _logger = __webpack_require__(10);
            var _logger2 = _interopRequireDefault(_logger);
            var _module = __webpack_require__(9);
            var _module2 = _interopRequireDefault(_module);
            var _align = __webpack_require__(36);
            var _background = __webpack_require__(37);
            var _code = __webpack_require__(13);
            var _code2 = _interopRequireDefault(_code);
            var _color = __webpack_require__(26);
            var _direction = __webpack_require__(38);
            var _font = __webpack_require__(39);
            var _size = __webpack_require__(40);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { default: obj };
            }
            function _defineProperty2(obj, key, value) {
              if (key in obj) {
                Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
              } else {
                obj[key] = value;
              }
              return obj;
            }
            function _classCallCheck2(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function _possibleConstructorReturn(self2, call) {
              if (!self2) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return call && (typeof call === "object" || typeof call === "function") ? call : self2;
            }
            function _inherits(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
              }
              subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
              if (superClass)
                Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
            }
            var debug = (0, _logger2.default)("quill:clipboard");
            var DOM_KEY = "__ql-matcher";
            var CLIPBOARD_CONFIG = [[Node.TEXT_NODE, matchText], [Node.TEXT_NODE, matchNewline], ["br", matchBreak], [Node.ELEMENT_NODE, matchNewline], [Node.ELEMENT_NODE, matchBlot], [Node.ELEMENT_NODE, matchSpacing], [Node.ELEMENT_NODE, matchAttributor], [Node.ELEMENT_NODE, matchStyles], ["li", matchIndent], ["b", matchAlias.bind(matchAlias, "bold")], ["i", matchAlias.bind(matchAlias, "italic")], ["style", matchIgnore]];
            var ATTRIBUTE_ATTRIBUTORS = [_align.AlignAttribute, _direction.DirectionAttribute].reduce(function(memo, attr2) {
              memo[attr2.keyName] = attr2;
              return memo;
            }, {});
            var STYLE_ATTRIBUTORS = [_align.AlignStyle, _background.BackgroundStyle, _color.ColorStyle, _direction.DirectionStyle, _font.FontStyle, _size.SizeStyle].reduce(function(memo, attr2) {
              memo[attr2.keyName] = attr2;
              return memo;
            }, {});
            var Clipboard = function(_Module) {
              _inherits(Clipboard2, _Module);
              function Clipboard2(quill, options) {
                _classCallCheck2(this, Clipboard2);
                var _this = _possibleConstructorReturn(this, (Clipboard2.__proto__ || Object.getPrototypeOf(Clipboard2)).call(this, quill, options));
                _this.quill.root.addEventListener("paste", _this.onPaste.bind(_this));
                _this.container = _this.quill.addContainer("ql-clipboard");
                _this.container.setAttribute("contenteditable", true);
                _this.container.setAttribute("tabindex", -1);
                _this.matchers = [];
                CLIPBOARD_CONFIG.concat(_this.options.matchers).forEach(function(_ref) {
                  var _ref2 = _slicedToArray(_ref, 2), selector = _ref2[0], matcher = _ref2[1];
                  if (!options.matchVisual && matcher === matchSpacing)
                    return;
                  _this.addMatcher(selector, matcher);
                });
                return _this;
              }
              _createClass(Clipboard2, [{
                key: "addMatcher",
                value: function addMatcher(selector, matcher) {
                  this.matchers.push([selector, matcher]);
                }
              }, {
                key: "convert",
                value: function convert(html2) {
                  if (typeof html2 === "string") {
                    this.container.innerHTML = html2.replace(/\>\r?\n +\</g, "><");
                    return this.convert();
                  }
                  var formats = this.quill.getFormat(this.quill.selection.savedRange.index);
                  if (formats[_code2.default.blotName]) {
                    var text4 = this.container.innerText;
                    this.container.innerHTML = "";
                    return new _quillDelta2.default().insert(text4, _defineProperty2({}, _code2.default.blotName, formats[_code2.default.blotName]));
                  }
                  var _prepareMatching = this.prepareMatching(), _prepareMatching2 = _slicedToArray(_prepareMatching, 2), elementMatchers = _prepareMatching2[0], textMatchers = _prepareMatching2[1];
                  var delta = traverse(this.container, elementMatchers, textMatchers);
                  if (deltaEndsWith(delta, "\n") && delta.ops[delta.ops.length - 1].attributes == null) {
                    delta = delta.compose(new _quillDelta2.default().retain(delta.length() - 1).delete(1));
                  }
                  debug.log("convert", this.container.innerHTML, delta);
                  this.container.innerHTML = "";
                  return delta;
                }
              }, {
                key: "dangerouslyPasteHTML",
                value: function dangerouslyPasteHTML(index3, html2) {
                  var source = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : _quill2.default.sources.API;
                  if (typeof index3 === "string") {
                    this.quill.setContents(this.convert(index3), html2);
                    this.quill.setSelection(0, _quill2.default.sources.SILENT);
                  } else {
                    var paste = this.convert(html2);
                    this.quill.updateContents(new _quillDelta2.default().retain(index3).concat(paste), source);
                    this.quill.setSelection(index3 + paste.length(), _quill2.default.sources.SILENT);
                  }
                }
              }, {
                key: "onPaste",
                value: function onPaste(e2) {
                  var _this2 = this;
                  if (e2.defaultPrevented || !this.quill.isEnabled())
                    return;
                  var range = this.quill.getSelection();
                  var delta = new _quillDelta2.default().retain(range.index);
                  var scrollTop = this.quill.scrollingContainer.scrollTop;
                  this.container.focus();
                  this.quill.selection.update(_quill2.default.sources.SILENT);
                  setTimeout(function() {
                    delta = delta.concat(_this2.convert()).delete(range.length);
                    _this2.quill.updateContents(delta, _quill2.default.sources.USER);
                    _this2.quill.setSelection(delta.length() - range.length, _quill2.default.sources.SILENT);
                    _this2.quill.scrollingContainer.scrollTop = scrollTop;
                    _this2.quill.focus();
                  }, 1);
                }
              }, {
                key: "prepareMatching",
                value: function prepareMatching() {
                  var _this3 = this;
                  var elementMatchers = [], textMatchers = [];
                  this.matchers.forEach(function(pair) {
                    var _pair = _slicedToArray(pair, 2), selector = _pair[0], matcher = _pair[1];
                    switch (selector) {
                      case Node.TEXT_NODE:
                        textMatchers.push(matcher);
                        break;
                      case Node.ELEMENT_NODE:
                        elementMatchers.push(matcher);
                        break;
                      default:
                        [].forEach.call(_this3.container.querySelectorAll(selector), function(node3) {
                          node3[DOM_KEY] = node3[DOM_KEY] || [];
                          node3[DOM_KEY].push(matcher);
                        });
                        break;
                    }
                  });
                  return [elementMatchers, textMatchers];
                }
              }]);
              return Clipboard2;
            }(_module2.default);
            Clipboard.DEFAULTS = {
              matchers: [],
              matchVisual: true
            };
            function applyFormat(delta, format, value) {
              if ((typeof format === "undefined" ? "undefined" : _typeof3(format)) === "object") {
                return Object.keys(format).reduce(function(delta2, key) {
                  return applyFormat(delta2, key, format[key]);
                }, delta);
              } else {
                return delta.reduce(function(delta2, op2) {
                  if (op2.attributes && op2.attributes[format]) {
                    return delta2.push(op2);
                  } else {
                    return delta2.insert(op2.insert, (0, _extend3.default)({}, _defineProperty2({}, format, value), op2.attributes));
                  }
                }, new _quillDelta2.default());
              }
            }
            function computeStyle(node3) {
              if (node3.nodeType !== Node.ELEMENT_NODE)
                return {};
              var DOM_KEY2 = "__ql-computed-style";
              return node3[DOM_KEY2] || (node3[DOM_KEY2] = window.getComputedStyle(node3));
            }
            function deltaEndsWith(delta, text4) {
              var endText = "";
              for (var i2 = delta.ops.length - 1; i2 >= 0 && endText.length < text4.length; --i2) {
                var op2 = delta.ops[i2];
                if (typeof op2.insert !== "string")
                  break;
                endText = op2.insert + endText;
              }
              return endText.slice(-1 * text4.length) === text4;
            }
            function isLine(node3) {
              if (node3.childNodes.length === 0)
                return false;
              var style = computeStyle(node3);
              return ["block", "list-item"].indexOf(style.display) > -1;
            }
            function traverse(node3, elementMatchers, textMatchers) {
              if (node3.nodeType === node3.TEXT_NODE) {
                return textMatchers.reduce(function(delta, matcher) {
                  return matcher(node3, delta);
                }, new _quillDelta2.default());
              } else if (node3.nodeType === node3.ELEMENT_NODE) {
                return [].reduce.call(node3.childNodes || [], function(delta, childNode) {
                  var childrenDelta = traverse(childNode, elementMatchers, textMatchers);
                  if (childNode.nodeType === node3.ELEMENT_NODE) {
                    childrenDelta = elementMatchers.reduce(function(childrenDelta2, matcher) {
                      return matcher(childNode, childrenDelta2);
                    }, childrenDelta);
                    childrenDelta = (childNode[DOM_KEY] || []).reduce(function(childrenDelta2, matcher) {
                      return matcher(childNode, childrenDelta2);
                    }, childrenDelta);
                  }
                  return delta.concat(childrenDelta);
                }, new _quillDelta2.default());
              } else {
                return new _quillDelta2.default();
              }
            }
            function matchAlias(format, node3, delta) {
              return applyFormat(delta, format, true);
            }
            function matchAttributor(node3, delta) {
              var attributes = _parchment2.default.Attributor.Attribute.keys(node3);
              var classes2 = _parchment2.default.Attributor.Class.keys(node3);
              var styles2 = _parchment2.default.Attributor.Style.keys(node3);
              var formats = {};
              attributes.concat(classes2).concat(styles2).forEach(function(name) {
                var attr2 = _parchment2.default.query(name, _parchment2.default.Scope.ATTRIBUTE);
                if (attr2 != null) {
                  formats[attr2.attrName] = attr2.value(node3);
                  if (formats[attr2.attrName])
                    return;
                }
                attr2 = ATTRIBUTE_ATTRIBUTORS[name];
                if (attr2 != null && (attr2.attrName === name || attr2.keyName === name)) {
                  formats[attr2.attrName] = attr2.value(node3) || void 0;
                }
                attr2 = STYLE_ATTRIBUTORS[name];
                if (attr2 != null && (attr2.attrName === name || attr2.keyName === name)) {
                  attr2 = STYLE_ATTRIBUTORS[name];
                  formats[attr2.attrName] = attr2.value(node3) || void 0;
                }
              });
              if (Object.keys(formats).length > 0) {
                delta = applyFormat(delta, formats);
              }
              return delta;
            }
            function matchBlot(node3, delta) {
              var match = _parchment2.default.query(node3);
              if (match == null)
                return delta;
              if (match.prototype instanceof _parchment2.default.Embed) {
                var embed = {};
                var value = match.value(node3);
                if (value != null) {
                  embed[match.blotName] = value;
                  delta = new _quillDelta2.default().insert(embed, match.formats(node3));
                }
              } else if (typeof match.formats === "function") {
                delta = applyFormat(delta, match.blotName, match.formats(node3));
              }
              return delta;
            }
            function matchBreak(node3, delta) {
              if (!deltaEndsWith(delta, "\n")) {
                delta.insert("\n");
              }
              return delta;
            }
            function matchIgnore() {
              return new _quillDelta2.default();
            }
            function matchIndent(node3, delta) {
              var match = _parchment2.default.query(node3);
              if (match == null || match.blotName !== "list-item" || !deltaEndsWith(delta, "\n")) {
                return delta;
              }
              var indent = -1, parent = node3.parentNode;
              while (!parent.classList.contains("ql-clipboard")) {
                if ((_parchment2.default.query(parent) || {}).blotName === "list") {
                  indent += 1;
                }
                parent = parent.parentNode;
              }
              if (indent <= 0)
                return delta;
              return delta.compose(new _quillDelta2.default().retain(delta.length() - 1).retain(1, { indent }));
            }
            function matchNewline(node3, delta) {
              if (!deltaEndsWith(delta, "\n")) {
                if (isLine(node3) || delta.length() > 0 && node3.nextSibling && isLine(node3.nextSibling)) {
                  delta.insert("\n");
                }
              }
              return delta;
            }
            function matchSpacing(node3, delta) {
              if (isLine(node3) && node3.nextElementSibling != null && !deltaEndsWith(delta, "\n\n")) {
                var nodeHeight = node3.offsetHeight + parseFloat(computeStyle(node3).marginTop) + parseFloat(computeStyle(node3).marginBottom);
                if (node3.nextElementSibling.offsetTop > node3.offsetTop + nodeHeight * 1.5) {
                  delta.insert("\n");
                }
              }
              return delta;
            }
            function matchStyles(node3, delta) {
              var formats = {};
              var style = node3.style || {};
              if (style.fontStyle && computeStyle(node3).fontStyle === "italic") {
                formats.italic = true;
              }
              if (style.fontWeight && (computeStyle(node3).fontWeight.startsWith("bold") || parseInt(computeStyle(node3).fontWeight) >= 700)) {
                formats.bold = true;
              }
              if (Object.keys(formats).length > 0) {
                delta = applyFormat(delta, formats);
              }
              if (parseFloat(style.textIndent || 0) > 0) {
                delta = new _quillDelta2.default().insert("	").concat(delta);
              }
              return delta;
            }
            function matchText(node3, delta) {
              var text4 = node3.data;
              if (node3.parentNode.tagName === "O:P") {
                return delta.insert(text4.trim());
              }
              if (text4.trim().length === 0 && node3.parentNode.classList.contains("ql-clipboard")) {
                return delta;
              }
              if (!computeStyle(node3.parentNode).whiteSpace.startsWith("pre")) {
                var replacer = function replacer2(collapse, match) {
                  match = match.replace(/[^\u00a0]/g, "");
                  return match.length < 1 && collapse ? " " : match;
                };
                text4 = text4.replace(/\r\n/g, " ").replace(/\n/g, " ");
                text4 = text4.replace(/\s\s+/g, replacer.bind(replacer, true));
                if (node3.previousSibling == null && isLine(node3.parentNode) || node3.previousSibling != null && isLine(node3.previousSibling)) {
                  text4 = text4.replace(/^\s+/, replacer.bind(replacer, false));
                }
                if (node3.nextSibling == null && isLine(node3.parentNode) || node3.nextSibling != null && isLine(node3.nextSibling)) {
                  text4 = text4.replace(/\s+$/, replacer.bind(replacer, false));
                }
              }
              return delta.insert(text4);
            }
            exports2.default = Clipboard;
            exports2.matchAttributor = matchAttributor;
            exports2.matchBlot = matchBlot;
            exports2.matchNewline = matchNewline;
            exports2.matchSpacing = matchSpacing;
            exports2.matchText = matchText;
          },
          /* 56 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _createClass = function() {
              function defineProperties(target, props) {
                for (var i2 = 0; i2 < props.length; i2++) {
                  var descriptor = props[i2];
                  descriptor.enumerable = descriptor.enumerable || false;
                  descriptor.configurable = true;
                  if ("value" in descriptor)
                    descriptor.writable = true;
                  Object.defineProperty(target, descriptor.key, descriptor);
                }
              }
              return function(Constructor, protoProps, staticProps) {
                if (protoProps)
                  defineProperties(Constructor.prototype, protoProps);
                if (staticProps)
                  defineProperties(Constructor, staticProps);
                return Constructor;
              };
            }();
            var _get = function get(object, property, receiver) {
              if (object === null)
                object = Function.prototype;
              var desc = Object.getOwnPropertyDescriptor(object, property);
              if (desc === void 0) {
                var parent = Object.getPrototypeOf(object);
                if (parent === null) {
                  return void 0;
                } else {
                  return get(parent, property, receiver);
                }
              } else if ("value" in desc) {
                return desc.value;
              } else {
                var getter = desc.get;
                if (getter === void 0) {
                  return void 0;
                }
                return getter.call(receiver);
              }
            };
            var _inline = __webpack_require__(6);
            var _inline2 = _interopRequireDefault(_inline);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { default: obj };
            }
            function _classCallCheck2(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function _possibleConstructorReturn(self2, call) {
              if (!self2) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return call && (typeof call === "object" || typeof call === "function") ? call : self2;
            }
            function _inherits(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
              }
              subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
              if (superClass)
                Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
            }
            var Bold = function(_Inline) {
              _inherits(Bold2, _Inline);
              function Bold2() {
                _classCallCheck2(this, Bold2);
                return _possibleConstructorReturn(this, (Bold2.__proto__ || Object.getPrototypeOf(Bold2)).apply(this, arguments));
              }
              _createClass(Bold2, [{
                key: "optimize",
                value: function optimize(context) {
                  _get(Bold2.prototype.__proto__ || Object.getPrototypeOf(Bold2.prototype), "optimize", this).call(this, context);
                  if (this.domNode.tagName !== this.statics.tagName[0]) {
                    this.replaceWith(this.statics.blotName);
                  }
                }
              }], [{
                key: "create",
                value: function create2() {
                  return _get(Bold2.__proto__ || Object.getPrototypeOf(Bold2), "create", this).call(this);
                }
              }, {
                key: "formats",
                value: function formats() {
                  return true;
                }
              }]);
              return Bold2;
            }(_inline2.default);
            Bold.blotName = "bold";
            Bold.tagName = ["STRONG", "B"];
            exports2.default = Bold;
          },
          /* 57 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.addControls = exports2.default = void 0;
            var _slicedToArray = function() {
              function sliceIterator(arr, i2) {
                var _arr = [];
                var _n = true;
                var _d = false;
                var _e = void 0;
                try {
                  for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                    _arr.push(_s.value);
                    if (i2 && _arr.length === i2)
                      break;
                  }
                } catch (err) {
                  _d = true;
                  _e = err;
                } finally {
                  try {
                    if (!_n && _i["return"])
                      _i["return"]();
                  } finally {
                    if (_d)
                      throw _e;
                  }
                }
                return _arr;
              }
              return function(arr, i2) {
                if (Array.isArray(arr)) {
                  return arr;
                } else if (Symbol.iterator in Object(arr)) {
                  return sliceIterator(arr, i2);
                } else {
                  throw new TypeError("Invalid attempt to destructure non-iterable instance");
                }
              };
            }();
            var _createClass = function() {
              function defineProperties(target, props) {
                for (var i2 = 0; i2 < props.length; i2++) {
                  var descriptor = props[i2];
                  descriptor.enumerable = descriptor.enumerable || false;
                  descriptor.configurable = true;
                  if ("value" in descriptor)
                    descriptor.writable = true;
                  Object.defineProperty(target, descriptor.key, descriptor);
                }
              }
              return function(Constructor, protoProps, staticProps) {
                if (protoProps)
                  defineProperties(Constructor.prototype, protoProps);
                if (staticProps)
                  defineProperties(Constructor, staticProps);
                return Constructor;
              };
            }();
            var _quillDelta = __webpack_require__(2);
            var _quillDelta2 = _interopRequireDefault(_quillDelta);
            var _parchment = __webpack_require__(0);
            var _parchment2 = _interopRequireDefault(_parchment);
            var _quill = __webpack_require__(5);
            var _quill2 = _interopRequireDefault(_quill);
            var _logger = __webpack_require__(10);
            var _logger2 = _interopRequireDefault(_logger);
            var _module = __webpack_require__(9);
            var _module2 = _interopRequireDefault(_module);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { default: obj };
            }
            function _defineProperty2(obj, key, value) {
              if (key in obj) {
                Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
              } else {
                obj[key] = value;
              }
              return obj;
            }
            function _classCallCheck2(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function _possibleConstructorReturn(self2, call) {
              if (!self2) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return call && (typeof call === "object" || typeof call === "function") ? call : self2;
            }
            function _inherits(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
              }
              subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
              if (superClass)
                Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
            }
            var debug = (0, _logger2.default)("quill:toolbar");
            var Toolbar = function(_Module) {
              _inherits(Toolbar2, _Module);
              function Toolbar2(quill, options) {
                _classCallCheck2(this, Toolbar2);
                var _this = _possibleConstructorReturn(this, (Toolbar2.__proto__ || Object.getPrototypeOf(Toolbar2)).call(this, quill, options));
                if (Array.isArray(_this.options.container)) {
                  var container = document.createElement("div");
                  addControls(container, _this.options.container);
                  quill.container.parentNode.insertBefore(container, quill.container);
                  _this.container = container;
                } else if (typeof _this.options.container === "string") {
                  _this.container = document.querySelector(_this.options.container);
                } else {
                  _this.container = _this.options.container;
                }
                if (!(_this.container instanceof HTMLElement)) {
                  var _ret;
                  return _ret = debug.error("Container required for toolbar", _this.options), _possibleConstructorReturn(_this, _ret);
                }
                _this.container.classList.add("ql-toolbar");
                _this.controls = [];
                _this.handlers = {};
                Object.keys(_this.options.handlers).forEach(function(format) {
                  _this.addHandler(format, _this.options.handlers[format]);
                });
                [].forEach.call(_this.container.querySelectorAll("button, select"), function(input) {
                  _this.attach(input);
                });
                _this.quill.on(_quill2.default.events.EDITOR_CHANGE, function(type, range) {
                  if (type === _quill2.default.events.SELECTION_CHANGE) {
                    _this.update(range);
                  }
                });
                _this.quill.on(_quill2.default.events.SCROLL_OPTIMIZE, function() {
                  var _this$quill$selection = _this.quill.selection.getRange(), _this$quill$selection2 = _slicedToArray(_this$quill$selection, 1), range = _this$quill$selection2[0];
                  _this.update(range);
                });
                return _this;
              }
              _createClass(Toolbar2, [{
                key: "addHandler",
                value: function addHandler(format, handler) {
                  this.handlers[format] = handler;
                }
              }, {
                key: "attach",
                value: function attach(input) {
                  var _this2 = this;
                  var format = [].find.call(input.classList, function(className) {
                    return className.indexOf("ql-") === 0;
                  });
                  if (!format)
                    return;
                  format = format.slice("ql-".length);
                  if (input.tagName === "BUTTON") {
                    input.setAttribute("type", "button");
                  }
                  if (this.handlers[format] == null) {
                    if (this.quill.scroll.whitelist != null && this.quill.scroll.whitelist[format] == null) {
                      debug.warn("ignoring attaching to disabled format", format, input);
                      return;
                    }
                    if (_parchment2.default.query(format) == null) {
                      debug.warn("ignoring attaching to nonexistent format", format, input);
                      return;
                    }
                  }
                  var eventName = input.tagName === "SELECT" ? "change" : "click";
                  input.addEventListener(eventName, function(e2) {
                    var value = void 0;
                    if (input.tagName === "SELECT") {
                      if (input.selectedIndex < 0)
                        return;
                      var selected = input.options[input.selectedIndex];
                      if (selected.hasAttribute("selected")) {
                        value = false;
                      } else {
                        value = selected.value || false;
                      }
                    } else {
                      if (input.classList.contains("ql-active")) {
                        value = false;
                      } else {
                        value = input.value || !input.hasAttribute("value");
                      }
                      e2.preventDefault();
                    }
                    _this2.quill.focus();
                    var _quill$selection$getR = _this2.quill.selection.getRange(), _quill$selection$getR2 = _slicedToArray(_quill$selection$getR, 1), range = _quill$selection$getR2[0];
                    if (_this2.handlers[format] != null) {
                      _this2.handlers[format].call(_this2, value);
                    } else if (_parchment2.default.query(format).prototype instanceof _parchment2.default.Embed) {
                      value = prompt("Enter " + format);
                      if (!value)
                        return;
                      _this2.quill.updateContents(new _quillDelta2.default().retain(range.index).delete(range.length).insert(_defineProperty2({}, format, value)), _quill2.default.sources.USER);
                    } else {
                      _this2.quill.format(format, value, _quill2.default.sources.USER);
                    }
                    _this2.update(range);
                  });
                  this.controls.push([format, input]);
                }
              }, {
                key: "update",
                value: function update(range) {
                  var formats = range == null ? {} : this.quill.getFormat(range);
                  this.controls.forEach(function(pair) {
                    var _pair = _slicedToArray(pair, 2), format = _pair[0], input = _pair[1];
                    if (input.tagName === "SELECT") {
                      var option = void 0;
                      if (range == null) {
                        option = null;
                      } else if (formats[format] == null) {
                        option = input.querySelector("option[selected]");
                      } else if (!Array.isArray(formats[format])) {
                        var value = formats[format];
                        if (typeof value === "string") {
                          value = value.replace(/\"/g, '\\"');
                        }
                        option = input.querySelector('option[value="' + value + '"]');
                      }
                      if (option == null) {
                        input.value = "";
                        input.selectedIndex = -1;
                      } else {
                        option.selected = true;
                      }
                    } else {
                      if (range == null) {
                        input.classList.remove("ql-active");
                      } else if (input.hasAttribute("value")) {
                        var isActive = formats[format] === input.getAttribute("value") || formats[format] != null && formats[format].toString() === input.getAttribute("value") || formats[format] == null && !input.getAttribute("value");
                        input.classList.toggle("ql-active", isActive);
                      } else {
                        input.classList.toggle("ql-active", formats[format] != null);
                      }
                    }
                  });
                }
              }]);
              return Toolbar2;
            }(_module2.default);
            Toolbar.DEFAULTS = {};
            function addButton(container, format, value) {
              var input = document.createElement("button");
              input.setAttribute("type", "button");
              input.classList.add("ql-" + format);
              if (value != null) {
                input.value = value;
              }
              container.appendChild(input);
            }
            function addControls(container, groups) {
              if (!Array.isArray(groups[0])) {
                groups = [groups];
              }
              groups.forEach(function(controls) {
                var group = document.createElement("span");
                group.classList.add("ql-formats");
                controls.forEach(function(control) {
                  if (typeof control === "string") {
                    addButton(group, control);
                  } else {
                    var format = Object.keys(control)[0];
                    var value = control[format];
                    if (Array.isArray(value)) {
                      addSelect(group, format, value);
                    } else {
                      addButton(group, format, value);
                    }
                  }
                });
                container.appendChild(group);
              });
            }
            function addSelect(container, format, values) {
              var input = document.createElement("select");
              input.classList.add("ql-" + format);
              values.forEach(function(value) {
                var option = document.createElement("option");
                if (value !== false) {
                  option.setAttribute("value", value);
                } else {
                  option.setAttribute("selected", "selected");
                }
                input.appendChild(option);
              });
              container.appendChild(input);
            }
            Toolbar.DEFAULTS = {
              container: null,
              handlers: {
                clean: function clean() {
                  var _this3 = this;
                  var range = this.quill.getSelection();
                  if (range == null)
                    return;
                  if (range.length == 0) {
                    var formats = this.quill.getFormat();
                    Object.keys(formats).forEach(function(name) {
                      if (_parchment2.default.query(name, _parchment2.default.Scope.INLINE) != null) {
                        _this3.quill.format(name, false);
                      }
                    });
                  } else {
                    this.quill.removeFormat(range, _quill2.default.sources.USER);
                  }
                },
                direction: function direction(value) {
                  var align = this.quill.getFormat()["align"];
                  if (value === "rtl" && align == null) {
                    this.quill.format("align", "right", _quill2.default.sources.USER);
                  } else if (!value && align === "right") {
                    this.quill.format("align", false, _quill2.default.sources.USER);
                  }
                  this.quill.format("direction", value, _quill2.default.sources.USER);
                },
                indent: function indent(value) {
                  var range = this.quill.getSelection();
                  var formats = this.quill.getFormat(range);
                  var indent2 = parseInt(formats.indent || 0);
                  if (value === "+1" || value === "-1") {
                    var modifier = value === "+1" ? 1 : -1;
                    if (formats.direction === "rtl")
                      modifier *= -1;
                    this.quill.format("indent", indent2 + modifier, _quill2.default.sources.USER);
                  }
                },
                link: function link(value) {
                  if (value === true) {
                    value = prompt("Enter link URL:");
                  }
                  this.quill.format("link", value, _quill2.default.sources.USER);
                },
                list: function list2(value) {
                  var range = this.quill.getSelection();
                  var formats = this.quill.getFormat(range);
                  if (value === "check") {
                    if (formats["list"] === "checked" || formats["list"] === "unchecked") {
                      this.quill.format("list", false, _quill2.default.sources.USER);
                    } else {
                      this.quill.format("list", "unchecked", _quill2.default.sources.USER);
                    }
                  } else {
                    this.quill.format("list", value, _quill2.default.sources.USER);
                  }
                }
              }
            };
            exports2.default = Toolbar;
            exports2.addControls = addControls;
          },
          /* 58 */
          /***/
          function(module2, exports2) {
            module2.exports = '<svg viewbox="0 0 18 18"> <polyline class="ql-even ql-stroke" points="5 7 3 9 5 11"></polyline> <polyline class="ql-even ql-stroke" points="13 7 15 9 13 11"></polyline> <line class=ql-stroke x1=10 x2=8 y1=5 y2=13></line> </svg>';
          },
          /* 59 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _createClass = function() {
              function defineProperties(target, props) {
                for (var i2 = 0; i2 < props.length; i2++) {
                  var descriptor = props[i2];
                  descriptor.enumerable = descriptor.enumerable || false;
                  descriptor.configurable = true;
                  if ("value" in descriptor)
                    descriptor.writable = true;
                  Object.defineProperty(target, descriptor.key, descriptor);
                }
              }
              return function(Constructor, protoProps, staticProps) {
                if (protoProps)
                  defineProperties(Constructor.prototype, protoProps);
                if (staticProps)
                  defineProperties(Constructor, staticProps);
                return Constructor;
              };
            }();
            var _get = function get(object, property, receiver) {
              if (object === null)
                object = Function.prototype;
              var desc = Object.getOwnPropertyDescriptor(object, property);
              if (desc === void 0) {
                var parent = Object.getPrototypeOf(object);
                if (parent === null) {
                  return void 0;
                } else {
                  return get(parent, property, receiver);
                }
              } else if ("value" in desc) {
                return desc.value;
              } else {
                var getter = desc.get;
                if (getter === void 0) {
                  return void 0;
                }
                return getter.call(receiver);
              }
            };
            var _picker = __webpack_require__(28);
            var _picker2 = _interopRequireDefault(_picker);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { default: obj };
            }
            function _classCallCheck2(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function _possibleConstructorReturn(self2, call) {
              if (!self2) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return call && (typeof call === "object" || typeof call === "function") ? call : self2;
            }
            function _inherits(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
              }
              subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
              if (superClass)
                Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
            }
            var ColorPicker = function(_Picker) {
              _inherits(ColorPicker2, _Picker);
              function ColorPicker2(select, label) {
                _classCallCheck2(this, ColorPicker2);
                var _this = _possibleConstructorReturn(this, (ColorPicker2.__proto__ || Object.getPrototypeOf(ColorPicker2)).call(this, select));
                _this.label.innerHTML = label;
                _this.container.classList.add("ql-color-picker");
                [].slice.call(_this.container.querySelectorAll(".ql-picker-item"), 0, 7).forEach(function(item) {
                  item.classList.add("ql-primary");
                });
                return _this;
              }
              _createClass(ColorPicker2, [{
                key: "buildItem",
                value: function buildItem(option) {
                  var item = _get(ColorPicker2.prototype.__proto__ || Object.getPrototypeOf(ColorPicker2.prototype), "buildItem", this).call(this, option);
                  item.style.backgroundColor = option.getAttribute("value") || "";
                  return item;
                }
              }, {
                key: "selectItem",
                value: function selectItem(item, trigger) {
                  _get(ColorPicker2.prototype.__proto__ || Object.getPrototypeOf(ColorPicker2.prototype), "selectItem", this).call(this, item, trigger);
                  var colorLabel = this.label.querySelector(".ql-color-label");
                  var value = item ? item.getAttribute("data-value") || "" : "";
                  if (colorLabel) {
                    if (colorLabel.tagName === "line") {
                      colorLabel.style.stroke = value;
                    } else {
                      colorLabel.style.fill = value;
                    }
                  }
                }
              }]);
              return ColorPicker2;
            }(_picker2.default);
            exports2.default = ColorPicker;
          },
          /* 60 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _createClass = function() {
              function defineProperties(target, props) {
                for (var i2 = 0; i2 < props.length; i2++) {
                  var descriptor = props[i2];
                  descriptor.enumerable = descriptor.enumerable || false;
                  descriptor.configurable = true;
                  if ("value" in descriptor)
                    descriptor.writable = true;
                  Object.defineProperty(target, descriptor.key, descriptor);
                }
              }
              return function(Constructor, protoProps, staticProps) {
                if (protoProps)
                  defineProperties(Constructor.prototype, protoProps);
                if (staticProps)
                  defineProperties(Constructor, staticProps);
                return Constructor;
              };
            }();
            var _get = function get(object, property, receiver) {
              if (object === null)
                object = Function.prototype;
              var desc = Object.getOwnPropertyDescriptor(object, property);
              if (desc === void 0) {
                var parent = Object.getPrototypeOf(object);
                if (parent === null) {
                  return void 0;
                } else {
                  return get(parent, property, receiver);
                }
              } else if ("value" in desc) {
                return desc.value;
              } else {
                var getter = desc.get;
                if (getter === void 0) {
                  return void 0;
                }
                return getter.call(receiver);
              }
            };
            var _picker = __webpack_require__(28);
            var _picker2 = _interopRequireDefault(_picker);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { default: obj };
            }
            function _classCallCheck2(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function _possibleConstructorReturn(self2, call) {
              if (!self2) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return call && (typeof call === "object" || typeof call === "function") ? call : self2;
            }
            function _inherits(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
              }
              subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
              if (superClass)
                Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
            }
            var IconPicker = function(_Picker) {
              _inherits(IconPicker2, _Picker);
              function IconPicker2(select, icons) {
                _classCallCheck2(this, IconPicker2);
                var _this = _possibleConstructorReturn(this, (IconPicker2.__proto__ || Object.getPrototypeOf(IconPicker2)).call(this, select));
                _this.container.classList.add("ql-icon-picker");
                [].forEach.call(_this.container.querySelectorAll(".ql-picker-item"), function(item) {
                  item.innerHTML = icons[item.getAttribute("data-value") || ""];
                });
                _this.defaultItem = _this.container.querySelector(".ql-selected");
                _this.selectItem(_this.defaultItem);
                return _this;
              }
              _createClass(IconPicker2, [{
                key: "selectItem",
                value: function selectItem(item, trigger) {
                  _get(IconPicker2.prototype.__proto__ || Object.getPrototypeOf(IconPicker2.prototype), "selectItem", this).call(this, item, trigger);
                  item = item || this.defaultItem;
                  this.label.innerHTML = item.innerHTML;
                }
              }]);
              return IconPicker2;
            }(_picker2.default);
            exports2.default = IconPicker;
          },
          /* 61 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _createClass = function() {
              function defineProperties(target, props) {
                for (var i2 = 0; i2 < props.length; i2++) {
                  var descriptor = props[i2];
                  descriptor.enumerable = descriptor.enumerable || false;
                  descriptor.configurable = true;
                  if ("value" in descriptor)
                    descriptor.writable = true;
                  Object.defineProperty(target, descriptor.key, descriptor);
                }
              }
              return function(Constructor, protoProps, staticProps) {
                if (protoProps)
                  defineProperties(Constructor.prototype, protoProps);
                if (staticProps)
                  defineProperties(Constructor, staticProps);
                return Constructor;
              };
            }();
            function _classCallCheck2(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            var Tooltip = function() {
              function Tooltip2(quill, boundsContainer) {
                var _this = this;
                _classCallCheck2(this, Tooltip2);
                this.quill = quill;
                this.boundsContainer = boundsContainer || document.body;
                this.root = quill.addContainer("ql-tooltip");
                this.root.innerHTML = this.constructor.TEMPLATE;
                if (this.quill.root === this.quill.scrollingContainer) {
                  this.quill.root.addEventListener("scroll", function() {
                    _this.root.style.marginTop = -1 * _this.quill.root.scrollTop + "px";
                  });
                }
                this.hide();
              }
              _createClass(Tooltip2, [{
                key: "hide",
                value: function hide2() {
                  this.root.classList.add("ql-hidden");
                }
              }, {
                key: "position",
                value: function position3(reference2) {
                  var left = reference2.left + reference2.width / 2 - this.root.offsetWidth / 2;
                  var top = reference2.bottom + this.quill.root.scrollTop;
                  this.root.style.left = left + "px";
                  this.root.style.top = top + "px";
                  this.root.classList.remove("ql-flip");
                  var containerBounds = this.boundsContainer.getBoundingClientRect();
                  var rootBounds = this.root.getBoundingClientRect();
                  var shift = 0;
                  if (rootBounds.right > containerBounds.right) {
                    shift = containerBounds.right - rootBounds.right;
                    this.root.style.left = left + shift + "px";
                  }
                  if (rootBounds.left < containerBounds.left) {
                    shift = containerBounds.left - rootBounds.left;
                    this.root.style.left = left + shift + "px";
                  }
                  if (rootBounds.bottom > containerBounds.bottom) {
                    var height2 = rootBounds.bottom - rootBounds.top;
                    var verticalShift = reference2.bottom - reference2.top + height2;
                    this.root.style.top = top - verticalShift + "px";
                    this.root.classList.add("ql-flip");
                  }
                  return shift;
                }
              }, {
                key: "show",
                value: function show2() {
                  this.root.classList.remove("ql-editing");
                  this.root.classList.remove("ql-hidden");
                }
              }]);
              return Tooltip2;
            }();
            exports2.default = Tooltip;
          },
          /* 62 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _slicedToArray = function() {
              function sliceIterator(arr, i2) {
                var _arr = [];
                var _n = true;
                var _d = false;
                var _e = void 0;
                try {
                  for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                    _arr.push(_s.value);
                    if (i2 && _arr.length === i2)
                      break;
                  }
                } catch (err) {
                  _d = true;
                  _e = err;
                } finally {
                  try {
                    if (!_n && _i["return"])
                      _i["return"]();
                  } finally {
                    if (_d)
                      throw _e;
                  }
                }
                return _arr;
              }
              return function(arr, i2) {
                if (Array.isArray(arr)) {
                  return arr;
                } else if (Symbol.iterator in Object(arr)) {
                  return sliceIterator(arr, i2);
                } else {
                  throw new TypeError("Invalid attempt to destructure non-iterable instance");
                }
              };
            }();
            var _get = function get(object, property, receiver) {
              if (object === null)
                object = Function.prototype;
              var desc = Object.getOwnPropertyDescriptor(object, property);
              if (desc === void 0) {
                var parent = Object.getPrototypeOf(object);
                if (parent === null) {
                  return void 0;
                } else {
                  return get(parent, property, receiver);
                }
              } else if ("value" in desc) {
                return desc.value;
              } else {
                var getter = desc.get;
                if (getter === void 0) {
                  return void 0;
                }
                return getter.call(receiver);
              }
            };
            var _createClass = function() {
              function defineProperties(target, props) {
                for (var i2 = 0; i2 < props.length; i2++) {
                  var descriptor = props[i2];
                  descriptor.enumerable = descriptor.enumerable || false;
                  descriptor.configurable = true;
                  if ("value" in descriptor)
                    descriptor.writable = true;
                  Object.defineProperty(target, descriptor.key, descriptor);
                }
              }
              return function(Constructor, protoProps, staticProps) {
                if (protoProps)
                  defineProperties(Constructor.prototype, protoProps);
                if (staticProps)
                  defineProperties(Constructor, staticProps);
                return Constructor;
              };
            }();
            var _extend = __webpack_require__(3);
            var _extend2 = _interopRequireDefault(_extend);
            var _emitter = __webpack_require__(8);
            var _emitter2 = _interopRequireDefault(_emitter);
            var _base = __webpack_require__(43);
            var _base2 = _interopRequireDefault(_base);
            var _link = __webpack_require__(27);
            var _link2 = _interopRequireDefault(_link);
            var _selection = __webpack_require__(15);
            var _icons = __webpack_require__(41);
            var _icons2 = _interopRequireDefault(_icons);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { default: obj };
            }
            function _classCallCheck2(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function _possibleConstructorReturn(self2, call) {
              if (!self2) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return call && (typeof call === "object" || typeof call === "function") ? call : self2;
            }
            function _inherits(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
              }
              subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
              if (superClass)
                Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
            }
            var TOOLBAR_CONFIG = [[{ header: ["1", "2", "3", false] }], ["bold", "italic", "underline", "link"], [{ list: "ordered" }, { list: "bullet" }], ["clean"]];
            var SnowTheme = function(_BaseTheme) {
              _inherits(SnowTheme2, _BaseTheme);
              function SnowTheme2(quill, options) {
                _classCallCheck2(this, SnowTheme2);
                if (options.modules.toolbar != null && options.modules.toolbar.container == null) {
                  options.modules.toolbar.container = TOOLBAR_CONFIG;
                }
                var _this = _possibleConstructorReturn(this, (SnowTheme2.__proto__ || Object.getPrototypeOf(SnowTheme2)).call(this, quill, options));
                _this.quill.container.classList.add("ql-snow");
                return _this;
              }
              _createClass(SnowTheme2, [{
                key: "extendToolbar",
                value: function extendToolbar(toolbar) {
                  toolbar.container.classList.add("ql-snow");
                  this.buildButtons([].slice.call(toolbar.container.querySelectorAll("button")), _icons2.default);
                  this.buildPickers([].slice.call(toolbar.container.querySelectorAll("select")), _icons2.default);
                  this.tooltip = new SnowTooltip(this.quill, this.options.bounds);
                  if (toolbar.container.querySelector(".ql-link")) {
                    this.quill.keyboard.addBinding({ key: "K", shortKey: true }, function(range, context) {
                      toolbar.handlers["link"].call(toolbar, !context.format.link);
                    });
                  }
                }
              }]);
              return SnowTheme2;
            }(_base2.default);
            SnowTheme.DEFAULTS = (0, _extend2.default)(true, {}, _base2.default.DEFAULTS, {
              modules: {
                toolbar: {
                  handlers: {
                    link: function link(value) {
                      if (value) {
                        var range = this.quill.getSelection();
                        if (range == null || range.length == 0)
                          return;
                        var preview = this.quill.getText(range);
                        if (/^\S+@\S+\.\S+$/.test(preview) && preview.indexOf("mailto:") !== 0) {
                          preview = "mailto:" + preview;
                        }
                        var tooltip = this.quill.theme.tooltip;
                        tooltip.edit("link", preview);
                      } else {
                        this.quill.format("link", false);
                      }
                    }
                  }
                }
              }
            });
            var SnowTooltip = function(_BaseTooltip) {
              _inherits(SnowTooltip2, _BaseTooltip);
              function SnowTooltip2(quill, bounds) {
                _classCallCheck2(this, SnowTooltip2);
                var _this2 = _possibleConstructorReturn(this, (SnowTooltip2.__proto__ || Object.getPrototypeOf(SnowTooltip2)).call(this, quill, bounds));
                _this2.preview = _this2.root.querySelector("a.ql-preview");
                return _this2;
              }
              _createClass(SnowTooltip2, [{
                key: "listen",
                value: function listen() {
                  var _this3 = this;
                  _get(SnowTooltip2.prototype.__proto__ || Object.getPrototypeOf(SnowTooltip2.prototype), "listen", this).call(this);
                  this.root.querySelector("a.ql-action").addEventListener("click", function(event) {
                    if (_this3.root.classList.contains("ql-editing")) {
                      _this3.save();
                    } else {
                      _this3.edit("link", _this3.preview.textContent);
                    }
                    event.preventDefault();
                  });
                  this.root.querySelector("a.ql-remove").addEventListener("click", function(event) {
                    if (_this3.linkRange != null) {
                      var range = _this3.linkRange;
                      _this3.restoreFocus();
                      _this3.quill.formatText(range, "link", false, _emitter2.default.sources.USER);
                      delete _this3.linkRange;
                    }
                    event.preventDefault();
                    _this3.hide();
                  });
                  this.quill.on(_emitter2.default.events.SELECTION_CHANGE, function(range, oldRange, source) {
                    if (range == null)
                      return;
                    if (range.length === 0 && source === _emitter2.default.sources.USER) {
                      var _quill$scroll$descend = _this3.quill.scroll.descendant(_link2.default, range.index), _quill$scroll$descend2 = _slicedToArray(_quill$scroll$descend, 2), link = _quill$scroll$descend2[0], offset = _quill$scroll$descend2[1];
                      if (link != null) {
                        _this3.linkRange = new _selection.Range(range.index - offset, link.length());
                        var preview = _link2.default.formats(link.domNode);
                        _this3.preview.textContent = preview;
                        _this3.preview.setAttribute("href", preview);
                        _this3.show();
                        _this3.position(_this3.quill.getBounds(_this3.linkRange));
                        return;
                      }
                    } else {
                      delete _this3.linkRange;
                    }
                    _this3.hide();
                  });
                }
              }, {
                key: "show",
                value: function show2() {
                  _get(SnowTooltip2.prototype.__proto__ || Object.getPrototypeOf(SnowTooltip2.prototype), "show", this).call(this);
                  this.root.removeAttribute("data-mode");
                }
              }]);
              return SnowTooltip2;
            }(_base.BaseTooltip);
            SnowTooltip.TEMPLATE = ['<a class="ql-preview" target="_blank" href="about:blank"></a>', '<input type="text" data-formula="e=mc^2" data-link="https://quilljs.com" data-video="Embed URL">', '<a class="ql-action"></a>', '<a class="ql-remove"></a>'].join("");
            exports2.default = SnowTheme;
          },
          /* 63 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _core = __webpack_require__(29);
            var _core2 = _interopRequireDefault(_core);
            var _align = __webpack_require__(36);
            var _direction = __webpack_require__(38);
            var _indent = __webpack_require__(64);
            var _blockquote = __webpack_require__(65);
            var _blockquote2 = _interopRequireDefault(_blockquote);
            var _header = __webpack_require__(66);
            var _header2 = _interopRequireDefault(_header);
            var _list = __webpack_require__(67);
            var _list2 = _interopRequireDefault(_list);
            var _background = __webpack_require__(37);
            var _color = __webpack_require__(26);
            var _font = __webpack_require__(39);
            var _size = __webpack_require__(40);
            var _bold = __webpack_require__(56);
            var _bold2 = _interopRequireDefault(_bold);
            var _italic = __webpack_require__(68);
            var _italic2 = _interopRequireDefault(_italic);
            var _link = __webpack_require__(27);
            var _link2 = _interopRequireDefault(_link);
            var _script = __webpack_require__(69);
            var _script2 = _interopRequireDefault(_script);
            var _strike = __webpack_require__(70);
            var _strike2 = _interopRequireDefault(_strike);
            var _underline = __webpack_require__(71);
            var _underline2 = _interopRequireDefault(_underline);
            var _image = __webpack_require__(72);
            var _image2 = _interopRequireDefault(_image);
            var _video = __webpack_require__(73);
            var _video2 = _interopRequireDefault(_video);
            var _code = __webpack_require__(13);
            var _code2 = _interopRequireDefault(_code);
            var _formula = __webpack_require__(74);
            var _formula2 = _interopRequireDefault(_formula);
            var _syntax = __webpack_require__(75);
            var _syntax2 = _interopRequireDefault(_syntax);
            var _toolbar = __webpack_require__(57);
            var _toolbar2 = _interopRequireDefault(_toolbar);
            var _icons = __webpack_require__(41);
            var _icons2 = _interopRequireDefault(_icons);
            var _picker = __webpack_require__(28);
            var _picker2 = _interopRequireDefault(_picker);
            var _colorPicker = __webpack_require__(59);
            var _colorPicker2 = _interopRequireDefault(_colorPicker);
            var _iconPicker = __webpack_require__(60);
            var _iconPicker2 = _interopRequireDefault(_iconPicker);
            var _tooltip = __webpack_require__(61);
            var _tooltip2 = _interopRequireDefault(_tooltip);
            var _bubble = __webpack_require__(108);
            var _bubble2 = _interopRequireDefault(_bubble);
            var _snow = __webpack_require__(62);
            var _snow2 = _interopRequireDefault(_snow);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { default: obj };
            }
            _core2.default.register({
              "attributors/attribute/direction": _direction.DirectionAttribute,
              "attributors/class/align": _align.AlignClass,
              "attributors/class/background": _background.BackgroundClass,
              "attributors/class/color": _color.ColorClass,
              "attributors/class/direction": _direction.DirectionClass,
              "attributors/class/font": _font.FontClass,
              "attributors/class/size": _size.SizeClass,
              "attributors/style/align": _align.AlignStyle,
              "attributors/style/background": _background.BackgroundStyle,
              "attributors/style/color": _color.ColorStyle,
              "attributors/style/direction": _direction.DirectionStyle,
              "attributors/style/font": _font.FontStyle,
              "attributors/style/size": _size.SizeStyle
            }, true);
            _core2.default.register({
              "formats/align": _align.AlignClass,
              "formats/direction": _direction.DirectionClass,
              "formats/indent": _indent.IndentClass,
              "formats/background": _background.BackgroundStyle,
              "formats/color": _color.ColorStyle,
              "formats/font": _font.FontClass,
              "formats/size": _size.SizeClass,
              "formats/blockquote": _blockquote2.default,
              "formats/code-block": _code2.default,
              "formats/header": _header2.default,
              "formats/list": _list2.default,
              "formats/bold": _bold2.default,
              "formats/code": _code.Code,
              "formats/italic": _italic2.default,
              "formats/link": _link2.default,
              "formats/script": _script2.default,
              "formats/strike": _strike2.default,
              "formats/underline": _underline2.default,
              "formats/image": _image2.default,
              "formats/video": _video2.default,
              "formats/list/item": _list.ListItem,
              "modules/formula": _formula2.default,
              "modules/syntax": _syntax2.default,
              "modules/toolbar": _toolbar2.default,
              "themes/bubble": _bubble2.default,
              "themes/snow": _snow2.default,
              "ui/icons": _icons2.default,
              "ui/picker": _picker2.default,
              "ui/icon-picker": _iconPicker2.default,
              "ui/color-picker": _colorPicker2.default,
              "ui/tooltip": _tooltip2.default
            }, true);
            exports2.default = _core2.default;
          },
          /* 64 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.IndentClass = void 0;
            var _createClass = function() {
              function defineProperties(target, props) {
                for (var i2 = 0; i2 < props.length; i2++) {
                  var descriptor = props[i2];
                  descriptor.enumerable = descriptor.enumerable || false;
                  descriptor.configurable = true;
                  if ("value" in descriptor)
                    descriptor.writable = true;
                  Object.defineProperty(target, descriptor.key, descriptor);
                }
              }
              return function(Constructor, protoProps, staticProps) {
                if (protoProps)
                  defineProperties(Constructor.prototype, protoProps);
                if (staticProps)
                  defineProperties(Constructor, staticProps);
                return Constructor;
              };
            }();
            var _get = function get(object, property, receiver) {
              if (object === null)
                object = Function.prototype;
              var desc = Object.getOwnPropertyDescriptor(object, property);
              if (desc === void 0) {
                var parent = Object.getPrototypeOf(object);
                if (parent === null) {
                  return void 0;
                } else {
                  return get(parent, property, receiver);
                }
              } else if ("value" in desc) {
                return desc.value;
              } else {
                var getter = desc.get;
                if (getter === void 0) {
                  return void 0;
                }
                return getter.call(receiver);
              }
            };
            var _parchment = __webpack_require__(0);
            var _parchment2 = _interopRequireDefault(_parchment);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { default: obj };
            }
            function _classCallCheck2(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function _possibleConstructorReturn(self2, call) {
              if (!self2) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return call && (typeof call === "object" || typeof call === "function") ? call : self2;
            }
            function _inherits(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
              }
              subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
              if (superClass)
                Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
            }
            var IdentAttributor = function(_Parchment$Attributor) {
              _inherits(IdentAttributor2, _Parchment$Attributor);
              function IdentAttributor2() {
                _classCallCheck2(this, IdentAttributor2);
                return _possibleConstructorReturn(this, (IdentAttributor2.__proto__ || Object.getPrototypeOf(IdentAttributor2)).apply(this, arguments));
              }
              _createClass(IdentAttributor2, [{
                key: "add",
                value: function add(node3, value) {
                  if (value === "+1" || value === "-1") {
                    var indent = this.value(node3) || 0;
                    value = value === "+1" ? indent + 1 : indent - 1;
                  }
                  if (value === 0) {
                    this.remove(node3);
                    return true;
                  } else {
                    return _get(IdentAttributor2.prototype.__proto__ || Object.getPrototypeOf(IdentAttributor2.prototype), "add", this).call(this, node3, value);
                  }
                }
              }, {
                key: "canAdd",
                value: function canAdd(node3, value) {
                  return _get(IdentAttributor2.prototype.__proto__ || Object.getPrototypeOf(IdentAttributor2.prototype), "canAdd", this).call(this, node3, value) || _get(IdentAttributor2.prototype.__proto__ || Object.getPrototypeOf(IdentAttributor2.prototype), "canAdd", this).call(this, node3, parseInt(value));
                }
              }, {
                key: "value",
                value: function value(node3) {
                  return parseInt(_get(IdentAttributor2.prototype.__proto__ || Object.getPrototypeOf(IdentAttributor2.prototype), "value", this).call(this, node3)) || void 0;
                }
              }]);
              return IdentAttributor2;
            }(_parchment2.default.Attributor.Class);
            var IndentClass = new IdentAttributor("indent", "ql-indent", {
              scope: _parchment2.default.Scope.BLOCK,
              whitelist: [1, 2, 3, 4, 5, 6, 7, 8]
            });
            exports2.IndentClass = IndentClass;
          },
          /* 65 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _block = __webpack_require__(4);
            var _block2 = _interopRequireDefault(_block);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { default: obj };
            }
            function _classCallCheck2(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function _possibleConstructorReturn(self2, call) {
              if (!self2) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return call && (typeof call === "object" || typeof call === "function") ? call : self2;
            }
            function _inherits(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
              }
              subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
              if (superClass)
                Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
            }
            var Blockquote = function(_Block) {
              _inherits(Blockquote2, _Block);
              function Blockquote2() {
                _classCallCheck2(this, Blockquote2);
                return _possibleConstructorReturn(this, (Blockquote2.__proto__ || Object.getPrototypeOf(Blockquote2)).apply(this, arguments));
              }
              return Blockquote2;
            }(_block2.default);
            Blockquote.blotName = "blockquote";
            Blockquote.tagName = "blockquote";
            exports2.default = Blockquote;
          },
          /* 66 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _createClass = function() {
              function defineProperties(target, props) {
                for (var i2 = 0; i2 < props.length; i2++) {
                  var descriptor = props[i2];
                  descriptor.enumerable = descriptor.enumerable || false;
                  descriptor.configurable = true;
                  if ("value" in descriptor)
                    descriptor.writable = true;
                  Object.defineProperty(target, descriptor.key, descriptor);
                }
              }
              return function(Constructor, protoProps, staticProps) {
                if (protoProps)
                  defineProperties(Constructor.prototype, protoProps);
                if (staticProps)
                  defineProperties(Constructor, staticProps);
                return Constructor;
              };
            }();
            var _block = __webpack_require__(4);
            var _block2 = _interopRequireDefault(_block);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { default: obj };
            }
            function _classCallCheck2(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function _possibleConstructorReturn(self2, call) {
              if (!self2) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return call && (typeof call === "object" || typeof call === "function") ? call : self2;
            }
            function _inherits(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
              }
              subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
              if (superClass)
                Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
            }
            var Header = function(_Block) {
              _inherits(Header2, _Block);
              function Header2() {
                _classCallCheck2(this, Header2);
                return _possibleConstructorReturn(this, (Header2.__proto__ || Object.getPrototypeOf(Header2)).apply(this, arguments));
              }
              _createClass(Header2, null, [{
                key: "formats",
                value: function formats(domNode) {
                  return this.tagName.indexOf(domNode.tagName) + 1;
                }
              }]);
              return Header2;
            }(_block2.default);
            Header.blotName = "header";
            Header.tagName = ["H1", "H2", "H3", "H4", "H5", "H6"];
            exports2.default = Header;
          },
          /* 67 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.default = exports2.ListItem = void 0;
            var _createClass = function() {
              function defineProperties(target, props) {
                for (var i2 = 0; i2 < props.length; i2++) {
                  var descriptor = props[i2];
                  descriptor.enumerable = descriptor.enumerable || false;
                  descriptor.configurable = true;
                  if ("value" in descriptor)
                    descriptor.writable = true;
                  Object.defineProperty(target, descriptor.key, descriptor);
                }
              }
              return function(Constructor, protoProps, staticProps) {
                if (protoProps)
                  defineProperties(Constructor.prototype, protoProps);
                if (staticProps)
                  defineProperties(Constructor, staticProps);
                return Constructor;
              };
            }();
            var _get = function get(object, property, receiver) {
              if (object === null)
                object = Function.prototype;
              var desc = Object.getOwnPropertyDescriptor(object, property);
              if (desc === void 0) {
                var parent = Object.getPrototypeOf(object);
                if (parent === null) {
                  return void 0;
                } else {
                  return get(parent, property, receiver);
                }
              } else if ("value" in desc) {
                return desc.value;
              } else {
                var getter = desc.get;
                if (getter === void 0) {
                  return void 0;
                }
                return getter.call(receiver);
              }
            };
            var _parchment = __webpack_require__(0);
            var _parchment2 = _interopRequireDefault(_parchment);
            var _block = __webpack_require__(4);
            var _block2 = _interopRequireDefault(_block);
            var _container = __webpack_require__(25);
            var _container2 = _interopRequireDefault(_container);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { default: obj };
            }
            function _defineProperty2(obj, key, value) {
              if (key in obj) {
                Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
              } else {
                obj[key] = value;
              }
              return obj;
            }
            function _classCallCheck2(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function _possibleConstructorReturn(self2, call) {
              if (!self2) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return call && (typeof call === "object" || typeof call === "function") ? call : self2;
            }
            function _inherits(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
              }
              subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
              if (superClass)
                Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
            }
            var ListItem = function(_Block) {
              _inherits(ListItem2, _Block);
              function ListItem2() {
                _classCallCheck2(this, ListItem2);
                return _possibleConstructorReturn(this, (ListItem2.__proto__ || Object.getPrototypeOf(ListItem2)).apply(this, arguments));
              }
              _createClass(ListItem2, [{
                key: "format",
                value: function format(name, value) {
                  if (name === List2.blotName && !value) {
                    this.replaceWith(_parchment2.default.create(this.statics.scope));
                  } else {
                    _get(ListItem2.prototype.__proto__ || Object.getPrototypeOf(ListItem2.prototype), "format", this).call(this, name, value);
                  }
                }
              }, {
                key: "remove",
                value: function remove2() {
                  if (this.prev == null && this.next == null) {
                    this.parent.remove();
                  } else {
                    _get(ListItem2.prototype.__proto__ || Object.getPrototypeOf(ListItem2.prototype), "remove", this).call(this);
                  }
                }
              }, {
                key: "replaceWith",
                value: function replaceWith(name, value) {
                  this.parent.isolate(this.offset(this.parent), this.length());
                  if (name === this.parent.statics.blotName) {
                    this.parent.replaceWith(name, value);
                    return this;
                  } else {
                    this.parent.unwrap();
                    return _get(ListItem2.prototype.__proto__ || Object.getPrototypeOf(ListItem2.prototype), "replaceWith", this).call(this, name, value);
                  }
                }
              }], [{
                key: "formats",
                value: function formats(domNode) {
                  return domNode.tagName === this.tagName ? void 0 : _get(ListItem2.__proto__ || Object.getPrototypeOf(ListItem2), "formats", this).call(this, domNode);
                }
              }]);
              return ListItem2;
            }(_block2.default);
            ListItem.blotName = "list-item";
            ListItem.tagName = "LI";
            var List2 = function(_Container) {
              _inherits(List3, _Container);
              _createClass(List3, null, [{
                key: "create",
                value: function create2(value) {
                  var tagName = value === "ordered" ? "OL" : "UL";
                  var node3 = _get(List3.__proto__ || Object.getPrototypeOf(List3), "create", this).call(this, tagName);
                  if (value === "checked" || value === "unchecked") {
                    node3.setAttribute("data-checked", value === "checked");
                  }
                  return node3;
                }
              }, {
                key: "formats",
                value: function formats(domNode) {
                  if (domNode.tagName === "OL")
                    return "ordered";
                  if (domNode.tagName === "UL") {
                    if (domNode.hasAttribute("data-checked")) {
                      return domNode.getAttribute("data-checked") === "true" ? "checked" : "unchecked";
                    } else {
                      return "bullet";
                    }
                  }
                  return void 0;
                }
              }]);
              function List3(domNode) {
                _classCallCheck2(this, List3);
                var _this2 = _possibleConstructorReturn(this, (List3.__proto__ || Object.getPrototypeOf(List3)).call(this, domNode));
                var listEventHandler = function listEventHandler2(e2) {
                  if (e2.target.parentNode !== domNode)
                    return;
                  var format = _this2.statics.formats(domNode);
                  var blot = _parchment2.default.find(e2.target);
                  if (format === "checked") {
                    blot.format("list", "unchecked");
                  } else if (format === "unchecked") {
                    blot.format("list", "checked");
                  }
                };
                domNode.addEventListener("touchstart", listEventHandler);
                domNode.addEventListener("mousedown", listEventHandler);
                return _this2;
              }
              _createClass(List3, [{
                key: "format",
                value: function format(name, value) {
                  if (this.children.length > 0) {
                    this.children.tail.format(name, value);
                  }
                }
              }, {
                key: "formats",
                value: function formats() {
                  return _defineProperty2({}, this.statics.blotName, this.statics.formats(this.domNode));
                }
              }, {
                key: "insertBefore",
                value: function insertBefore2(blot, ref) {
                  if (blot instanceof ListItem) {
                    _get(List3.prototype.__proto__ || Object.getPrototypeOf(List3.prototype), "insertBefore", this).call(this, blot, ref);
                  } else {
                    var index3 = ref == null ? this.length() : ref.offset(this);
                    var after2 = this.split(index3);
                    after2.parent.insertBefore(blot, after2);
                  }
                }
              }, {
                key: "optimize",
                value: function optimize(context) {
                  _get(List3.prototype.__proto__ || Object.getPrototypeOf(List3.prototype), "optimize", this).call(this, context);
                  var next2 = this.next;
                  if (next2 != null && next2.prev === this && next2.statics.blotName === this.statics.blotName && next2.domNode.tagName === this.domNode.tagName && next2.domNode.getAttribute("data-checked") === this.domNode.getAttribute("data-checked")) {
                    next2.moveChildren(this);
                    next2.remove();
                  }
                }
              }, {
                key: "replace",
                value: function replace(target) {
                  if (target.statics.blotName !== this.statics.blotName) {
                    var item = _parchment2.default.create(this.statics.defaultChild);
                    target.moveChildren(item);
                    this.appendChild(item);
                  }
                  _get(List3.prototype.__proto__ || Object.getPrototypeOf(List3.prototype), "replace", this).call(this, target);
                }
              }]);
              return List3;
            }(_container2.default);
            List2.blotName = "list";
            List2.scope = _parchment2.default.Scope.BLOCK_BLOT;
            List2.tagName = ["OL", "UL"];
            List2.defaultChild = "list-item";
            List2.allowedChildren = [ListItem];
            exports2.ListItem = ListItem;
            exports2.default = List2;
          },
          /* 68 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _bold = __webpack_require__(56);
            var _bold2 = _interopRequireDefault(_bold);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { default: obj };
            }
            function _classCallCheck2(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function _possibleConstructorReturn(self2, call) {
              if (!self2) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return call && (typeof call === "object" || typeof call === "function") ? call : self2;
            }
            function _inherits(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
              }
              subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
              if (superClass)
                Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
            }
            var Italic = function(_Bold) {
              _inherits(Italic2, _Bold);
              function Italic2() {
                _classCallCheck2(this, Italic2);
                return _possibleConstructorReturn(this, (Italic2.__proto__ || Object.getPrototypeOf(Italic2)).apply(this, arguments));
              }
              return Italic2;
            }(_bold2.default);
            Italic.blotName = "italic";
            Italic.tagName = ["EM", "I"];
            exports2.default = Italic;
          },
          /* 69 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _createClass = function() {
              function defineProperties(target, props) {
                for (var i2 = 0; i2 < props.length; i2++) {
                  var descriptor = props[i2];
                  descriptor.enumerable = descriptor.enumerable || false;
                  descriptor.configurable = true;
                  if ("value" in descriptor)
                    descriptor.writable = true;
                  Object.defineProperty(target, descriptor.key, descriptor);
                }
              }
              return function(Constructor, protoProps, staticProps) {
                if (protoProps)
                  defineProperties(Constructor.prototype, protoProps);
                if (staticProps)
                  defineProperties(Constructor, staticProps);
                return Constructor;
              };
            }();
            var _get = function get(object, property, receiver) {
              if (object === null)
                object = Function.prototype;
              var desc = Object.getOwnPropertyDescriptor(object, property);
              if (desc === void 0) {
                var parent = Object.getPrototypeOf(object);
                if (parent === null) {
                  return void 0;
                } else {
                  return get(parent, property, receiver);
                }
              } else if ("value" in desc) {
                return desc.value;
              } else {
                var getter = desc.get;
                if (getter === void 0) {
                  return void 0;
                }
                return getter.call(receiver);
              }
            };
            var _inline = __webpack_require__(6);
            var _inline2 = _interopRequireDefault(_inline);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { default: obj };
            }
            function _classCallCheck2(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function _possibleConstructorReturn(self2, call) {
              if (!self2) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return call && (typeof call === "object" || typeof call === "function") ? call : self2;
            }
            function _inherits(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
              }
              subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
              if (superClass)
                Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
            }
            var Script = function(_Inline) {
              _inherits(Script2, _Inline);
              function Script2() {
                _classCallCheck2(this, Script2);
                return _possibleConstructorReturn(this, (Script2.__proto__ || Object.getPrototypeOf(Script2)).apply(this, arguments));
              }
              _createClass(Script2, null, [{
                key: "create",
                value: function create2(value) {
                  if (value === "super") {
                    return document.createElement("sup");
                  } else if (value === "sub") {
                    return document.createElement("sub");
                  } else {
                    return _get(Script2.__proto__ || Object.getPrototypeOf(Script2), "create", this).call(this, value);
                  }
                }
              }, {
                key: "formats",
                value: function formats(domNode) {
                  if (domNode.tagName === "SUB")
                    return "sub";
                  if (domNode.tagName === "SUP")
                    return "super";
                  return void 0;
                }
              }]);
              return Script2;
            }(_inline2.default);
            Script.blotName = "script";
            Script.tagName = ["SUB", "SUP"];
            exports2.default = Script;
          },
          /* 70 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _inline = __webpack_require__(6);
            var _inline2 = _interopRequireDefault(_inline);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { default: obj };
            }
            function _classCallCheck2(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function _possibleConstructorReturn(self2, call) {
              if (!self2) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return call && (typeof call === "object" || typeof call === "function") ? call : self2;
            }
            function _inherits(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
              }
              subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
              if (superClass)
                Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
            }
            var Strike = function(_Inline) {
              _inherits(Strike2, _Inline);
              function Strike2() {
                _classCallCheck2(this, Strike2);
                return _possibleConstructorReturn(this, (Strike2.__proto__ || Object.getPrototypeOf(Strike2)).apply(this, arguments));
              }
              return Strike2;
            }(_inline2.default);
            Strike.blotName = "strike";
            Strike.tagName = "S";
            exports2.default = Strike;
          },
          /* 71 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _inline = __webpack_require__(6);
            var _inline2 = _interopRequireDefault(_inline);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { default: obj };
            }
            function _classCallCheck2(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function _possibleConstructorReturn(self2, call) {
              if (!self2) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return call && (typeof call === "object" || typeof call === "function") ? call : self2;
            }
            function _inherits(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
              }
              subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
              if (superClass)
                Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
            }
            var Underline = function(_Inline) {
              _inherits(Underline2, _Inline);
              function Underline2() {
                _classCallCheck2(this, Underline2);
                return _possibleConstructorReturn(this, (Underline2.__proto__ || Object.getPrototypeOf(Underline2)).apply(this, arguments));
              }
              return Underline2;
            }(_inline2.default);
            Underline.blotName = "underline";
            Underline.tagName = "U";
            exports2.default = Underline;
          },
          /* 72 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _createClass = function() {
              function defineProperties(target, props) {
                for (var i2 = 0; i2 < props.length; i2++) {
                  var descriptor = props[i2];
                  descriptor.enumerable = descriptor.enumerable || false;
                  descriptor.configurable = true;
                  if ("value" in descriptor)
                    descriptor.writable = true;
                  Object.defineProperty(target, descriptor.key, descriptor);
                }
              }
              return function(Constructor, protoProps, staticProps) {
                if (protoProps)
                  defineProperties(Constructor.prototype, protoProps);
                if (staticProps)
                  defineProperties(Constructor, staticProps);
                return Constructor;
              };
            }();
            var _get = function get(object, property, receiver) {
              if (object === null)
                object = Function.prototype;
              var desc = Object.getOwnPropertyDescriptor(object, property);
              if (desc === void 0) {
                var parent = Object.getPrototypeOf(object);
                if (parent === null) {
                  return void 0;
                } else {
                  return get(parent, property, receiver);
                }
              } else if ("value" in desc) {
                return desc.value;
              } else {
                var getter = desc.get;
                if (getter === void 0) {
                  return void 0;
                }
                return getter.call(receiver);
              }
            };
            var _parchment = __webpack_require__(0);
            var _parchment2 = _interopRequireDefault(_parchment);
            var _link = __webpack_require__(27);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { default: obj };
            }
            function _classCallCheck2(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function _possibleConstructorReturn(self2, call) {
              if (!self2) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return call && (typeof call === "object" || typeof call === "function") ? call : self2;
            }
            function _inherits(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
              }
              subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
              if (superClass)
                Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
            }
            var ATTRIBUTES = ["alt", "height", "width"];
            var Image3 = function(_Parchment$Embed) {
              _inherits(Image4, _Parchment$Embed);
              function Image4() {
                _classCallCheck2(this, Image4);
                return _possibleConstructorReturn(this, (Image4.__proto__ || Object.getPrototypeOf(Image4)).apply(this, arguments));
              }
              _createClass(Image4, [{
                key: "format",
                value: function format(name, value) {
                  if (ATTRIBUTES.indexOf(name) > -1) {
                    if (value) {
                      this.domNode.setAttribute(name, value);
                    } else {
                      this.domNode.removeAttribute(name);
                    }
                  } else {
                    _get(Image4.prototype.__proto__ || Object.getPrototypeOf(Image4.prototype), "format", this).call(this, name, value);
                  }
                }
              }], [{
                key: "create",
                value: function create2(value) {
                  var node3 = _get(Image4.__proto__ || Object.getPrototypeOf(Image4), "create", this).call(this, value);
                  if (typeof value === "string") {
                    node3.setAttribute("src", this.sanitize(value));
                  }
                  return node3;
                }
              }, {
                key: "formats",
                value: function formats(domNode) {
                  return ATTRIBUTES.reduce(function(formats2, attribute) {
                    if (domNode.hasAttribute(attribute)) {
                      formats2[attribute] = domNode.getAttribute(attribute);
                    }
                    return formats2;
                  }, {});
                }
              }, {
                key: "match",
                value: function match(url) {
                  return /\.(jpe?g|gif|png)$/.test(url) || /^data:image\/.+;base64/.test(url);
                }
              }, {
                key: "sanitize",
                value: function sanitize(url) {
                  return (0, _link.sanitize)(url, ["http", "https", "data"]) ? url : "//:0";
                }
              }, {
                key: "value",
                value: function value(domNode) {
                  return domNode.getAttribute("src");
                }
              }]);
              return Image4;
            }(_parchment2.default.Embed);
            Image3.blotName = "image";
            Image3.tagName = "IMG";
            exports2.default = Image3;
          },
          /* 73 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _createClass = function() {
              function defineProperties(target, props) {
                for (var i2 = 0; i2 < props.length; i2++) {
                  var descriptor = props[i2];
                  descriptor.enumerable = descriptor.enumerable || false;
                  descriptor.configurable = true;
                  if ("value" in descriptor)
                    descriptor.writable = true;
                  Object.defineProperty(target, descriptor.key, descriptor);
                }
              }
              return function(Constructor, protoProps, staticProps) {
                if (protoProps)
                  defineProperties(Constructor.prototype, protoProps);
                if (staticProps)
                  defineProperties(Constructor, staticProps);
                return Constructor;
              };
            }();
            var _get = function get(object, property, receiver) {
              if (object === null)
                object = Function.prototype;
              var desc = Object.getOwnPropertyDescriptor(object, property);
              if (desc === void 0) {
                var parent = Object.getPrototypeOf(object);
                if (parent === null) {
                  return void 0;
                } else {
                  return get(parent, property, receiver);
                }
              } else if ("value" in desc) {
                return desc.value;
              } else {
                var getter = desc.get;
                if (getter === void 0) {
                  return void 0;
                }
                return getter.call(receiver);
              }
            };
            var _block = __webpack_require__(4);
            var _link = __webpack_require__(27);
            var _link2 = _interopRequireDefault(_link);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { default: obj };
            }
            function _classCallCheck2(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function _possibleConstructorReturn(self2, call) {
              if (!self2) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return call && (typeof call === "object" || typeof call === "function") ? call : self2;
            }
            function _inherits(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
              }
              subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
              if (superClass)
                Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
            }
            var ATTRIBUTES = ["height", "width"];
            var Video = function(_BlockEmbed) {
              _inherits(Video2, _BlockEmbed);
              function Video2() {
                _classCallCheck2(this, Video2);
                return _possibleConstructorReturn(this, (Video2.__proto__ || Object.getPrototypeOf(Video2)).apply(this, arguments));
              }
              _createClass(Video2, [{
                key: "format",
                value: function format(name, value) {
                  if (ATTRIBUTES.indexOf(name) > -1) {
                    if (value) {
                      this.domNode.setAttribute(name, value);
                    } else {
                      this.domNode.removeAttribute(name);
                    }
                  } else {
                    _get(Video2.prototype.__proto__ || Object.getPrototypeOf(Video2.prototype), "format", this).call(this, name, value);
                  }
                }
              }], [{
                key: "create",
                value: function create2(value) {
                  var node3 = _get(Video2.__proto__ || Object.getPrototypeOf(Video2), "create", this).call(this, value);
                  node3.setAttribute("frameborder", "0");
                  node3.setAttribute("allowfullscreen", true);
                  node3.setAttribute("src", this.sanitize(value));
                  return node3;
                }
              }, {
                key: "formats",
                value: function formats(domNode) {
                  return ATTRIBUTES.reduce(function(formats2, attribute) {
                    if (domNode.hasAttribute(attribute)) {
                      formats2[attribute] = domNode.getAttribute(attribute);
                    }
                    return formats2;
                  }, {});
                }
              }, {
                key: "sanitize",
                value: function sanitize(url) {
                  return _link2.default.sanitize(url);
                }
              }, {
                key: "value",
                value: function value(domNode) {
                  return domNode.getAttribute("src");
                }
              }]);
              return Video2;
            }(_block.BlockEmbed);
            Video.blotName = "video";
            Video.className = "ql-video";
            Video.tagName = "IFRAME";
            exports2.default = Video;
          },
          /* 74 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.default = exports2.FormulaBlot = void 0;
            var _createClass = function() {
              function defineProperties(target, props) {
                for (var i2 = 0; i2 < props.length; i2++) {
                  var descriptor = props[i2];
                  descriptor.enumerable = descriptor.enumerable || false;
                  descriptor.configurable = true;
                  if ("value" in descriptor)
                    descriptor.writable = true;
                  Object.defineProperty(target, descriptor.key, descriptor);
                }
              }
              return function(Constructor, protoProps, staticProps) {
                if (protoProps)
                  defineProperties(Constructor.prototype, protoProps);
                if (staticProps)
                  defineProperties(Constructor, staticProps);
                return Constructor;
              };
            }();
            var _get = function get(object, property, receiver) {
              if (object === null)
                object = Function.prototype;
              var desc = Object.getOwnPropertyDescriptor(object, property);
              if (desc === void 0) {
                var parent = Object.getPrototypeOf(object);
                if (parent === null) {
                  return void 0;
                } else {
                  return get(parent, property, receiver);
                }
              } else if ("value" in desc) {
                return desc.value;
              } else {
                var getter = desc.get;
                if (getter === void 0) {
                  return void 0;
                }
                return getter.call(receiver);
              }
            };
            var _embed = __webpack_require__(35);
            var _embed2 = _interopRequireDefault(_embed);
            var _quill = __webpack_require__(5);
            var _quill2 = _interopRequireDefault(_quill);
            var _module = __webpack_require__(9);
            var _module2 = _interopRequireDefault(_module);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { default: obj };
            }
            function _classCallCheck2(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function _possibleConstructorReturn(self2, call) {
              if (!self2) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return call && (typeof call === "object" || typeof call === "function") ? call : self2;
            }
            function _inherits(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
              }
              subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
              if (superClass)
                Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
            }
            var FormulaBlot = function(_Embed) {
              _inherits(FormulaBlot2, _Embed);
              function FormulaBlot2() {
                _classCallCheck2(this, FormulaBlot2);
                return _possibleConstructorReturn(this, (FormulaBlot2.__proto__ || Object.getPrototypeOf(FormulaBlot2)).apply(this, arguments));
              }
              _createClass(FormulaBlot2, null, [{
                key: "create",
                value: function create2(value) {
                  var node3 = _get(FormulaBlot2.__proto__ || Object.getPrototypeOf(FormulaBlot2), "create", this).call(this, value);
                  if (typeof value === "string") {
                    window.katex.render(value, node3, {
                      throwOnError: false,
                      errorColor: "#f00"
                    });
                    node3.setAttribute("data-value", value);
                  }
                  return node3;
                }
              }, {
                key: "value",
                value: function value(domNode) {
                  return domNode.getAttribute("data-value");
                }
              }]);
              return FormulaBlot2;
            }(_embed2.default);
            FormulaBlot.blotName = "formula";
            FormulaBlot.className = "ql-formula";
            FormulaBlot.tagName = "SPAN";
            var Formula2 = function(_Module) {
              _inherits(Formula3, _Module);
              _createClass(Formula3, null, [{
                key: "register",
                value: function register2() {
                  _quill2.default.register(FormulaBlot, true);
                }
              }]);
              function Formula3() {
                _classCallCheck2(this, Formula3);
                var _this2 = _possibleConstructorReturn(this, (Formula3.__proto__ || Object.getPrototypeOf(Formula3)).call(this));
                if (window.katex == null) {
                  throw new Error("Formula module requires KaTeX.");
                }
                return _this2;
              }
              return Formula3;
            }(_module2.default);
            exports2.FormulaBlot = FormulaBlot;
            exports2.default = Formula2;
          },
          /* 75 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.default = exports2.CodeToken = exports2.CodeBlock = void 0;
            var _createClass = function() {
              function defineProperties(target, props) {
                for (var i2 = 0; i2 < props.length; i2++) {
                  var descriptor = props[i2];
                  descriptor.enumerable = descriptor.enumerable || false;
                  descriptor.configurable = true;
                  if ("value" in descriptor)
                    descriptor.writable = true;
                  Object.defineProperty(target, descriptor.key, descriptor);
                }
              }
              return function(Constructor, protoProps, staticProps) {
                if (protoProps)
                  defineProperties(Constructor.prototype, protoProps);
                if (staticProps)
                  defineProperties(Constructor, staticProps);
                return Constructor;
              };
            }();
            var _get = function get(object, property, receiver) {
              if (object === null)
                object = Function.prototype;
              var desc = Object.getOwnPropertyDescriptor(object, property);
              if (desc === void 0) {
                var parent = Object.getPrototypeOf(object);
                if (parent === null) {
                  return void 0;
                } else {
                  return get(parent, property, receiver);
                }
              } else if ("value" in desc) {
                return desc.value;
              } else {
                var getter = desc.get;
                if (getter === void 0) {
                  return void 0;
                }
                return getter.call(receiver);
              }
            };
            var _parchment = __webpack_require__(0);
            var _parchment2 = _interopRequireDefault(_parchment);
            var _quill = __webpack_require__(5);
            var _quill2 = _interopRequireDefault(_quill);
            var _module = __webpack_require__(9);
            var _module2 = _interopRequireDefault(_module);
            var _code = __webpack_require__(13);
            var _code2 = _interopRequireDefault(_code);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { default: obj };
            }
            function _classCallCheck2(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function _possibleConstructorReturn(self2, call) {
              if (!self2) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return call && (typeof call === "object" || typeof call === "function") ? call : self2;
            }
            function _inherits(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
              }
              subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
              if (superClass)
                Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
            }
            var SyntaxCodeBlock = function(_CodeBlock) {
              _inherits(SyntaxCodeBlock2, _CodeBlock);
              function SyntaxCodeBlock2() {
                _classCallCheck2(this, SyntaxCodeBlock2);
                return _possibleConstructorReturn(this, (SyntaxCodeBlock2.__proto__ || Object.getPrototypeOf(SyntaxCodeBlock2)).apply(this, arguments));
              }
              _createClass(SyntaxCodeBlock2, [{
                key: "replaceWith",
                value: function replaceWith(block) {
                  this.domNode.textContent = this.domNode.textContent;
                  this.attach();
                  _get(SyntaxCodeBlock2.prototype.__proto__ || Object.getPrototypeOf(SyntaxCodeBlock2.prototype), "replaceWith", this).call(this, block);
                }
              }, {
                key: "highlight",
                value: function highlight(_highlight) {
                  var text4 = this.domNode.textContent;
                  if (this.cachedText !== text4) {
                    if (text4.trim().length > 0 || this.cachedText == null) {
                      this.domNode.innerHTML = _highlight(text4);
                      this.domNode.normalize();
                      this.attach();
                    }
                    this.cachedText = text4;
                  }
                }
              }]);
              return SyntaxCodeBlock2;
            }(_code2.default);
            SyntaxCodeBlock.className = "ql-syntax";
            var CodeToken = new _parchment2.default.Attributor.Class("token", "hljs", {
              scope: _parchment2.default.Scope.INLINE
            });
            var Syntax = function(_Module) {
              _inherits(Syntax2, _Module);
              _createClass(Syntax2, null, [{
                key: "register",
                value: function register2() {
                  _quill2.default.register(CodeToken, true);
                  _quill2.default.register(SyntaxCodeBlock, true);
                }
              }]);
              function Syntax2(quill, options) {
                _classCallCheck2(this, Syntax2);
                var _this2 = _possibleConstructorReturn(this, (Syntax2.__proto__ || Object.getPrototypeOf(Syntax2)).call(this, quill, options));
                if (typeof _this2.options.highlight !== "function") {
                  throw new Error("Syntax module requires highlight.js. Please include the library on the page before Quill.");
                }
                var timer = null;
                _this2.quill.on(_quill2.default.events.SCROLL_OPTIMIZE, function() {
                  clearTimeout(timer);
                  timer = setTimeout(function() {
                    _this2.highlight();
                    timer = null;
                  }, _this2.options.interval);
                });
                _this2.highlight();
                return _this2;
              }
              _createClass(Syntax2, [{
                key: "highlight",
                value: function highlight() {
                  var _this3 = this;
                  if (this.quill.selection.composing)
                    return;
                  this.quill.update(_quill2.default.sources.USER);
                  var range = this.quill.getSelection();
                  this.quill.scroll.descendants(SyntaxCodeBlock).forEach(function(code) {
                    code.highlight(_this3.options.highlight);
                  });
                  this.quill.update(_quill2.default.sources.SILENT);
                  if (range != null) {
                    this.quill.setSelection(range, _quill2.default.sources.SILENT);
                  }
                }
              }]);
              return Syntax2;
            }(_module2.default);
            Syntax.DEFAULTS = {
              highlight: function() {
                if (window.hljs == null)
                  return null;
                return function(text4) {
                  var result = window.hljs.highlightAuto(text4);
                  return result.value;
                };
              }(),
              interval: 1e3
            };
            exports2.CodeBlock = SyntaxCodeBlock;
            exports2.CodeToken = CodeToken;
            exports2.default = Syntax;
          },
          /* 76 */
          /***/
          function(module2, exports2) {
            module2.exports = '<svg viewbox="0 0 18 18"> <line class=ql-stroke x1=3 x2=15 y1=9 y2=9></line> <line class=ql-stroke x1=3 x2=13 y1=14 y2=14></line> <line class=ql-stroke x1=3 x2=9 y1=4 y2=4></line> </svg>';
          },
          /* 77 */
          /***/
          function(module2, exports2) {
            module2.exports = '<svg viewbox="0 0 18 18"> <line class=ql-stroke x1=15 x2=3 y1=9 y2=9></line> <line class=ql-stroke x1=14 x2=4 y1=14 y2=14></line> <line class=ql-stroke x1=12 x2=6 y1=4 y2=4></line> </svg>';
          },
          /* 78 */
          /***/
          function(module2, exports2) {
            module2.exports = '<svg viewbox="0 0 18 18"> <line class=ql-stroke x1=15 x2=3 y1=9 y2=9></line> <line class=ql-stroke x1=15 x2=5 y1=14 y2=14></line> <line class=ql-stroke x1=15 x2=9 y1=4 y2=4></line> </svg>';
          },
          /* 79 */
          /***/
          function(module2, exports2) {
            module2.exports = '<svg viewbox="0 0 18 18"> <line class=ql-stroke x1=15 x2=3 y1=9 y2=9></line> <line class=ql-stroke x1=15 x2=3 y1=14 y2=14></line> <line class=ql-stroke x1=15 x2=3 y1=4 y2=4></line> </svg>';
          },
          /* 80 */
          /***/
          function(module2, exports2) {
            module2.exports = '<svg viewbox="0 0 18 18"> <g class="ql-fill ql-color-label"> <polygon points="6 6.868 6 6 5 6 5 7 5.942 7 6 6.868"></polygon> <rect height=1 width=1 x=4 y=4></rect> <polygon points="6.817 5 6 5 6 6 6.38 6 6.817 5"></polygon> <rect height=1 width=1 x=2 y=6></rect> <rect height=1 width=1 x=3 y=5></rect> <rect height=1 width=1 x=4 y=7></rect> <polygon points="4 11.439 4 11 3 11 3 12 3.755 12 4 11.439"></polygon> <rect height=1 width=1 x=2 y=12></rect> <rect height=1 width=1 x=2 y=9></rect> <rect height=1 width=1 x=2 y=15></rect> <polygon points="4.63 10 4 10 4 11 4.192 11 4.63 10"></polygon> <rect height=1 width=1 x=3 y=8></rect> <path d=M10.832,4.2L11,4.582V4H10.708A1.948,1.948,0,0,1,10.832,4.2Z></path> <path d=M7,4.582L7.168,4.2A1.929,1.929,0,0,1,7.292,4H7V4.582Z></path> <path d=M8,13H7.683l-0.351.8a1.933,1.933,0,0,1-.124.2H8V13Z></path> <rect height=1 width=1 x=12 y=2></rect> <rect height=1 width=1 x=11 y=3></rect> <path d=M9,3H8V3.282A1.985,1.985,0,0,1,9,3Z></path> <rect height=1 width=1 x=2 y=3></rect> <rect height=1 width=1 x=6 y=2></rect> <rect height=1 width=1 x=3 y=2></rect> <rect height=1 width=1 x=5 y=3></rect> <rect height=1 width=1 x=9 y=2></rect> <rect height=1 width=1 x=15 y=14></rect> <polygon points="13.447 10.174 13.469 10.225 13.472 10.232 13.808 11 14 11 14 10 13.37 10 13.447 10.174"></polygon> <rect height=1 width=1 x=13 y=7></rect> <rect height=1 width=1 x=15 y=5></rect> <rect height=1 width=1 x=14 y=6></rect> <rect height=1 width=1 x=15 y=8></rect> <rect height=1 width=1 x=14 y=9></rect> <path d=M3.775,14H3v1H4V14.314A1.97,1.97,0,0,1,3.775,14Z></path> <rect height=1 width=1 x=14 y=3></rect> <polygon points="12 6.868 12 6 11.62 6 12 6.868"></polygon> <rect height=1 width=1 x=15 y=2></rect> <rect height=1 width=1 x=12 y=5></rect> <rect height=1 width=1 x=13 y=4></rect> <polygon points="12.933 9 13 9 13 8 12.495 8 12.933 9"></polygon> <rect height=1 width=1 x=9 y=14></rect> <rect height=1 width=1 x=8 y=15></rect> <path d=M6,14.926V15H7V14.316A1.993,1.993,0,0,1,6,14.926Z></path> <rect height=1 width=1 x=5 y=15></rect> <path d=M10.668,13.8L10.317,13H10v1h0.792A1.947,1.947,0,0,1,10.668,13.8Z></path> <rect height=1 width=1 x=11 y=15></rect> <path d=M14.332,12.2a1.99,1.99,0,0,1,.166.8H15V12H14.245Z></path> <rect height=1 width=1 x=14 y=15></rect> <rect height=1 width=1 x=15 y=11></rect> </g> <polyline class=ql-stroke points="5.5 13 9 5 12.5 13"></polyline> <line class=ql-stroke x1=11.63 x2=6.38 y1=11 y2=11></line> </svg>';
          },
          /* 81 */
          /***/
          function(module2, exports2) {
            module2.exports = '<svg viewbox="0 0 18 18"> <rect class="ql-fill ql-stroke" height=3 width=3 x=4 y=5></rect> <rect class="ql-fill ql-stroke" height=3 width=3 x=11 y=5></rect> <path class="ql-even ql-fill ql-stroke" d=M7,8c0,4.031-3,5-3,5></path> <path class="ql-even ql-fill ql-stroke" d=M14,8c0,4.031-3,5-3,5></path> </svg>';
          },
          /* 82 */
          /***/
          function(module2, exports2) {
            module2.exports = '<svg viewbox="0 0 18 18"> <path class=ql-stroke d=M5,4H9.5A2.5,2.5,0,0,1,12,6.5v0A2.5,2.5,0,0,1,9.5,9H5A0,0,0,0,1,5,9V4A0,0,0,0,1,5,4Z></path> <path class=ql-stroke d=M5,9h5.5A2.5,2.5,0,0,1,13,11.5v0A2.5,2.5,0,0,1,10.5,14H5a0,0,0,0,1,0,0V9A0,0,0,0,1,5,9Z></path> </svg>';
          },
          /* 83 */
          /***/
          function(module2, exports2) {
            module2.exports = '<svg class="" viewbox="0 0 18 18"> <line class=ql-stroke x1=5 x2=13 y1=3 y2=3></line> <line class=ql-stroke x1=6 x2=9.35 y1=12 y2=3></line> <line class=ql-stroke x1=11 x2=15 y1=11 y2=15></line> <line class=ql-stroke x1=15 x2=11 y1=11 y2=15></line> <rect class=ql-fill height=1 rx=0.5 ry=0.5 width=7 x=2 y=14></rect> </svg>';
          },
          /* 84 */
          /***/
          function(module2, exports2) {
            module2.exports = '<svg viewbox="0 0 18 18"> <line class="ql-color-label ql-stroke ql-transparent" x1=3 x2=15 y1=15 y2=15></line> <polyline class=ql-stroke points="5.5 11 9 3 12.5 11"></polyline> <line class=ql-stroke x1=11.63 x2=6.38 y1=9 y2=9></line> </svg>';
          },
          /* 85 */
          /***/
          function(module2, exports2) {
            module2.exports = '<svg viewbox="0 0 18 18"> <polygon class="ql-stroke ql-fill" points="3 11 5 9 3 7 3 11"></polygon> <line class="ql-stroke ql-fill" x1=15 x2=11 y1=4 y2=4></line> <path class=ql-fill d=M11,3a3,3,0,0,0,0,6h1V3H11Z></path> <rect class=ql-fill height=11 width=1 x=11 y=4></rect> <rect class=ql-fill height=11 width=1 x=13 y=4></rect> </svg>';
          },
          /* 86 */
          /***/
          function(module2, exports2) {
            module2.exports = '<svg viewbox="0 0 18 18"> <polygon class="ql-stroke ql-fill" points="15 12 13 10 15 8 15 12"></polygon> <line class="ql-stroke ql-fill" x1=9 x2=5 y1=4 y2=4></line> <path class=ql-fill d=M5,3A3,3,0,0,0,5,9H6V3H5Z></path> <rect class=ql-fill height=11 width=1 x=5 y=4></rect> <rect class=ql-fill height=11 width=1 x=7 y=4></rect> </svg>';
          },
          /* 87 */
          /***/
          function(module2, exports2) {
            module2.exports = '<svg viewbox="0 0 18 18"> <path class=ql-fill d=M14,16H4a1,1,0,0,1,0-2H14A1,1,0,0,1,14,16Z /> <path class=ql-fill d=M14,4H4A1,1,0,0,1,4,2H14A1,1,0,0,1,14,4Z /> <rect class=ql-fill x=3 y=6 width=12 height=6 rx=1 ry=1 /> </svg>';
          },
          /* 88 */
          /***/
          function(module2, exports2) {
            module2.exports = '<svg viewbox="0 0 18 18"> <path class=ql-fill d=M13,16H5a1,1,0,0,1,0-2h8A1,1,0,0,1,13,16Z /> <path class=ql-fill d=M13,4H5A1,1,0,0,1,5,2h8A1,1,0,0,1,13,4Z /> <rect class=ql-fill x=2 y=6 width=14 height=6 rx=1 ry=1 /> </svg>';
          },
          /* 89 */
          /***/
          function(module2, exports2) {
            module2.exports = '<svg viewbox="0 0 18 18"> <path class=ql-fill d=M15,8H13a1,1,0,0,1,0-2h2A1,1,0,0,1,15,8Z /> <path class=ql-fill d=M15,12H13a1,1,0,0,1,0-2h2A1,1,0,0,1,15,12Z /> <path class=ql-fill d=M15,16H5a1,1,0,0,1,0-2H15A1,1,0,0,1,15,16Z /> <path class=ql-fill d=M15,4H5A1,1,0,0,1,5,2H15A1,1,0,0,1,15,4Z /> <rect class=ql-fill x=2 y=6 width=8 height=6 rx=1 ry=1 /> </svg>';
          },
          /* 90 */
          /***/
          function(module2, exports2) {
            module2.exports = '<svg viewbox="0 0 18 18"> <path class=ql-fill d=M5,8H3A1,1,0,0,1,3,6H5A1,1,0,0,1,5,8Z /> <path class=ql-fill d=M5,12H3a1,1,0,0,1,0-2H5A1,1,0,0,1,5,12Z /> <path class=ql-fill d=M13,16H3a1,1,0,0,1,0-2H13A1,1,0,0,1,13,16Z /> <path class=ql-fill d=M13,4H3A1,1,0,0,1,3,2H13A1,1,0,0,1,13,4Z /> <rect class=ql-fill x=8 y=6 width=8 height=6 rx=1 ry=1 transform="translate(24 18) rotate(-180)"/> </svg>';
          },
          /* 91 */
          /***/
          function(module2, exports2) {
            module2.exports = '<svg viewbox="0 0 18 18"> <path class=ql-fill d=M11.759,2.482a2.561,2.561,0,0,0-3.53.607A7.656,7.656,0,0,0,6.8,6.2C6.109,9.188,5.275,14.677,4.15,14.927a1.545,1.545,0,0,0-1.3-.933A0.922,0.922,0,0,0,2,15.036S1.954,16,4.119,16s3.091-2.691,3.7-5.553c0.177-.826.36-1.726,0.554-2.6L8.775,6.2c0.381-1.421.807-2.521,1.306-2.676a1.014,1.014,0,0,0,1.02.56A0.966,0.966,0,0,0,11.759,2.482Z></path> <rect class=ql-fill height=1.6 rx=0.8 ry=0.8 width=5 x=5.15 y=6.2></rect> <path class=ql-fill d=M13.663,12.027a1.662,1.662,0,0,1,.266-0.276q0.193,0.069.456,0.138a2.1,2.1,0,0,0,.535.069,1.075,1.075,0,0,0,.767-0.3,1.044,1.044,0,0,0,.314-0.8,0.84,0.84,0,0,0-.238-0.619,0.8,0.8,0,0,0-.594-0.239,1.154,1.154,0,0,0-.781.3,4.607,4.607,0,0,0-.781,1q-0.091.15-.218,0.346l-0.246.38c-0.068-.288-0.137-0.582-0.212-0.885-0.459-1.847-2.494-.984-2.941-0.8-0.482.2-.353,0.647-0.094,0.529a0.869,0.869,0,0,1,1.281.585c0.217,0.751.377,1.436,0.527,2.038a5.688,5.688,0,0,1-.362.467,2.69,2.69,0,0,1-.264.271q-0.221-.08-0.471-0.147a2.029,2.029,0,0,0-.522-0.066,1.079,1.079,0,0,0-.768.3A1.058,1.058,0,0,0,9,15.131a0.82,0.82,0,0,0,.832.852,1.134,1.134,0,0,0,.787-0.3,5.11,5.11,0,0,0,.776-0.993q0.141-.219.215-0.34c0.046-.076.122-0.194,0.223-0.346a2.786,2.786,0,0,0,.918,1.726,2.582,2.582,0,0,0,2.376-.185c0.317-.181.212-0.565,0-0.494A0.807,0.807,0,0,1,14.176,15a5.159,5.159,0,0,1-.913-2.446l0,0Q13.487,12.24,13.663,12.027Z></path> </svg>';
          },
          /* 92 */
          /***/
          function(module2, exports2) {
            module2.exports = '<svg viewBox="0 0 18 18"> <path class=ql-fill d=M10,4V14a1,1,0,0,1-2,0V10H3v4a1,1,0,0,1-2,0V4A1,1,0,0,1,3,4V8H8V4a1,1,0,0,1,2,0Zm6.06787,9.209H14.98975V7.59863a.54085.54085,0,0,0-.605-.60547h-.62744a1.01119,1.01119,0,0,0-.748.29688L11.645,8.56641a.5435.5435,0,0,0-.022.8584l.28613.30762a.53861.53861,0,0,0,.84717.0332l.09912-.08789a1.2137,1.2137,0,0,0,.2417-.35254h.02246s-.01123.30859-.01123.60547V13.209H12.041a.54085.54085,0,0,0-.605.60547v.43945a.54085.54085,0,0,0,.605.60547h4.02686a.54085.54085,0,0,0,.605-.60547v-.43945A.54085.54085,0,0,0,16.06787,13.209Z /> </svg>';
          },
          /* 93 */
          /***/
          function(module2, exports2) {
            module2.exports = '<svg viewBox="0 0 18 18"> <path class=ql-fill d=M16.73975,13.81445v.43945a.54085.54085,0,0,1-.605.60547H11.855a.58392.58392,0,0,1-.64893-.60547V14.0127c0-2.90527,3.39941-3.42187,3.39941-4.55469a.77675.77675,0,0,0-.84717-.78125,1.17684,1.17684,0,0,0-.83594.38477c-.2749.26367-.561.374-.85791.13184l-.4292-.34082c-.30811-.24219-.38525-.51758-.1543-.81445a2.97155,2.97155,0,0,1,2.45361-1.17676,2.45393,2.45393,0,0,1,2.68408,2.40918c0,2.45312-3.1792,2.92676-3.27832,3.93848h2.79443A.54085.54085,0,0,1,16.73975,13.81445ZM9,3A.99974.99974,0,0,0,8,4V8H3V4A1,1,0,0,0,1,4V14a1,1,0,0,0,2,0V10H8v4a1,1,0,0,0,2,0V4A.99974.99974,0,0,0,9,3Z /> </svg>';
          },
          /* 94 */
          /***/
          function(module2, exports2) {
            module2.exports = '<svg viewbox="0 0 18 18"> <line class=ql-stroke x1=7 x2=13 y1=4 y2=4></line> <line class=ql-stroke x1=5 x2=11 y1=14 y2=14></line> <line class=ql-stroke x1=8 x2=10 y1=14 y2=4></line> </svg>';
          },
          /* 95 */
          /***/
          function(module2, exports2) {
            module2.exports = '<svg viewbox="0 0 18 18"> <rect class=ql-stroke height=10 width=12 x=3 y=4></rect> <circle class=ql-fill cx=6 cy=7 r=1></circle> <polyline class="ql-even ql-fill" points="5 12 5 11 7 9 8 10 11 7 13 9 13 12 5 12"></polyline> </svg>';
          },
          /* 96 */
          /***/
          function(module2, exports2) {
            module2.exports = '<svg viewbox="0 0 18 18"> <line class=ql-stroke x1=3 x2=15 y1=14 y2=14></line> <line class=ql-stroke x1=3 x2=15 y1=4 y2=4></line> <line class=ql-stroke x1=9 x2=15 y1=9 y2=9></line> <polyline class="ql-fill ql-stroke" points="3 7 3 11 5 9 3 7"></polyline> </svg>';
          },
          /* 97 */
          /***/
          function(module2, exports2) {
            module2.exports = '<svg viewbox="0 0 18 18"> <line class=ql-stroke x1=3 x2=15 y1=14 y2=14></line> <line class=ql-stroke x1=3 x2=15 y1=4 y2=4></line> <line class=ql-stroke x1=9 x2=15 y1=9 y2=9></line> <polyline class=ql-stroke points="5 7 5 11 3 9 5 7"></polyline> </svg>';
          },
          /* 98 */
          /***/
          function(module2, exports2) {
            module2.exports = '<svg viewbox="0 0 18 18"> <line class=ql-stroke x1=7 x2=11 y1=7 y2=11></line> <path class="ql-even ql-stroke" d=M8.9,4.577a3.476,3.476,0,0,1,.36,4.679A3.476,3.476,0,0,1,4.577,8.9C3.185,7.5,2.035,6.4,4.217,4.217S7.5,3.185,8.9,4.577Z></path> <path class="ql-even ql-stroke" d=M13.423,9.1a3.476,3.476,0,0,0-4.679-.36,3.476,3.476,0,0,0,.36,4.679c1.392,1.392,2.5,2.542,4.679.36S14.815,10.5,13.423,9.1Z></path> </svg>';
          },
          /* 99 */
          /***/
          function(module2, exports2) {
            module2.exports = '<svg viewbox="0 0 18 18"> <line class=ql-stroke x1=7 x2=15 y1=4 y2=4></line> <line class=ql-stroke x1=7 x2=15 y1=9 y2=9></line> <line class=ql-stroke x1=7 x2=15 y1=14 y2=14></line> <line class="ql-stroke ql-thin" x1=2.5 x2=4.5 y1=5.5 y2=5.5></line> <path class=ql-fill d=M3.5,6A0.5,0.5,0,0,1,3,5.5V3.085l-0.276.138A0.5,0.5,0,0,1,2.053,3c-0.124-.247-0.023-0.324.224-0.447l1-.5A0.5,0.5,0,0,1,4,2.5v3A0.5,0.5,0,0,1,3.5,6Z></path> <path class="ql-stroke ql-thin" d=M4.5,10.5h-2c0-.234,1.85-1.076,1.85-2.234A0.959,0.959,0,0,0,2.5,8.156></path> <path class="ql-stroke ql-thin" d=M2.5,14.846a0.959,0.959,0,0,0,1.85-.109A0.7,0.7,0,0,0,3.75,14a0.688,0.688,0,0,0,.6-0.736,0.959,0.959,0,0,0-1.85-.109></path> </svg>';
          },
          /* 100 */
          /***/
          function(module2, exports2) {
            module2.exports = '<svg viewbox="0 0 18 18"> <line class=ql-stroke x1=6 x2=15 y1=4 y2=4></line> <line class=ql-stroke x1=6 x2=15 y1=9 y2=9></line> <line class=ql-stroke x1=6 x2=15 y1=14 y2=14></line> <line class=ql-stroke x1=3 x2=3 y1=4 y2=4></line> <line class=ql-stroke x1=3 x2=3 y1=9 y2=9></line> <line class=ql-stroke x1=3 x2=3 y1=14 y2=14></line> </svg>';
          },
          /* 101 */
          /***/
          function(module2, exports2) {
            module2.exports = '<svg class="" viewbox="0 0 18 18"> <line class=ql-stroke x1=9 x2=15 y1=4 y2=4></line> <polyline class=ql-stroke points="3 4 4 5 6 3"></polyline> <line class=ql-stroke x1=9 x2=15 y1=14 y2=14></line> <polyline class=ql-stroke points="3 14 4 15 6 13"></polyline> <line class=ql-stroke x1=9 x2=15 y1=9 y2=9></line> <polyline class=ql-stroke points="3 9 4 10 6 8"></polyline> </svg>';
          },
          /* 102 */
          /***/
          function(module2, exports2) {
            module2.exports = '<svg viewbox="0 0 18 18"> <path class=ql-fill d=M15.5,15H13.861a3.858,3.858,0,0,0,1.914-2.975,1.8,1.8,0,0,0-1.6-1.751A1.921,1.921,0,0,0,12.021,11.7a0.50013,0.50013,0,1,0,.957.291h0a0.914,0.914,0,0,1,1.053-.725,0.81,0.81,0,0,1,.744.762c0,1.076-1.16971,1.86982-1.93971,2.43082A1.45639,1.45639,0,0,0,12,15.5a0.5,0.5,0,0,0,.5.5h3A0.5,0.5,0,0,0,15.5,15Z /> <path class=ql-fill d=M9.65,5.241a1,1,0,0,0-1.409.108L6,7.964,3.759,5.349A1,1,0,0,0,2.192,6.59178Q2.21541,6.6213,2.241,6.649L4.684,9.5,2.241,12.35A1,1,0,0,0,3.71,13.70722q0.02557-.02768.049-0.05722L6,11.036,8.241,13.65a1,1,0,1,0,1.567-1.24277Q9.78459,12.3777,9.759,12.35L7.316,9.5,9.759,6.651A1,1,0,0,0,9.65,5.241Z /> </svg>';
          },
          /* 103 */
          /***/
          function(module2, exports2) {
            module2.exports = '<svg viewbox="0 0 18 18"> <path class=ql-fill d=M15.5,7H13.861a4.015,4.015,0,0,0,1.914-2.975,1.8,1.8,0,0,0-1.6-1.751A1.922,1.922,0,0,0,12.021,3.7a0.5,0.5,0,1,0,.957.291,0.917,0.917,0,0,1,1.053-.725,0.81,0.81,0,0,1,.744.762c0,1.077-1.164,1.925-1.934,2.486A1.423,1.423,0,0,0,12,7.5a0.5,0.5,0,0,0,.5.5h3A0.5,0.5,0,0,0,15.5,7Z /> <path class=ql-fill d=M9.651,5.241a1,1,0,0,0-1.41.108L6,7.964,3.759,5.349a1,1,0,1,0-1.519,1.3L4.683,9.5,2.241,12.35a1,1,0,1,0,1.519,1.3L6,11.036,8.241,13.65a1,1,0,0,0,1.519-1.3L7.317,9.5,9.759,6.651A1,1,0,0,0,9.651,5.241Z /> </svg>';
          },
          /* 104 */
          /***/
          function(module2, exports2) {
            module2.exports = '<svg viewbox="0 0 18 18"> <line class="ql-stroke ql-thin" x1=15.5 x2=2.5 y1=8.5 y2=9.5></line> <path class=ql-fill d=M9.007,8C6.542,7.791,6,7.519,6,6.5,6,5.792,7.283,5,9,5c1.571,0,2.765.679,2.969,1.309a1,1,0,0,0,1.9-.617C13.356,4.106,11.354,3,9,3,6.2,3,4,4.538,4,6.5a3.2,3.2,0,0,0,.5,1.843Z></path> <path class=ql-fill d=M8.984,10C11.457,10.208,12,10.479,12,11.5c0,0.708-1.283,1.5-3,1.5-1.571,0-2.765-.679-2.969-1.309a1,1,0,1,0-1.9.617C4.644,13.894,6.646,15,9,15c2.8,0,5-1.538,5-3.5a3.2,3.2,0,0,0-.5-1.843Z></path> </svg>';
          },
          /* 105 */
          /***/
          function(module2, exports2) {
            module2.exports = '<svg viewbox="0 0 18 18"> <path class=ql-stroke d=M5,3V9a4.012,4.012,0,0,0,4,4H9a4.012,4.012,0,0,0,4-4V3></path> <rect class=ql-fill height=1 rx=0.5 ry=0.5 width=12 x=3 y=15></rect> </svg>';
          },
          /* 106 */
          /***/
          function(module2, exports2) {
            module2.exports = '<svg viewbox="0 0 18 18"> <rect class=ql-stroke height=12 width=12 x=3 y=3></rect> <rect class=ql-fill height=12 width=1 x=5 y=3></rect> <rect class=ql-fill height=12 width=1 x=12 y=3></rect> <rect class=ql-fill height=2 width=8 x=5 y=8></rect> <rect class=ql-fill height=1 width=3 x=3 y=5></rect> <rect class=ql-fill height=1 width=3 x=3 y=7></rect> <rect class=ql-fill height=1 width=3 x=3 y=10></rect> <rect class=ql-fill height=1 width=3 x=3 y=12></rect> <rect class=ql-fill height=1 width=3 x=12 y=5></rect> <rect class=ql-fill height=1 width=3 x=12 y=7></rect> <rect class=ql-fill height=1 width=3 x=12 y=10></rect> <rect class=ql-fill height=1 width=3 x=12 y=12></rect> </svg>';
          },
          /* 107 */
          /***/
          function(module2, exports2) {
            module2.exports = '<svg viewbox="0 0 18 18"> <polygon class=ql-stroke points="7 11 9 13 11 11 7 11"></polygon> <polygon class=ql-stroke points="7 7 9 5 11 7 7 7"></polygon> </svg>';
          },
          /* 108 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.default = exports2.BubbleTooltip = void 0;
            var _get = function get(object, property, receiver) {
              if (object === null)
                object = Function.prototype;
              var desc = Object.getOwnPropertyDescriptor(object, property);
              if (desc === void 0) {
                var parent = Object.getPrototypeOf(object);
                if (parent === null) {
                  return void 0;
                } else {
                  return get(parent, property, receiver);
                }
              } else if ("value" in desc) {
                return desc.value;
              } else {
                var getter = desc.get;
                if (getter === void 0) {
                  return void 0;
                }
                return getter.call(receiver);
              }
            };
            var _createClass = function() {
              function defineProperties(target, props) {
                for (var i2 = 0; i2 < props.length; i2++) {
                  var descriptor = props[i2];
                  descriptor.enumerable = descriptor.enumerable || false;
                  descriptor.configurable = true;
                  if ("value" in descriptor)
                    descriptor.writable = true;
                  Object.defineProperty(target, descriptor.key, descriptor);
                }
              }
              return function(Constructor, protoProps, staticProps) {
                if (protoProps)
                  defineProperties(Constructor.prototype, protoProps);
                if (staticProps)
                  defineProperties(Constructor, staticProps);
                return Constructor;
              };
            }();
            var _extend = __webpack_require__(3);
            var _extend2 = _interopRequireDefault(_extend);
            var _emitter = __webpack_require__(8);
            var _emitter2 = _interopRequireDefault(_emitter);
            var _base = __webpack_require__(43);
            var _base2 = _interopRequireDefault(_base);
            var _selection = __webpack_require__(15);
            var _icons = __webpack_require__(41);
            var _icons2 = _interopRequireDefault(_icons);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { default: obj };
            }
            function _classCallCheck2(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function _possibleConstructorReturn(self2, call) {
              if (!self2) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return call && (typeof call === "object" || typeof call === "function") ? call : self2;
            }
            function _inherits(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
              }
              subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
              if (superClass)
                Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
            }
            var TOOLBAR_CONFIG = [["bold", "italic", "link"], [{ header: 1 }, { header: 2 }, "blockquote"]];
            var BubbleTheme = function(_BaseTheme) {
              _inherits(BubbleTheme2, _BaseTheme);
              function BubbleTheme2(quill, options) {
                _classCallCheck2(this, BubbleTheme2);
                if (options.modules.toolbar != null && options.modules.toolbar.container == null) {
                  options.modules.toolbar.container = TOOLBAR_CONFIG;
                }
                var _this = _possibleConstructorReturn(this, (BubbleTheme2.__proto__ || Object.getPrototypeOf(BubbleTheme2)).call(this, quill, options));
                _this.quill.container.classList.add("ql-bubble");
                return _this;
              }
              _createClass(BubbleTheme2, [{
                key: "extendToolbar",
                value: function extendToolbar(toolbar) {
                  this.tooltip = new BubbleTooltip(this.quill, this.options.bounds);
                  this.tooltip.root.appendChild(toolbar.container);
                  this.buildButtons([].slice.call(toolbar.container.querySelectorAll("button")), _icons2.default);
                  this.buildPickers([].slice.call(toolbar.container.querySelectorAll("select")), _icons2.default);
                }
              }]);
              return BubbleTheme2;
            }(_base2.default);
            BubbleTheme.DEFAULTS = (0, _extend2.default)(true, {}, _base2.default.DEFAULTS, {
              modules: {
                toolbar: {
                  handlers: {
                    link: function link(value) {
                      if (!value) {
                        this.quill.format("link", false);
                      } else {
                        this.quill.theme.tooltip.edit();
                      }
                    }
                  }
                }
              }
            });
            var BubbleTooltip = function(_BaseTooltip) {
              _inherits(BubbleTooltip2, _BaseTooltip);
              function BubbleTooltip2(quill, bounds) {
                _classCallCheck2(this, BubbleTooltip2);
                var _this2 = _possibleConstructorReturn(this, (BubbleTooltip2.__proto__ || Object.getPrototypeOf(BubbleTooltip2)).call(this, quill, bounds));
                _this2.quill.on(_emitter2.default.events.EDITOR_CHANGE, function(type, range, oldRange, source) {
                  if (type !== _emitter2.default.events.SELECTION_CHANGE)
                    return;
                  if (range != null && range.length > 0 && source === _emitter2.default.sources.USER) {
                    _this2.show();
                    _this2.root.style.left = "0px";
                    _this2.root.style.width = "";
                    _this2.root.style.width = _this2.root.offsetWidth + "px";
                    var lines = _this2.quill.getLines(range.index, range.length);
                    if (lines.length === 1) {
                      _this2.position(_this2.quill.getBounds(range));
                    } else {
                      var lastLine = lines[lines.length - 1];
                      var index3 = _this2.quill.getIndex(lastLine);
                      var length2 = Math.min(lastLine.length() - 1, range.index + range.length - index3);
                      var _bounds = _this2.quill.getBounds(new _selection.Range(index3, length2));
                      _this2.position(_bounds);
                    }
                  } else if (document.activeElement !== _this2.textbox && _this2.quill.hasFocus()) {
                    _this2.hide();
                  }
                });
                return _this2;
              }
              _createClass(BubbleTooltip2, [{
                key: "listen",
                value: function listen() {
                  var _this3 = this;
                  _get(BubbleTooltip2.prototype.__proto__ || Object.getPrototypeOf(BubbleTooltip2.prototype), "listen", this).call(this);
                  this.root.querySelector(".ql-close").addEventListener("click", function() {
                    _this3.root.classList.remove("ql-editing");
                  });
                  this.quill.on(_emitter2.default.events.SCROLL_OPTIMIZE, function() {
                    setTimeout(function() {
                      if (_this3.root.classList.contains("ql-hidden"))
                        return;
                      var range = _this3.quill.getSelection();
                      if (range != null) {
                        _this3.position(_this3.quill.getBounds(range));
                      }
                    }, 1);
                  });
                }
              }, {
                key: "cancel",
                value: function cancel() {
                  this.show();
                }
              }, {
                key: "position",
                value: function position3(reference2) {
                  var shift = _get(BubbleTooltip2.prototype.__proto__ || Object.getPrototypeOf(BubbleTooltip2.prototype), "position", this).call(this, reference2);
                  var arrow = this.root.querySelector(".ql-tooltip-arrow");
                  arrow.style.marginLeft = "";
                  if (shift === 0)
                    return shift;
                  arrow.style.marginLeft = -1 * shift - arrow.offsetWidth / 2 + "px";
                }
              }]);
              return BubbleTooltip2;
            }(_base.BaseTooltip);
            BubbleTooltip.TEMPLATE = ['<span class="ql-tooltip-arrow"></span>', '<div class="ql-tooltip-editor">', '<input type="text" data-formula="e=mc^2" data-link="https://quilljs.com" data-video="Embed URL">', '<a class="ql-close"></a>', "</div>"].join("");
            exports2.BubbleTooltip = BubbleTooltip;
            exports2.default = BubbleTheme;
          },
          /* 109 */
          /***/
          function(module2, exports2, __webpack_require__) {
            module2.exports = __webpack_require__(63);
          }
          /******/
        ])["default"]
      );
    });
  }
});

// ../simple-mind-map/node_modules/fast-diff/diff.js
var require_diff = __commonJS({
  "../simple-mind-map/node_modules/fast-diff/diff.js"(exports, module) {
    var DIFF_DELETE = -1;
    var DIFF_INSERT = 1;
    var DIFF_EQUAL = 0;
    function diff_main(text1, text22, cursor_pos) {
      if (text1 == text22) {
        if (text1) {
          return [[DIFF_EQUAL, text1]];
        }
        return [];
      }
      if (cursor_pos < 0 || text1.length < cursor_pos) {
        cursor_pos = null;
      }
      var commonlength = diff_commonPrefix(text1, text22);
      var commonprefix = text1.substring(0, commonlength);
      text1 = text1.substring(commonlength);
      text22 = text22.substring(commonlength);
      commonlength = diff_commonSuffix(text1, text22);
      var commonsuffix = text1.substring(text1.length - commonlength);
      text1 = text1.substring(0, text1.length - commonlength);
      text22 = text22.substring(0, text22.length - commonlength);
      var diffs = diff_compute_(text1, text22);
      if (commonprefix) {
        diffs.unshift([DIFF_EQUAL, commonprefix]);
      }
      if (commonsuffix) {
        diffs.push([DIFF_EQUAL, commonsuffix]);
      }
      diff_cleanupMerge(diffs);
      if (cursor_pos != null) {
        diffs = fix_cursor(diffs, cursor_pos);
      }
      diffs = fix_emoji(diffs);
      return diffs;
    }
    function diff_compute_(text1, text22) {
      var diffs;
      if (!text1) {
        return [[DIFF_INSERT, text22]];
      }
      if (!text22) {
        return [[DIFF_DELETE, text1]];
      }
      var longtext = text1.length > text22.length ? text1 : text22;
      var shorttext = text1.length > text22.length ? text22 : text1;
      var i2 = longtext.indexOf(shorttext);
      if (i2 != -1) {
        diffs = [
          [DIFF_INSERT, longtext.substring(0, i2)],
          [DIFF_EQUAL, shorttext],
          [DIFF_INSERT, longtext.substring(i2 + shorttext.length)]
        ];
        if (text1.length > text22.length) {
          diffs[0][0] = diffs[2][0] = DIFF_DELETE;
        }
        return diffs;
      }
      if (shorttext.length == 1) {
        return [[DIFF_DELETE, text1], [DIFF_INSERT, text22]];
      }
      var hm = diff_halfMatch_(text1, text22);
      if (hm) {
        var text1_a = hm[0];
        var text1_b = hm[1];
        var text2_a = hm[2];
        var text2_b = hm[3];
        var mid_common = hm[4];
        var diffs_a = diff_main(text1_a, text2_a);
        var diffs_b = diff_main(text1_b, text2_b);
        return diffs_a.concat([[DIFF_EQUAL, mid_common]], diffs_b);
      }
      return diff_bisect_(text1, text22);
    }
    function diff_bisect_(text1, text22) {
      var text1_length = text1.length;
      var text2_length = text22.length;
      var max_d = Math.ceil((text1_length + text2_length) / 2);
      var v_offset = max_d;
      var v_length = 2 * max_d;
      var v1 = new Array(v_length);
      var v2 = new Array(v_length);
      for (var x2 = 0; x2 < v_length; x2++) {
        v1[x2] = -1;
        v2[x2] = -1;
      }
      v1[v_offset + 1] = 0;
      v2[v_offset + 1] = 0;
      var delta = text1_length - text2_length;
      var front2 = delta % 2 != 0;
      var k1start = 0;
      var k1end = 0;
      var k2start = 0;
      var k2end = 0;
      for (var d = 0; d < max_d; d++) {
        for (var k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {
          var k1_offset = v_offset + k1;
          var x1;
          if (k1 == -d || k1 != d && v1[k1_offset - 1] < v1[k1_offset + 1]) {
            x1 = v1[k1_offset + 1];
          } else {
            x1 = v1[k1_offset - 1] + 1;
          }
          var y1 = x1 - k1;
          while (x1 < text1_length && y1 < text2_length && text1.charAt(x1) == text22.charAt(y1)) {
            x1++;
            y1++;
          }
          v1[k1_offset] = x1;
          if (x1 > text1_length) {
            k1end += 2;
          } else if (y1 > text2_length) {
            k1start += 2;
          } else if (front2) {
            var k2_offset = v_offset + delta - k1;
            if (k2_offset >= 0 && k2_offset < v_length && v2[k2_offset] != -1) {
              var x22 = text1_length - v2[k2_offset];
              if (x1 >= x22) {
                return diff_bisectSplit_(text1, text22, x1, y1);
              }
            }
          }
        }
        for (var k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {
          var k2_offset = v_offset + k2;
          var x22;
          if (k2 == -d || k2 != d && v2[k2_offset - 1] < v2[k2_offset + 1]) {
            x22 = v2[k2_offset + 1];
          } else {
            x22 = v2[k2_offset - 1] + 1;
          }
          var y22 = x22 - k2;
          while (x22 < text1_length && y22 < text2_length && text1.charAt(text1_length - x22 - 1) == text22.charAt(text2_length - y22 - 1)) {
            x22++;
            y22++;
          }
          v2[k2_offset] = x22;
          if (x22 > text1_length) {
            k2end += 2;
          } else if (y22 > text2_length) {
            k2start += 2;
          } else if (!front2) {
            var k1_offset = v_offset + delta - k2;
            if (k1_offset >= 0 && k1_offset < v_length && v1[k1_offset] != -1) {
              var x1 = v1[k1_offset];
              var y1 = v_offset + x1 - k1_offset;
              x22 = text1_length - x22;
              if (x1 >= x22) {
                return diff_bisectSplit_(text1, text22, x1, y1);
              }
            }
          }
        }
      }
      return [[DIFF_DELETE, text1], [DIFF_INSERT, text22]];
    }
    function diff_bisectSplit_(text1, text22, x2, y3) {
      var text1a = text1.substring(0, x2);
      var text2a = text22.substring(0, y3);
      var text1b = text1.substring(x2);
      var text2b = text22.substring(y3);
      var diffs = diff_main(text1a, text2a);
      var diffsb = diff_main(text1b, text2b);
      return diffs.concat(diffsb);
    }
    function diff_commonPrefix(text1, text22) {
      if (!text1 || !text22 || text1.charAt(0) != text22.charAt(0)) {
        return 0;
      }
      var pointermin = 0;
      var pointermax = Math.min(text1.length, text22.length);
      var pointermid = pointermax;
      var pointerstart = 0;
      while (pointermin < pointermid) {
        if (text1.substring(pointerstart, pointermid) == text22.substring(pointerstart, pointermid)) {
          pointermin = pointermid;
          pointerstart = pointermin;
        } else {
          pointermax = pointermid;
        }
        pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
      }
      return pointermid;
    }
    function diff_commonSuffix(text1, text22) {
      if (!text1 || !text22 || text1.charAt(text1.length - 1) != text22.charAt(text22.length - 1)) {
        return 0;
      }
      var pointermin = 0;
      var pointermax = Math.min(text1.length, text22.length);
      var pointermid = pointermax;
      var pointerend = 0;
      while (pointermin < pointermid) {
        if (text1.substring(text1.length - pointermid, text1.length - pointerend) == text22.substring(text22.length - pointermid, text22.length - pointerend)) {
          pointermin = pointermid;
          pointerend = pointermin;
        } else {
          pointermax = pointermid;
        }
        pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
      }
      return pointermid;
    }
    function diff_halfMatch_(text1, text22) {
      var longtext = text1.length > text22.length ? text1 : text22;
      var shorttext = text1.length > text22.length ? text22 : text1;
      if (longtext.length < 4 || shorttext.length * 2 < longtext.length) {
        return null;
      }
      function diff_halfMatchI_(longtext2, shorttext2, i2) {
        var seed = longtext2.substring(i2, i2 + Math.floor(longtext2.length / 4));
        var j = -1;
        var best_common = "";
        var best_longtext_a, best_longtext_b, best_shorttext_a, best_shorttext_b;
        while ((j = shorttext2.indexOf(seed, j + 1)) != -1) {
          var prefixLength = diff_commonPrefix(
            longtext2.substring(i2),
            shorttext2.substring(j)
          );
          var suffixLength = diff_commonSuffix(
            longtext2.substring(0, i2),
            shorttext2.substring(0, j)
          );
          if (best_common.length < suffixLength + prefixLength) {
            best_common = shorttext2.substring(j - suffixLength, j) + shorttext2.substring(j, j + prefixLength);
            best_longtext_a = longtext2.substring(0, i2 - suffixLength);
            best_longtext_b = longtext2.substring(i2 + prefixLength);
            best_shorttext_a = shorttext2.substring(0, j - suffixLength);
            best_shorttext_b = shorttext2.substring(j + prefixLength);
          }
        }
        if (best_common.length * 2 >= longtext2.length) {
          return [
            best_longtext_a,
            best_longtext_b,
            best_shorttext_a,
            best_shorttext_b,
            best_common
          ];
        } else {
          return null;
        }
      }
      var hm1 = diff_halfMatchI_(
        longtext,
        shorttext,
        Math.ceil(longtext.length / 4)
      );
      var hm2 = diff_halfMatchI_(
        longtext,
        shorttext,
        Math.ceil(longtext.length / 2)
      );
      var hm;
      if (!hm1 && !hm2) {
        return null;
      } else if (!hm2) {
        hm = hm1;
      } else if (!hm1) {
        hm = hm2;
      } else {
        hm = hm1[4].length > hm2[4].length ? hm1 : hm2;
      }
      var text1_a, text1_b, text2_a, text2_b;
      if (text1.length > text22.length) {
        text1_a = hm[0];
        text1_b = hm[1];
        text2_a = hm[2];
        text2_b = hm[3];
      } else {
        text2_a = hm[0];
        text2_b = hm[1];
        text1_a = hm[2];
        text1_b = hm[3];
      }
      var mid_common = hm[4];
      return [text1_a, text1_b, text2_a, text2_b, mid_common];
    }
    function diff_cleanupMerge(diffs) {
      diffs.push([DIFF_EQUAL, ""]);
      var pointer = 0;
      var count_delete = 0;
      var count_insert = 0;
      var text_delete = "";
      var text_insert = "";
      var commonlength;
      while (pointer < diffs.length) {
        switch (diffs[pointer][0]) {
          case DIFF_INSERT:
            count_insert++;
            text_insert += diffs[pointer][1];
            pointer++;
            break;
          case DIFF_DELETE:
            count_delete++;
            text_delete += diffs[pointer][1];
            pointer++;
            break;
          case DIFF_EQUAL:
            if (count_delete + count_insert > 1) {
              if (count_delete !== 0 && count_insert !== 0) {
                commonlength = diff_commonPrefix(text_insert, text_delete);
                if (commonlength !== 0) {
                  if (pointer - count_delete - count_insert > 0 && diffs[pointer - count_delete - count_insert - 1][0] == DIFF_EQUAL) {
                    diffs[pointer - count_delete - count_insert - 1][1] += text_insert.substring(0, commonlength);
                  } else {
                    diffs.splice(0, 0, [
                      DIFF_EQUAL,
                      text_insert.substring(0, commonlength)
                    ]);
                    pointer++;
                  }
                  text_insert = text_insert.substring(commonlength);
                  text_delete = text_delete.substring(commonlength);
                }
                commonlength = diff_commonSuffix(text_insert, text_delete);
                if (commonlength !== 0) {
                  diffs[pointer][1] = text_insert.substring(text_insert.length - commonlength) + diffs[pointer][1];
                  text_insert = text_insert.substring(0, text_insert.length - commonlength);
                  text_delete = text_delete.substring(0, text_delete.length - commonlength);
                }
              }
              if (count_delete === 0) {
                diffs.splice(
                  pointer - count_insert,
                  count_delete + count_insert,
                  [DIFF_INSERT, text_insert]
                );
              } else if (count_insert === 0) {
                diffs.splice(
                  pointer - count_delete,
                  count_delete + count_insert,
                  [DIFF_DELETE, text_delete]
                );
              } else {
                diffs.splice(
                  pointer - count_delete - count_insert,
                  count_delete + count_insert,
                  [DIFF_DELETE, text_delete],
                  [DIFF_INSERT, text_insert]
                );
              }
              pointer = pointer - count_delete - count_insert + (count_delete ? 1 : 0) + (count_insert ? 1 : 0) + 1;
            } else if (pointer !== 0 && diffs[pointer - 1][0] == DIFF_EQUAL) {
              diffs[pointer - 1][1] += diffs[pointer][1];
              diffs.splice(pointer, 1);
            } else {
              pointer++;
            }
            count_insert = 0;
            count_delete = 0;
            text_delete = "";
            text_insert = "";
            break;
        }
      }
      if (diffs[diffs.length - 1][1] === "") {
        diffs.pop();
      }
      var changes = false;
      pointer = 1;
      while (pointer < diffs.length - 1) {
        if (diffs[pointer - 1][0] == DIFF_EQUAL && diffs[pointer + 1][0] == DIFF_EQUAL) {
          if (diffs[pointer][1].substring(diffs[pointer][1].length - diffs[pointer - 1][1].length) == diffs[pointer - 1][1]) {
            diffs[pointer][1] = diffs[pointer - 1][1] + diffs[pointer][1].substring(0, diffs[pointer][1].length - diffs[pointer - 1][1].length);
            diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];
            diffs.splice(pointer - 1, 1);
            changes = true;
          } else if (diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) == diffs[pointer + 1][1]) {
            diffs[pointer - 1][1] += diffs[pointer + 1][1];
            diffs[pointer][1] = diffs[pointer][1].substring(diffs[pointer + 1][1].length) + diffs[pointer + 1][1];
            diffs.splice(pointer + 1, 1);
            changes = true;
          }
        }
        pointer++;
      }
      if (changes) {
        diff_cleanupMerge(diffs);
      }
    }
    var diff = diff_main;
    diff.INSERT = DIFF_INSERT;
    diff.DELETE = DIFF_DELETE;
    diff.EQUAL = DIFF_EQUAL;
    module.exports = diff;
    function cursor_normalize_diff(diffs, cursor_pos) {
      if (cursor_pos === 0) {
        return [DIFF_EQUAL, diffs];
      }
      for (var current_pos = 0, i2 = 0; i2 < diffs.length; i2++) {
        var d = diffs[i2];
        if (d[0] === DIFF_DELETE || d[0] === DIFF_EQUAL) {
          var next_pos = current_pos + d[1].length;
          if (cursor_pos === next_pos) {
            return [i2 + 1, diffs];
          } else if (cursor_pos < next_pos) {
            diffs = diffs.slice();
            var split_pos = cursor_pos - current_pos;
            var d_left = [d[0], d[1].slice(0, split_pos)];
            var d_right = [d[0], d[1].slice(split_pos)];
            diffs.splice(i2, 1, d_left, d_right);
            return [i2 + 1, diffs];
          } else {
            current_pos = next_pos;
          }
        }
      }
      throw new Error("cursor_pos is out of bounds!");
    }
    function fix_cursor(diffs, cursor_pos) {
      var norm = cursor_normalize_diff(diffs, cursor_pos);
      var ndiffs = norm[1];
      var cursor_pointer = norm[0];
      var d = ndiffs[cursor_pointer];
      var d_next = ndiffs[cursor_pointer + 1];
      if (d == null) {
        return diffs;
      } else if (d[0] !== DIFF_EQUAL) {
        return diffs;
      } else {
        if (d_next != null && d[1] + d_next[1] === d_next[1] + d[1]) {
          ndiffs.splice(cursor_pointer, 2, d_next, d);
          return merge_tuples(ndiffs, cursor_pointer, 2);
        } else if (d_next != null && d_next[1].indexOf(d[1]) === 0) {
          ndiffs.splice(cursor_pointer, 2, [d_next[0], d[1]], [0, d[1]]);
          var suffix = d_next[1].slice(d[1].length);
          if (suffix.length > 0) {
            ndiffs.splice(cursor_pointer + 2, 0, [d_next[0], suffix]);
          }
          return merge_tuples(ndiffs, cursor_pointer, 3);
        } else {
          return diffs;
        }
      }
    }
    function fix_emoji(diffs) {
      var compact = false;
      var starts_with_pair_end = function(str) {
        return str.charCodeAt(0) >= 56320 && str.charCodeAt(0) <= 57343;
      };
      var ends_with_pair_start = function(str) {
        return str.charCodeAt(str.length - 1) >= 55296 && str.charCodeAt(str.length - 1) <= 56319;
      };
      for (var i2 = 2; i2 < diffs.length; i2 += 1) {
        if (diffs[i2 - 2][0] === DIFF_EQUAL && ends_with_pair_start(diffs[i2 - 2][1]) && diffs[i2 - 1][0] === DIFF_DELETE && starts_with_pair_end(diffs[i2 - 1][1]) && diffs[i2][0] === DIFF_INSERT && starts_with_pair_end(diffs[i2][1])) {
          compact = true;
          diffs[i2 - 1][1] = diffs[i2 - 2][1].slice(-1) + diffs[i2 - 1][1];
          diffs[i2][1] = diffs[i2 - 2][1].slice(-1) + diffs[i2][1];
          diffs[i2 - 2][1] = diffs[i2 - 2][1].slice(0, -1);
        }
      }
      if (!compact) {
        return diffs;
      }
      var fixed_diffs = [];
      for (var i2 = 0; i2 < diffs.length; i2 += 1) {
        if (diffs[i2][1].length > 0) {
          fixed_diffs.push(diffs[i2]);
        }
      }
      return fixed_diffs;
    }
    function merge_tuples(diffs, start, length2) {
      for (var i2 = start + length2 - 1; i2 >= 0 && i2 >= start - 1; i2--) {
        if (i2 + 1 < diffs.length) {
          var left_d = diffs[i2];
          var right_d = diffs[i2 + 1];
          if (left_d[0] === right_d[1]) {
            diffs.splice(i2, 2, [left_d[0], left_d[1] + right_d[1]]);
          }
        }
      }
      return diffs;
    }
  }
});

// ../simple-mind-map/node_modules/object-keys/isArguments.js
var require_isArguments = __commonJS({
  "../simple-mind-map/node_modules/object-keys/isArguments.js"(exports, module) {
    "use strict";
    var toStr = Object.prototype.toString;
    module.exports = function isArguments(value) {
      var str = toStr.call(value);
      var isArgs = str === "[object Arguments]";
      if (!isArgs) {
        isArgs = str !== "[object Array]" && value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && toStr.call(value.callee) === "[object Function]";
      }
      return isArgs;
    };
  }
});

// ../simple-mind-map/node_modules/object-keys/implementation.js
var require_implementation = __commonJS({
  "../simple-mind-map/node_modules/object-keys/implementation.js"(exports, module) {
    "use strict";
    var keysShim;
    if (!Object.keys) {
      has = Object.prototype.hasOwnProperty;
      toStr = Object.prototype.toString;
      isArgs = require_isArguments();
      isEnumerable = Object.prototype.propertyIsEnumerable;
      hasDontEnumBug = !isEnumerable.call({ toString: null }, "toString");
      hasProtoEnumBug = isEnumerable.call(function() {
      }, "prototype");
      dontEnums = [
        "toString",
        "toLocaleString",
        "valueOf",
        "hasOwnProperty",
        "isPrototypeOf",
        "propertyIsEnumerable",
        "constructor"
      ];
      equalsConstructorPrototype = function(o2) {
        var ctor = o2.constructor;
        return ctor && ctor.prototype === o2;
      };
      excludedKeys = {
        $applicationCache: true,
        $console: true,
        $external: true,
        $frame: true,
        $frameElement: true,
        $frames: true,
        $innerHeight: true,
        $innerWidth: true,
        $onmozfullscreenchange: true,
        $onmozfullscreenerror: true,
        $outerHeight: true,
        $outerWidth: true,
        $pageXOffset: true,
        $pageYOffset: true,
        $parent: true,
        $scrollLeft: true,
        $scrollTop: true,
        $scrollX: true,
        $scrollY: true,
        $self: true,
        $webkitIndexedDB: true,
        $webkitStorageInfo: true,
        $window: true
      };
      hasAutomationEqualityBug = function() {
        if (typeof window === "undefined") {
          return false;
        }
        for (var k in window) {
          try {
            if (!excludedKeys["$" + k] && has.call(window, k) && window[k] !== null && typeof window[k] === "object") {
              try {
                equalsConstructorPrototype(window[k]);
              } catch (e2) {
                return true;
              }
            }
          } catch (e2) {
            return true;
          }
        }
        return false;
      }();
      equalsConstructorPrototypeIfNotBuggy = function(o2) {
        if (typeof window === "undefined" || !hasAutomationEqualityBug) {
          return equalsConstructorPrototype(o2);
        }
        try {
          return equalsConstructorPrototype(o2);
        } catch (e2) {
          return false;
        }
      };
      keysShim = function keys(object) {
        var isObject = object !== null && typeof object === "object";
        var isFunction = toStr.call(object) === "[object Function]";
        var isArguments = isArgs(object);
        var isString = isObject && toStr.call(object) === "[object String]";
        var theKeys = [];
        if (!isObject && !isFunction && !isArguments) {
          throw new TypeError("Object.keys called on a non-object");
        }
        var skipProto = hasProtoEnumBug && isFunction;
        if (isString && object.length > 0 && !has.call(object, 0)) {
          for (var i2 = 0; i2 < object.length; ++i2) {
            theKeys.push(String(i2));
          }
        }
        if (isArguments && object.length > 0) {
          for (var j = 0; j < object.length; ++j) {
            theKeys.push(String(j));
          }
        } else {
          for (var name in object) {
            if (!(skipProto && name === "prototype") && has.call(object, name)) {
              theKeys.push(String(name));
            }
          }
        }
        if (hasDontEnumBug) {
          var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);
          for (var k = 0; k < dontEnums.length; ++k) {
            if (!(skipConstructor && dontEnums[k] === "constructor") && has.call(object, dontEnums[k])) {
              theKeys.push(dontEnums[k]);
            }
          }
        }
        return theKeys;
      };
    }
    var has;
    var toStr;
    var isArgs;
    var isEnumerable;
    var hasDontEnumBug;
    var hasProtoEnumBug;
    var dontEnums;
    var equalsConstructorPrototype;
    var excludedKeys;
    var hasAutomationEqualityBug;
    var equalsConstructorPrototypeIfNotBuggy;
    module.exports = keysShim;
  }
});

// ../simple-mind-map/node_modules/object-keys/index.js
var require_object_keys2 = __commonJS({
  "../simple-mind-map/node_modules/object-keys/index.js"(exports, module) {
    "use strict";
    var slice = Array.prototype.slice;
    var isArgs = require_isArguments();
    var origKeys = Object.keys;
    var keysShim = origKeys ? function keys(o2) {
      return origKeys(o2);
    } : require_implementation();
    var originalKeys = Object.keys;
    keysShim.shim = function shimObjectKeys() {
      if (Object.keys) {
        var keysWorksWithArguments = function() {
          var args = Object.keys(arguments);
          return args && args.length === arguments.length;
        }(1, 2);
        if (!keysWorksWithArguments) {
          Object.keys = function keys(object) {
            if (isArgs(object)) {
              return originalKeys(slice.call(object));
            }
            return originalKeys(object);
          };
        }
      } else {
        Object.keys = keysShim;
      }
      return Object.keys || keysShim;
    };
    module.exports = keysShim;
  }
});

// ../simple-mind-map/node_modules/has-symbols/shams.js
var require_shams = __commonJS({
  "../simple-mind-map/node_modules/has-symbols/shams.js"(exports, module) {
    "use strict";
    module.exports = function hasSymbols() {
      if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
        return false;
      }
      if (typeof Symbol.iterator === "symbol") {
        return true;
      }
      var obj = {};
      var sym = Symbol("test");
      var symObj = Object(sym);
      if (typeof sym === "string") {
        return false;
      }
      if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
        return false;
      }
      if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
        return false;
      }
      var symVal = 42;
      obj[sym] = symVal;
      for (sym in obj) {
        return false;
      }
      if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
        return false;
      }
      if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
        return false;
      }
      var syms = Object.getOwnPropertySymbols(obj);
      if (syms.length !== 1 || syms[0] !== sym) {
        return false;
      }
      if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
        return false;
      }
      if (typeof Object.getOwnPropertyDescriptor === "function") {
        var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
        if (descriptor.value !== symVal || descriptor.enumerable !== true) {
          return false;
        }
      }
      return true;
    };
  }
});

// ../simple-mind-map/node_modules/has-tostringtag/shams.js
var require_shams2 = __commonJS({
  "../simple-mind-map/node_modules/has-tostringtag/shams.js"(exports, module) {
    "use strict";
    var hasSymbols = require_shams();
    module.exports = function hasToStringTagShams() {
      return hasSymbols() && !!Symbol.toStringTag;
    };
  }
});

// ../simple-mind-map/node_modules/has-symbols/index.js
var require_has_symbols = __commonJS({
  "../simple-mind-map/node_modules/has-symbols/index.js"(exports, module) {
    "use strict";
    var origSymbol = typeof Symbol !== "undefined" && Symbol;
    var hasSymbolSham = require_shams();
    module.exports = function hasNativeSymbols() {
      if (typeof origSymbol !== "function") {
        return false;
      }
      if (typeof Symbol !== "function") {
        return false;
      }
      if (typeof origSymbol("foo") !== "symbol") {
        return false;
      }
      if (typeof Symbol("bar") !== "symbol") {
        return false;
      }
      return hasSymbolSham();
    };
  }
});

// ../simple-mind-map/node_modules/function-bind/implementation.js
var require_implementation2 = __commonJS({
  "../simple-mind-map/node_modules/function-bind/implementation.js"(exports, module) {
    "use strict";
    var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
    var slice = Array.prototype.slice;
    var toStr = Object.prototype.toString;
    var funcType = "[object Function]";
    module.exports = function bind(that) {
      var target = this;
      if (typeof target !== "function" || toStr.call(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
      }
      var args = slice.call(arguments, 1);
      var bound;
      var binder = function() {
        if (this instanceof bound) {
          var result = target.apply(
            this,
            args.concat(slice.call(arguments))
          );
          if (Object(result) === result) {
            return result;
          }
          return this;
        } else {
          return target.apply(
            that,
            args.concat(slice.call(arguments))
          );
        }
      };
      var boundLength = Math.max(0, target.length - args.length);
      var boundArgs = [];
      for (var i2 = 0; i2 < boundLength; i2++) {
        boundArgs.push("$" + i2);
      }
      bound = Function("binder", "return function (" + boundArgs.join(",") + "){ return binder.apply(this,arguments); }")(binder);
      if (target.prototype) {
        var Empty = function Empty2() {
        };
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
      }
      return bound;
    };
  }
});

// ../simple-mind-map/node_modules/function-bind/index.js
var require_function_bind = __commonJS({
  "../simple-mind-map/node_modules/function-bind/index.js"(exports, module) {
    "use strict";
    var implementation = require_implementation2();
    module.exports = Function.prototype.bind || implementation;
  }
});

// ../simple-mind-map/node_modules/has/src/index.js
var require_src = __commonJS({
  "../simple-mind-map/node_modules/has/src/index.js"(exports, module) {
    "use strict";
    var bind = require_function_bind();
    module.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);
  }
});

// ../simple-mind-map/node_modules/get-intrinsic/index.js
var require_get_intrinsic = __commonJS({
  "../simple-mind-map/node_modules/get-intrinsic/index.js"(exports, module) {
    "use strict";
    var undefined2;
    var $SyntaxError = SyntaxError;
    var $Function = Function;
    var $TypeError = TypeError;
    var getEvalledConstructor = function(expressionSyntax) {
      try {
        return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
      } catch (e2) {
      }
    };
    var $gOPD = Object.getOwnPropertyDescriptor;
    if ($gOPD) {
      try {
        $gOPD({}, "");
      } catch (e2) {
        $gOPD = null;
      }
    }
    var throwTypeError = function() {
      throw new $TypeError();
    };
    var ThrowTypeError = $gOPD ? function() {
      try {
        arguments.callee;
        return throwTypeError;
      } catch (calleeThrows) {
        try {
          return $gOPD(arguments, "callee").get;
        } catch (gOPDthrows) {
          return throwTypeError;
        }
      }
    }() : throwTypeError;
    var hasSymbols = require_has_symbols()();
    var getProto = Object.getPrototypeOf || function(x2) {
      return x2.__proto__;
    };
    var needsEval = {};
    var TypedArray = typeof Uint8Array === "undefined" ? undefined2 : getProto(Uint8Array);
    var INTRINSICS = {
      "%AggregateError%": typeof AggregateError === "undefined" ? undefined2 : AggregateError,
      "%Array%": Array,
      "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined2 : ArrayBuffer,
      "%ArrayIteratorPrototype%": hasSymbols ? getProto([][Symbol.iterator]()) : undefined2,
      "%AsyncFromSyncIteratorPrototype%": undefined2,
      "%AsyncFunction%": needsEval,
      "%AsyncGenerator%": needsEval,
      "%AsyncGeneratorFunction%": needsEval,
      "%AsyncIteratorPrototype%": needsEval,
      "%Atomics%": typeof Atomics === "undefined" ? undefined2 : Atomics,
      "%BigInt%": typeof BigInt === "undefined" ? undefined2 : BigInt,
      "%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined2 : BigInt64Array,
      "%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined2 : BigUint64Array,
      "%Boolean%": Boolean,
      "%DataView%": typeof DataView === "undefined" ? undefined2 : DataView,
      "%Date%": Date,
      "%decodeURI%": decodeURI,
      "%decodeURIComponent%": decodeURIComponent,
      "%encodeURI%": encodeURI,
      "%encodeURIComponent%": encodeURIComponent,
      "%Error%": Error,
      "%eval%": eval,
      // eslint-disable-line no-eval
      "%EvalError%": EvalError,
      "%Float32Array%": typeof Float32Array === "undefined" ? undefined2 : Float32Array,
      "%Float64Array%": typeof Float64Array === "undefined" ? undefined2 : Float64Array,
      "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined2 : FinalizationRegistry,
      "%Function%": $Function,
      "%GeneratorFunction%": needsEval,
      "%Int8Array%": typeof Int8Array === "undefined" ? undefined2 : Int8Array,
      "%Int16Array%": typeof Int16Array === "undefined" ? undefined2 : Int16Array,
      "%Int32Array%": typeof Int32Array === "undefined" ? undefined2 : Int32Array,
      "%isFinite%": isFinite,
      "%isNaN%": isNaN,
      "%IteratorPrototype%": hasSymbols ? getProto(getProto([][Symbol.iterator]())) : undefined2,
      "%JSON%": typeof JSON === "object" ? JSON : undefined2,
      "%Map%": typeof Map === "undefined" ? undefined2 : Map,
      "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols ? undefined2 : getProto((/* @__PURE__ */ new Map())[Symbol.iterator]()),
      "%Math%": Math,
      "%Number%": Number,
      "%Object%": Object,
      "%parseFloat%": parseFloat,
      "%parseInt%": parseInt,
      "%Promise%": typeof Promise === "undefined" ? undefined2 : Promise,
      "%Proxy%": typeof Proxy === "undefined" ? undefined2 : Proxy,
      "%RangeError%": RangeError,
      "%ReferenceError%": ReferenceError,
      "%Reflect%": typeof Reflect === "undefined" ? undefined2 : Reflect,
      "%RegExp%": RegExp,
      "%Set%": typeof Set === "undefined" ? undefined2 : Set,
      "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols ? undefined2 : getProto((/* @__PURE__ */ new Set())[Symbol.iterator]()),
      "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined2 : SharedArrayBuffer,
      "%String%": String,
      "%StringIteratorPrototype%": hasSymbols ? getProto(""[Symbol.iterator]()) : undefined2,
      "%Symbol%": hasSymbols ? Symbol : undefined2,
      "%SyntaxError%": $SyntaxError,
      "%ThrowTypeError%": ThrowTypeError,
      "%TypedArray%": TypedArray,
      "%TypeError%": $TypeError,
      "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined2 : Uint8Array,
      "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined2 : Uint8ClampedArray,
      "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined2 : Uint16Array,
      "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined2 : Uint32Array,
      "%URIError%": URIError,
      "%WeakMap%": typeof WeakMap === "undefined" ? undefined2 : WeakMap,
      "%WeakRef%": typeof WeakRef === "undefined" ? undefined2 : WeakRef,
      "%WeakSet%": typeof WeakSet === "undefined" ? undefined2 : WeakSet
    };
    try {
      null.error;
    } catch (e2) {
      errorProto = getProto(getProto(e2));
      INTRINSICS["%Error.prototype%"] = errorProto;
    }
    var errorProto;
    var doEval = function doEval2(name) {
      var value;
      if (name === "%AsyncFunction%") {
        value = getEvalledConstructor("async function () {}");
      } else if (name === "%GeneratorFunction%") {
        value = getEvalledConstructor("function* () {}");
      } else if (name === "%AsyncGeneratorFunction%") {
        value = getEvalledConstructor("async function* () {}");
      } else if (name === "%AsyncGenerator%") {
        var fn = doEval2("%AsyncGeneratorFunction%");
        if (fn) {
          value = fn.prototype;
        }
      } else if (name === "%AsyncIteratorPrototype%") {
        var gen = doEval2("%AsyncGenerator%");
        if (gen) {
          value = getProto(gen.prototype);
        }
      }
      INTRINSICS[name] = value;
      return value;
    };
    var LEGACY_ALIASES = {
      "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
      "%ArrayPrototype%": ["Array", "prototype"],
      "%ArrayProto_entries%": ["Array", "prototype", "entries"],
      "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
      "%ArrayProto_keys%": ["Array", "prototype", "keys"],
      "%ArrayProto_values%": ["Array", "prototype", "values"],
      "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
      "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
      "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
      "%BooleanPrototype%": ["Boolean", "prototype"],
      "%DataViewPrototype%": ["DataView", "prototype"],
      "%DatePrototype%": ["Date", "prototype"],
      "%ErrorPrototype%": ["Error", "prototype"],
      "%EvalErrorPrototype%": ["EvalError", "prototype"],
      "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
      "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
      "%FunctionPrototype%": ["Function", "prototype"],
      "%Generator%": ["GeneratorFunction", "prototype"],
      "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
      "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
      "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
      "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
      "%JSONParse%": ["JSON", "parse"],
      "%JSONStringify%": ["JSON", "stringify"],
      "%MapPrototype%": ["Map", "prototype"],
      "%NumberPrototype%": ["Number", "prototype"],
      "%ObjectPrototype%": ["Object", "prototype"],
      "%ObjProto_toString%": ["Object", "prototype", "toString"],
      "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
      "%PromisePrototype%": ["Promise", "prototype"],
      "%PromiseProto_then%": ["Promise", "prototype", "then"],
      "%Promise_all%": ["Promise", "all"],
      "%Promise_reject%": ["Promise", "reject"],
      "%Promise_resolve%": ["Promise", "resolve"],
      "%RangeErrorPrototype%": ["RangeError", "prototype"],
      "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
      "%RegExpPrototype%": ["RegExp", "prototype"],
      "%SetPrototype%": ["Set", "prototype"],
      "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
      "%StringPrototype%": ["String", "prototype"],
      "%SymbolPrototype%": ["Symbol", "prototype"],
      "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
      "%TypedArrayPrototype%": ["TypedArray", "prototype"],
      "%TypeErrorPrototype%": ["TypeError", "prototype"],
      "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
      "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
      "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
      "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
      "%URIErrorPrototype%": ["URIError", "prototype"],
      "%WeakMapPrototype%": ["WeakMap", "prototype"],
      "%WeakSetPrototype%": ["WeakSet", "prototype"]
    };
    var bind = require_function_bind();
    var hasOwn = require_src();
    var $concat = bind.call(Function.call, Array.prototype.concat);
    var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
    var $replace = bind.call(Function.call, String.prototype.replace);
    var $strSlice = bind.call(Function.call, String.prototype.slice);
    var $exec = bind.call(Function.call, RegExp.prototype.exec);
    var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
    var reEscapeChar = /\\(\\)?/g;
    var stringToPath = function stringToPath2(string3) {
      var first = $strSlice(string3, 0, 1);
      var last = $strSlice(string3, -1);
      if (first === "%" && last !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
      } else if (last === "%" && first !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
      }
      var result = [];
      $replace(string3, rePropName, function(match, number, quote, subString) {
        result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number || match;
      });
      return result;
    };
    var getBaseIntrinsic = function getBaseIntrinsic2(name, allowMissing) {
      var intrinsicName = name;
      var alias;
      if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
        alias = LEGACY_ALIASES[intrinsicName];
        intrinsicName = "%" + alias[0] + "%";
      }
      if (hasOwn(INTRINSICS, intrinsicName)) {
        var value = INTRINSICS[intrinsicName];
        if (value === needsEval) {
          value = doEval(intrinsicName);
        }
        if (typeof value === "undefined" && !allowMissing) {
          throw new $TypeError("intrinsic " + name + " exists, but is not available. Please file an issue!");
        }
        return {
          alias,
          name: intrinsicName,
          value
        };
      }
      throw new $SyntaxError("intrinsic " + name + " does not exist!");
    };
    module.exports = function GetIntrinsic(name, allowMissing) {
      if (typeof name !== "string" || name.length === 0) {
        throw new $TypeError("intrinsic name must be a non-empty string");
      }
      if (arguments.length > 1 && typeof allowMissing !== "boolean") {
        throw new $TypeError('"allowMissing" argument must be a boolean');
      }
      if ($exec(/^%?[^%]*%?$/, name) === null) {
        throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
      }
      var parts = stringToPath(name);
      var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
      var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
      var intrinsicRealName = intrinsic.name;
      var value = intrinsic.value;
      var skipFurtherCaching = false;
      var alias = intrinsic.alias;
      if (alias) {
        intrinsicBaseName = alias[0];
        $spliceApply(parts, $concat([0, 1], alias));
      }
      for (var i2 = 1, isOwn = true; i2 < parts.length; i2 += 1) {
        var part = parts[i2];
        var first = $strSlice(part, 0, 1);
        var last = $strSlice(part, -1);
        if ((first === '"' || first === "'" || first === "`" || (last === '"' || last === "'" || last === "`")) && first !== last) {
          throw new $SyntaxError("property names with quotes must have matching quotes");
        }
        if (part === "constructor" || !isOwn) {
          skipFurtherCaching = true;
        }
        intrinsicBaseName += "." + part;
        intrinsicRealName = "%" + intrinsicBaseName + "%";
        if (hasOwn(INTRINSICS, intrinsicRealName)) {
          value = INTRINSICS[intrinsicRealName];
        } else if (value != null) {
          if (!(part in value)) {
            if (!allowMissing) {
              throw new $TypeError("base intrinsic for " + name + " exists, but the property is not available.");
            }
            return void 0;
          }
          if ($gOPD && i2 + 1 >= parts.length) {
            var desc = $gOPD(value, part);
            isOwn = !!desc;
            if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
              value = desc.get;
            } else {
              value = value[part];
            }
          } else {
            isOwn = hasOwn(value, part);
            value = value[part];
          }
          if (isOwn && !skipFurtherCaching) {
            INTRINSICS[intrinsicRealName] = value;
          }
        }
      }
      return value;
    };
  }
});

// ../simple-mind-map/node_modules/call-bind/index.js
var require_call_bind = __commonJS({
  "../simple-mind-map/node_modules/call-bind/index.js"(exports, module) {
    "use strict";
    var bind = require_function_bind();
    var GetIntrinsic = require_get_intrinsic();
    var $apply = GetIntrinsic("%Function.prototype.apply%");
    var $call = GetIntrinsic("%Function.prototype.call%");
    var $reflectApply = GetIntrinsic("%Reflect.apply%", true) || bind.call($call, $apply);
    var $gOPD = GetIntrinsic("%Object.getOwnPropertyDescriptor%", true);
    var $defineProperty = GetIntrinsic("%Object.defineProperty%", true);
    var $max = GetIntrinsic("%Math.max%");
    if ($defineProperty) {
      try {
        $defineProperty({}, "a", { value: 1 });
      } catch (e2) {
        $defineProperty = null;
      }
    }
    module.exports = function callBind(originalFunction) {
      var func = $reflectApply(bind, $call, arguments);
      if ($gOPD && $defineProperty) {
        var desc = $gOPD(func, "length");
        if (desc.configurable) {
          $defineProperty(
            func,
            "length",
            { value: 1 + $max(0, originalFunction.length - (arguments.length - 1)) }
          );
        }
      }
      return func;
    };
    var applyBind = function applyBind2() {
      return $reflectApply(bind, $apply, arguments);
    };
    if ($defineProperty) {
      $defineProperty(module.exports, "apply", { value: applyBind });
    } else {
      module.exports.apply = applyBind;
    }
  }
});

// ../simple-mind-map/node_modules/call-bind/callBound.js
var require_callBound = __commonJS({
  "../simple-mind-map/node_modules/call-bind/callBound.js"(exports, module) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var callBind = require_call_bind();
    var $indexOf = callBind(GetIntrinsic("String.prototype.indexOf"));
    module.exports = function callBoundIntrinsic(name, allowMissing) {
      var intrinsic = GetIntrinsic(name, !!allowMissing);
      if (typeof intrinsic === "function" && $indexOf(name, ".prototype.") > -1) {
        return callBind(intrinsic);
      }
      return intrinsic;
    };
  }
});

// ../simple-mind-map/node_modules/is-arguments/index.js
var require_is_arguments = __commonJS({
  "../simple-mind-map/node_modules/is-arguments/index.js"(exports, module) {
    "use strict";
    var hasToStringTag = require_shams2()();
    var callBound = require_callBound();
    var $toString = callBound("Object.prototype.toString");
    var isStandardArguments = function isArguments(value) {
      if (hasToStringTag && value && typeof value === "object" && Symbol.toStringTag in value) {
        return false;
      }
      return $toString(value) === "[object Arguments]";
    };
    var isLegacyArguments = function isArguments(value) {
      if (isStandardArguments(value)) {
        return true;
      }
      return value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && $toString(value) !== "[object Array]" && $toString(value.callee) === "[object Function]";
    };
    var supportsStandardArguments = function() {
      return isStandardArguments(arguments);
    }();
    isStandardArguments.isLegacyArguments = isLegacyArguments;
    module.exports = supportsStandardArguments ? isStandardArguments : isLegacyArguments;
  }
});

// ../simple-mind-map/node_modules/has-property-descriptors/index.js
var require_has_property_descriptors = __commonJS({
  "../simple-mind-map/node_modules/has-property-descriptors/index.js"(exports, module) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var $defineProperty = GetIntrinsic("%Object.defineProperty%", true);
    var hasPropertyDescriptors = function hasPropertyDescriptors2() {
      if ($defineProperty) {
        try {
          $defineProperty({}, "a", { value: 1 });
          return true;
        } catch (e2) {
          return false;
        }
      }
      return false;
    };
    hasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
      if (!hasPropertyDescriptors()) {
        return null;
      }
      try {
        return $defineProperty([], "length", { value: 1 }).length !== 1;
      } catch (e2) {
        return true;
      }
    };
    module.exports = hasPropertyDescriptors;
  }
});

// ../simple-mind-map/node_modules/define-properties/index.js
var require_define_properties = __commonJS({
  "../simple-mind-map/node_modules/define-properties/index.js"(exports, module) {
    "use strict";
    var keys = require_object_keys2();
    var hasSymbols = typeof Symbol === "function" && typeof Symbol("foo") === "symbol";
    var toStr = Object.prototype.toString;
    var concat = Array.prototype.concat;
    var origDefineProperty = Object.defineProperty;
    var isFunction = function(fn) {
      return typeof fn === "function" && toStr.call(fn) === "[object Function]";
    };
    var hasPropertyDescriptors = require_has_property_descriptors()();
    var supportsDescriptors = origDefineProperty && hasPropertyDescriptors;
    var defineProperty = function(object, name, value, predicate) {
      if (name in object) {
        if (predicate === true) {
          if (object[name] === value) {
            return;
          }
        } else if (!isFunction(predicate) || !predicate()) {
          return;
        }
      }
      if (supportsDescriptors) {
        origDefineProperty(object, name, {
          configurable: true,
          enumerable: false,
          value,
          writable: true
        });
      } else {
        object[name] = value;
      }
    };
    var defineProperties = function(object, map3) {
      var predicates = arguments.length > 2 ? arguments[2] : {};
      var props = keys(map3);
      if (hasSymbols) {
        props = concat.call(props, Object.getOwnPropertySymbols(map3));
      }
      for (var i2 = 0; i2 < props.length; i2 += 1) {
        defineProperty(object, props[i2], map3[props[i2]], predicates[props[i2]]);
      }
    };
    defineProperties.supportsDescriptors = !!supportsDescriptors;
    module.exports = defineProperties;
  }
});

// ../simple-mind-map/node_modules/object-is/implementation.js
var require_implementation3 = __commonJS({
  "../simple-mind-map/node_modules/object-is/implementation.js"(exports, module) {
    "use strict";
    var numberIsNaN = function(value) {
      return value !== value;
    };
    module.exports = function is2(a2, b) {
      if (a2 === 0 && b === 0) {
        return 1 / a2 === 1 / b;
      }
      if (a2 === b) {
        return true;
      }
      if (numberIsNaN(a2) && numberIsNaN(b)) {
        return true;
      }
      return false;
    };
  }
});

// ../simple-mind-map/node_modules/object-is/polyfill.js
var require_polyfill = __commonJS({
  "../simple-mind-map/node_modules/object-is/polyfill.js"(exports, module) {
    "use strict";
    var implementation = require_implementation3();
    module.exports = function getPolyfill() {
      return typeof Object.is === "function" ? Object.is : implementation;
    };
  }
});

// ../simple-mind-map/node_modules/object-is/shim.js
var require_shim = __commonJS({
  "../simple-mind-map/node_modules/object-is/shim.js"(exports, module) {
    "use strict";
    var getPolyfill = require_polyfill();
    var define2 = require_define_properties();
    module.exports = function shimObjectIs() {
      var polyfill = getPolyfill();
      define2(Object, { is: polyfill }, {
        is: function testObjectIs() {
          return Object.is !== polyfill;
        }
      });
      return polyfill;
    };
  }
});

// ../simple-mind-map/node_modules/object-is/index.js
var require_object_is = __commonJS({
  "../simple-mind-map/node_modules/object-is/index.js"(exports, module) {
    "use strict";
    var define2 = require_define_properties();
    var callBind = require_call_bind();
    var implementation = require_implementation3();
    var getPolyfill = require_polyfill();
    var shim = require_shim();
    var polyfill = callBind(getPolyfill(), Object);
    define2(polyfill, {
      getPolyfill,
      implementation,
      shim
    });
    module.exports = polyfill;
  }
});

// ../simple-mind-map/node_modules/is-regex/index.js
var require_is_regex = __commonJS({
  "../simple-mind-map/node_modules/is-regex/index.js"(exports, module) {
    "use strict";
    var callBound = require_callBound();
    var hasToStringTag = require_shams2()();
    var has;
    var $exec;
    var isRegexMarker;
    var badStringifier;
    if (hasToStringTag) {
      has = callBound("Object.prototype.hasOwnProperty");
      $exec = callBound("RegExp.prototype.exec");
      isRegexMarker = {};
      throwRegexMarker = function() {
        throw isRegexMarker;
      };
      badStringifier = {
        toString: throwRegexMarker,
        valueOf: throwRegexMarker
      };
      if (typeof Symbol.toPrimitive === "symbol") {
        badStringifier[Symbol.toPrimitive] = throwRegexMarker;
      }
    }
    var throwRegexMarker;
    var $toString = callBound("Object.prototype.toString");
    var gOPD = Object.getOwnPropertyDescriptor;
    var regexClass = "[object RegExp]";
    module.exports = hasToStringTag ? function isRegex(value) {
      if (!value || typeof value !== "object") {
        return false;
      }
      var descriptor = gOPD(value, "lastIndex");
      var hasLastIndexDataProperty = descriptor && has(descriptor, "value");
      if (!hasLastIndexDataProperty) {
        return false;
      }
      try {
        $exec(value, badStringifier);
      } catch (e2) {
        return e2 === isRegexMarker;
      }
    } : function isRegex(value) {
      if (!value || typeof value !== "object" && typeof value !== "function") {
        return false;
      }
      return $toString(value) === regexClass;
    };
  }
});

// ../simple-mind-map/node_modules/functions-have-names/index.js
var require_functions_have_names = __commonJS({
  "../simple-mind-map/node_modules/functions-have-names/index.js"(exports, module) {
    "use strict";
    var functionsHaveNames = function functionsHaveNames2() {
      return typeof function f3() {
      }.name === "string";
    };
    var gOPD = Object.getOwnPropertyDescriptor;
    if (gOPD) {
      try {
        gOPD([], "length");
      } catch (e2) {
        gOPD = null;
      }
    }
    functionsHaveNames.functionsHaveConfigurableNames = function functionsHaveConfigurableNames() {
      if (!functionsHaveNames() || !gOPD) {
        return false;
      }
      var desc = gOPD(function() {
      }, "name");
      return !!desc && !!desc.configurable;
    };
    var $bind = Function.prototype.bind;
    functionsHaveNames.boundFunctionsHaveNames = function boundFunctionsHaveNames() {
      return functionsHaveNames() && typeof $bind === "function" && function f3() {
      }.bind().name !== "";
    };
    module.exports = functionsHaveNames;
  }
});

// ../simple-mind-map/node_modules/regexp.prototype.flags/implementation.js
var require_implementation4 = __commonJS({
  "../simple-mind-map/node_modules/regexp.prototype.flags/implementation.js"(exports, module) {
    "use strict";
    var functionsHaveConfigurableNames = require_functions_have_names().functionsHaveConfigurableNames();
    var $Object = Object;
    var $TypeError = TypeError;
    module.exports = function flags() {
      if (this != null && this !== $Object(this)) {
        throw new $TypeError("RegExp.prototype.flags getter called on non-object");
      }
      var result = "";
      if (this.hasIndices) {
        result += "d";
      }
      if (this.global) {
        result += "g";
      }
      if (this.ignoreCase) {
        result += "i";
      }
      if (this.multiline) {
        result += "m";
      }
      if (this.dotAll) {
        result += "s";
      }
      if (this.unicode) {
        result += "u";
      }
      if (this.sticky) {
        result += "y";
      }
      return result;
    };
    if (functionsHaveConfigurableNames && Object.defineProperty) {
      Object.defineProperty(module.exports, "name", { value: "get flags" });
    }
  }
});

// ../simple-mind-map/node_modules/regexp.prototype.flags/polyfill.js
var require_polyfill2 = __commonJS({
  "../simple-mind-map/node_modules/regexp.prototype.flags/polyfill.js"(exports, module) {
    "use strict";
    var implementation = require_implementation4();
    var supportsDescriptors = require_define_properties().supportsDescriptors;
    var $gOPD = Object.getOwnPropertyDescriptor;
    module.exports = function getPolyfill() {
      if (supportsDescriptors && /a/mig.flags === "gim") {
        var descriptor = $gOPD(RegExp.prototype, "flags");
        if (descriptor && typeof descriptor.get === "function" && typeof RegExp.prototype.dotAll === "boolean" && typeof RegExp.prototype.hasIndices === "boolean") {
          var calls = "";
          var o2 = {};
          Object.defineProperty(o2, "hasIndices", {
            get: function() {
              calls += "d";
            }
          });
          Object.defineProperty(o2, "sticky", {
            get: function() {
              calls += "y";
            }
          });
          if (calls === "dy") {
            return descriptor.get;
          }
        }
      }
      return implementation;
    };
  }
});

// ../simple-mind-map/node_modules/regexp.prototype.flags/shim.js
var require_shim2 = __commonJS({
  "../simple-mind-map/node_modules/regexp.prototype.flags/shim.js"(exports, module) {
    "use strict";
    var supportsDescriptors = require_define_properties().supportsDescriptors;
    var getPolyfill = require_polyfill2();
    var gOPD = Object.getOwnPropertyDescriptor;
    var defineProperty = Object.defineProperty;
    var TypeErr = TypeError;
    var getProto = Object.getPrototypeOf;
    var regex = /a/;
    module.exports = function shimFlags() {
      if (!supportsDescriptors || !getProto) {
        throw new TypeErr("RegExp.prototype.flags requires a true ES5 environment that supports property descriptors");
      }
      var polyfill = getPolyfill();
      var proto = getProto(regex);
      var descriptor = gOPD(proto, "flags");
      if (!descriptor || descriptor.get !== polyfill) {
        defineProperty(proto, "flags", {
          configurable: true,
          enumerable: false,
          get: polyfill
        });
      }
      return polyfill;
    };
  }
});

// ../simple-mind-map/node_modules/regexp.prototype.flags/index.js
var require_regexp_prototype = __commonJS({
  "../simple-mind-map/node_modules/regexp.prototype.flags/index.js"(exports, module) {
    "use strict";
    var define2 = require_define_properties();
    var callBind = require_call_bind();
    var implementation = require_implementation4();
    var getPolyfill = require_polyfill2();
    var shim = require_shim2();
    var flagsBound = callBind(getPolyfill());
    define2(flagsBound, {
      getPolyfill,
      implementation,
      shim
    });
    module.exports = flagsBound;
  }
});

// ../simple-mind-map/node_modules/is-date-object/index.js
var require_is_date_object = __commonJS({
  "../simple-mind-map/node_modules/is-date-object/index.js"(exports, module) {
    "use strict";
    var getDay = Date.prototype.getDay;
    var tryDateObject = function tryDateGetDayCall(value) {
      try {
        getDay.call(value);
        return true;
      } catch (e2) {
        return false;
      }
    };
    var toStr = Object.prototype.toString;
    var dateClass = "[object Date]";
    var hasToStringTag = require_shams2()();
    module.exports = function isDateObject(value) {
      if (typeof value !== "object" || value === null) {
        return false;
      }
      return hasToStringTag ? tryDateObject(value) : toStr.call(value) === dateClass;
    };
  }
});

// ../simple-mind-map/node_modules/deep-equal/index.js
var require_deep_equal = __commonJS({
  "../simple-mind-map/node_modules/deep-equal/index.js"(exports, module) {
    var objectKeys = require_object_keys2();
    var isArguments = require_is_arguments();
    var is2 = require_object_is();
    var isRegex = require_is_regex();
    var flags = require_regexp_prototype();
    var isDate = require_is_date_object();
    var getTime = Date.prototype.getTime;
    function deepEqual(actual, expected, options) {
      var opts = options || {};
      if (opts.strict ? is2(actual, expected) : actual === expected) {
        return true;
      }
      if (!actual || !expected || typeof actual !== "object" && typeof expected !== "object") {
        return opts.strict ? is2(actual, expected) : actual == expected;
      }
      return objEquiv(actual, expected, opts);
    }
    function isUndefinedOrNull(value) {
      return value === null || value === void 0;
    }
    function isBuffer(x2) {
      if (!x2 || typeof x2 !== "object" || typeof x2.length !== "number") {
        return false;
      }
      if (typeof x2.copy !== "function" || typeof x2.slice !== "function") {
        return false;
      }
      if (x2.length > 0 && typeof x2[0] !== "number") {
        return false;
      }
      return true;
    }
    function objEquiv(a2, b, opts) {
      var i2, key;
      if (typeof a2 !== typeof b) {
        return false;
      }
      if (isUndefinedOrNull(a2) || isUndefinedOrNull(b)) {
        return false;
      }
      if (a2.prototype !== b.prototype) {
        return false;
      }
      if (isArguments(a2) !== isArguments(b)) {
        return false;
      }
      var aIsRegex = isRegex(a2);
      var bIsRegex = isRegex(b);
      if (aIsRegex !== bIsRegex) {
        return false;
      }
      if (aIsRegex || bIsRegex) {
        return a2.source === b.source && flags(a2) === flags(b);
      }
      if (isDate(a2) && isDate(b)) {
        return getTime.call(a2) === getTime.call(b);
      }
      var aIsBuffer = isBuffer(a2);
      var bIsBuffer = isBuffer(b);
      if (aIsBuffer !== bIsBuffer) {
        return false;
      }
      if (aIsBuffer || bIsBuffer) {
        if (a2.length !== b.length) {
          return false;
        }
        for (i2 = 0; i2 < a2.length; i2++) {
          if (a2[i2] !== b[i2]) {
            return false;
          }
        }
        return true;
      }
      if (typeof a2 !== typeof b) {
        return false;
      }
      try {
        var ka = objectKeys(a2);
        var kb = objectKeys(b);
      } catch (e2) {
        return false;
      }
      if (ka.length !== kb.length) {
        return false;
      }
      ka.sort();
      kb.sort();
      for (i2 = ka.length - 1; i2 >= 0; i2--) {
        if (ka[i2] != kb[i2]) {
          return false;
        }
      }
      for (i2 = ka.length - 1; i2 >= 0; i2--) {
        key = ka[i2];
        if (!deepEqual(a2[key], b[key], opts)) {
          return false;
        }
      }
      return true;
    }
    module.exports = deepEqual;
  }
});

// ../simple-mind-map/node_modules/extend/index.js
var require_extend = __commonJS({
  "../simple-mind-map/node_modules/extend/index.js"(exports, module) {
    "use strict";
    var hasOwn = Object.prototype.hasOwnProperty;
    var toStr = Object.prototype.toString;
    var defineProperty = Object.defineProperty;
    var gOPD = Object.getOwnPropertyDescriptor;
    var isArray = function isArray2(arr) {
      if (typeof Array.isArray === "function") {
        return Array.isArray(arr);
      }
      return toStr.call(arr) === "[object Array]";
    };
    var isPlainObject = function isPlainObject2(obj) {
      if (!obj || toStr.call(obj) !== "[object Object]") {
        return false;
      }
      var hasOwnConstructor = hasOwn.call(obj, "constructor");
      var hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, "isPrototypeOf");
      if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {
        return false;
      }
      var key;
      for (key in obj) {
      }
      return typeof key === "undefined" || hasOwn.call(obj, key);
    };
    var setProperty = function setProperty2(target, options) {
      if (defineProperty && options.name === "__proto__") {
        defineProperty(target, options.name, {
          enumerable: true,
          configurable: true,
          value: options.newValue,
          writable: true
        });
      } else {
        target[options.name] = options.newValue;
      }
    };
    var getProperty = function getProperty2(obj, name) {
      if (name === "__proto__") {
        if (!hasOwn.call(obj, name)) {
          return void 0;
        } else if (gOPD) {
          return gOPD(obj, name).value;
        }
      }
      return obj[name];
    };
    module.exports = function extend2() {
      var options, name, src, copy, copyIsArray, clone;
      var target = arguments[0];
      var i2 = 1;
      var length2 = arguments.length;
      var deep = false;
      if (typeof target === "boolean") {
        deep = target;
        target = arguments[1] || {};
        i2 = 2;
      }
      if (target == null || typeof target !== "object" && typeof target !== "function") {
        target = {};
      }
      for (; i2 < length2; ++i2) {
        options = arguments[i2];
        if (options != null) {
          for (name in options) {
            src = getProperty(target, name);
            copy = getProperty(options, name);
            if (target !== copy) {
              if (deep && copy && (isPlainObject(copy) || (copyIsArray = isArray(copy)))) {
                if (copyIsArray) {
                  copyIsArray = false;
                  clone = src && isArray(src) ? src : [];
                } else {
                  clone = src && isPlainObject(src) ? src : {};
                }
                setProperty(target, { name, newValue: extend2(deep, clone, copy) });
              } else if (typeof copy !== "undefined") {
                setProperty(target, { name, newValue: copy });
              }
            }
          }
        }
      }
      return target;
    };
  }
});

// ../simple-mind-map/node_modules/quill-delta/lib/op.js
var require_op = __commonJS({
  "../simple-mind-map/node_modules/quill-delta/lib/op.js"(exports, module) {
    var equal = require_deep_equal();
    var extend2 = require_extend();
    var lib = {
      attributes: {
        compose: function(a2, b, keepNull) {
          if (typeof a2 !== "object")
            a2 = {};
          if (typeof b !== "object")
            b = {};
          var attributes = extend2(true, {}, b);
          if (!keepNull) {
            attributes = Object.keys(attributes).reduce(function(copy, key2) {
              if (attributes[key2] != null) {
                copy[key2] = attributes[key2];
              }
              return copy;
            }, {});
          }
          for (var key in a2) {
            if (a2[key] !== void 0 && b[key] === void 0) {
              attributes[key] = a2[key];
            }
          }
          return Object.keys(attributes).length > 0 ? attributes : void 0;
        },
        diff: function(a2, b) {
          if (typeof a2 !== "object")
            a2 = {};
          if (typeof b !== "object")
            b = {};
          var attributes = Object.keys(a2).concat(Object.keys(b)).reduce(function(attributes2, key) {
            if (!equal(a2[key], b[key])) {
              attributes2[key] = b[key] === void 0 ? null : b[key];
            }
            return attributes2;
          }, {});
          return Object.keys(attributes).length > 0 ? attributes : void 0;
        },
        transform: function(a2, b, priority) {
          if (typeof a2 !== "object")
            return b;
          if (typeof b !== "object")
            return void 0;
          if (!priority)
            return b;
          var attributes = Object.keys(b).reduce(function(attributes2, key) {
            if (a2[key] === void 0)
              attributes2[key] = b[key];
            return attributes2;
          }, {});
          return Object.keys(attributes).length > 0 ? attributes : void 0;
        }
      },
      iterator: function(ops) {
        return new Iterator(ops);
      },
      length: function(op2) {
        if (typeof op2["delete"] === "number") {
          return op2["delete"];
        } else if (typeof op2.retain === "number") {
          return op2.retain;
        } else {
          return typeof op2.insert === "string" ? op2.insert.length : 1;
        }
      }
    };
    function Iterator(ops) {
      this.ops = ops;
      this.index = 0;
      this.offset = 0;
    }
    Iterator.prototype.hasNext = function() {
      return this.peekLength() < Infinity;
    };
    Iterator.prototype.next = function(length2) {
      if (!length2)
        length2 = Infinity;
      var nextOp = this.ops[this.index];
      if (nextOp) {
        var offset = this.offset;
        var opLength = lib.length(nextOp);
        if (length2 >= opLength - offset) {
          length2 = opLength - offset;
          this.index += 1;
          this.offset = 0;
        } else {
          this.offset += length2;
        }
        if (typeof nextOp["delete"] === "number") {
          return { "delete": length2 };
        } else {
          var retOp = {};
          if (nextOp.attributes) {
            retOp.attributes = nextOp.attributes;
          }
          if (typeof nextOp.retain === "number") {
            retOp.retain = length2;
          } else if (typeof nextOp.insert === "string") {
            retOp.insert = nextOp.insert.substr(offset, length2);
          } else {
            retOp.insert = nextOp.insert;
          }
          return retOp;
        }
      } else {
        return { retain: Infinity };
      }
    };
    Iterator.prototype.peek = function() {
      return this.ops[this.index];
    };
    Iterator.prototype.peekLength = function() {
      if (this.ops[this.index]) {
        return lib.length(this.ops[this.index]) - this.offset;
      } else {
        return Infinity;
      }
    };
    Iterator.prototype.peekType = function() {
      if (this.ops[this.index]) {
        if (typeof this.ops[this.index]["delete"] === "number") {
          return "delete";
        } else if (typeof this.ops[this.index].retain === "number") {
          return "retain";
        } else {
          return "insert";
        }
      }
      return "retain";
    };
    Iterator.prototype.rest = function() {
      if (!this.hasNext()) {
        return [];
      } else if (this.offset === 0) {
        return this.ops.slice(this.index);
      } else {
        var offset = this.offset;
        var index3 = this.index;
        var next2 = this.next();
        var rest = this.ops.slice(this.index);
        this.offset = offset;
        this.index = index3;
        return [next2].concat(rest);
      }
    };
    module.exports = lib;
  }
});

// ../simple-mind-map/node_modules/quill-delta/lib/delta.js
var require_delta = __commonJS({
  "../simple-mind-map/node_modules/quill-delta/lib/delta.js"(exports, module) {
    var diff = require_diff();
    var equal = require_deep_equal();
    var extend2 = require_extend();
    var op2 = require_op();
    var NULL_CHARACTER = String.fromCharCode(0);
    var Delta2 = function(ops) {
      if (Array.isArray(ops)) {
        this.ops = ops;
      } else if (ops != null && Array.isArray(ops.ops)) {
        this.ops = ops.ops;
      } else {
        this.ops = [];
      }
    };
    Delta2.prototype.insert = function(text4, attributes) {
      var newOp = {};
      if (text4.length === 0)
        return this;
      newOp.insert = text4;
      if (attributes != null && typeof attributes === "object" && Object.keys(attributes).length > 0) {
        newOp.attributes = attributes;
      }
      return this.push(newOp);
    };
    Delta2.prototype["delete"] = function(length2) {
      if (length2 <= 0)
        return this;
      return this.push({ "delete": length2 });
    };
    Delta2.prototype.retain = function(length2, attributes) {
      if (length2 <= 0)
        return this;
      var newOp = { retain: length2 };
      if (attributes != null && typeof attributes === "object" && Object.keys(attributes).length > 0) {
        newOp.attributes = attributes;
      }
      return this.push(newOp);
    };
    Delta2.prototype.push = function(newOp) {
      var index3 = this.ops.length;
      var lastOp = this.ops[index3 - 1];
      newOp = extend2(true, {}, newOp);
      if (typeof lastOp === "object") {
        if (typeof newOp["delete"] === "number" && typeof lastOp["delete"] === "number") {
          this.ops[index3 - 1] = { "delete": lastOp["delete"] + newOp["delete"] };
          return this;
        }
        if (typeof lastOp["delete"] === "number" && newOp.insert != null) {
          index3 -= 1;
          lastOp = this.ops[index3 - 1];
          if (typeof lastOp !== "object") {
            this.ops.unshift(newOp);
            return this;
          }
        }
        if (equal(newOp.attributes, lastOp.attributes)) {
          if (typeof newOp.insert === "string" && typeof lastOp.insert === "string") {
            this.ops[index3 - 1] = { insert: lastOp.insert + newOp.insert };
            if (typeof newOp.attributes === "object")
              this.ops[index3 - 1].attributes = newOp.attributes;
            return this;
          } else if (typeof newOp.retain === "number" && typeof lastOp.retain === "number") {
            this.ops[index3 - 1] = { retain: lastOp.retain + newOp.retain };
            if (typeof newOp.attributes === "object")
              this.ops[index3 - 1].attributes = newOp.attributes;
            return this;
          }
        }
      }
      if (index3 === this.ops.length) {
        this.ops.push(newOp);
      } else {
        this.ops.splice(index3, 0, newOp);
      }
      return this;
    };
    Delta2.prototype.chop = function() {
      var lastOp = this.ops[this.ops.length - 1];
      if (lastOp && lastOp.retain && !lastOp.attributes) {
        this.ops.pop();
      }
      return this;
    };
    Delta2.prototype.filter = function(predicate) {
      return this.ops.filter(predicate);
    };
    Delta2.prototype.forEach = function(predicate) {
      this.ops.forEach(predicate);
    };
    Delta2.prototype.map = function(predicate) {
      return this.ops.map(predicate);
    };
    Delta2.prototype.partition = function(predicate) {
      var passed = [], failed = [];
      this.forEach(function(op3) {
        var target = predicate(op3) ? passed : failed;
        target.push(op3);
      });
      return [passed, failed];
    };
    Delta2.prototype.reduce = function(predicate, initial) {
      return this.ops.reduce(predicate, initial);
    };
    Delta2.prototype.changeLength = function() {
      return this.reduce(function(length2, elem) {
        if (elem.insert) {
          return length2 + op2.length(elem);
        } else if (elem.delete) {
          return length2 - elem.delete;
        }
        return length2;
      }, 0);
    };
    Delta2.prototype.length = function() {
      return this.reduce(function(length2, elem) {
        return length2 + op2.length(elem);
      }, 0);
    };
    Delta2.prototype.slice = function(start, end) {
      start = start || 0;
      if (typeof end !== "number")
        end = Infinity;
      var ops = [];
      var iter = op2.iterator(this.ops);
      var index3 = 0;
      while (index3 < end && iter.hasNext()) {
        var nextOp;
        if (index3 < start) {
          nextOp = iter.next(start - index3);
        } else {
          nextOp = iter.next(end - index3);
          ops.push(nextOp);
        }
        index3 += op2.length(nextOp);
      }
      return new Delta2(ops);
    };
    Delta2.prototype.compose = function(other) {
      var thisIter = op2.iterator(this.ops);
      var otherIter = op2.iterator(other.ops);
      var ops = [];
      var firstOther = otherIter.peek();
      if (firstOther != null && typeof firstOther.retain === "number" && firstOther.attributes == null) {
        var firstLeft = firstOther.retain;
        while (thisIter.peekType() === "insert" && thisIter.peekLength() <= firstLeft) {
          firstLeft -= thisIter.peekLength();
          ops.push(thisIter.next());
        }
        if (firstOther.retain - firstLeft > 0) {
          otherIter.next(firstOther.retain - firstLeft);
        }
      }
      var delta = new Delta2(ops);
      while (thisIter.hasNext() || otherIter.hasNext()) {
        if (otherIter.peekType() === "insert") {
          delta.push(otherIter.next());
        } else if (thisIter.peekType() === "delete") {
          delta.push(thisIter.next());
        } else {
          var length2 = Math.min(thisIter.peekLength(), otherIter.peekLength());
          var thisOp = thisIter.next(length2);
          var otherOp = otherIter.next(length2);
          if (typeof otherOp.retain === "number") {
            var newOp = {};
            if (typeof thisOp.retain === "number") {
              newOp.retain = length2;
            } else {
              newOp.insert = thisOp.insert;
            }
            var attributes = op2.attributes.compose(thisOp.attributes, otherOp.attributes, typeof thisOp.retain === "number");
            if (attributes)
              newOp.attributes = attributes;
            delta.push(newOp);
            if (!otherIter.hasNext() && equal(delta.ops[delta.ops.length - 1], newOp)) {
              var rest = new Delta2(thisIter.rest());
              return delta.concat(rest).chop();
            }
          } else if (typeof otherOp["delete"] === "number" && typeof thisOp.retain === "number") {
            delta.push(otherOp);
          }
        }
      }
      return delta.chop();
    };
    Delta2.prototype.concat = function(other) {
      var delta = new Delta2(this.ops.slice());
      if (other.ops.length > 0) {
        delta.push(other.ops[0]);
        delta.ops = delta.ops.concat(other.ops.slice(1));
      }
      return delta;
    };
    Delta2.prototype.diff = function(other, index3) {
      if (this.ops === other.ops) {
        return new Delta2();
      }
      var strings = [this, other].map(function(delta2) {
        return delta2.map(function(op3) {
          if (op3.insert != null) {
            return typeof op3.insert === "string" ? op3.insert : NULL_CHARACTER;
          }
          var prep = delta2 === other ? "on" : "with";
          throw new Error("diff() called " + prep + " non-document");
        }).join("");
      });
      var delta = new Delta2();
      var diffResult = diff(strings[0], strings[1], index3);
      var thisIter = op2.iterator(this.ops);
      var otherIter = op2.iterator(other.ops);
      diffResult.forEach(function(component) {
        var length2 = component[1].length;
        while (length2 > 0) {
          var opLength = 0;
          switch (component[0]) {
            case diff.INSERT:
              opLength = Math.min(otherIter.peekLength(), length2);
              delta.push(otherIter.next(opLength));
              break;
            case diff.DELETE:
              opLength = Math.min(length2, thisIter.peekLength());
              thisIter.next(opLength);
              delta["delete"](opLength);
              break;
            case diff.EQUAL:
              opLength = Math.min(thisIter.peekLength(), otherIter.peekLength(), length2);
              var thisOp = thisIter.next(opLength);
              var otherOp = otherIter.next(opLength);
              if (equal(thisOp.insert, otherOp.insert)) {
                delta.retain(opLength, op2.attributes.diff(thisOp.attributes, otherOp.attributes));
              } else {
                delta.push(otherOp)["delete"](opLength);
              }
              break;
          }
          length2 -= opLength;
        }
      });
      return delta.chop();
    };
    Delta2.prototype.eachLine = function(predicate, newline) {
      newline = newline || "\n";
      var iter = op2.iterator(this.ops);
      var line = new Delta2();
      var i2 = 0;
      while (iter.hasNext()) {
        if (iter.peekType() !== "insert")
          return;
        var thisOp = iter.peek();
        var start = op2.length(thisOp) - iter.peekLength();
        var index3 = typeof thisOp.insert === "string" ? thisOp.insert.indexOf(newline, start) - start : -1;
        if (index3 < 0) {
          line.push(iter.next());
        } else if (index3 > 0) {
          line.push(iter.next(index3));
        } else {
          if (predicate(line, iter.next(1).attributes || {}, i2) === false) {
            return;
          }
          i2 += 1;
          line = new Delta2();
        }
      }
      if (line.length() > 0) {
        predicate(line, {}, i2);
      }
    };
    Delta2.prototype.transform = function(other, priority) {
      priority = !!priority;
      if (typeof other === "number") {
        return this.transformPosition(other, priority);
      }
      var thisIter = op2.iterator(this.ops);
      var otherIter = op2.iterator(other.ops);
      var delta = new Delta2();
      while (thisIter.hasNext() || otherIter.hasNext()) {
        if (thisIter.peekType() === "insert" && (priority || otherIter.peekType() !== "insert")) {
          delta.retain(op2.length(thisIter.next()));
        } else if (otherIter.peekType() === "insert") {
          delta.push(otherIter.next());
        } else {
          var length2 = Math.min(thisIter.peekLength(), otherIter.peekLength());
          var thisOp = thisIter.next(length2);
          var otherOp = otherIter.next(length2);
          if (thisOp["delete"]) {
            continue;
          } else if (otherOp["delete"]) {
            delta.push(otherOp);
          } else {
            delta.retain(length2, op2.attributes.transform(thisOp.attributes, otherOp.attributes, priority));
          }
        }
      }
      return delta.chop();
    };
    Delta2.prototype.transformPosition = function(index3, priority) {
      priority = !!priority;
      var thisIter = op2.iterator(this.ops);
      var offset = 0;
      while (thisIter.hasNext() && offset <= index3) {
        var length2 = thisIter.peekLength();
        var nextType = thisIter.peekType();
        thisIter.next();
        if (nextType === "delete") {
          index3 -= Math.min(length2, index3 - offset);
          continue;
        } else if (nextType === "insert" && (offset < index3 || !priority)) {
          index3 += length2;
        }
        offset += length2;
      }
      return index3;
    };
    module.exports = Delta2;
  }
});

// ../simple-mind-map/src/constants/constant.js
var constant_exports = {};
__export(constant_exports, {
  CONSTANTS: () => CONSTANTS,
  ERROR_TYPES: () => ERROR_TYPES,
  commonCaches: () => commonCaches,
  cssContent: () => cssContent,
  initRootNodePositionMap: () => initRootNodePositionMap,
  layoutList: () => layoutList,
  layoutValueList: () => layoutValueList,
  nodeDataNoStylePropList: () => nodeDataNoStylePropList,
  selfCloseTagList: () => selfCloseTagList,
  themeList: () => themeList
});
var themeList = [
  {
    name: "\u9ED8\u8BA4",
    value: "default",
    dark: false
  },
  {
    name: "\u6697\u82722",
    value: "dark2",
    dark: true
  },
  {
    name: "\u5929\u6E05\u7EFF",
    value: "skyGreen",
    dark: false
  },
  {
    name: "\u8111\u56FE\u7ECF\u51782",
    value: "classic2",
    dark: false
  },
  {
    name: "\u8111\u56FE\u7ECF\u51783",
    value: "classic3",
    dark: false
  },
  {
    name: "\u7ECF\u5178\u7EFF",
    value: "classicGreen",
    dark: false
  },
  {
    name: "\u7ECF\u5178\u84DD",
    value: "classicBlue",
    dark: false
  },
  {
    name: "\u5929\u7A7A\u84DD",
    value: "blueSky",
    dark: false
  },
  {
    name: "\u8111\u6B8B\u7C89",
    value: "brainImpairedPink",
    dark: false
  },
  {
    name: "\u6697\u8272",
    value: "dark",
    dark: true
  },
  {
    name: "\u6CE5\u571F\u9EC4",
    value: "earthYellow",
    dark: false
  },
  {
    name: "\u6E05\u65B0\u7EFF",
    value: "freshGreen",
    dark: false
  },
  {
    name: "\u6E05\u65B0\u7EA2",
    value: "freshRed",
    dark: false
  },
  {
    name: "\u6D6A\u6F2B\u7D2B",
    value: "romanticPurple",
    dark: false
  },
  {
    name: "\u7C89\u7EA2\u8461\u8404",
    value: "pinkGrape",
    dark: false
  },
  {
    name: "\u8584\u8377",
    value: "mint",
    dark: false
  },
  {
    name: "\u91D1\u8272vip",
    value: "gold",
    dark: false
  },
  {
    name: "\u6D3B\u529B\u6A59",
    value: "vitalityOrange",
    dark: false
  },
  {
    name: "\u7EFF\u53F6",
    value: "greenLeaf",
    dark: false
  },
  {
    name: "\u8111\u56FE\u7ECF\u5178",
    value: "classic",
    dark: true
  },
  {
    name: "\u8111\u56FE\u7ECF\u51784",
    value: "classic4",
    dark: false
  },
  {
    name: "\u5C0F\u9EC4\u4EBA",
    value: "minions",
    dark: false
  },
  {
    name: "\u7B80\u7EA6\u9ED1",
    value: "simpleBlack",
    dark: false
  },
  {
    name: "\u8BFE\u7A0B\u7EFF",
    value: "courseGreen",
    dark: false
  },
  {
    name: "\u5496\u5561",
    value: "coffee",
    dark: false
  },
  {
    name: "\u7EA2\u8272\u7CBE\u795E",
    value: "redSpirit",
    dark: false
  },
  {
    name: "\u9ED1\u8272\u5E7D\u9ED8",
    value: "blackHumour",
    dark: true
  },
  {
    name: "\u6DF1\u591C\u529E\u516C\u5BA4",
    value: "lateNightOffice",
    dark: true
  },
  {
    name: "\u9ED1\u91D1",
    value: "blackGold",
    dark: true
  },
  {
    name: "\u725B\u6CB9\u679C",
    value: "avocado",
    dark: false
  },
  {
    name: "\u79CB\u5929",
    value: "autumn",
    dark: false
  },
  {
    name: "\u6A59\u6C41",
    value: "orangeJuice",
    dark: true
  }
];
var CONSTANTS = {
  CHANGE_THEME: "changeTheme",
  CHANGE_LAYOUT: "changeLayout",
  SET_DATA: "setData",
  TRANSFORM_TO_NORMAL_NODE: "transformAllNodesToNormalNode",
  MODE: {
    READONLY: "readonly",
    EDIT: "edit"
  },
  LAYOUT: {
    LOGICAL_STRUCTURE: "logicalStructure",
    MIND_MAP: "mindMap",
    ORGANIZATION_STRUCTURE: "organizationStructure",
    CATALOG_ORGANIZATION: "catalogOrganization",
    TIMELINE: "timeline",
    TIMELINE2: "timeline2",
    FISHBONE: "fishbone",
    VERTICAL_TIMELINE: "verticalTimeline"
  },
  DIR: {
    UP: "up",
    LEFT: "left",
    DOWN: "down",
    RIGHT: "right"
  },
  KEY_DIR: {
    LEFT: "Left",
    UP: "Up",
    RIGHT: "Right",
    DOWN: "Down"
  },
  SHAPE: {
    RECTANGLE: "rectangle",
    DIAMOND: "diamond",
    PARALLELOGRAM: "parallelogram",
    ROUNDED_RECTANGLE: "roundedRectangle",
    OCTAGONAL_RECTANGLE: "octagonalRectangle",
    OUTER_TRIANGULAR_RECTANGLE: "outerTriangularRectangle",
    INNER_TRIANGULAR_RECTANGLE: "innerTriangularRectangle",
    ELLIPSE: "ellipse",
    CIRCLE: "circle"
  },
  MOUSE_WHEEL_ACTION: {
    ZOOM: "zoom",
    MOVE: "move"
  },
  INIT_ROOT_NODE_POSITION: {
    LEFT: "left",
    TOP: "top",
    RIGHT: "right",
    BOTTOM: "bottom",
    CENTER: "center"
  },
  LAYOUT_GROW_DIR: {
    LEFT: "left",
    TOP: "top",
    RIGHT: "right",
    BOTTOM: "bottom"
  },
  PASTE_TYPE: {
    CLIP_BOARD: "clipBoard",
    CANVAS: "canvas"
  },
  SCROLL_BAR_DIR: {
    VERTICAL: "vertical",
    HORIZONTAL: "horizontal"
  },
  CREATE_NEW_NODE_BEHAVIOR: {
    DEFAULT: "default",
    NOT_ACTIVE: "notActive",
    ACTIVE_ONLY: "activeOnly"
  }
};
var initRootNodePositionMap = {
  [CONSTANTS.INIT_ROOT_NODE_POSITION.LEFT]: 0,
  [CONSTANTS.INIT_ROOT_NODE_POSITION.TOP]: 0,
  [CONSTANTS.INIT_ROOT_NODE_POSITION.RIGHT]: 1,
  [CONSTANTS.INIT_ROOT_NODE_POSITION.BOTTOM]: 1,
  [CONSTANTS.INIT_ROOT_NODE_POSITION.CENTER]: 0.5
};
var layoutList = [
  {
    name: "\u903B\u8F91\u7ED3\u6784\u56FE",
    value: CONSTANTS.LAYOUT.LOGICAL_STRUCTURE
  },
  {
    name: "\u601D\u7EF4\u5BFC\u56FE",
    value: CONSTANTS.LAYOUT.MIND_MAP
  },
  {
    name: "\u7EC4\u7EC7\u7ED3\u6784\u56FE",
    value: CONSTANTS.LAYOUT.ORGANIZATION_STRUCTURE
  },
  {
    name: "\u76EE\u5F55\u7EC4\u7EC7\u56FE",
    value: CONSTANTS.LAYOUT.CATALOG_ORGANIZATION
  },
  {
    name: "\u65F6\u95F4\u8F74",
    value: CONSTANTS.LAYOUT.TIMELINE
  },
  {
    name: "\u65F6\u95F4\u8F742",
    value: CONSTANTS.LAYOUT.TIMELINE2
  },
  {
    name: "\u7AD6\u5411\u65F6\u95F4\u8F74",
    value: CONSTANTS.LAYOUT.VERTICAL_TIMELINE
  },
  {
    name: "\u9C7C\u9AA8\u56FE",
    value: CONSTANTS.LAYOUT.FISHBONE
  }
];
var layoutValueList = [
  CONSTANTS.LAYOUT.LOGICAL_STRUCTURE,
  CONSTANTS.LAYOUT.MIND_MAP,
  CONSTANTS.LAYOUT.CATALOG_ORGANIZATION,
  CONSTANTS.LAYOUT.ORGANIZATION_STRUCTURE,
  CONSTANTS.LAYOUT.TIMELINE,
  CONSTANTS.LAYOUT.TIMELINE2,
  CONSTANTS.LAYOUT.VERTICAL_TIMELINE,
  CONSTANTS.LAYOUT.FISHBONE
];
var nodeDataNoStylePropList = [
  "text",
  "image",
  "imageTitle",
  "imageSize",
  "icon",
  "tag",
  "hyperlink",
  "hyperlinkTitle",
  "note",
  "expand",
  "isActive",
  "generalization",
  "richText",
  "resetRichText",
  "uid",
  "activeStyle",
  "associativeLineTargets",
  "associativeLineTargetControlOffsets",
  "associativeLinePoint",
  "associativeLineText"
];
var commonCaches = {
  measureCustomNodeContentSizeEl: null,
  measureRichtextNodeTextSizeEl: null
};
var ERROR_TYPES = {
  READ_CLIPBOARD_ERROR: "read_clipboard_error",
  PARSE_PASTE_DATA_ERROR: "parse_paste_data_error",
  CUSTOM_HANDLE_CLIPBOARD_TEXT_ERROR: "custom_handle_clipboard_text_error",
  LOAD_CLIPBOARD_IMAGE_ERROR: "load_clipboard_image_error",
  BEFORE_TEXT_EDIT_ERROR: "before_text_edit_error",
  EXPORT_ERROR: "export_error",
  EXPORT_LOAD_IMAGE_ERROR: "export_load_image_error"
};
var cssContent = `
  /* \u9F20\u6807hover\u548C\u6FC0\u6D3B\u65F6\u6E32\u67D3\u7684\u77E9\u5F62 */
  .smm-hover-node{
    display: none;
    opacity: 0.6;
    stroke-width: 1;
  }

  .smm-node:not(.smm-node-dragging):hover .smm-hover-node{
    display: block;
  }

  .smm-node.active .smm-hover-node{
    display: block;
    opacity: 1;
    stroke-width: 2;
  }
`;
var selfCloseTagList = [
  "img",
  "br",
  "hr",
  "input",
  "link",
  "meta",
  "area"
];

// ../simple-mind-map/src/core/view/View.js
var View = class {
  //  构造函数
  constructor(opt = {}) {
    this.opt = opt;
    this.mindMap = this.opt.mindMap;
    this.scale = 1;
    this.sx = 0;
    this.sy = 0;
    this.x = 0;
    this.y = 0;
    this.firstDrag = true;
    this.setTransformData(this.mindMap.opt.viewData);
    this.bind();
  }
  //  绑定
  bind() {
    this.mindMap.keyCommand.addShortcut("Control+=", () => {
      this.enlarge();
    });
    this.mindMap.keyCommand.addShortcut("Control+-", () => {
      this.narrow();
    });
    this.mindMap.keyCommand.addShortcut("Control+i", () => {
      this.fit();
    });
    this.mindMap.event.on("mousedown", () => {
      if (this.mindMap.opt.isDisableDrag)
        return;
      this.sx = this.x;
      this.sy = this.y;
    });
    this.mindMap.event.on("drag", (e2, event) => {
      if (e2.ctrlKey || this.mindMap.opt.isDisableDrag) {
        return;
      }
      if (this.firstDrag) {
        this.firstDrag = false;
        if (this.mindMap.renderer.activeNodeList.length > 0) {
          this.mindMap.execCommand("CLEAR_ACTIVE_NODE");
        }
      }
      this.x = this.sx + event.mousemoveOffset.x;
      this.y = this.sy + event.mousemoveOffset.y;
      this.transform();
    });
    this.mindMap.event.on("mouseup", () => {
      this.firstDrag = true;
    });
    this.mindMap.event.on("mousewheel", (e2, dirs, event, isTouchPad) => {
      const {
        customHandleMousewheel,
        mousewheelAction,
        mouseScaleCenterUseMousePosition,
        mousewheelMoveStep,
        mousewheelZoomActionReverse,
        disableMouseWheelZoom
      } = this.mindMap.opt;
      if (customHandleMousewheel && typeof customHandleMousewheel === "function") {
        return customHandleMousewheel(e2);
      }
      if (mousewheelAction === CONSTANTS.MOUSE_WHEEL_ACTION.ZOOM || e2.ctrlKey) {
        if (disableMouseWheelZoom)
          return;
        const { x: clientX, y: clientY } = this.mindMap.toPos(
          e2.clientX,
          e2.clientY
        );
        const cx2 = mouseScaleCenterUseMousePosition ? clientX : void 0;
        const cy2 = mouseScaleCenterUseMousePosition ? clientY : void 0;
        if (isTouchPad && (dirs.includes(CONSTANTS.DIR.LEFT) || dirs.includes(CONSTANTS.DIR.RIGHT))) {
          dirs = dirs.filter((dir) => {
            return ![CONSTANTS.DIR.LEFT, CONSTANTS.DIR.RIGHT].includes(dir);
          });
        }
        switch (true) {
          case dirs.includes(CONSTANTS.DIR.UP || CONSTANTS.DIR.LEFT):
            mousewheelZoomActionReverse ? this.enlarge(cx2, cy2, isTouchPad) : this.narrow(cx2, cy2, isTouchPad);
            break;
          case dirs.includes(CONSTANTS.DIR.DOWN || CONSTANTS.DIR.RIGHT):
            mousewheelZoomActionReverse ? this.narrow(cx2, cy2, isTouchPad) : this.enlarge(cx2, cy2, isTouchPad);
            break;
        }
      } else {
        const step = isTouchPad ? 5 : mousewheelMoveStep;
        let mx = 0;
        let my = 0;
        if (dirs.includes(CONSTANTS.DIR.DOWN)) {
          my = -step;
        }
        if (dirs.includes(CONSTANTS.DIR.UP)) {
          my = step;
        }
        if (dirs.includes(CONSTANTS.DIR.LEFT)) {
          mx = step;
        }
        if (dirs.includes(CONSTANTS.DIR.RIGHT)) {
          mx = -step;
        }
        this.translateXY(mx, my);
      }
    });
  }
  //  获取当前变换状态数据
  getTransformData() {
    return {
      transform: this.mindMap.draw.transform(),
      state: {
        scale: this.scale,
        x: this.x,
        y: this.y,
        sx: this.sx,
        sy: this.sy
      }
    };
  }
  //  动态设置变换状态数据
  setTransformData(viewData) {
    if (viewData) {
      Object.keys(viewData.state).forEach((prop) => {
        this[prop] = viewData.state[prop];
      });
      this.mindMap.draw.transform({
        ...viewData.transform
      });
      this.mindMap.emit("view_data_change", this.getTransformData());
      this.mindMap.emit("scale", this.scale);
    }
  }
  //  平移x,y方向
  translateXY(x2, y3) {
    if (x2 === 0 && y3 === 0)
      return;
    this.x += x2;
    this.y += y3;
    this.transform();
  }
  //  平移x方向
  translateX(step) {
    if (step === 0)
      return;
    this.x += step;
    this.transform();
  }
  //  平移x方式到
  translateXTo(x2) {
    this.x = x2;
    this.transform();
  }
  //  平移y方向
  translateY(step) {
    if (step === 0)
      return;
    this.y += step;
    this.transform();
  }
  //  平移y方向到
  translateYTo(y3) {
    this.y = y3;
    this.transform();
  }
  //   应用变换
  transform() {
    try {
      this.limitMindMapInCanvas();
    } catch (error) {
    }
    this.mindMap.draw.transform({
      origin: [0, 0],
      scale: this.scale,
      translate: [this.x, this.y]
    });
    this.mindMap.emit("view_data_change", this.getTransformData());
  }
  //  恢复
  reset() {
    let scaleChange = this.scale !== 1;
    this.scale = 1;
    this.x = 0;
    this.y = 0;
    this.transform();
    if (scaleChange) {
      this.mindMap.emit("scale", this.scale);
    }
  }
  //  缩小
  narrow(cx2, cy2, isTouchPad) {
    const scaleRatio = this.mindMap.opt.scaleRatio / (isTouchPad ? 5 : 1);
    const scale3 = Math.max(this.scale - scaleRatio, 0.1);
    this.scaleInCenter(scale3, cx2, cy2);
    this.transform();
    this.mindMap.emit("scale", this.scale);
  }
  //  放大
  enlarge(cx2, cy2, isTouchPad) {
    const scaleRatio = this.mindMap.opt.scaleRatio / (isTouchPad ? 5 : 1);
    const scale3 = this.scale + scaleRatio;
    this.scaleInCenter(scale3, cx2, cy2);
    this.transform();
    this.mindMap.emit("scale", this.scale);
  }
  // 基于指定中心进行缩放，cx，cy 可不指定，此时会使用画布中心点
  scaleInCenter(scale3, cx2, cy2) {
    if (cx2 === void 0 || cy2 === void 0) {
      cx2 = this.mindMap.width / 2;
      cy2 = this.mindMap.height / 2;
    }
    const prevScale = this.scale;
    const ratio = 1 - scale3 / prevScale;
    const dx2 = (cx2 - this.x) * ratio;
    const dy2 = (cy2 - this.y) * ratio;
    this.x += dx2;
    this.y += dy2;
    this.scale = scale3;
  }
  //  设置缩放
  setScale(scale3, cx2, cy2) {
    if (cx2 !== void 0 && cy2 !== void 0) {
      this.scaleInCenter(scale3, cx2, cy2);
    } else {
      this.scale = scale3;
    }
    this.transform();
    this.mindMap.emit("scale", this.scale);
  }
  // 适应画布大小
  fit() {
    const { fitPadding } = this.mindMap.opt;
    const draw = this.mindMap.draw;
    const origTransform = draw.transform();
    const rect = draw.rbox();
    const drawWidth = rect.width / origTransform.scaleX;
    const drawHeight = rect.height / origTransform.scaleY;
    const drawRatio = drawWidth / drawHeight;
    let { width: elWidth, height: elHeight } = this.mindMap.elRect;
    elWidth = elWidth - fitPadding * 2;
    elHeight = elHeight - fitPadding * 2;
    const elRatio = elWidth / elHeight;
    let newScale = 0;
    let flag = "";
    if (drawWidth <= elWidth && drawHeight <= elHeight) {
      newScale = 1;
      flag = 1;
    } else {
      let newWidth = 0;
      let newHeight = 0;
      if (drawRatio > elRatio) {
        newWidth = elWidth;
        newHeight = elWidth / drawRatio;
        flag = 2;
      } else {
        newHeight = elHeight;
        newWidth = elHeight * drawRatio;
        flag = 3;
      }
      newScale = newWidth / drawWidth;
    }
    this.setScale(newScale);
    const newRect = draw.rbox();
    newRect.x -= this.mindMap.elRect.left;
    newRect.y -= this.mindMap.elRect.top;
    let newX = 0;
    let newY = 0;
    if (flag === 1) {
      newX = -newRect.x + fitPadding + (elWidth - newRect.width) / 2;
      newY = -newRect.y + fitPadding + (elHeight - newRect.height) / 2;
    } else if (flag === 2) {
      newX = -newRect.x + fitPadding;
      newY = -newRect.y + fitPadding + (elHeight - newRect.height) / 2;
    } else if (flag === 3) {
      newX = -newRect.x + fitPadding + (elWidth - newRect.width) / 2;
      newY = -newRect.y + fitPadding;
    }
    this.translateXY(newX, newY);
  }
  // 将思维导图限制在画布内
  limitMindMapInCanvas() {
    const { isLimitMindMapInCanvasWhenHasScrollbar, isLimitMindMapInCanvas } = this.mindMap.opt;
    if (this.mindMap.scrollbar) {
      if (!isLimitMindMapInCanvasWhenHasScrollbar)
        return;
    } else {
      if (!isLimitMindMapInCanvas)
        return;
    }
    let { scale: scale3, left, top, right, bottom } = this.getPositionLimit();
    const scaleRatio = this.scale / scale3;
    left *= scaleRatio;
    right *= scaleRatio;
    top *= scaleRatio;
    bottom *= scaleRatio;
    const centerX = this.mindMap.width / 2;
    const centerY = this.mindMap.height / 2;
    const scaleOffset = this.scale - 1;
    left -= scaleOffset * centerX;
    right -= scaleOffset * centerX;
    top -= scaleOffset * centerY;
    bottom -= scaleOffset * centerY;
    if (this.x > left) {
      this.x = left;
    }
    if (this.x < right) {
      this.x = right;
    }
    if (this.y > top) {
      this.y = top;
    }
    if (this.y < bottom) {
      this.y = bottom;
    }
  }
  // 计算图形四个方向的位置边界值
  getPositionLimit() {
    const { scaleX, scaleY } = this.mindMap.draw.transform();
    const drawRect = this.mindMap.draw.rbox();
    const rootRect = this.mindMap.renderer.root.group.rbox();
    const rootCenterOffset = this.mindMap.renderer.layout.getRootCenterOffset(
      rootRect.width,
      rootRect.height
    );
    const left = rootRect.x - drawRect.x - rootCenterOffset.x * scaleX;
    const right = rootRect.x - drawRect.x2 - rootCenterOffset.x * scaleX;
    const top = rootRect.y - drawRect.y - rootCenterOffset.y * scaleY;
    const bottom = rootRect.y - drawRect.y2 - rootCenterOffset.y * scaleY;
    return {
      scale: scaleX,
      left,
      right,
      top,
      bottom
    };
  }
};
var View_default = View;

// ../simple-mind-map/src/core/event/Event.js
var import_eventemitter3 = __toESM(require_eventemitter3());
var Event2 = class extends import_eventemitter3.default {
  //  构造函数
  constructor(opt = {}) {
    super();
    this.opt = opt;
    this.mindMap = opt.mindMap;
    this.isLeftMousedown = false;
    this.isRightMousedown = false;
    this.isMiddleMousedown = false;
    this.mousedownPos = {
      x: 0,
      y: 0
    };
    this.mousemovePos = {
      x: 0,
      y: 0
    };
    this.mousemoveOffset = {
      x: 0,
      y: 0
    };
    this.bindFn();
    this.bind();
  }
  //  绑定函数上下文
  bindFn() {
    this.onBodyMousedown = this.onBodyMousedown.bind(this);
    this.onBodyClick = this.onBodyClick.bind(this);
    this.onDrawClick = this.onDrawClick.bind(this);
    this.onMousedown = this.onMousedown.bind(this);
    this.onMousemove = this.onMousemove.bind(this);
    this.onMouseup = this.onMouseup.bind(this);
    this.onNodeMouseup = this.onNodeMouseup.bind(this);
    this.onMousewheel = this.onMousewheel.bind(this);
    this.onContextmenu = this.onContextmenu.bind(this);
    this.onSvgMousedown = this.onSvgMousedown.bind(this);
    this.onKeyup = this.onKeyup.bind(this);
    this.onMouseenter = this.onMouseenter.bind(this);
    this.onMouseleave = this.onMouseleave.bind(this);
  }
  //  绑定事件
  bind() {
    document.body.addEventListener("mousedown", this.onBodyMousedown);
    document.body.addEventListener("click", this.onBodyClick);
    this.mindMap.svg.on("click", this.onDrawClick);
    this.mindMap.el.addEventListener("mousedown", this.onMousedown);
    this.mindMap.svg.on("mousedown", this.onSvgMousedown);
    window.addEventListener("mousemove", this.onMousemove);
    window.addEventListener("mouseup", this.onMouseup);
    this.on("node_mouseup", this.onNodeMouseup);
    this.mindMap.el.addEventListener("wheel", this.onMousewheel);
    this.mindMap.svg.on("contextmenu", this.onContextmenu);
    this.mindMap.svg.on("mouseenter", this.onMouseenter);
    this.mindMap.svg.on("mouseleave", this.onMouseleave);
    window.addEventListener("keyup", this.onKeyup);
  }
  //  解绑事件
  unbind() {
    document.body.removeEventListener("mousedown", this.onBodyMousedown);
    document.body.removeEventListener("click", this.onBodyClick);
    this.mindMap.svg.off("click", this.onDrawClick);
    this.mindMap.el.removeEventListener("mousedown", this.onMousedown);
    window.removeEventListener("mousemove", this.onMousemove);
    window.removeEventListener("mouseup", this.onMouseup);
    this.off("node_mouseup", this.onNodeMouseup);
    this.mindMap.el.removeEventListener("wheel", this.onMousewheel);
    this.mindMap.svg.off("contextmenu", this.onContextmenu);
    this.mindMap.svg.off("mouseenter", this.onMouseenter);
    this.mindMap.svg.off("mouseleave", this.onMouseleave);
    window.removeEventListener("keyup", this.onKeyup);
  }
  //   画布的单击事件
  onDrawClick(e2) {
    this.emit("draw_click", e2);
  }
  // 页面的鼠标按下事件
  onBodyMousedown(e2) {
    this.emit("body_mousedown", e2);
  }
  // 页面的单击事件
  onBodyClick(e2) {
    this.emit("body_click", e2);
  }
  //   svg画布的鼠标按下事件
  onSvgMousedown(e2) {
    this.emit("svg_mousedown", e2);
  }
  //  鼠标按下事件
  onMousedown(e2) {
    if (e2.which === 1) {
      this.isLeftMousedown = true;
    } else if (e2.which === 3) {
      this.isRightMousedown = true;
    } else if (e2.which === 2) {
      this.isMiddleMousedown = true;
    }
    this.mousedownPos.x = e2.clientX;
    this.mousedownPos.y = e2.clientY;
    this.emit("mousedown", e2, this);
  }
  //  鼠标移动事件
  onMousemove(e2) {
    let { useLeftKeySelectionRightKeyDrag } = this.mindMap.opt;
    this.mousemovePos.x = e2.clientX;
    this.mousemovePos.y = e2.clientY;
    this.mousemoveOffset.x = e2.clientX - this.mousedownPos.x;
    this.mousemoveOffset.y = e2.clientY - this.mousedownPos.y;
    this.emit("mousemove", e2, this);
    if (this.isMiddleMousedown || (useLeftKeySelectionRightKeyDrag ? this.isRightMousedown : this.isLeftMousedown)) {
      e2.preventDefault();
      this.emit("drag", e2, this);
    }
  }
  //  鼠标松开事件
  onMouseup(e2) {
    this.onNodeMouseup();
    this.emit("mouseup", e2, this);
  }
  // 节点鼠标松开事件
  onNodeMouseup() {
    this.isLeftMousedown = false;
    this.isRightMousedown = false;
    this.isMiddleMousedown = false;
  }
  //  鼠标滚动/触控板滑动
  onMousewheel(e2) {
    e2.stopPropagation();
    e2.preventDefault();
    const dirs = [];
    if (e2.deltaY < 0)
      dirs.push(CONSTANTS.DIR.UP);
    if (e2.deltaY > 0)
      dirs.push(CONSTANTS.DIR.DOWN);
    if (e2.deltaX < 0)
      dirs.push(CONSTANTS.DIR.LEFT);
    if (e2.deltaX > 0)
      dirs.push(CONSTANTS.DIR.RIGHT);
    let isTouchPad = false;
    if (e2.wheelDeltaY === e2.deltaY * -3 || Math.abs(e2.wheelDeltaY) <= 10) {
      isTouchPad = true;
    }
    this.emit("mousewheel", e2, dirs, this, isTouchPad);
  }
  //  鼠标右键菜单事件
  onContextmenu(e2) {
    e2.preventDefault();
    this.emit("contextmenu", e2);
  }
  //  按键松开事件
  onKeyup(e2) {
    this.emit("keyup", e2);
  }
  // 进入
  onMouseenter(e2) {
    this.emit("svg_mouseenter", e2);
  }
  // 离开
  onMouseleave(e2) {
    this.emit("svg_mouseleave", e2);
  }
};
var Event_default = Event2;

// ../simple-mind-map/src/core/render/Render.js
var import_deepmerge = __toESM(require_cjs());

// ../simple-mind-map/node_modules/uuid/dist/esm-browser/rng.js
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);
    if (!getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
  }
  return getRandomValues(rnds8);
}

// ../simple-mind-map/node_modules/uuid/dist/esm-browser/stringify.js
var byteToHex = [];
for (let i2 = 0; i2 < 256; ++i2) {
  byteToHex.push((i2 + 256).toString(16).slice(1));
}
function unsafeStringify(arr, offset = 0) {
  return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
}

// ../simple-mind-map/node_modules/uuid/dist/esm-browser/native.js
var randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
var native_default = {
  randomUUID
};

// ../simple-mind-map/node_modules/uuid/dist/esm-browser/v4.js
function v4(options, buf, offset) {
  if (native_default.randomUUID && !buf && !options) {
    return native_default.randomUUID();
  }
  options = options || {};
  const rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (let i2 = 0; i2 < 16; ++i2) {
      buf[offset + i2] = rnds[i2];
    }
    return buf;
  }
  return unsafeStringify(rnds);
}
var v4_default = v4;

// ../simple-mind-map/src/utils/mersenneTwister.js
function MersenneTwister(seed) {
  this.N = 624;
  this.M = 397;
  this.MATRIX_A = 2567483615;
  this.UPPER_MASK = 2147483648;
  this.LOWER_MASK = 2147483647;
  this.mt = new Array(this.N);
  this.mti = this.N + 1;
  this.init_genrand(seed);
}
MersenneTwister.prototype.init_genrand = function(s2) {
  this.mt[0] = s2 >>> 0;
  for (this.mti = 1; this.mti < this.N; this.mti++) {
    s2 = this.mt[this.mti - 1] ^ this.mt[this.mti - 1] >>> 30;
    this.mt[this.mti] = (((s2 & 4294901760) >>> 16) * 1812433253 << 16) + (s2 & 65535) * 1812433253 + this.mti;
    this.mt[this.mti] >>>= 0;
  }
};
MersenneTwister.prototype.genrand_int32 = function() {
  var y3;
  var mag01 = new Array(0, this.MATRIX_A);
  if (this.mti >= this.N) {
    var kk;
    if (this.mti == this.N + 1)
      this.init_genrand(5489);
    for (kk = 0; kk < this.N - this.M; kk++) {
      y3 = this.mt[kk] & this.UPPER_MASK | this.mt[kk + 1] & this.LOWER_MASK;
      this.mt[kk] = this.mt[kk + this.M] ^ y3 >>> 1 ^ mag01[y3 & 1];
    }
    for (; kk < this.N - 1; kk++) {
      y3 = this.mt[kk] & this.UPPER_MASK | this.mt[kk + 1] & this.LOWER_MASK;
      this.mt[kk] = this.mt[kk + (this.M - this.N)] ^ y3 >>> 1 ^ mag01[y3 & 1];
    }
    y3 = this.mt[this.N - 1] & this.UPPER_MASK | this.mt[0] & this.LOWER_MASK;
    this.mt[this.N - 1] = this.mt[this.M - 1] ^ y3 >>> 1 ^ mag01[y3 & 1];
    this.mti = 0;
  }
  y3 = this.mt[this.mti++];
  y3 ^= y3 >>> 11;
  y3 ^= y3 << 7 & 2636928640;
  y3 ^= y3 << 15 & 4022730752;
  y3 ^= y3 >>> 18;
  return y3 >>> 0;
};

// ../simple-mind-map/src/utils/index.js
var walk = (root2, parent, beforeCallback, afterCallback, isRoot, layerIndex = 0, index3 = 0) => {
  let stop = false;
  if (beforeCallback) {
    stop = beforeCallback(root2, parent, isRoot, layerIndex, index3);
  }
  if (!stop && root2.children && root2.children.length > 0) {
    let _layerIndex = layerIndex + 1;
    root2.children.forEach((node3, nodeIndex) => {
      walk(
        node3,
        root2,
        beforeCallback,
        afterCallback,
        false,
        _layerIndex,
        nodeIndex
      );
    });
  }
  afterCallback && afterCallback(root2, parent, isRoot, layerIndex, index3);
};
var bfsWalk = (root2, callback) => {
  let stack = [root2];
  let isStop = false;
  if (callback(root2, null) === "stop") {
    isStop = true;
  }
  while (stack.length) {
    if (isStop) {
      break;
    }
    let cur = stack.shift();
    if (cur.children && cur.children.length) {
      cur.children.forEach((item) => {
        if (isStop)
          return;
        stack.push(item);
        if (callback(item, cur) === "stop") {
          isStop = true;
        }
      });
    }
  }
};
var resizeImgSizeByOriginRatio = (width2, height2, newWidth, newHeight) => {
  let arr = [];
  let nRatio = width2 / height2;
  let mRatio = newWidth / newHeight;
  if (nRatio > mRatio) {
    arr = [nRatio * newHeight, newHeight];
  } else {
    arr = [newWidth, newWidth / nRatio];
  }
  return arr;
};
var resizeImgSize = (width2, height2, maxWidth, maxHeight) => {
  let nRatio = width2 / height2;
  let arr = [];
  if (maxWidth && maxHeight) {
    if (width2 <= maxWidth && height2 <= maxHeight) {
      arr = [width2, height2];
    } else {
      let mRatio = maxWidth / maxHeight;
      if (nRatio > mRatio) {
        arr = [nRatio * maxHeight, maxHeight];
      } else {
        arr = [maxWidth, maxWidth / nRatio];
      }
    }
  } else if (maxWidth) {
    if (width2 <= maxWidth) {
      arr = [width2, height2];
    } else {
      arr = [maxWidth, maxWidth / nRatio];
    }
  } else if (maxHeight) {
    if (height2 <= maxHeight) {
      arr = [width2, height2];
    } else {
      arr = [nRatio * maxHeight, maxHeight];
    }
  }
  return arr;
};
var getStrWithBrFromHtml = (str) => {
  str = str.replace(/<br>/gim, "\n");
  let el2 = document.createElement("div");
  el2.innerHTML = str;
  str = el2.textContent;
  return str;
};
var simpleDeepClone = (data2) => {
  try {
    return JSON.parse(JSON.stringify(data2));
  } catch (error) {
    return null;
  }
};
var copyRenderTree = (tree, root2, removeActiveState = false) => {
  tree.data = simpleDeepClone(root2.data);
  if (removeActiveState) {
    tree.data.isActive = false;
    if (tree.data.generalization) {
      tree.data.generalization.isActive = false;
    }
  }
  tree.children = [];
  if (root2.children && root2.children.length > 0) {
    root2.children.forEach((item, index3) => {
      tree.children[index3] = copyRenderTree({}, item, removeActiveState);
    });
  }
  return tree;
};
var copyNodeTree = (tree, root2, removeActiveState = false, removeId = true) => {
  tree.data = simpleDeepClone(root2.nodeData ? root2.nodeData.data : root2.data);
  if (removeId) {
    delete tree.data.uid;
  } else if (!tree.data.uid) {
    tree.data.uid = createUid();
  }
  if (removeActiveState) {
    tree.data.isActive = false;
  }
  tree.children = [];
  if (root2.children && root2.children.length > 0) {
    root2.children.forEach((item, index3) => {
      tree.children[index3] = copyNodeTree({}, item, removeActiveState, removeId);
    });
  } else if (root2.nodeData && root2.nodeData.children && root2.nodeData.children.length > 0) {
    root2.nodeData.children.forEach((item, index3) => {
      tree.children[index3] = copyNodeTree({}, item, removeActiveState, removeId);
    });
  }
  return tree;
};
var imgToDataUrl = (src) => {
  return new Promise((resolve, reject) => {
    const img = new Image();
    img.setAttribute("crossOrigin", "anonymous");
    img.onload = () => {
      try {
        let canvas = document.createElement("canvas");
        canvas.width = img.width;
        canvas.height = img.height;
        let ctx = canvas.getContext("2d");
        ctx.drawImage(img, 0, 0, img.width, img.height);
        resolve(canvas.toDataURL());
      } catch (e2) {
        reject(e2);
      }
    };
    img.onerror = (e2) => {
      reject(e2);
    };
    img.src = src;
  });
};
var parseDataUrl = (data2) => {
  if (!/^data:/.test(data2))
    return data2;
  let [typeStr, base64] = data2.split(",");
  let res = /^data:[^/]+\/([^;]+);/.exec(typeStr);
  let type = res[1];
  return {
    type,
    base64
  };
};
var downloadFile = (file, fileName) => {
  let a2 = document.createElement("a");
  a2.href = file;
  a2.download = fileName;
  a2.click();
};
var throttle = (fn, time = 300, ctx) => {
  let timer = null;
  return (...args) => {
    if (timer) {
      return;
    }
    timer = setTimeout(() => {
      fn.call(ctx, ...args);
      timer = null;
    }, time);
  };
};
var asyncRun = (taskList, callback = () => {
}) => {
  let index3 = 0;
  let len = taskList.length;
  if (len <= 0) {
    return callback();
  }
  let loop = () => {
    if (index3 >= len) {
      callback();
      return;
    }
    taskList[index3]();
    setTimeout(() => {
      index3++;
      loop();
    }, 0);
  };
  loop();
};
var degToRad = (deg) => {
  return deg * (Math.PI / 180);
};
var camelCaseToHyphen = (str) => {
  return str.replace(/([a-z])([A-Z])/g, (...args) => {
    return args[1] + "-" + args[2].toLowerCase();
  });
};
var measureTextContext = null;
var measureText = (text4, { italic, bold, fontSize, fontFamily }) => {
  const font = joinFontStr({
    italic,
    bold,
    fontSize,
    fontFamily
  });
  if (!measureTextContext) {
    const canvas = document.createElement("canvas");
    measureTextContext = canvas.getContext("2d");
  }
  measureTextContext.save();
  measureTextContext.font = font;
  const { width: width2, actualBoundingBoxAscent, actualBoundingBoxDescent } = measureTextContext.measureText(text4);
  measureTextContext.restore();
  const height2 = actualBoundingBoxAscent + actualBoundingBoxDescent;
  return { width: width2, height: height2 };
};
var joinFontStr = ({ italic, bold, fontSize, fontFamily }) => {
  return `${italic ? "italic " : ""} ${bold ? "bold " : ""} ${fontSize}px ${fontFamily} `;
};
var nextTick = function(fn, ctx) {
  let pending = false;
  let timerFunc = null;
  let handle = () => {
    pending = false;
    ctx ? fn.call(ctx) : fn();
  };
  if (typeof MutationObserver !== "undefined") {
    let counter = 1;
    let observer = new MutationObserver(handle);
    let textNode = document.createTextNode(counter);
    observer.observe(textNode, {
      characterData: true
      // 设为 true 表示监视指定目标节点或子节点树中节点所包含的字符数据的变化
    });
    timerFunc = function() {
      counter = (counter + 1) % 2;
      textNode.data = counter;
    };
  } else {
    timerFunc = setTimeout;
  }
  return function() {
    if (pending)
      return;
    pending = true;
    timerFunc(handle, 0);
  };
};
var checkNodeOuter = (mindMap, node3) => {
  let elRect = mindMap.elRect;
  let { scaleX, scaleY, translateX, translateY } = mindMap.draw.transform();
  let { left, top, width: width2, height: height2 } = node3;
  let right = (left + width2) * scaleX + translateX;
  let bottom = (top + height2) * scaleY + translateY;
  left = left * scaleX + translateX;
  top = top * scaleY + translateY;
  let offsetLeft = 0;
  let offsetTop = 0;
  if (left < 0) {
    offsetLeft = -left;
  }
  if (right > elRect.width) {
    offsetLeft = -(right - elRect.width);
  }
  if (top < 0) {
    offsetTop = -top;
  }
  if (bottom > elRect.height) {
    offsetTop = -(bottom - elRect.height);
  }
  return {
    isOuter: offsetLeft !== 0 || offsetTop !== 0,
    offsetLeft,
    offsetTop
  };
};
var getTextFromHtmlEl = null;
var getTextFromHtml = (html2) => {
  if (!getTextFromHtmlEl) {
    getTextFromHtmlEl = document.createElement("div");
  }
  getTextFromHtmlEl.innerHTML = html2;
  return getTextFromHtmlEl.textContent;
};
var readBlob = (blob) => {
  return new Promise((resolve, reject) => {
    let reader = new FileReader();
    reader.onload = (evt) => {
      resolve(evt.target.result);
    };
    reader.onerror = (err) => {
      reject(err);
    };
    reader.readAsDataURL(blob);
  });
};
var getImageSize = (src) => {
  return new Promise((resolve) => {
    let img = new Image();
    img.src = src;
    img.onload = () => {
      resolve({
        width: img.width,
        height: img.height
      });
    };
    img.onerror = () => {
      resolve({
        width: 0,
        height: 0
      });
    };
  });
};
var createUid = () => {
  return v4_default();
};
var loadImage = (imgFile) => {
  return new Promise((resolve, reject) => {
    let fr = new FileReader();
    fr.readAsDataURL(imgFile);
    fr.onload = async (e2) => {
      let url = e2.target.result;
      let size2 = await getImageSize(url);
      resolve({
        url,
        size: size2
      });
    };
    fr.onerror = (error) => {
      reject(error);
    };
  });
};
var removeHTMLEntities = (str) => {
  ;
  [["&nbsp;", "&#160;"]].forEach((item) => {
    str = str.replaceAll(item[0], item[1]);
  });
  return str;
};
var getType = (data2) => {
  return Object.prototype.toString.call(data2).slice(8, -1);
};
var isUndef = (data2) => {
  return data2 === null || data2 === void 0 || data2 === "";
};
var removeHtmlStyle = (html2) => {
  return html2.replaceAll(/(<[^\s]+)\s+style=["'][^'"]+["']\s*(>)/g, "$1$2");
};
var addHtmlStyle = (html2, tag, style) => {
  const reg = new RegExp(`(<${tag}[^>]*)(>[^<>]*</${tag}>)`, "g");
  return html2.replaceAll(reg, `$1 style="${style}"$2`);
};
var checkIsRichTextEl = null;
var checkIsRichText = (str) => {
  if (!checkIsRichTextEl) {
    checkIsRichTextEl = document.createElement("div");
  }
  checkIsRichTextEl.innerHTML = str;
  for (let c3 = checkIsRichTextEl.childNodes, i2 = c3.length; i2--; ) {
    if (c3[i2].nodeType == 1)
      return true;
  }
  return false;
};
var replaceHtmlTextEl = null;
var replaceHtmlText = (html2, searchText, replaceText) => {
  if (!replaceHtmlTextEl) {
    replaceHtmlTextEl = document.createElement("div");
  }
  replaceHtmlTextEl.innerHTML = html2;
  let walk2 = (root2) => {
    let childNodes = root2.childNodes;
    childNodes.forEach((node3) => {
      if (node3.nodeType === 1) {
        walk2(node3);
      } else if (node3.nodeType === 3) {
        root2.replaceChild(
          document.createTextNode(
            node3.nodeValue.replaceAll(searchText, replaceText)
          ),
          node3
        );
      }
    });
  };
  walk2(replaceHtmlTextEl);
  return replaceHtmlTextEl.innerHTML;
};
var isWhite = (color) => {
  color = String(color).replaceAll(/\s+/g, "");
  return ["#fff", "#ffffff", "#FFF", "#FFFFFF", "rgb(255,255,255)"].includes(
    color
  ) || /rgba\(255,255,255,[^)]+\)/.test(color);
};
var isTransparent = (color) => {
  color = String(color).replaceAll(/\s+/g, "");
  return ["", "transparent"].includes(color) || /rgba\(\d+,\d+,\d+,0\)/.test(color);
};
var getVisibleColorFromTheme = (themeConfig) => {
  let { lineColor, root: root2, second, node: node3 } = themeConfig;
  let list2 = [
    lineColor,
    root2.fillColor,
    root2.color,
    second.fillColor,
    second.color,
    node3.fillColor,
    node3.color,
    root2.borderColor,
    second.borderColor,
    node3.borderColor
  ];
  for (let i2 = 0; i2 < list2.length; i2++) {
    let color = list2[i2];
    if (!isTransparent(color) && !isWhite(color)) {
      return color;
    }
  }
};
var getObjectChangedProps = (oldObject, newObject) => {
  const res = {};
  Object.keys(newObject).forEach((prop) => {
    const oldVal = oldObject[prop];
    const newVal = newObject[prop];
    if (getType(oldVal) !== getType(newVal)) {
      res[prop] = newVal;
      return;
    }
    if (getType(oldVal) === "Object") {
      if (JSON.stringify(oldVal) !== JSON.stringify(newVal)) {
        res[prop] = newVal;
        return;
      }
    } else {
      if (oldVal !== newVal) {
        res[prop] = newVal;
        return;
      }
    }
  });
  return res;
};
var checkIsNodeStyleDataKey = (key) => {
  if (/^_/.test(key))
    return false;
  if (!nodeDataNoStylePropList.includes(key)) {
    return true;
  }
  return false;
};
var mergerIconList = (list2) => {
  return list2.reduce((result, item) => {
    const existingItem = result.find((x2) => x2.type === item.type);
    if (existingItem) {
      item.list.forEach((newObj) => {
        const existingObj = existingItem.list.find((x2) => x2.name === newObj.name);
        if (existingObj) {
          existingObj.icon = newObj.icon;
        } else {
          existingItem.list.push(newObj);
        }
      });
    } else {
      result.push({ ...item });
    }
    return result;
  }, []);
};
var getTopAncestorsFomNodeList = (list2) => {
  let res = [];
  list2.forEach((node3) => {
    if (!list2.find((item) => {
      return item.uid !== node3.uid && item.isAncestor(node3);
    })) {
      res.push(node3);
    }
  });
  return res;
};
var parseAddGeneralizationNodeList = (list2) => {
  const cache = {};
  const uidToParent = {};
  list2.forEach((node3) => {
    const parent = node3.parent;
    if (parent) {
      const pUid = parent.uid;
      uidToParent[pUid] = parent;
      const index3 = node3.getIndexInBrothers();
      const data2 = {
        node: node3,
        index: index3
      };
      if (cache[pUid]) {
        if (!cache[pUid].find((item) => {
          return item.index === data2.index;
        })) {
          cache[pUid].push(data2);
        }
      } else {
        cache[pUid] = [data2];
      }
    }
  });
  const res = [];
  Object.keys(cache).forEach((uid) => {
    if (cache[uid].length > 1) {
      const rangeList = cache[uid].map((item) => {
        return item.index;
      }).sort((a2, b) => {
        return a2 - b;
      });
      res.push({
        node: uidToParent[uid],
        range: [rangeList[0], rangeList[rangeList.length - 1]]
      });
    } else {
      res.push({
        node: cache[uid][0].node
      });
    }
  });
  return res;
};
var checkTwoRectIsOverlap = (minx1, maxx1, miny1, maxy1, minx2, maxx2, miny2, maxy2) => {
  return maxx1 > minx2 && maxx2 > minx1 && maxy1 > miny2 && maxy2 > miny1;
};
var focusInput = (el2) => {
  let selection = window.getSelection();
  let range = document.createRange();
  range.selectNodeContents(el2);
  range.collapse();
  selection.removeAllRanges();
  selection.addRange(range);
};
var selectAllInput = (el2) => {
  let selection = window.getSelection();
  let range = document.createRange();
  range.selectNodeContents(el2);
  selection.removeAllRanges();
  selection.addRange(range);
};
var addDataToAppointNodes = (appointNodes, data2 = {}) => {
  const walk2 = (list2) => {
    list2.forEach((node3) => {
      node3.data = {
        ...node3.data,
        ...data2
      };
      if (node3.children && node3.children.length > 0) {
        walk2(node3.children);
      }
    });
  };
  walk2(appointNodes);
  return appointNodes;
};
var createUidForAppointNodes = (appointNodes, createNewId = false) => {
  const walk2 = (list2) => {
    list2.forEach((node3) => {
      if (!node3.data) {
        node3.data = {};
      }
      if (createNewId || isUndef(node3.data.uid)) {
        node3.data.uid = createUid();
      }
      if (node3.children && node3.children.length > 0) {
        walk2(node3.children);
      }
    });
  };
  walk2(appointNodes);
  return appointNodes;
};
var formatDataToArray = (data2) => {
  if (!data2)
    return [];
  return Array.isArray(data2) ? data2 : [data2];
};
var getNodeDataIndex = (node3) => {
  return node3.parent ? node3.parent.nodeData.children.findIndex((item) => {
    return item.data.uid === node3.uid;
  }) : 0;
};
var getNodeIndexInNodeList = (node3, nodeList) => {
  return nodeList.findIndex((item) => {
    return item.uid === node3.uid;
  });
};
var generateColorByContent = (str) => {
  let hash = 0;
  for (let i2 = 0; i2 < str.length; i2++) {
    hash = str.charCodeAt(i2) + ((hash << 5) - hash);
  }
  const rng2 = new MersenneTwister(hash);
  const h2 = rng2.genrand_int32() % 360;
  return "hsla(" + h2 + ", 50%, 50%, 1)";
};
var htmlEscape = (str) => {
  ;
  [
    ["&", "&amp;"],
    ["<", "&lt;"],
    [">", "&gt;"]
  ].forEach((item) => {
    str = str.replace(new RegExp(item[0], "g"), item[1]);
  });
  return str;
};
var setDataToClipboard = (data2) => {
  if (navigator.clipboard) {
    navigator.clipboard.writeText(JSON.stringify(data2));
  }
};
var getDataFromClipboard = async () => {
  let text4 = null;
  let img = null;
  if (navigator.clipboard) {
    text4 = await navigator.clipboard.readText();
    const items = await navigator.clipboard.read();
    if (items && items.length > 0) {
      for (const clipboardItem of items) {
        for (const type of clipboardItem.types) {
          if (/^image\//.test(type)) {
            img = await clipboardItem.getType(type);
            break;
          }
        }
      }
    }
  }
  return {
    text: text4,
    img
  };
};
var removeFromParentNodeData = (node3) => {
  if (!node3 || !node3.parent)
    return;
  const index3 = getNodeDataIndex(node3);
  if (index3 === -1)
    return;
  node3.parent.nodeData.children.splice(index3, 1);
};
var handleSelfCloseTags = (str) => {
  selfCloseTagList.forEach((tagName) => {
    str = str.replaceAll(
      new RegExp(`<${tagName}([^>]*)>`, "g"),
      `<${tagName} $1 />`
    );
  });
  return str;
};
var checkNodeListIsEqual = (list1, list2) => {
  if (list1.length !== list2.length)
    return false;
  for (let i2 = 0; i2 < list1.length; i2++) {
    if (!list2.find((item) => {
      return item.uid === list1[i2].uid;
    })) {
      return false;
    }
  }
  return true;
};

// ../simple-mind-map/src/core/render/node/Style.js
var rootProp = ["paddingX", "paddingY"];
var backgroundStyleProps = [
  "backgroundColor",
  "backgroundImage",
  "backgroundRepeat",
  "backgroundPosition",
  "backgroundSize"
];
var Style = class {
  //   设置背景样式
  static setBackgroundStyle(el2, themeConfig) {
    if (!Style.cacheStyle) {
      Style.cacheStyle = {};
      let style = window.getComputedStyle(el2);
      backgroundStyleProps.forEach((prop) => {
        Style.cacheStyle[prop] = style[prop];
      });
    }
    let {
      backgroundColor,
      backgroundImage,
      backgroundRepeat,
      backgroundPosition,
      backgroundSize
    } = themeConfig;
    el2.style.backgroundColor = backgroundColor;
    if (backgroundImage && backgroundImage !== "none") {
      el2.style.backgroundImage = `url(${backgroundImage})`;
      el2.style.backgroundRepeat = backgroundRepeat;
      el2.style.backgroundPosition = backgroundPosition;
      el2.style.backgroundSize = backgroundSize;
    } else {
      el2.style.backgroundImage = "none";
    }
  }
  // 移除背景样式
  static removeBackgroundStyle(el2) {
    if (!Style.cacheStyle)
      return;
    backgroundStyleProps.forEach((prop) => {
      el2.style[prop] = Style.cacheStyle[prop];
    });
    Style.cacheStyle = null;
  }
  //  构造函数
  constructor(ctx) {
    this.ctx = ctx;
    this._markerPath = null;
    this._marker = null;
  }
  //  合并样式
  merge(prop, root2) {
    let themeConfig = this.ctx.mindMap.themeConfig;
    let defaultConfig = themeConfig.node;
    if (root2 || rootProp.includes(prop)) {
      defaultConfig = themeConfig;
    } else if (this.ctx.isGeneralization) {
      defaultConfig = themeConfig.generalization;
    } else if (this.ctx.layerIndex === 0) {
      defaultConfig = themeConfig.root;
    } else if (this.ctx.layerIndex === 1) {
      defaultConfig = themeConfig.second;
    }
    return this.getSelfStyle(prop) !== void 0 ? this.getSelfStyle(prop) : defaultConfig[prop];
  }
  //  获取某个样式值
  getStyle(prop, root2) {
    return this.merge(prop, root2);
  }
  //  获取自身自定义样式
  getSelfStyle(prop) {
    return this.ctx.getData(prop);
  }
  //  矩形
  rect(node3) {
    this.shape(node3);
    node3.radius(this.merge("borderRadius"));
  }
  //   矩形外的其他形状
  shape(node3) {
    node3.fill({
      color: this.merge("fillColor")
    });
    node3.stroke({
      color: this.merge("borderColor"),
      width: this.merge("borderWidth"),
      dasharray: this.merge("borderDasharray")
    });
  }
  //  文字
  text(node3) {
    node3.fill({
      color: this.merge("color")
    }).css({
      "font-family": this.merge("fontFamily"),
      "font-size": this.merge("fontSize"),
      "font-weight": this.merge("fontWeight"),
      "font-style": this.merge("fontStyle"),
      "text-decoration": this.merge("textDecoration")
    });
  }
  // 生成内联样式
  createStyleText() {
    return `
      color: ${this.merge("color")};
      font-family: ${this.merge("fontFamily")};
      font-size: ${this.merge("fontSize") + "px"};
      font-weight: ${this.merge("fontWeight")};
      font-style: ${this.merge("fontStyle")};
      text-decoration: ${this.merge("textDecoration")}
    `;
  }
  // 获取文本样式
  getTextFontStyle() {
    return {
      italic: this.merge("fontStyle") === "italic",
      bold: this.merge("fontWeight"),
      fontSize: this.merge("fontSize"),
      fontFamily: this.merge("fontFamily")
    };
  }
  //  html文字节点
  domText(node3, fontSizeScale = 1, isMultiLine) {
    node3.style.fontFamily = this.merge("fontFamily");
    node3.style.fontSize = this.merge("fontSize") * fontSizeScale + "px";
    node3.style.fontWeight = this.merge("fontWeight") || "normal";
    node3.style.lineHeight = !isMultiLine ? "normal" : this.merge("lineHeight");
    node3.style.fontStyle = this.merge("fontStyle");
  }
  //  标签文字
  tagText(node3) {
    node3.fill({
      color: "#fff"
    }).css({
      "font-size": "12px"
    });
  }
  //  标签矩形
  tagRect(node3, text4, color) {
    node3.fill({
      color: color || generateColorByContent(text4.node.textContent)
    });
  }
  //  内置图标
  iconNode(node3) {
    node3.attr({
      fill: this.merge("color")
    });
  }
  //  连线
  line(line, { width: width2, color, dasharray } = {}, enableMarker, childNode) {
    line.stroke({ color, dasharray, width: width2 }).fill({ color: "none" });
    if (enableMarker) {
      const showMarker = this.merge("showLineMarker", true);
      const childNodeStyle = childNode.style;
      if (showMarker) {
        childNodeStyle._marker = childNodeStyle._marker || childNodeStyle.createMarker();
        childNodeStyle._markerPath.stroke({ color }).fill({ color });
        line.marker("end", childNodeStyle._marker);
      } else if (childNodeStyle._marker) {
        line.attr("marker-end", "");
        childNodeStyle._marker.remove();
        childNodeStyle._marker = null;
      }
    }
  }
  // 创建箭头
  createMarker() {
    return this.ctx.lineDraw.marker(20, 20, (add) => {
      add.ref(8, 5);
      add.size(20, 20);
      add.attr("markerUnits", "userSpaceOnUse");
      add.attr("orient", "auto-start-reverse");
      this._markerPath = add.path("M0,0 L2,5 L0,10 L10,5 Z");
    });
  }
  //  概要连线
  generalizationLine(node3) {
    node3.stroke({
      width: this.merge("generalizationLineWidth", true),
      color: this.merge("generalizationLineColor", true)
    }).fill({ color: "none" });
  }
  //  展开收起按钮
  iconBtn(node3, node22, fillNode) {
    let { color, fill, fontSize, fontColor } = this.ctx.mindMap.opt.expandBtnStyle || {
      color: "#808080",
      fill: "#fff",
      fontSize: 12,
      strokeColor: "#333333",
      fontColor: "#333333"
    };
    node3.fill({ color });
    node22.fill({ color });
    fillNode.fill({ color: fill });
    if (this.ctx.mindMap.opt.isShowExpandNum) {
      node3.attr({ "font-size": fontSize, "font-color": fontColor });
    }
  }
  // 是否设置了自定义的样式
  hasCustomStyle() {
    let res = false;
    Object.keys(this.ctx.getData()).forEach((item) => {
      if (checkIsNodeStyleDataKey(item)) {
        res = true;
      }
    });
    return res;
  }
  // hover和激活节点
  hoverNode(node3) {
    const { hoverRectColor } = this.ctx.mindMap.opt;
    node3.radius(5).fill("none").stroke({
      color: hoverRectColor
    });
  }
};
Style.cacheStyle = null;
var Style_default = Style;

// ../simple-mind-map/node_modules/@svgdotjs/svg.js/dist/svg.esm.js
var methods$1 = {};
var names = [];
function registerMethods(name, m3) {
  if (Array.isArray(name)) {
    for (const _name of name) {
      registerMethods(_name, m3);
    }
    return;
  }
  if (typeof name === "object") {
    for (const _name in name) {
      registerMethods(_name, name[_name]);
    }
    return;
  }
  addMethodNames(Object.getOwnPropertyNames(m3));
  methods$1[name] = Object.assign(methods$1[name] || {}, m3);
}
function getMethodsFor(name) {
  return methods$1[name] || {};
}
function getMethodNames() {
  return [...new Set(names)];
}
function addMethodNames(_names) {
  names.push(..._names);
}
function map(array2, block) {
  let i2;
  const il = array2.length;
  const result = [];
  for (i2 = 0; i2 < il; i2++) {
    result.push(block(array2[i2]));
  }
  return result;
}
function filter(array2, block) {
  let i2;
  const il = array2.length;
  const result = [];
  for (i2 = 0; i2 < il; i2++) {
    if (block(array2[i2])) {
      result.push(array2[i2]);
    }
  }
  return result;
}
function radians(d) {
  return d % 360 * Math.PI / 180;
}
function camelCase(s2) {
  return s2.toLowerCase().replace(/-(.)/g, function(m3, g) {
    return g.toUpperCase();
  });
}
function unCamelCase(s2) {
  return s2.replace(/([A-Z])/g, function(m3, g) {
    return "-" + g.toLowerCase();
  });
}
function capitalize(s2) {
  return s2.charAt(0).toUpperCase() + s2.slice(1);
}
function proportionalSize(element2, width2, height2, box) {
  if (width2 == null || height2 == null) {
    box = box || element2.bbox();
    if (width2 == null) {
      width2 = box.width / box.height * height2;
    } else if (height2 == null) {
      height2 = box.height / box.width * width2;
    }
  }
  return {
    width: width2,
    height: height2
  };
}
function getOrigin(o2, element2) {
  const origin = o2.origin;
  let ox = o2.ox != null ? o2.ox : o2.originX != null ? o2.originX : "center";
  let oy = o2.oy != null ? o2.oy : o2.originY != null ? o2.originY : "center";
  if (origin != null) {
    [ox, oy] = Array.isArray(origin) ? origin : typeof origin === "object" ? [origin.x, origin.y] : [origin, origin];
  }
  const condX = typeof ox === "string";
  const condY = typeof oy === "string";
  if (condX || condY) {
    const {
      height: height2,
      width: width2,
      x: x2,
      y: y3
    } = element2.bbox();
    if (condX) {
      ox = ox.includes("left") ? x2 : ox.includes("right") ? x2 + width2 : x2 + width2 / 2;
    }
    if (condY) {
      oy = oy.includes("top") ? y3 : oy.includes("bottom") ? y3 + height2 : y3 + height2 / 2;
    }
  }
  return [ox, oy];
}
var svg = "http://www.w3.org/2000/svg";
var html = "http://www.w3.org/1999/xhtml";
var xmlns = "http://www.w3.org/2000/xmlns/";
var xlink = "http://www.w3.org/1999/xlink";
var svgjs = "http://svgjs.dev/svgjs";
var globals = {
  window: typeof window === "undefined" ? null : window,
  document: typeof document === "undefined" ? null : document
};
var Base = class {
  // constructor (node/*, {extensions = []} */) {
  //   // this.tags = []
  //   //
  //   // for (let extension of extensions) {
  //   //   extension.setup.call(this, node)
  //   //   this.tags.push(extension.name)
  //   // }
  // }
};
var elements = {};
var root = "___SYMBOL___ROOT___";
function create(name, ns = svg) {
  return globals.document.createElementNS(ns, name);
}
function makeInstance(element2, isHTML = false) {
  if (element2 instanceof Base)
    return element2;
  if (typeof element2 === "object") {
    return adopter(element2);
  }
  if (element2 == null) {
    return new elements[root]();
  }
  if (typeof element2 === "string" && element2.charAt(0) !== "<") {
    return adopter(globals.document.querySelector(element2));
  }
  const wrapper = isHTML ? globals.document.createElement("div") : create("svg");
  wrapper.innerHTML = element2;
  element2 = adopter(wrapper.firstChild);
  wrapper.removeChild(wrapper.firstChild);
  return element2;
}
function nodeOrNew(name, node3) {
  return node3 && node3.ownerDocument && node3 instanceof node3.ownerDocument.defaultView.Node ? node3 : create(name);
}
function adopt(node3) {
  if (!node3)
    return null;
  if (node3.instance instanceof Base)
    return node3.instance;
  if (node3.nodeName === "#document-fragment") {
    return new elements.Fragment(node3);
  }
  let className = capitalize(node3.nodeName || "Dom");
  if (className === "LinearGradient" || className === "RadialGradient") {
    className = "Gradient";
  } else if (!elements[className]) {
    className = "Dom";
  }
  return new elements[className](node3);
}
var adopter = adopt;
function register(element2, name = element2.name, asRoot = false) {
  elements[name] = element2;
  if (asRoot)
    elements[root] = element2;
  addMethodNames(Object.getOwnPropertyNames(element2.prototype));
  return element2;
}
function getClass(name) {
  return elements[name];
}
var did = 1e3;
function eid(name) {
  return "Svgjs" + capitalize(name) + did++;
}
function assignNewId(node3) {
  for (let i2 = node3.children.length - 1; i2 >= 0; i2--) {
    assignNewId(node3.children[i2]);
  }
  if (node3.id) {
    node3.id = eid(node3.nodeName);
    return node3;
  }
  return node3;
}
function extend(modules, methods2) {
  let key, i2;
  modules = Array.isArray(modules) ? modules : [modules];
  for (i2 = modules.length - 1; i2 >= 0; i2--) {
    for (key in methods2) {
      modules[i2].prototype[key] = methods2[key];
    }
  }
}
function wrapWithAttrCheck(fn) {
  return function(...args) {
    const o2 = args[args.length - 1];
    if (o2 && o2.constructor === Object && !(o2 instanceof Array)) {
      return fn.apply(this, args.slice(0, -1)).attr(o2);
    } else {
      return fn.apply(this, args);
    }
  };
}
function siblings() {
  return this.parent().children();
}
function position() {
  return this.parent().index(this);
}
function next() {
  return this.siblings()[this.position() + 1];
}
function prev() {
  return this.siblings()[this.position() - 1];
}
function forward() {
  const i2 = this.position();
  const p2 = this.parent();
  p2.add(this.remove(), i2 + 1);
  return this;
}
function backward() {
  const i2 = this.position();
  const p2 = this.parent();
  p2.add(this.remove(), i2 ? i2 - 1 : 0);
  return this;
}
function front() {
  const p2 = this.parent();
  p2.add(this.remove());
  return this;
}
function back() {
  const p2 = this.parent();
  p2.add(this.remove(), 0);
  return this;
}
function before(element2) {
  element2 = makeInstance(element2);
  element2.remove();
  const i2 = this.position();
  this.parent().add(element2, i2);
  return this;
}
function after(element2) {
  element2 = makeInstance(element2);
  element2.remove();
  const i2 = this.position();
  this.parent().add(element2, i2 + 1);
  return this;
}
function insertBefore(element2) {
  element2 = makeInstance(element2);
  element2.before(this);
  return this;
}
function insertAfter(element2) {
  element2 = makeInstance(element2);
  element2.after(this);
  return this;
}
registerMethods("Dom", {
  siblings,
  position,
  next,
  prev,
  forward,
  backward,
  front,
  back,
  before,
  after,
  insertBefore,
  insertAfter
});
var numberAndUnit = /^([+-]?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?)([a-z%]*)$/i;
var hex = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i;
var rgb = /rgb\((\d+),(\d+),(\d+)\)/;
var reference = /(#[a-z_][a-z0-9\-_]*)/i;
var transforms = /\)\s*,?\s*/;
var whitespace = /\s/g;
var isHex = /^#[a-f0-9]{3}$|^#[a-f0-9]{6}$/i;
var isRgb = /^rgb\(/;
var isBlank = /^(\s+)?$/;
var isNumber = /^[+-]?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i;
var isImage = /\.(jpg|jpeg|png|gif|svg)(\?[^=]+.*)?/i;
var delimiter = /[\s,]+/;
var isPathLetter = /[MLHVCSQTAZ]/i;
function classes() {
  const attr2 = this.attr("class");
  return attr2 == null ? [] : attr2.trim().split(delimiter);
}
function hasClass(name) {
  return this.classes().indexOf(name) !== -1;
}
function addClass(name) {
  if (!this.hasClass(name)) {
    const array2 = this.classes();
    array2.push(name);
    this.attr("class", array2.join(" "));
  }
  return this;
}
function removeClass(name) {
  if (this.hasClass(name)) {
    this.attr("class", this.classes().filter(function(c3) {
      return c3 !== name;
    }).join(" "));
  }
  return this;
}
function toggleClass(name) {
  return this.hasClass(name) ? this.removeClass(name) : this.addClass(name);
}
registerMethods("Dom", {
  classes,
  hasClass,
  addClass,
  removeClass,
  toggleClass
});
function css(style, val) {
  const ret = {};
  if (arguments.length === 0) {
    this.node.style.cssText.split(/\s*;\s*/).filter(function(el2) {
      return !!el2.length;
    }).forEach(function(el2) {
      const t2 = el2.split(/\s*:\s*/);
      ret[t2[0]] = t2[1];
    });
    return ret;
  }
  if (arguments.length < 2) {
    if (Array.isArray(style)) {
      for (const name of style) {
        const cased = camelCase(name);
        ret[name] = this.node.style[cased];
      }
      return ret;
    }
    if (typeof style === "string") {
      return this.node.style[camelCase(style)];
    }
    if (typeof style === "object") {
      for (const name in style) {
        this.node.style[camelCase(name)] = style[name] == null || isBlank.test(style[name]) ? "" : style[name];
      }
    }
  }
  if (arguments.length === 2) {
    this.node.style[camelCase(style)] = val == null || isBlank.test(val) ? "" : val;
  }
  return this;
}
function show() {
  return this.css("display", "");
}
function hide() {
  return this.css("display", "none");
}
function visible() {
  return this.css("display") !== "none";
}
registerMethods("Dom", {
  css,
  show,
  hide,
  visible
});
function data(a2, v2, r2) {
  if (a2 == null) {
    return this.data(map(filter(this.node.attributes, (el2) => el2.nodeName.indexOf("data-") === 0), (el2) => el2.nodeName.slice(5)));
  } else if (a2 instanceof Array) {
    const data2 = {};
    for (const key of a2) {
      data2[key] = this.data(key);
    }
    return data2;
  } else if (typeof a2 === "object") {
    for (v2 in a2) {
      this.data(v2, a2[v2]);
    }
  } else if (arguments.length < 2) {
    try {
      return JSON.parse(this.attr("data-" + a2));
    } catch (e2) {
      return this.attr("data-" + a2);
    }
  } else {
    this.attr("data-" + a2, v2 === null ? null : r2 === true || typeof v2 === "string" || typeof v2 === "number" ? v2 : JSON.stringify(v2));
  }
  return this;
}
registerMethods("Dom", {
  data
});
function remember(k, v2) {
  if (typeof arguments[0] === "object") {
    for (const key in k) {
      this.remember(key, k[key]);
    }
  } else if (arguments.length === 1) {
    return this.memory()[k];
  } else {
    this.memory()[k] = v2;
  }
  return this;
}
function forget() {
  if (arguments.length === 0) {
    this._memory = {};
  } else {
    for (let i2 = arguments.length - 1; i2 >= 0; i2--) {
      delete this.memory()[arguments[i2]];
    }
  }
  return this;
}
function memory() {
  return this._memory = this._memory || {};
}
registerMethods("Dom", {
  remember,
  forget,
  memory
});
function sixDigitHex(hex3) {
  return hex3.length === 4 ? ["#", hex3.substring(1, 2), hex3.substring(1, 2), hex3.substring(2, 3), hex3.substring(2, 3), hex3.substring(3, 4), hex3.substring(3, 4)].join("") : hex3;
}
function componentHex(component) {
  const integer = Math.round(component);
  const bounded = Math.max(0, Math.min(255, integer));
  const hex3 = bounded.toString(16);
  return hex3.length === 1 ? "0" + hex3 : hex3;
}
function is(object, space) {
  for (let i2 = space.length; i2--; ) {
    if (object[space[i2]] == null) {
      return false;
    }
  }
  return true;
}
function getParameters(a2, b) {
  const params = is(a2, "rgb") ? {
    _a: a2.r,
    _b: a2.g,
    _c: a2.b,
    _d: 0,
    space: "rgb"
  } : is(a2, "xyz") ? {
    _a: a2.x,
    _b: a2.y,
    _c: a2.z,
    _d: 0,
    space: "xyz"
  } : is(a2, "hsl") ? {
    _a: a2.h,
    _b: a2.s,
    _c: a2.l,
    _d: 0,
    space: "hsl"
  } : is(a2, "lab") ? {
    _a: a2.l,
    _b: a2.a,
    _c: a2.b,
    _d: 0,
    space: "lab"
  } : is(a2, "lch") ? {
    _a: a2.l,
    _b: a2.c,
    _c: a2.h,
    _d: 0,
    space: "lch"
  } : is(a2, "cmyk") ? {
    _a: a2.c,
    _b: a2.m,
    _c: a2.y,
    _d: a2.k,
    space: "cmyk"
  } : {
    _a: 0,
    _b: 0,
    _c: 0,
    space: "rgb"
  };
  params.space = b || params.space;
  return params;
}
function cieSpace(space) {
  if (space === "lab" || space === "xyz" || space === "lch") {
    return true;
  } else {
    return false;
  }
}
function hueToRgb(p2, q, t2) {
  if (t2 < 0)
    t2 += 1;
  if (t2 > 1)
    t2 -= 1;
  if (t2 < 1 / 6)
    return p2 + (q - p2) * 6 * t2;
  if (t2 < 1 / 2)
    return q;
  if (t2 < 2 / 3)
    return p2 + (q - p2) * (2 / 3 - t2) * 6;
  return p2;
}
var Color = class {
  constructor(...inputs) {
    this.init(...inputs);
  }
  // Test if given value is a color
  static isColor(color) {
    return color && (color instanceof Color || this.isRgb(color) || this.test(color));
  }
  // Test if given value is an rgb object
  static isRgb(color) {
    return color && typeof color.r === "number" && typeof color.g === "number" && typeof color.b === "number";
  }
  /*
  Generating random colors
  */
  static random(mode = "vibrant", t2, u2) {
    const {
      random,
      round,
      sin,
      PI: pi
    } = Math;
    if (mode === "vibrant") {
      const l2 = (81 - 57) * random() + 57;
      const c3 = (83 - 45) * random() + 45;
      const h2 = 360 * random();
      const color = new Color(l2, c3, h2, "lch");
      return color;
    } else if (mode === "sine") {
      t2 = t2 == null ? random() : t2;
      const r2 = round(80 * sin(2 * pi * t2 / 0.5 + 0.01) + 150);
      const g = round(50 * sin(2 * pi * t2 / 0.5 + 4.6) + 200);
      const b = round(100 * sin(2 * pi * t2 / 0.5 + 2.3) + 150);
      const color = new Color(r2, g, b);
      return color;
    } else if (mode === "pastel") {
      const l2 = (94 - 86) * random() + 86;
      const c3 = (26 - 9) * random() + 9;
      const h2 = 360 * random();
      const color = new Color(l2, c3, h2, "lch");
      return color;
    } else if (mode === "dark") {
      const l2 = 10 + 10 * random();
      const c3 = (125 - 75) * random() + 86;
      const h2 = 360 * random();
      const color = new Color(l2, c3, h2, "lch");
      return color;
    } else if (mode === "rgb") {
      const r2 = 255 * random();
      const g = 255 * random();
      const b = 255 * random();
      const color = new Color(r2, g, b);
      return color;
    } else if (mode === "lab") {
      const l2 = 100 * random();
      const a2 = 256 * random() - 128;
      const b = 256 * random() - 128;
      const color = new Color(l2, a2, b, "lab");
      return color;
    } else if (mode === "grey") {
      const grey = 255 * random();
      const color = new Color(grey, grey, grey);
      return color;
    } else {
      throw new Error("Unsupported random color mode");
    }
  }
  // Test if given value is a color string
  static test(color) {
    return typeof color === "string" && (isHex.test(color) || isRgb.test(color));
  }
  cmyk() {
    const {
      _a: _a2,
      _b: _b2,
      _c
    } = this.rgb();
    const [r2, g, b] = [_a2, _b2, _c].map((v2) => v2 / 255);
    const k = Math.min(1 - r2, 1 - g, 1 - b);
    if (k === 1) {
      return new Color(0, 0, 0, 1, "cmyk");
    }
    const c3 = (1 - r2 - k) / (1 - k);
    const m3 = (1 - g - k) / (1 - k);
    const y3 = (1 - b - k) / (1 - k);
    const color = new Color(c3, m3, y3, k, "cmyk");
    return color;
  }
  hsl() {
    const {
      _a: _a2,
      _b: _b2,
      _c
    } = this.rgb();
    const [r2, g, b] = [_a2, _b2, _c].map((v2) => v2 / 255);
    const max2 = Math.max(r2, g, b);
    const min = Math.min(r2, g, b);
    const l2 = (max2 + min) / 2;
    const isGrey = max2 === min;
    const delta = max2 - min;
    const s2 = isGrey ? 0 : l2 > 0.5 ? delta / (2 - max2 - min) : delta / (max2 + min);
    const h2 = isGrey ? 0 : max2 === r2 ? ((g - b) / delta + (g < b ? 6 : 0)) / 6 : max2 === g ? ((b - r2) / delta + 2) / 6 : max2 === b ? ((r2 - g) / delta + 4) / 6 : 0;
    const color = new Color(360 * h2, 100 * s2, 100 * l2, "hsl");
    return color;
  }
  init(a2 = 0, b = 0, c3 = 0, d = 0, space = "rgb") {
    a2 = !a2 ? 0 : a2;
    if (this.space) {
      for (const component in this.space) {
        delete this[this.space[component]];
      }
    }
    if (typeof a2 === "number") {
      space = typeof d === "string" ? d : space;
      d = typeof d === "string" ? 0 : d;
      Object.assign(this, {
        _a: a2,
        _b: b,
        _c: c3,
        _d: d,
        space
      });
    } else if (a2 instanceof Array) {
      this.space = b || (typeof a2[3] === "string" ? a2[3] : a2[4]) || "rgb";
      Object.assign(this, {
        _a: a2[0],
        _b: a2[1],
        _c: a2[2],
        _d: a2[3] || 0
      });
    } else if (a2 instanceof Object) {
      const values = getParameters(a2, b);
      Object.assign(this, values);
    } else if (typeof a2 === "string") {
      if (isRgb.test(a2)) {
        const noWhitespace = a2.replace(whitespace, "");
        const [_a3, _b3, _c2] = rgb.exec(noWhitespace).slice(1, 4).map((v2) => parseInt(v2));
        Object.assign(this, {
          _a: _a3,
          _b: _b3,
          _c: _c2,
          _d: 0,
          space: "rgb"
        });
      } else if (isHex.test(a2)) {
        const hexParse = (v2) => parseInt(v2, 16);
        const [, _a3, _b3, _c2] = hex.exec(sixDigitHex(a2)).map(hexParse);
        Object.assign(this, {
          _a: _a3,
          _b: _b3,
          _c: _c2,
          _d: 0,
          space: "rgb"
        });
      } else
        throw Error("Unsupported string format, can't construct Color");
    }
    const {
      _a: _a2,
      _b: _b2,
      _c,
      _d
    } = this;
    const components = this.space === "rgb" ? {
      r: _a2,
      g: _b2,
      b: _c
    } : this.space === "xyz" ? {
      x: _a2,
      y: _b2,
      z: _c
    } : this.space === "hsl" ? {
      h: _a2,
      s: _b2,
      l: _c
    } : this.space === "lab" ? {
      l: _a2,
      a: _b2,
      b: _c
    } : this.space === "lch" ? {
      l: _a2,
      c: _b2,
      h: _c
    } : this.space === "cmyk" ? {
      c: _a2,
      m: _b2,
      y: _c,
      k: _d
    } : {};
    Object.assign(this, components);
  }
  lab() {
    const {
      x: x2,
      y: y3,
      z
    } = this.xyz();
    const l2 = 116 * y3 - 16;
    const a2 = 500 * (x2 - y3);
    const b = 200 * (y3 - z);
    const color = new Color(l2, a2, b, "lab");
    return color;
  }
  lch() {
    const {
      l: l2,
      a: a2,
      b
    } = this.lab();
    const c3 = Math.sqrt(a2 ** 2 + b ** 2);
    let h2 = 180 * Math.atan2(b, a2) / Math.PI;
    if (h2 < 0) {
      h2 *= -1;
      h2 = 360 - h2;
    }
    const color = new Color(l2, c3, h2, "lch");
    return color;
  }
  /*
  Conversion Methods
  */
  rgb() {
    if (this.space === "rgb") {
      return this;
    } else if (cieSpace(this.space)) {
      let {
        x: x2,
        y: y3,
        z
      } = this;
      if (this.space === "lab" || this.space === "lch") {
        let {
          l: l2,
          a: a2,
          b: b2
        } = this;
        if (this.space === "lch") {
          const {
            c: c3,
            h: h2
          } = this;
          const dToR = Math.PI / 180;
          a2 = c3 * Math.cos(dToR * h2);
          b2 = c3 * Math.sin(dToR * h2);
        }
        const yL = (l2 + 16) / 116;
        const xL = a2 / 500 + yL;
        const zL = yL - b2 / 200;
        const ct = 16 / 116;
        const mx = 8856e-6;
        const nm = 7.787;
        x2 = 0.95047 * (xL ** 3 > mx ? xL ** 3 : (xL - ct) / nm);
        y3 = 1 * (yL ** 3 > mx ? yL ** 3 : (yL - ct) / nm);
        z = 1.08883 * (zL ** 3 > mx ? zL ** 3 : (zL - ct) / nm);
      }
      const rU = x2 * 3.2406 + y3 * -1.5372 + z * -0.4986;
      const gU = x2 * -0.9689 + y3 * 1.8758 + z * 0.0415;
      const bU = x2 * 0.0557 + y3 * -0.204 + z * 1.057;
      const pow = Math.pow;
      const bd = 31308e-7;
      const r2 = rU > bd ? 1.055 * pow(rU, 1 / 2.4) - 0.055 : 12.92 * rU;
      const g = gU > bd ? 1.055 * pow(gU, 1 / 2.4) - 0.055 : 12.92 * gU;
      const b = bU > bd ? 1.055 * pow(bU, 1 / 2.4) - 0.055 : 12.92 * bU;
      const color = new Color(255 * r2, 255 * g, 255 * b);
      return color;
    } else if (this.space === "hsl") {
      let {
        h: h2,
        s: s2,
        l: l2
      } = this;
      h2 /= 360;
      s2 /= 100;
      l2 /= 100;
      if (s2 === 0) {
        l2 *= 255;
        const color2 = new Color(l2, l2, l2);
        return color2;
      }
      const q = l2 < 0.5 ? l2 * (1 + s2) : l2 + s2 - l2 * s2;
      const p2 = 2 * l2 - q;
      const r2 = 255 * hueToRgb(p2, q, h2 + 1 / 3);
      const g = 255 * hueToRgb(p2, q, h2);
      const b = 255 * hueToRgb(p2, q, h2 - 1 / 3);
      const color = new Color(r2, g, b);
      return color;
    } else if (this.space === "cmyk") {
      const {
        c: c3,
        m: m3,
        y: y3,
        k
      } = this;
      const r2 = 255 * (1 - Math.min(1, c3 * (1 - k) + k));
      const g = 255 * (1 - Math.min(1, m3 * (1 - k) + k));
      const b = 255 * (1 - Math.min(1, y3 * (1 - k) + k));
      const color = new Color(r2, g, b);
      return color;
    } else {
      return this;
    }
  }
  toArray() {
    const {
      _a: _a2,
      _b: _b2,
      _c,
      _d,
      space
    } = this;
    return [_a2, _b2, _c, _d, space];
  }
  toHex() {
    const [r2, g, b] = this._clamped().map(componentHex);
    return `#${r2}${g}${b}`;
  }
  toRgb() {
    const [rV, gV, bV] = this._clamped();
    const string3 = `rgb(${rV},${gV},${bV})`;
    return string3;
  }
  toString() {
    return this.toHex();
  }
  xyz() {
    const {
      _a: r255,
      _b: g255,
      _c: b255
    } = this.rgb();
    const [r2, g, b] = [r255, g255, b255].map((v2) => v2 / 255);
    const rL = r2 > 0.04045 ? Math.pow((r2 + 0.055) / 1.055, 2.4) : r2 / 12.92;
    const gL = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
    const bL = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;
    const xU = (rL * 0.4124 + gL * 0.3576 + bL * 0.1805) / 0.95047;
    const yU = (rL * 0.2126 + gL * 0.7152 + bL * 0.0722) / 1;
    const zU = (rL * 0.0193 + gL * 0.1192 + bL * 0.9505) / 1.08883;
    const x2 = xU > 8856e-6 ? Math.pow(xU, 1 / 3) : 7.787 * xU + 16 / 116;
    const y3 = yU > 8856e-6 ? Math.pow(yU, 1 / 3) : 7.787 * yU + 16 / 116;
    const z = zU > 8856e-6 ? Math.pow(zU, 1 / 3) : 7.787 * zU + 16 / 116;
    const color = new Color(x2, y3, z, "xyz");
    return color;
  }
  /*
  Input and Output methods
  */
  _clamped() {
    const {
      _a: _a2,
      _b: _b2,
      _c
    } = this.rgb();
    const {
      max: max2,
      min,
      round
    } = Math;
    const format = (v2) => max2(0, min(round(v2), 255));
    return [_a2, _b2, _c].map(format);
  }
  /*
  Constructing colors
  */
};
var Point = class {
  // Initialize
  constructor(...args) {
    this.init(...args);
  }
  // Clone point
  clone() {
    return new Point(this);
  }
  init(x2, y3) {
    const base = {
      x: 0,
      y: 0
    };
    const source = Array.isArray(x2) ? {
      x: x2[0],
      y: x2[1]
    } : typeof x2 === "object" ? {
      x: x2.x,
      y: x2.y
    } : {
      x: x2,
      y: y3
    };
    this.x = source.x == null ? base.x : source.x;
    this.y = source.y == null ? base.y : source.y;
    return this;
  }
  toArray() {
    return [this.x, this.y];
  }
  transform(m3) {
    return this.clone().transformO(m3);
  }
  // Transform point with matrix
  transformO(m3) {
    if (!Matrix.isMatrixLike(m3)) {
      m3 = new Matrix(m3);
    }
    const {
      x: x2,
      y: y3
    } = this;
    this.x = m3.a * x2 + m3.c * y3 + m3.e;
    this.y = m3.b * x2 + m3.d * y3 + m3.f;
    return this;
  }
};
function point(x2, y3) {
  return new Point(x2, y3).transform(this.screenCTM().inverse());
}
function closeEnough(a2, b, threshold) {
  return Math.abs(b - a2) < (threshold || 1e-6);
}
var Matrix = class {
  constructor(...args) {
    this.init(...args);
  }
  static formatTransforms(o2) {
    const flipBoth = o2.flip === "both" || o2.flip === true;
    const flipX = o2.flip && (flipBoth || o2.flip === "x") ? -1 : 1;
    const flipY = o2.flip && (flipBoth || o2.flip === "y") ? -1 : 1;
    const skewX = o2.skew && o2.skew.length ? o2.skew[0] : isFinite(o2.skew) ? o2.skew : isFinite(o2.skewX) ? o2.skewX : 0;
    const skewY = o2.skew && o2.skew.length ? o2.skew[1] : isFinite(o2.skew) ? o2.skew : isFinite(o2.skewY) ? o2.skewY : 0;
    const scaleX = o2.scale && o2.scale.length ? o2.scale[0] * flipX : isFinite(o2.scale) ? o2.scale * flipX : isFinite(o2.scaleX) ? o2.scaleX * flipX : flipX;
    const scaleY = o2.scale && o2.scale.length ? o2.scale[1] * flipY : isFinite(o2.scale) ? o2.scale * flipY : isFinite(o2.scaleY) ? o2.scaleY * flipY : flipY;
    const shear = o2.shear || 0;
    const theta = o2.rotate || o2.theta || 0;
    const origin = new Point(o2.origin || o2.around || o2.ox || o2.originX, o2.oy || o2.originY);
    const ox = origin.x;
    const oy = origin.y;
    const position3 = new Point(o2.position || o2.px || o2.positionX || NaN, o2.py || o2.positionY || NaN);
    const px = position3.x;
    const py = position3.y;
    const translate = new Point(o2.translate || o2.tx || o2.translateX, o2.ty || o2.translateY);
    const tx = translate.x;
    const ty = translate.y;
    const relative = new Point(o2.relative || o2.rx || o2.relativeX, o2.ry || o2.relativeY);
    const rx2 = relative.x;
    const ry2 = relative.y;
    return {
      scaleX,
      scaleY,
      skewX,
      skewY,
      shear,
      theta,
      rx: rx2,
      ry: ry2,
      tx,
      ty,
      ox,
      oy,
      px,
      py
    };
  }
  static fromArray(a2) {
    return {
      a: a2[0],
      b: a2[1],
      c: a2[2],
      d: a2[3],
      e: a2[4],
      f: a2[5]
    };
  }
  static isMatrixLike(o2) {
    return o2.a != null || o2.b != null || o2.c != null || o2.d != null || o2.e != null || o2.f != null;
  }
  // left matrix, right matrix, target matrix which is overwritten
  static matrixMultiply(l2, r2, o2) {
    const a2 = l2.a * r2.a + l2.c * r2.b;
    const b = l2.b * r2.a + l2.d * r2.b;
    const c3 = l2.a * r2.c + l2.c * r2.d;
    const d = l2.b * r2.c + l2.d * r2.d;
    const e2 = l2.e + l2.a * r2.e + l2.c * r2.f;
    const f3 = l2.f + l2.b * r2.e + l2.d * r2.f;
    o2.a = a2;
    o2.b = b;
    o2.c = c3;
    o2.d = d;
    o2.e = e2;
    o2.f = f3;
    return o2;
  }
  around(cx2, cy2, matrix) {
    return this.clone().aroundO(cx2, cy2, matrix);
  }
  // Transform around a center point
  aroundO(cx2, cy2, matrix) {
    const dx2 = cx2 || 0;
    const dy2 = cy2 || 0;
    return this.translateO(-dx2, -dy2).lmultiplyO(matrix).translateO(dx2, dy2);
  }
  // Clones this matrix
  clone() {
    return new Matrix(this);
  }
  // Decomposes this matrix into its affine parameters
  decompose(cx2 = 0, cy2 = 0) {
    const a2 = this.a;
    const b = this.b;
    const c3 = this.c;
    const d = this.d;
    const e2 = this.e;
    const f3 = this.f;
    const determinant = a2 * d - b * c3;
    const ccw = determinant > 0 ? 1 : -1;
    const sx = ccw * Math.sqrt(a2 * a2 + b * b);
    const thetaRad = Math.atan2(ccw * b, ccw * a2);
    const theta = 180 / Math.PI * thetaRad;
    const ct = Math.cos(thetaRad);
    const st = Math.sin(thetaRad);
    const lam = (a2 * c3 + b * d) / determinant;
    const sy = c3 * sx / (lam * a2 - b) || d * sx / (lam * b + a2);
    const tx = e2 - cx2 + cx2 * ct * sx + cy2 * (lam * ct * sx - st * sy);
    const ty = f3 - cy2 + cx2 * st * sx + cy2 * (lam * st * sx + ct * sy);
    return {
      // Return the affine parameters
      scaleX: sx,
      scaleY: sy,
      shear: lam,
      rotate: theta,
      translateX: tx,
      translateY: ty,
      originX: cx2,
      originY: cy2,
      // Return the matrix parameters
      a: this.a,
      b: this.b,
      c: this.c,
      d: this.d,
      e: this.e,
      f: this.f
    };
  }
  // Check if two matrices are equal
  equals(other) {
    if (other === this)
      return true;
    const comp = new Matrix(other);
    return closeEnough(this.a, comp.a) && closeEnough(this.b, comp.b) && closeEnough(this.c, comp.c) && closeEnough(this.d, comp.d) && closeEnough(this.e, comp.e) && closeEnough(this.f, comp.f);
  }
  // Flip matrix on x or y, at a given offset
  flip(axis, around) {
    return this.clone().flipO(axis, around);
  }
  flipO(axis, around) {
    return axis === "x" ? this.scaleO(-1, 1, around, 0) : axis === "y" ? this.scaleO(1, -1, 0, around) : this.scaleO(-1, -1, axis, around || axis);
  }
  // Initialize
  init(source) {
    const base = Matrix.fromArray([1, 0, 0, 1, 0, 0]);
    source = source instanceof Element ? source.matrixify() : typeof source === "string" ? Matrix.fromArray(source.split(delimiter).map(parseFloat)) : Array.isArray(source) ? Matrix.fromArray(source) : typeof source === "object" && Matrix.isMatrixLike(source) ? source : typeof source === "object" ? new Matrix().transform(source) : arguments.length === 6 ? Matrix.fromArray([].slice.call(arguments)) : base;
    this.a = source.a != null ? source.a : base.a;
    this.b = source.b != null ? source.b : base.b;
    this.c = source.c != null ? source.c : base.c;
    this.d = source.d != null ? source.d : base.d;
    this.e = source.e != null ? source.e : base.e;
    this.f = source.f != null ? source.f : base.f;
    return this;
  }
  inverse() {
    return this.clone().inverseO();
  }
  // Inverses matrix
  inverseO() {
    const a2 = this.a;
    const b = this.b;
    const c3 = this.c;
    const d = this.d;
    const e2 = this.e;
    const f3 = this.f;
    const det = a2 * d - b * c3;
    if (!det)
      throw new Error("Cannot invert " + this);
    const na = d / det;
    const nb = -b / det;
    const nc = -c3 / det;
    const nd = a2 / det;
    const ne = -(na * e2 + nc * f3);
    const nf = -(nb * e2 + nd * f3);
    this.a = na;
    this.b = nb;
    this.c = nc;
    this.d = nd;
    this.e = ne;
    this.f = nf;
    return this;
  }
  lmultiply(matrix) {
    return this.clone().lmultiplyO(matrix);
  }
  lmultiplyO(matrix) {
    const r2 = this;
    const l2 = matrix instanceof Matrix ? matrix : new Matrix(matrix);
    return Matrix.matrixMultiply(l2, r2, this);
  }
  // Left multiplies by the given matrix
  multiply(matrix) {
    return this.clone().multiplyO(matrix);
  }
  multiplyO(matrix) {
    const l2 = this;
    const r2 = matrix instanceof Matrix ? matrix : new Matrix(matrix);
    return Matrix.matrixMultiply(l2, r2, this);
  }
  // Rotate matrix
  rotate(r2, cx2, cy2) {
    return this.clone().rotateO(r2, cx2, cy2);
  }
  rotateO(r2, cx2 = 0, cy2 = 0) {
    r2 = radians(r2);
    const cos = Math.cos(r2);
    const sin = Math.sin(r2);
    const {
      a: a2,
      b,
      c: c3,
      d,
      e: e2,
      f: f3
    } = this;
    this.a = a2 * cos - b * sin;
    this.b = b * cos + a2 * sin;
    this.c = c3 * cos - d * sin;
    this.d = d * cos + c3 * sin;
    this.e = e2 * cos - f3 * sin + cy2 * sin - cx2 * cos + cx2;
    this.f = f3 * cos + e2 * sin - cx2 * sin - cy2 * cos + cy2;
    return this;
  }
  // Scale matrix
  scale(x2, y3, cx2, cy2) {
    return this.clone().scaleO(...arguments);
  }
  scaleO(x2, y3 = x2, cx2 = 0, cy2 = 0) {
    if (arguments.length === 3) {
      cy2 = cx2;
      cx2 = y3;
      y3 = x2;
    }
    const {
      a: a2,
      b,
      c: c3,
      d,
      e: e2,
      f: f3
    } = this;
    this.a = a2 * x2;
    this.b = b * y3;
    this.c = c3 * x2;
    this.d = d * y3;
    this.e = e2 * x2 - cx2 * x2 + cx2;
    this.f = f3 * y3 - cy2 * y3 + cy2;
    return this;
  }
  // Shear matrix
  shear(a2, cx2, cy2) {
    return this.clone().shearO(a2, cx2, cy2);
  }
  shearO(lx, cx2 = 0, cy2 = 0) {
    const {
      a: a2,
      b,
      c: c3,
      d,
      e: e2,
      f: f3
    } = this;
    this.a = a2 + b * lx;
    this.c = c3 + d * lx;
    this.e = e2 + f3 * lx - cy2 * lx;
    return this;
  }
  // Skew Matrix
  skew(x2, y3, cx2, cy2) {
    return this.clone().skewO(...arguments);
  }
  skewO(x2, y3 = x2, cx2 = 0, cy2 = 0) {
    if (arguments.length === 3) {
      cy2 = cx2;
      cx2 = y3;
      y3 = x2;
    }
    x2 = radians(x2);
    y3 = radians(y3);
    const lx = Math.tan(x2);
    const ly = Math.tan(y3);
    const {
      a: a2,
      b,
      c: c3,
      d,
      e: e2,
      f: f3
    } = this;
    this.a = a2 + b * lx;
    this.b = b + a2 * ly;
    this.c = c3 + d * lx;
    this.d = d + c3 * ly;
    this.e = e2 + f3 * lx - cy2 * lx;
    this.f = f3 + e2 * ly - cx2 * ly;
    return this;
  }
  // SkewX
  skewX(x2, cx2, cy2) {
    return this.skew(x2, 0, cx2, cy2);
  }
  // SkewY
  skewY(y3, cx2, cy2) {
    return this.skew(0, y3, cx2, cy2);
  }
  toArray() {
    return [this.a, this.b, this.c, this.d, this.e, this.f];
  }
  // Convert matrix to string
  toString() {
    return "matrix(" + this.a + "," + this.b + "," + this.c + "," + this.d + "," + this.e + "," + this.f + ")";
  }
  // Transform a matrix into another matrix by manipulating the space
  transform(o2) {
    if (Matrix.isMatrixLike(o2)) {
      const matrix = new Matrix(o2);
      return matrix.multiplyO(this);
    }
    const t2 = Matrix.formatTransforms(o2);
    const current = this;
    const {
      x: ox,
      y: oy
    } = new Point(t2.ox, t2.oy).transform(current);
    const transformer = new Matrix().translateO(t2.rx, t2.ry).lmultiplyO(current).translateO(-ox, -oy).scaleO(t2.scaleX, t2.scaleY).skewO(t2.skewX, t2.skewY).shearO(t2.shear).rotateO(t2.theta).translateO(ox, oy);
    if (isFinite(t2.px) || isFinite(t2.py)) {
      const origin = new Point(ox, oy).transform(transformer);
      const dx2 = isFinite(t2.px) ? t2.px - origin.x : 0;
      const dy2 = isFinite(t2.py) ? t2.py - origin.y : 0;
      transformer.translateO(dx2, dy2);
    }
    transformer.translateO(t2.tx, t2.ty);
    return transformer;
  }
  // Translate matrix
  translate(x2, y3) {
    return this.clone().translateO(x2, y3);
  }
  translateO(x2, y3) {
    this.e += x2 || 0;
    this.f += y3 || 0;
    return this;
  }
  valueOf() {
    return {
      a: this.a,
      b: this.b,
      c: this.c,
      d: this.d,
      e: this.e,
      f: this.f
    };
  }
};
function ctm() {
  return new Matrix(this.node.getCTM());
}
function screenCTM() {
  if (typeof this.isRoot === "function" && !this.isRoot()) {
    const rect = this.rect(1, 1);
    const m3 = rect.node.getScreenCTM();
    rect.remove();
    return new Matrix(m3);
  }
  return new Matrix(this.node.getScreenCTM());
}
register(Matrix, "Matrix");
function parser() {
  if (!parser.nodes) {
    const svg2 = makeInstance().size(2, 0);
    svg2.node.style.cssText = ["opacity: 0", "position: absolute", "left: -100%", "top: -100%", "overflow: hidden"].join(";");
    svg2.attr("focusable", "false");
    svg2.attr("aria-hidden", "true");
    const path2 = svg2.path().node;
    parser.nodes = {
      svg: svg2,
      path: path2
    };
  }
  if (!parser.nodes.svg.node.parentNode) {
    const b = globals.document.body || globals.document.documentElement;
    parser.nodes.svg.addTo(b);
  }
  return parser.nodes;
}
function isNulledBox(box) {
  return !box.width && !box.height && !box.x && !box.y;
}
function domContains(node3) {
  return node3 === globals.document || (globals.document.documentElement.contains || function(node4) {
    while (node4.parentNode) {
      node4 = node4.parentNode;
    }
    return node4 === globals.document;
  }).call(globals.document.documentElement, node3);
}
var Box = class {
  constructor(...args) {
    this.init(...args);
  }
  addOffset() {
    this.x += globals.window.pageXOffset;
    this.y += globals.window.pageYOffset;
    return new Box(this);
  }
  init(source) {
    const base = [0, 0, 0, 0];
    source = typeof source === "string" ? source.split(delimiter).map(parseFloat) : Array.isArray(source) ? source : typeof source === "object" ? [source.left != null ? source.left : source.x, source.top != null ? source.top : source.y, source.width, source.height] : arguments.length === 4 ? [].slice.call(arguments) : base;
    this.x = source[0] || 0;
    this.y = source[1] || 0;
    this.width = this.w = source[2] || 0;
    this.height = this.h = source[3] || 0;
    this.x2 = this.x + this.w;
    this.y2 = this.y + this.h;
    this.cx = this.x + this.w / 2;
    this.cy = this.y + this.h / 2;
    return this;
  }
  isNulled() {
    return isNulledBox(this);
  }
  // Merge rect box with another, return a new instance
  merge(box) {
    const x2 = Math.min(this.x, box.x);
    const y3 = Math.min(this.y, box.y);
    const width2 = Math.max(this.x + this.width, box.x + box.width) - x2;
    const height2 = Math.max(this.y + this.height, box.y + box.height) - y3;
    return new Box(x2, y3, width2, height2);
  }
  toArray() {
    return [this.x, this.y, this.width, this.height];
  }
  toString() {
    return this.x + " " + this.y + " " + this.width + " " + this.height;
  }
  transform(m3) {
    if (!(m3 instanceof Matrix)) {
      m3 = new Matrix(m3);
    }
    let xMin = Infinity;
    let xMax = -Infinity;
    let yMin = Infinity;
    let yMax = -Infinity;
    const pts = [new Point(this.x, this.y), new Point(this.x2, this.y), new Point(this.x, this.y2), new Point(this.x2, this.y2)];
    pts.forEach(function(p2) {
      p2 = p2.transform(m3);
      xMin = Math.min(xMin, p2.x);
      xMax = Math.max(xMax, p2.x);
      yMin = Math.min(yMin, p2.y);
      yMax = Math.max(yMax, p2.y);
    });
    return new Box(xMin, yMin, xMax - xMin, yMax - yMin);
  }
};
function getBox(el2, getBBoxFn, retry) {
  let box;
  try {
    box = getBBoxFn(el2.node);
    if (isNulledBox(box) && !domContains(el2.node)) {
      throw new Error("Element not in the dom");
    }
  } catch (e2) {
    box = retry(el2);
  }
  return box;
}
function bbox() {
  const getBBox = (node3) => node3.getBBox();
  const retry = (el2) => {
    try {
      const clone = el2.clone().addTo(parser().svg).show();
      const box2 = clone.node.getBBox();
      clone.remove();
      return box2;
    } catch (e2) {
      throw new Error(`Getting bbox of element "${el2.node.nodeName}" is not possible: ${e2.toString()}`);
    }
  };
  const box = getBox(this, getBBox, retry);
  const bbox2 = new Box(box);
  return bbox2;
}
function rbox(el2) {
  const getRBox = (node3) => node3.getBoundingClientRect();
  const retry = (el3) => {
    throw new Error(`Getting rbox of element "${el3.node.nodeName}" is not possible`);
  };
  const box = getBox(this, getRBox, retry);
  const rbox2 = new Box(box);
  if (el2) {
    return rbox2.transform(el2.screenCTM().inverseO());
  }
  return rbox2.addOffset();
}
function inside(x2, y3) {
  const box = this.bbox();
  return x2 > box.x && y3 > box.y && x2 < box.x + box.width && y3 < box.y + box.height;
}
registerMethods({
  viewbox: {
    viewbox(x2, y3, width2, height2) {
      if (x2 == null)
        return new Box(this.attr("viewBox"));
      return this.attr("viewBox", new Box(x2, y3, width2, height2));
    },
    zoom(level, point4) {
      let {
        width: width2,
        height: height2
      } = this.attr(["width", "height"]);
      if (!width2 && !height2 || typeof width2 === "string" || typeof height2 === "string") {
        width2 = this.node.clientWidth;
        height2 = this.node.clientHeight;
      }
      if (!width2 || !height2) {
        throw new Error("Impossible to get absolute width and height. Please provide an absolute width and height attribute on the zooming element");
      }
      const v2 = this.viewbox();
      const zoomX = width2 / v2.width;
      const zoomY = height2 / v2.height;
      const zoom = Math.min(zoomX, zoomY);
      if (level == null) {
        return zoom;
      }
      let zoomAmount = zoom / level;
      if (zoomAmount === Infinity)
        zoomAmount = Number.MAX_SAFE_INTEGER / 100;
      point4 = point4 || new Point(width2 / 2 / zoomX + v2.x, height2 / 2 / zoomY + v2.y);
      const box = new Box(v2).transform(new Matrix({
        scale: zoomAmount,
        origin: point4
      }));
      return this.viewbox(box);
    }
  }
});
register(Box, "Box");
var List = class extends Array {
  constructor(arr = [], ...args) {
    super(arr, ...args);
    if (typeof arr === "number")
      return this;
    this.length = 0;
    this.push(...arr);
  }
};
extend([List], {
  each(fnOrMethodName, ...args) {
    if (typeof fnOrMethodName === "function") {
      return this.map((el2, i2, arr) => {
        return fnOrMethodName.call(el2, el2, i2, arr);
      });
    } else {
      return this.map((el2) => {
        return el2[fnOrMethodName](...args);
      });
    }
  },
  toArray() {
    return Array.prototype.concat.apply([], this);
  }
});
var reserved = ["toArray", "constructor", "each"];
List.extend = function(methods2) {
  methods2 = methods2.reduce((obj, name) => {
    if (reserved.includes(name))
      return obj;
    if (name[0] === "_")
      return obj;
    obj[name] = function(...attrs2) {
      return this.each(name, ...attrs2);
    };
    return obj;
  }, {});
  extend([List], methods2);
};
function baseFind(query, parent) {
  return new List(map((parent || globals.document).querySelectorAll(query), function(node3) {
    return adopt(node3);
  }));
}
function find(query) {
  return baseFind(query, this.node);
}
function findOne(query) {
  return adopt(this.node.querySelector(query));
}
var listenerId = 0;
var windowEvents = {};
function getEvents(instance) {
  let n2 = instance.getEventHolder();
  if (n2 === globals.window)
    n2 = windowEvents;
  if (!n2.events)
    n2.events = {};
  return n2.events;
}
function getEventTarget(instance) {
  return instance.getEventTarget();
}
function clearEvents(instance) {
  let n2 = instance.getEventHolder();
  if (n2 === globals.window)
    n2 = windowEvents;
  if (n2.events)
    n2.events = {};
}
function on(node3, events, listener, binding, options) {
  const l2 = listener.bind(binding || node3);
  const instance = makeInstance(node3);
  const bag = getEvents(instance);
  const n2 = getEventTarget(instance);
  events = Array.isArray(events) ? events : events.split(delimiter);
  if (!listener._svgjsListenerId) {
    listener._svgjsListenerId = ++listenerId;
  }
  events.forEach(function(event) {
    const ev = event.split(".")[0];
    const ns = event.split(".")[1] || "*";
    bag[ev] = bag[ev] || {};
    bag[ev][ns] = bag[ev][ns] || {};
    bag[ev][ns][listener._svgjsListenerId] = l2;
    n2.addEventListener(ev, l2, options || false);
  });
}
function off(node3, events, listener, options) {
  const instance = makeInstance(node3);
  const bag = getEvents(instance);
  const n2 = getEventTarget(instance);
  if (typeof listener === "function") {
    listener = listener._svgjsListenerId;
    if (!listener)
      return;
  }
  events = Array.isArray(events) ? events : (events || "").split(delimiter);
  events.forEach(function(event) {
    const ev = event && event.split(".")[0];
    const ns = event && event.split(".")[1];
    let namespace, l2;
    if (listener) {
      if (bag[ev] && bag[ev][ns || "*"]) {
        n2.removeEventListener(ev, bag[ev][ns || "*"][listener], options || false);
        delete bag[ev][ns || "*"][listener];
      }
    } else if (ev && ns) {
      if (bag[ev] && bag[ev][ns]) {
        for (l2 in bag[ev][ns]) {
          off(n2, [ev, ns].join("."), l2);
        }
        delete bag[ev][ns];
      }
    } else if (ns) {
      for (event in bag) {
        for (namespace in bag[event]) {
          if (ns === namespace) {
            off(n2, [event, ns].join("."));
          }
        }
      }
    } else if (ev) {
      if (bag[ev]) {
        for (namespace in bag[ev]) {
          off(n2, [ev, namespace].join("."));
        }
        delete bag[ev];
      }
    } else {
      for (event in bag) {
        off(n2, event);
      }
      clearEvents(instance);
    }
  });
}
function dispatch(node3, event, data2, options) {
  const n2 = getEventTarget(node3);
  if (event instanceof globals.window.Event) {
    n2.dispatchEvent(event);
  } else {
    event = new globals.window.CustomEvent(event, {
      detail: data2,
      cancelable: true,
      ...options
    });
    n2.dispatchEvent(event);
  }
  return event;
}
var EventTarget = class extends Base {
  addEventListener() {
  }
  dispatch(event, data2, options) {
    return dispatch(this, event, data2, options);
  }
  dispatchEvent(event) {
    const bag = this.getEventHolder().events;
    if (!bag)
      return true;
    const events = bag[event.type];
    for (const i2 in events) {
      for (const j in events[i2]) {
        events[i2][j](event);
      }
    }
    return !event.defaultPrevented;
  }
  // Fire given event
  fire(event, data2, options) {
    this.dispatch(event, data2, options);
    return this;
  }
  getEventHolder() {
    return this;
  }
  getEventTarget() {
    return this;
  }
  // Unbind event from listener
  off(event, listener, options) {
    off(this, event, listener, options);
    return this;
  }
  // Bind given event to listener
  on(event, listener, binding, options) {
    on(this, event, listener, binding, options);
    return this;
  }
  removeEventListener() {
  }
};
register(EventTarget, "EventTarget");
function noop() {
}
var timeline = {
  duration: 400,
  ease: ">",
  delay: 0
};
var attrs = {
  // fill and stroke
  "fill-opacity": 1,
  "stroke-opacity": 1,
  "stroke-width": 0,
  "stroke-linejoin": "miter",
  "stroke-linecap": "butt",
  fill: "#000000",
  stroke: "#000000",
  opacity: 1,
  // position
  x: 0,
  y: 0,
  cx: 0,
  cy: 0,
  // size
  width: 0,
  height: 0,
  // radius
  r: 0,
  rx: 0,
  ry: 0,
  // gradient
  offset: 0,
  "stop-opacity": 1,
  "stop-color": "#000000",
  // text
  "text-anchor": "start"
};
var SVGArray = class extends Array {
  constructor(...args) {
    super(...args);
    this.init(...args);
  }
  clone() {
    return new this.constructor(this);
  }
  init(arr) {
    if (typeof arr === "number")
      return this;
    this.length = 0;
    this.push(...this.parse(arr));
    return this;
  }
  // Parse whitespace separated string
  parse(array2 = []) {
    if (array2 instanceof Array)
      return array2;
    return array2.trim().split(delimiter).map(parseFloat);
  }
  toArray() {
    return Array.prototype.concat.apply([], this);
  }
  toSet() {
    return new Set(this);
  }
  toString() {
    return this.join(" ");
  }
  // Flattens the array if needed
  valueOf() {
    const ret = [];
    ret.push(...this);
    return ret;
  }
};
var SVGNumber = class {
  // Initialize
  constructor(...args) {
    this.init(...args);
  }
  convert(unit) {
    return new SVGNumber(this.value, unit);
  }
  // Divide number
  divide(number) {
    number = new SVGNumber(number);
    return new SVGNumber(this / number, this.unit || number.unit);
  }
  init(value, unit) {
    unit = Array.isArray(value) ? value[1] : unit;
    value = Array.isArray(value) ? value[0] : value;
    this.value = 0;
    this.unit = unit || "";
    if (typeof value === "number") {
      this.value = isNaN(value) ? 0 : !isFinite(value) ? value < 0 ? -34e37 : 34e37 : value;
    } else if (typeof value === "string") {
      unit = value.match(numberAndUnit);
      if (unit) {
        this.value = parseFloat(unit[1]);
        if (unit[5] === "%") {
          this.value /= 100;
        } else if (unit[5] === "s") {
          this.value *= 1e3;
        }
        this.unit = unit[5];
      }
    } else {
      if (value instanceof SVGNumber) {
        this.value = value.valueOf();
        this.unit = value.unit;
      }
    }
    return this;
  }
  // Subtract number
  minus(number) {
    number = new SVGNumber(number);
    return new SVGNumber(this - number, this.unit || number.unit);
  }
  // Add number
  plus(number) {
    number = new SVGNumber(number);
    return new SVGNumber(this + number, this.unit || number.unit);
  }
  // Multiply number
  times(number) {
    number = new SVGNumber(number);
    return new SVGNumber(this * number, this.unit || number.unit);
  }
  toArray() {
    return [this.value, this.unit];
  }
  toJSON() {
    return this.toString();
  }
  toString() {
    return (this.unit === "%" ? ~~(this.value * 1e8) / 1e6 : this.unit === "s" ? this.value / 1e3 : this.value) + this.unit;
  }
  valueOf() {
    return this.value;
  }
};
var hooks = [];
function registerAttrHook(fn) {
  hooks.push(fn);
}
function attr(attr2, val, ns) {
  if (attr2 == null) {
    attr2 = {};
    val = this.node.attributes;
    for (const node3 of val) {
      attr2[node3.nodeName] = isNumber.test(node3.nodeValue) ? parseFloat(node3.nodeValue) : node3.nodeValue;
    }
    return attr2;
  } else if (attr2 instanceof Array) {
    return attr2.reduce((last, curr) => {
      last[curr] = this.attr(curr);
      return last;
    }, {});
  } else if (typeof attr2 === "object" && attr2.constructor === Object) {
    for (val in attr2)
      this.attr(val, attr2[val]);
  } else if (val === null) {
    this.node.removeAttribute(attr2);
  } else if (val == null) {
    val = this.node.getAttribute(attr2);
    return val == null ? attrs[attr2] : isNumber.test(val) ? parseFloat(val) : val;
  } else {
    val = hooks.reduce((_val, hook) => {
      return hook(attr2, _val, this);
    }, val);
    if (typeof val === "number") {
      val = new SVGNumber(val);
    } else if (Color.isColor(val)) {
      val = new Color(val);
    } else if (val.constructor === Array) {
      val = new SVGArray(val);
    }
    if (attr2 === "leading") {
      if (this.leading) {
        this.leading(val);
      }
    } else {
      typeof ns === "string" ? this.node.setAttributeNS(ns, attr2, val.toString()) : this.node.setAttribute(attr2, val.toString());
    }
    if (this.rebuild && (attr2 === "font-size" || attr2 === "x")) {
      this.rebuild();
    }
  }
  return this;
}
var Dom = class extends EventTarget {
  constructor(node3, attrs2) {
    super();
    this.node = node3;
    this.type = node3.nodeName;
    if (attrs2 && node3 !== attrs2) {
      this.attr(attrs2);
    }
  }
  // Add given element at a position
  add(element2, i2) {
    element2 = makeInstance(element2);
    if (element2.removeNamespace && this.node instanceof globals.window.SVGElement) {
      element2.removeNamespace();
    }
    if (i2 == null) {
      this.node.appendChild(element2.node);
    } else if (element2.node !== this.node.childNodes[i2]) {
      this.node.insertBefore(element2.node, this.node.childNodes[i2]);
    }
    return this;
  }
  // Add element to given container and return self
  addTo(parent, i2) {
    return makeInstance(parent).put(this, i2);
  }
  // Returns all child elements
  children() {
    return new List(map(this.node.children, function(node3) {
      return adopt(node3);
    }));
  }
  // Remove all elements in this container
  clear() {
    while (this.node.hasChildNodes()) {
      this.node.removeChild(this.node.lastChild);
    }
    return this;
  }
  // Clone element
  clone(deep = true) {
    this.writeDataToDom();
    return new this.constructor(assignNewId(this.node.cloneNode(deep)));
  }
  // Iterates over all children and invokes a given block
  each(block, deep) {
    const children = this.children();
    let i2, il;
    for (i2 = 0, il = children.length; i2 < il; i2++) {
      block.apply(children[i2], [i2, children]);
      if (deep) {
        children[i2].each(block, deep);
      }
    }
    return this;
  }
  element(nodeName, attrs2) {
    return this.put(new Dom(create(nodeName), attrs2));
  }
  // Get first child
  first() {
    return adopt(this.node.firstChild);
  }
  // Get a element at the given index
  get(i2) {
    return adopt(this.node.childNodes[i2]);
  }
  getEventHolder() {
    return this.node;
  }
  getEventTarget() {
    return this.node;
  }
  // Checks if the given element is a child
  has(element2) {
    return this.index(element2) >= 0;
  }
  html(htmlOrFn, outerHTML) {
    return this.xml(htmlOrFn, outerHTML, html);
  }
  // Get / set id
  id(id) {
    if (typeof id === "undefined" && !this.node.id) {
      this.node.id = eid(this.type);
    }
    return this.attr("id", id);
  }
  // Gets index of given element
  index(element2) {
    return [].slice.call(this.node.childNodes).indexOf(element2.node);
  }
  // Get the last child
  last() {
    return adopt(this.node.lastChild);
  }
  // matches the element vs a css selector
  matches(selector) {
    const el2 = this.node;
    const matcher = el2.matches || el2.matchesSelector || el2.msMatchesSelector || el2.mozMatchesSelector || el2.webkitMatchesSelector || el2.oMatchesSelector || null;
    return matcher && matcher.call(el2, selector);
  }
  // Returns the parent element instance
  parent(type) {
    let parent = this;
    if (!parent.node.parentNode)
      return null;
    parent = adopt(parent.node.parentNode);
    if (!type)
      return parent;
    do {
      if (typeof type === "string" ? parent.matches(type) : parent instanceof type)
        return parent;
    } while (parent = adopt(parent.node.parentNode));
    return parent;
  }
  // Basically does the same as `add()` but returns the added element instead
  put(element2, i2) {
    element2 = makeInstance(element2);
    this.add(element2, i2);
    return element2;
  }
  // Add element to given container and return container
  putIn(parent, i2) {
    return makeInstance(parent).add(this, i2);
  }
  // Remove element
  remove() {
    if (this.parent()) {
      this.parent().removeElement(this);
    }
    return this;
  }
  // Remove a given child
  removeElement(element2) {
    this.node.removeChild(element2.node);
    return this;
  }
  // Replace this with element
  replace(element2) {
    element2 = makeInstance(element2);
    if (this.node.parentNode) {
      this.node.parentNode.replaceChild(element2.node, this.node);
    }
    return element2;
  }
  round(precision = 2, map3 = null) {
    const factor = 10 ** precision;
    const attrs2 = this.attr(map3);
    for (const i2 in attrs2) {
      if (typeof attrs2[i2] === "number") {
        attrs2[i2] = Math.round(attrs2[i2] * factor) / factor;
      }
    }
    this.attr(attrs2);
    return this;
  }
  // Import / Export raw svg
  svg(svgOrFn, outerSVG) {
    return this.xml(svgOrFn, outerSVG, svg);
  }
  // Return id on string conversion
  toString() {
    return this.id();
  }
  words(text4) {
    this.node.textContent = text4;
    return this;
  }
  wrap(node3) {
    const parent = this.parent();
    if (!parent) {
      return this.addTo(node3);
    }
    const position3 = parent.index(this);
    return parent.put(node3, position3).put(this);
  }
  // write svgjs data to the dom
  writeDataToDom() {
    this.each(function() {
      this.writeDataToDom();
    });
    return this;
  }
  // Import / Export raw svg
  xml(xmlOrFn, outerXML, ns) {
    if (typeof xmlOrFn === "boolean") {
      ns = outerXML;
      outerXML = xmlOrFn;
      xmlOrFn = null;
    }
    if (xmlOrFn == null || typeof xmlOrFn === "function") {
      outerXML = outerXML == null ? true : outerXML;
      this.writeDataToDom();
      let current = this;
      if (xmlOrFn != null) {
        current = adopt(current.node.cloneNode(true));
        if (outerXML) {
          const result = xmlOrFn(current);
          current = result || current;
          if (result === false)
            return "";
        }
        current.each(function() {
          const result = xmlOrFn(this);
          const _this = result || this;
          if (result === false) {
            this.remove();
          } else if (result && this !== _this) {
            this.replace(_this);
          }
        }, true);
      }
      return outerXML ? current.node.outerHTML : current.node.innerHTML;
    }
    outerXML = outerXML == null ? false : outerXML;
    const well = create("wrapper", ns);
    const fragment = globals.document.createDocumentFragment();
    well.innerHTML = xmlOrFn;
    for (let len = well.children.length; len--; ) {
      fragment.appendChild(well.firstElementChild);
    }
    const parent = this.parent();
    return outerXML ? this.replace(fragment) && parent : this.add(fragment);
  }
};
extend(Dom, {
  attr,
  find,
  findOne
});
register(Dom, "Dom");
var Element = class extends Dom {
  constructor(node3, attrs2) {
    super(node3, attrs2);
    this.dom = {};
    this.node.instance = this;
    if (node3.hasAttribute("svgjs:data")) {
      this.setData(JSON.parse(node3.getAttribute("svgjs:data")) || {});
    }
  }
  // Move element by its center
  center(x2, y3) {
    return this.cx(x2).cy(y3);
  }
  // Move by center over x-axis
  cx(x2) {
    return x2 == null ? this.x() + this.width() / 2 : this.x(x2 - this.width() / 2);
  }
  // Move by center over y-axis
  cy(y3) {
    return y3 == null ? this.y() + this.height() / 2 : this.y(y3 - this.height() / 2);
  }
  // Get defs
  defs() {
    const root2 = this.root();
    return root2 && root2.defs();
  }
  // Relative move over x and y axes
  dmove(x2, y3) {
    return this.dx(x2).dy(y3);
  }
  // Relative move over x axis
  dx(x2 = 0) {
    return this.x(new SVGNumber(x2).plus(this.x()));
  }
  // Relative move over y axis
  dy(y3 = 0) {
    return this.y(new SVGNumber(y3).plus(this.y()));
  }
  getEventHolder() {
    return this;
  }
  // Set height of element
  height(height2) {
    return this.attr("height", height2);
  }
  // Move element to given x and y values
  move(x2, y3) {
    return this.x(x2).y(y3);
  }
  // return array of all ancestors of given type up to the root svg
  parents(until = this.root()) {
    const isSelector = typeof until === "string";
    if (!isSelector) {
      until = makeInstance(until);
    }
    const parents = new List();
    let parent = this;
    while ((parent = parent.parent()) && parent.node !== globals.document && parent.nodeName !== "#document-fragment") {
      parents.push(parent);
      if (!isSelector && parent.node === until.node) {
        break;
      }
      if (isSelector && parent.matches(until)) {
        break;
      }
      if (parent.node === this.root().node) {
        return null;
      }
    }
    return parents;
  }
  // Get referenced element form attribute value
  reference(attr2) {
    attr2 = this.attr(attr2);
    if (!attr2)
      return null;
    const m3 = (attr2 + "").match(reference);
    return m3 ? makeInstance(m3[1]) : null;
  }
  // Get parent document
  root() {
    const p2 = this.parent(getClass(root));
    return p2 && p2.root();
  }
  // set given data to the elements data property
  setData(o2) {
    this.dom = o2;
    return this;
  }
  // Set element size to given width and height
  size(width2, height2) {
    const p2 = proportionalSize(this, width2, height2);
    return this.width(new SVGNumber(p2.width)).height(new SVGNumber(p2.height));
  }
  // Set width of element
  width(width2) {
    return this.attr("width", width2);
  }
  // write svgjs data to the dom
  writeDataToDom() {
    this.node.removeAttribute("svgjs:data");
    if (Object.keys(this.dom).length) {
      this.node.setAttribute("svgjs:data", JSON.stringify(this.dom));
    }
    return super.writeDataToDom();
  }
  // Move over x-axis
  x(x2) {
    return this.attr("x", x2);
  }
  // Move over y-axis
  y(y3) {
    return this.attr("y", y3);
  }
};
extend(Element, {
  bbox,
  rbox,
  inside,
  point,
  ctm,
  screenCTM
});
register(Element, "Element");
var sugar = {
  stroke: ["color", "width", "opacity", "linecap", "linejoin", "miterlimit", "dasharray", "dashoffset"],
  fill: ["color", "opacity", "rule"],
  prefix: function(t2, a2) {
    return a2 === "color" ? t2 : t2 + "-" + a2;
  }
};
["fill", "stroke"].forEach(function(m3) {
  const extension2 = {};
  let i2;
  extension2[m3] = function(o2) {
    if (typeof o2 === "undefined") {
      return this.attr(m3);
    }
    if (typeof o2 === "string" || o2 instanceof Color || Color.isRgb(o2) || o2 instanceof Element) {
      this.attr(m3, o2);
    } else {
      for (i2 = sugar[m3].length - 1; i2 >= 0; i2--) {
        if (o2[sugar[m3][i2]] != null) {
          this.attr(sugar.prefix(m3, sugar[m3][i2]), o2[sugar[m3][i2]]);
        }
      }
    }
    return this;
  };
  registerMethods(["Element", "Runner"], extension2);
});
registerMethods(["Element", "Runner"], {
  // Let the user set the matrix directly
  matrix: function(mat, b, c3, d, e2, f3) {
    if (mat == null) {
      return new Matrix(this);
    }
    return this.attr("transform", new Matrix(mat, b, c3, d, e2, f3));
  },
  // Map rotation to transform
  rotate: function(angle, cx2, cy2) {
    return this.transform({
      rotate: angle,
      ox: cx2,
      oy: cy2
    }, true);
  },
  // Map skew to transform
  skew: function(x2, y3, cx2, cy2) {
    return arguments.length === 1 || arguments.length === 3 ? this.transform({
      skew: x2,
      ox: y3,
      oy: cx2
    }, true) : this.transform({
      skew: [x2, y3],
      ox: cx2,
      oy: cy2
    }, true);
  },
  shear: function(lam, cx2, cy2) {
    return this.transform({
      shear: lam,
      ox: cx2,
      oy: cy2
    }, true);
  },
  // Map scale to transform
  scale: function(x2, y3, cx2, cy2) {
    return arguments.length === 1 || arguments.length === 3 ? this.transform({
      scale: x2,
      ox: y3,
      oy: cx2
    }, true) : this.transform({
      scale: [x2, y3],
      ox: cx2,
      oy: cy2
    }, true);
  },
  // Map translate to transform
  translate: function(x2, y3) {
    return this.transform({
      translate: [x2, y3]
    }, true);
  },
  // Map relative translations to transform
  relative: function(x2, y3) {
    return this.transform({
      relative: [x2, y3]
    }, true);
  },
  // Map flip to transform
  flip: function(direction = "both", origin = "center") {
    if ("xybothtrue".indexOf(direction) === -1) {
      origin = direction;
      direction = "both";
    }
    return this.transform({
      flip: direction,
      origin
    }, true);
  },
  // Opacity
  opacity: function(value) {
    return this.attr("opacity", value);
  }
});
registerMethods("radius", {
  // Add x and y radius
  radius: function(x2, y3 = x2) {
    const type = (this._element || this).type;
    return type === "radialGradient" ? this.attr("r", new SVGNumber(x2)) : this.rx(x2).ry(y3);
  }
});
registerMethods("Path", {
  // Get path length
  length: function() {
    return this.node.getTotalLength();
  },
  // Get point at length
  pointAt: function(length2) {
    return new Point(this.node.getPointAtLength(length2));
  }
});
registerMethods(["Element", "Runner"], {
  // Set font
  font: function(a2, v2) {
    if (typeof a2 === "object") {
      for (v2 in a2)
        this.font(v2, a2[v2]);
      return this;
    }
    return a2 === "leading" ? this.leading(v2) : a2 === "anchor" ? this.attr("text-anchor", v2) : a2 === "size" || a2 === "family" || a2 === "weight" || a2 === "stretch" || a2 === "variant" || a2 === "style" ? this.attr("font-" + a2, v2) : this.attr(a2, v2);
  }
});
var methods = ["click", "dblclick", "mousedown", "mouseup", "mouseover", "mouseout", "mousemove", "mouseenter", "mouseleave", "touchstart", "touchmove", "touchleave", "touchend", "touchcancel"].reduce(function(last, event) {
  const fn = function(f3) {
    if (f3 === null) {
      this.off(event);
    } else {
      this.on(event, f3);
    }
    return this;
  };
  last[event] = fn;
  return last;
}, {});
registerMethods("Element", methods);
function untransform() {
  return this.attr("transform", null);
}
function matrixify() {
  const matrix = (this.attr("transform") || "").split(transforms).slice(0, -1).map(function(str) {
    const kv = str.trim().split("(");
    return [kv[0], kv[1].split(delimiter).map(function(str2) {
      return parseFloat(str2);
    })];
  }).reverse().reduce(function(matrix2, transform2) {
    if (transform2[0] === "matrix") {
      return matrix2.lmultiply(Matrix.fromArray(transform2[1]));
    }
    return matrix2[transform2[0]].apply(matrix2, transform2[1]);
  }, new Matrix());
  return matrix;
}
function toParent(parent, i2) {
  if (this === parent)
    return this;
  const ctm2 = this.screenCTM();
  const pCtm = parent.screenCTM().inverse();
  this.addTo(parent, i2).untransform().transform(pCtm.multiply(ctm2));
  return this;
}
function toRoot(i2) {
  return this.toParent(this.root(), i2);
}
function transform(o2, relative) {
  if (o2 == null || typeof o2 === "string") {
    const decomposed = new Matrix(this).decompose();
    return o2 == null ? decomposed : decomposed[o2];
  }
  if (!Matrix.isMatrixLike(o2)) {
    o2 = {
      ...o2,
      origin: getOrigin(o2, this)
    };
  }
  const cleanRelative = relative === true ? this : relative || false;
  const result = new Matrix(cleanRelative).transform(o2);
  return this.attr("transform", result);
}
registerMethods("Element", {
  untransform,
  matrixify,
  toParent,
  toRoot,
  transform
});
var Container = class extends Element {
  flatten(parent = this, index3) {
    this.each(function() {
      if (this instanceof Container) {
        return this.flatten().ungroup();
      }
    });
    return this;
  }
  ungroup(parent = this.parent(), index3 = parent.index(this)) {
    index3 = index3 === -1 ? parent.children().length : index3;
    this.each(function(i2, children) {
      return children[children.length - i2 - 1].toParent(parent, index3);
    });
    return this.remove();
  }
};
register(Container, "Container");
var Defs = class extends Container {
  constructor(node3, attrs2 = node3) {
    super(nodeOrNew("defs", node3), attrs2);
  }
  flatten() {
    return this;
  }
  ungroup() {
    return this;
  }
};
register(Defs, "Defs");
var Shape = class extends Element {
};
register(Shape, "Shape");
function rx(rx2) {
  return this.attr("rx", rx2);
}
function ry(ry2) {
  return this.attr("ry", ry2);
}
function x$3(x2) {
  return x2 == null ? this.cx() - this.rx() : this.cx(x2 + this.rx());
}
function y$3(y3) {
  return y3 == null ? this.cy() - this.ry() : this.cy(y3 + this.ry());
}
function cx$1(x2) {
  return this.attr("cx", x2);
}
function cy$1(y3) {
  return this.attr("cy", y3);
}
function width$2(width2) {
  return width2 == null ? this.rx() * 2 : this.rx(new SVGNumber(width2).divide(2));
}
function height$2(height2) {
  return height2 == null ? this.ry() * 2 : this.ry(new SVGNumber(height2).divide(2));
}
var circled = {
  __proto__: null,
  rx,
  ry,
  x: x$3,
  y: y$3,
  cx: cx$1,
  cy: cy$1,
  width: width$2,
  height: height$2
};
var Ellipse = class extends Shape {
  constructor(node3, attrs2 = node3) {
    super(nodeOrNew("ellipse", node3), attrs2);
  }
  size(width2, height2) {
    const p2 = proportionalSize(this, width2, height2);
    return this.rx(new SVGNumber(p2.width).divide(2)).ry(new SVGNumber(p2.height).divide(2));
  }
};
extend(Ellipse, circled);
registerMethods("Container", {
  // Create an ellipse
  ellipse: wrapWithAttrCheck(function(width2 = 0, height2 = width2) {
    return this.put(new Ellipse()).size(width2, height2).move(0, 0);
  })
});
register(Ellipse, "Ellipse");
var Fragment = class extends Dom {
  constructor(node3 = globals.document.createDocumentFragment()) {
    super(node3);
  }
  // Import / Export raw xml
  xml(xmlOrFn, outerXML, ns) {
    if (typeof xmlOrFn === "boolean") {
      ns = outerXML;
      outerXML = xmlOrFn;
      xmlOrFn = null;
    }
    if (xmlOrFn == null || typeof xmlOrFn === "function") {
      const wrapper = new Dom(create("wrapper", ns));
      wrapper.add(this.node.cloneNode(true));
      return wrapper.xml(false, ns);
    }
    return super.xml(xmlOrFn, false, ns);
  }
};
register(Fragment, "Fragment");
function from(x2, y3) {
  return (this._element || this).type === "radialGradient" ? this.attr({
    fx: new SVGNumber(x2),
    fy: new SVGNumber(y3)
  }) : this.attr({
    x1: new SVGNumber(x2),
    y1: new SVGNumber(y3)
  });
}
function to(x2, y3) {
  return (this._element || this).type === "radialGradient" ? this.attr({
    cx: new SVGNumber(x2),
    cy: new SVGNumber(y3)
  }) : this.attr({
    x2: new SVGNumber(x2),
    y2: new SVGNumber(y3)
  });
}
var gradiented = {
  __proto__: null,
  from,
  to
};
var Gradient = class extends Container {
  constructor(type, attrs2) {
    super(nodeOrNew(type + "Gradient", typeof type === "string" ? null : type), attrs2);
  }
  // custom attr to handle transform
  attr(a2, b, c3) {
    if (a2 === "transform")
      a2 = "gradientTransform";
    return super.attr(a2, b, c3);
  }
  bbox() {
    return new Box();
  }
  targets() {
    return baseFind('svg [fill*="' + this.id() + '"]');
  }
  // Alias string conversion to fill
  toString() {
    return this.url();
  }
  // Update gradient
  update(block) {
    this.clear();
    if (typeof block === "function") {
      block.call(this, this);
    }
    return this;
  }
  // Return the fill id
  url() {
    return 'url("#' + this.id() + '")';
  }
};
extend(Gradient, gradiented);
registerMethods({
  Container: {
    // Create gradient element in defs
    gradient(...args) {
      return this.defs().gradient(...args);
    }
  },
  // define gradient
  Defs: {
    gradient: wrapWithAttrCheck(function(type, block) {
      return this.put(new Gradient(type)).update(block);
    })
  }
});
register(Gradient, "Gradient");
var Pattern = class extends Container {
  // Initialize node
  constructor(node3, attrs2 = node3) {
    super(nodeOrNew("pattern", node3), attrs2);
  }
  // custom attr to handle transform
  attr(a2, b, c3) {
    if (a2 === "transform")
      a2 = "patternTransform";
    return super.attr(a2, b, c3);
  }
  bbox() {
    return new Box();
  }
  targets() {
    return baseFind('svg [fill*="' + this.id() + '"]');
  }
  // Alias string conversion to fill
  toString() {
    return this.url();
  }
  // Update pattern by rebuilding
  update(block) {
    this.clear();
    if (typeof block === "function") {
      block.call(this, this);
    }
    return this;
  }
  // Return the fill id
  url() {
    return 'url("#' + this.id() + '")';
  }
};
registerMethods({
  Container: {
    // Create pattern element in defs
    pattern(...args) {
      return this.defs().pattern(...args);
    }
  },
  Defs: {
    pattern: wrapWithAttrCheck(function(width2, height2, block) {
      return this.put(new Pattern()).update(block).attr({
        x: 0,
        y: 0,
        width: width2,
        height: height2,
        patternUnits: "userSpaceOnUse"
      });
    })
  }
});
register(Pattern, "Pattern");
var Image2 = class extends Shape {
  constructor(node3, attrs2 = node3) {
    super(nodeOrNew("image", node3), attrs2);
  }
  // (re)load image
  load(url, callback) {
    if (!url)
      return this;
    const img = new globals.window.Image();
    on(img, "load", function(e2) {
      const p2 = this.parent(Pattern);
      if (this.width() === 0 && this.height() === 0) {
        this.size(img.width, img.height);
      }
      if (p2 instanceof Pattern) {
        if (p2.width() === 0 && p2.height() === 0) {
          p2.size(this.width(), this.height());
        }
      }
      if (typeof callback === "function") {
        callback.call(this, e2);
      }
    }, this);
    on(img, "load error", function() {
      off(img);
    });
    return this.attr("href", img.src = url, xlink);
  }
};
registerAttrHook(function(attr2, val, _this) {
  if (attr2 === "fill" || attr2 === "stroke") {
    if (isImage.test(val)) {
      val = _this.root().defs().image(val);
    }
  }
  if (val instanceof Image2) {
    val = _this.root().defs().pattern(0, 0, (pattern) => {
      pattern.add(val);
    });
  }
  return val;
});
registerMethods({
  Container: {
    // create image element, load image and set its size
    image: wrapWithAttrCheck(function(source, callback) {
      return this.put(new Image2()).size(0, 0).load(source, callback);
    })
  }
});
register(Image2, "Image");
var PointArray = class extends SVGArray {
  // Get bounding box of points
  bbox() {
    let maxX = -Infinity;
    let maxY = -Infinity;
    let minX = Infinity;
    let minY = Infinity;
    this.forEach(function(el2) {
      maxX = Math.max(el2[0], maxX);
      maxY = Math.max(el2[1], maxY);
      minX = Math.min(el2[0], minX);
      minY = Math.min(el2[1], minY);
    });
    return new Box(minX, minY, maxX - minX, maxY - minY);
  }
  // Move point string
  move(x2, y3) {
    const box = this.bbox();
    x2 -= box.x;
    y3 -= box.y;
    if (!isNaN(x2) && !isNaN(y3)) {
      for (let i2 = this.length - 1; i2 >= 0; i2--) {
        this[i2] = [this[i2][0] + x2, this[i2][1] + y3];
      }
    }
    return this;
  }
  // Parse point string and flat array
  parse(array2 = [0, 0]) {
    const points = [];
    if (array2 instanceof Array) {
      array2 = Array.prototype.concat.apply([], array2);
    } else {
      array2 = array2.trim().split(delimiter).map(parseFloat);
    }
    if (array2.length % 2 !== 0)
      array2.pop();
    for (let i2 = 0, len = array2.length; i2 < len; i2 = i2 + 2) {
      points.push([array2[i2], array2[i2 + 1]]);
    }
    return points;
  }
  // Resize poly string
  size(width2, height2) {
    let i2;
    const box = this.bbox();
    for (i2 = this.length - 1; i2 >= 0; i2--) {
      if (box.width)
        this[i2][0] = (this[i2][0] - box.x) * width2 / box.width + box.x;
      if (box.height)
        this[i2][1] = (this[i2][1] - box.y) * height2 / box.height + box.y;
    }
    return this;
  }
  // Convert array to line object
  toLine() {
    return {
      x1: this[0][0],
      y1: this[0][1],
      x2: this[1][0],
      y2: this[1][1]
    };
  }
  // Convert array to string
  toString() {
    const array2 = [];
    for (let i2 = 0, il = this.length; i2 < il; i2++) {
      array2.push(this[i2].join(","));
    }
    return array2.join(" ");
  }
  transform(m3) {
    return this.clone().transformO(m3);
  }
  // transform points with matrix (similar to Point.transform)
  transformO(m3) {
    if (!Matrix.isMatrixLike(m3)) {
      m3 = new Matrix(m3);
    }
    for (let i2 = this.length; i2--; ) {
      const [x2, y3] = this[i2];
      this[i2][0] = m3.a * x2 + m3.c * y3 + m3.e;
      this[i2][1] = m3.b * x2 + m3.d * y3 + m3.f;
    }
    return this;
  }
};
var MorphArray = PointArray;
function x$2(x2) {
  return x2 == null ? this.bbox().x : this.move(x2, this.bbox().y);
}
function y$2(y3) {
  return y3 == null ? this.bbox().y : this.move(this.bbox().x, y3);
}
function width$1(width2) {
  const b = this.bbox();
  return width2 == null ? b.width : this.size(width2, b.height);
}
function height$1(height2) {
  const b = this.bbox();
  return height2 == null ? b.height : this.size(b.width, height2);
}
var pointed = {
  __proto__: null,
  MorphArray,
  x: x$2,
  y: y$2,
  width: width$1,
  height: height$1
};
var Line = class extends Shape {
  // Initialize node
  constructor(node3, attrs2 = node3) {
    super(nodeOrNew("line", node3), attrs2);
  }
  // Get array
  array() {
    return new PointArray([[this.attr("x1"), this.attr("y1")], [this.attr("x2"), this.attr("y2")]]);
  }
  // Move by left top corner
  move(x2, y3) {
    return this.attr(this.array().move(x2, y3).toLine());
  }
  // Overwrite native plot() method
  plot(x1, y1, x2, y22) {
    if (x1 == null) {
      return this.array();
    } else if (typeof y1 !== "undefined") {
      x1 = {
        x1,
        y1,
        x2,
        y2: y22
      };
    } else {
      x1 = new PointArray(x1).toLine();
    }
    return this.attr(x1);
  }
  // Set element size to given width and height
  size(width2, height2) {
    const p2 = proportionalSize(this, width2, height2);
    return this.attr(this.array().size(p2.width, p2.height).toLine());
  }
};
extend(Line, pointed);
registerMethods({
  Container: {
    // Create a line element
    line: wrapWithAttrCheck(function(...args) {
      return Line.prototype.plot.apply(this.put(new Line()), args[0] != null ? args : [0, 0, 0, 0]);
    })
  }
});
register(Line, "Line");
var Marker = class extends Container {
  // Initialize node
  constructor(node3, attrs2 = node3) {
    super(nodeOrNew("marker", node3), attrs2);
  }
  // Set height of element
  height(height2) {
    return this.attr("markerHeight", height2);
  }
  orient(orient) {
    return this.attr("orient", orient);
  }
  // Set marker refX and refY
  ref(x2, y3) {
    return this.attr("refX", x2).attr("refY", y3);
  }
  // Return the fill id
  toString() {
    return "url(#" + this.id() + ")";
  }
  // Update marker
  update(block) {
    this.clear();
    if (typeof block === "function") {
      block.call(this, this);
    }
    return this;
  }
  // Set width of element
  width(width2) {
    return this.attr("markerWidth", width2);
  }
};
registerMethods({
  Container: {
    marker(...args) {
      return this.defs().marker(...args);
    }
  },
  Defs: {
    // Create marker
    marker: wrapWithAttrCheck(function(width2, height2, block) {
      return this.put(new Marker()).size(width2, height2).ref(width2 / 2, height2 / 2).viewbox(0, 0, width2, height2).attr("orient", "auto").update(block);
    })
  },
  marker: {
    // Create and attach markers
    marker(marker, width2, height2, block) {
      let attr2 = ["marker"];
      if (marker !== "all")
        attr2.push(marker);
      attr2 = attr2.join("-");
      marker = arguments[1] instanceof Marker ? arguments[1] : this.defs().marker(width2, height2, block);
      return this.attr(attr2, marker);
    }
  }
});
register(Marker, "Marker");
function makeSetterGetter(k, f3) {
  return function(v2) {
    if (v2 == null)
      return this[k];
    this[k] = v2;
    if (f3)
      f3.call(this);
    return this;
  };
}
var easing = {
  "-": function(pos) {
    return pos;
  },
  "<>": function(pos) {
    return -Math.cos(pos * Math.PI) / 2 + 0.5;
  },
  ">": function(pos) {
    return Math.sin(pos * Math.PI / 2);
  },
  "<": function(pos) {
    return -Math.cos(pos * Math.PI / 2) + 1;
  },
  bezier: function(x1, y1, x2, y22) {
    return function(t2) {
      if (t2 < 0) {
        if (x1 > 0) {
          return y1 / x1 * t2;
        } else if (x2 > 0) {
          return y22 / x2 * t2;
        } else {
          return 0;
        }
      } else if (t2 > 1) {
        if (x2 < 1) {
          return (1 - y22) / (1 - x2) * t2 + (y22 - x2) / (1 - x2);
        } else if (x1 < 1) {
          return (1 - y1) / (1 - x1) * t2 + (y1 - x1) / (1 - x1);
        } else {
          return 1;
        }
      } else {
        return 3 * t2 * (1 - t2) ** 2 * y1 + 3 * t2 ** 2 * (1 - t2) * y22 + t2 ** 3;
      }
    };
  },
  // see https://www.w3.org/TR/css-easing-1/#step-timing-function-algo
  steps: function(steps, stepPosition = "end") {
    stepPosition = stepPosition.split("-").reverse()[0];
    let jumps = steps;
    if (stepPosition === "none") {
      --jumps;
    } else if (stepPosition === "both") {
      ++jumps;
    }
    return (t2, beforeFlag = false) => {
      let step = Math.floor(t2 * steps);
      const jumping = t2 * step % 1 === 0;
      if (stepPosition === "start" || stepPosition === "both") {
        ++step;
      }
      if (beforeFlag && jumping) {
        --step;
      }
      if (t2 >= 0 && step < 0) {
        step = 0;
      }
      if (t2 <= 1 && step > jumps) {
        step = jumps;
      }
      return step / jumps;
    };
  }
};
var Stepper = class {
  done() {
    return false;
  }
};
var Ease = class extends Stepper {
  constructor(fn = timeline.ease) {
    super();
    this.ease = easing[fn] || fn;
  }
  step(from2, to2, pos) {
    if (typeof from2 !== "number") {
      return pos < 1 ? from2 : to2;
    }
    return from2 + (to2 - from2) * this.ease(pos);
  }
};
var Controller = class extends Stepper {
  constructor(fn) {
    super();
    this.stepper = fn;
  }
  done(c3) {
    return c3.done;
  }
  step(current, target, dt, c3) {
    return this.stepper(current, target, dt, c3);
  }
};
function recalculate() {
  const duration = (this._duration || 500) / 1e3;
  const overshoot = this._overshoot || 0;
  const eps = 1e-10;
  const pi = Math.PI;
  const os = Math.log(overshoot / 100 + eps);
  const zeta = -os / Math.sqrt(pi * pi + os * os);
  const wn = 3.9 / (zeta * duration);
  this.d = 2 * zeta * wn;
  this.k = wn * wn;
}
var Spring = class extends Controller {
  constructor(duration = 500, overshoot = 0) {
    super();
    this.duration(duration).overshoot(overshoot);
  }
  step(current, target, dt, c3) {
    if (typeof current === "string")
      return current;
    c3.done = dt === Infinity;
    if (dt === Infinity)
      return target;
    if (dt === 0)
      return current;
    if (dt > 100)
      dt = 16;
    dt /= 1e3;
    const velocity = c3.velocity || 0;
    const acceleration = -this.d * velocity - this.k * (current - target);
    const newPosition = current + velocity * dt + acceleration * dt * dt / 2;
    c3.velocity = velocity + acceleration * dt;
    c3.done = Math.abs(target - newPosition) + Math.abs(velocity) < 2e-3;
    return c3.done ? target : newPosition;
  }
};
extend(Spring, {
  duration: makeSetterGetter("_duration", recalculate),
  overshoot: makeSetterGetter("_overshoot", recalculate)
});
var PID = class extends Controller {
  constructor(p2 = 0.1, i2 = 0.01, d = 0, windup = 1e3) {
    super();
    this.p(p2).i(i2).d(d).windup(windup);
  }
  step(current, target, dt, c3) {
    if (typeof current === "string")
      return current;
    c3.done = dt === Infinity;
    if (dt === Infinity)
      return target;
    if (dt === 0)
      return current;
    const p2 = target - current;
    let i2 = (c3.integral || 0) + p2 * dt;
    const d = (p2 - (c3.error || 0)) / dt;
    const windup = this._windup;
    if (windup !== false) {
      i2 = Math.max(-windup, Math.min(i2, windup));
    }
    c3.error = p2;
    c3.integral = i2;
    c3.done = Math.abs(p2) < 1e-3;
    return c3.done ? target : current + (this.P * p2 + this.I * i2 + this.D * d);
  }
};
extend(PID, {
  windup: makeSetterGetter("_windup"),
  p: makeSetterGetter("P"),
  i: makeSetterGetter("I"),
  d: makeSetterGetter("D")
});
var segmentParameters = {
  M: 2,
  L: 2,
  H: 1,
  V: 1,
  C: 6,
  S: 4,
  Q: 4,
  T: 2,
  A: 7,
  Z: 0
};
var pathHandlers = {
  M: function(c3, p2, p0) {
    p2.x = p0.x = c3[0];
    p2.y = p0.y = c3[1];
    return ["M", p2.x, p2.y];
  },
  L: function(c3, p2) {
    p2.x = c3[0];
    p2.y = c3[1];
    return ["L", c3[0], c3[1]];
  },
  H: function(c3, p2) {
    p2.x = c3[0];
    return ["H", c3[0]];
  },
  V: function(c3, p2) {
    p2.y = c3[0];
    return ["V", c3[0]];
  },
  C: function(c3, p2) {
    p2.x = c3[4];
    p2.y = c3[5];
    return ["C", c3[0], c3[1], c3[2], c3[3], c3[4], c3[5]];
  },
  S: function(c3, p2) {
    p2.x = c3[2];
    p2.y = c3[3];
    return ["S", c3[0], c3[1], c3[2], c3[3]];
  },
  Q: function(c3, p2) {
    p2.x = c3[2];
    p2.y = c3[3];
    return ["Q", c3[0], c3[1], c3[2], c3[3]];
  },
  T: function(c3, p2) {
    p2.x = c3[0];
    p2.y = c3[1];
    return ["T", c3[0], c3[1]];
  },
  Z: function(c3, p2, p0) {
    p2.x = p0.x;
    p2.y = p0.y;
    return ["Z"];
  },
  A: function(c3, p2) {
    p2.x = c3[5];
    p2.y = c3[6];
    return ["A", c3[0], c3[1], c3[2], c3[3], c3[4], c3[5], c3[6]];
  }
};
var mlhvqtcsaz = "mlhvqtcsaz".split("");
for (let i2 = 0, il = mlhvqtcsaz.length; i2 < il; ++i2) {
  pathHandlers[mlhvqtcsaz[i2]] = function(i3) {
    return function(c3, p2, p0) {
      if (i3 === "H")
        c3[0] = c3[0] + p2.x;
      else if (i3 === "V")
        c3[0] = c3[0] + p2.y;
      else if (i3 === "A") {
        c3[5] = c3[5] + p2.x;
        c3[6] = c3[6] + p2.y;
      } else {
        for (let j = 0, jl = c3.length; j < jl; ++j) {
          c3[j] = c3[j] + (j % 2 ? p2.y : p2.x);
        }
      }
      return pathHandlers[i3](c3, p2, p0);
    };
  }(mlhvqtcsaz[i2].toUpperCase());
}
function makeAbsolut(parser2) {
  const command = parser2.segment[0];
  return pathHandlers[command](parser2.segment.slice(1), parser2.p, parser2.p0);
}
function segmentComplete(parser2) {
  return parser2.segment.length && parser2.segment.length - 1 === segmentParameters[parser2.segment[0].toUpperCase()];
}
function startNewSegment(parser2, token) {
  parser2.inNumber && finalizeNumber(parser2, false);
  const pathLetter = isPathLetter.test(token);
  if (pathLetter) {
    parser2.segment = [token];
  } else {
    const lastCommand = parser2.lastCommand;
    const small = lastCommand.toLowerCase();
    const isSmall = lastCommand === small;
    parser2.segment = [small === "m" ? isSmall ? "l" : "L" : lastCommand];
  }
  parser2.inSegment = true;
  parser2.lastCommand = parser2.segment[0];
  return pathLetter;
}
function finalizeNumber(parser2, inNumber) {
  if (!parser2.inNumber)
    throw new Error("Parser Error");
  parser2.number && parser2.segment.push(parseFloat(parser2.number));
  parser2.inNumber = inNumber;
  parser2.number = "";
  parser2.pointSeen = false;
  parser2.hasExponent = false;
  if (segmentComplete(parser2)) {
    finalizeSegment(parser2);
  }
}
function finalizeSegment(parser2) {
  parser2.inSegment = false;
  if (parser2.absolute) {
    parser2.segment = makeAbsolut(parser2);
  }
  parser2.segments.push(parser2.segment);
}
function isArcFlag(parser2) {
  if (!parser2.segment.length)
    return false;
  const isArc = parser2.segment[0].toUpperCase() === "A";
  const length2 = parser2.segment.length;
  return isArc && (length2 === 4 || length2 === 5);
}
function isExponential(parser2) {
  return parser2.lastToken.toUpperCase() === "E";
}
function pathParser(d, toAbsolute = true) {
  let index3 = 0;
  let token = "";
  const parser2 = {
    segment: [],
    inNumber: false,
    number: "",
    lastToken: "",
    inSegment: false,
    segments: [],
    pointSeen: false,
    hasExponent: false,
    absolute: toAbsolute,
    p0: new Point(),
    p: new Point()
  };
  while (parser2.lastToken = token, token = d.charAt(index3++)) {
    if (!parser2.inSegment) {
      if (startNewSegment(parser2, token)) {
        continue;
      }
    }
    if (token === ".") {
      if (parser2.pointSeen || parser2.hasExponent) {
        finalizeNumber(parser2, false);
        --index3;
        continue;
      }
      parser2.inNumber = true;
      parser2.pointSeen = true;
      parser2.number += token;
      continue;
    }
    if (!isNaN(parseInt(token))) {
      if (parser2.number === "0" || isArcFlag(parser2)) {
        parser2.inNumber = true;
        parser2.number = token;
        finalizeNumber(parser2, true);
        continue;
      }
      parser2.inNumber = true;
      parser2.number += token;
      continue;
    }
    if (token === " " || token === ",") {
      if (parser2.inNumber) {
        finalizeNumber(parser2, false);
      }
      continue;
    }
    if (token === "-") {
      if (parser2.inNumber && !isExponential(parser2)) {
        finalizeNumber(parser2, false);
        --index3;
        continue;
      }
      parser2.number += token;
      parser2.inNumber = true;
      continue;
    }
    if (token.toUpperCase() === "E") {
      parser2.number += token;
      parser2.hasExponent = true;
      continue;
    }
    if (isPathLetter.test(token)) {
      if (parser2.inNumber) {
        finalizeNumber(parser2, false);
      } else if (!segmentComplete(parser2)) {
        throw new Error("parser Error");
      } else {
        finalizeSegment(parser2);
      }
      --index3;
    }
  }
  if (parser2.inNumber) {
    finalizeNumber(parser2, false);
  }
  if (parser2.inSegment && segmentComplete(parser2)) {
    finalizeSegment(parser2);
  }
  return parser2.segments;
}
function arrayToString(a2) {
  let s2 = "";
  for (let i2 = 0, il = a2.length; i2 < il; i2++) {
    s2 += a2[i2][0];
    if (a2[i2][1] != null) {
      s2 += a2[i2][1];
      if (a2[i2][2] != null) {
        s2 += " ";
        s2 += a2[i2][2];
        if (a2[i2][3] != null) {
          s2 += " ";
          s2 += a2[i2][3];
          s2 += " ";
          s2 += a2[i2][4];
          if (a2[i2][5] != null) {
            s2 += " ";
            s2 += a2[i2][5];
            s2 += " ";
            s2 += a2[i2][6];
            if (a2[i2][7] != null) {
              s2 += " ";
              s2 += a2[i2][7];
            }
          }
        }
      }
    }
  }
  return s2 + " ";
}
var PathArray = class extends SVGArray {
  // Get bounding box of path
  bbox() {
    parser().path.setAttribute("d", this.toString());
    return new Box(parser.nodes.path.getBBox());
  }
  // Move path string
  move(x2, y3) {
    const box = this.bbox();
    x2 -= box.x;
    y3 -= box.y;
    if (!isNaN(x2) && !isNaN(y3)) {
      for (let l2, i2 = this.length - 1; i2 >= 0; i2--) {
        l2 = this[i2][0];
        if (l2 === "M" || l2 === "L" || l2 === "T") {
          this[i2][1] += x2;
          this[i2][2] += y3;
        } else if (l2 === "H") {
          this[i2][1] += x2;
        } else if (l2 === "V") {
          this[i2][1] += y3;
        } else if (l2 === "C" || l2 === "S" || l2 === "Q") {
          this[i2][1] += x2;
          this[i2][2] += y3;
          this[i2][3] += x2;
          this[i2][4] += y3;
          if (l2 === "C") {
            this[i2][5] += x2;
            this[i2][6] += y3;
          }
        } else if (l2 === "A") {
          this[i2][6] += x2;
          this[i2][7] += y3;
        }
      }
    }
    return this;
  }
  // Absolutize and parse path to array
  parse(d = "M0 0") {
    if (Array.isArray(d)) {
      d = Array.prototype.concat.apply([], d).toString();
    }
    return pathParser(d);
  }
  // Resize path string
  size(width2, height2) {
    const box = this.bbox();
    let i2, l2;
    box.width = box.width === 0 ? 1 : box.width;
    box.height = box.height === 0 ? 1 : box.height;
    for (i2 = this.length - 1; i2 >= 0; i2--) {
      l2 = this[i2][0];
      if (l2 === "M" || l2 === "L" || l2 === "T") {
        this[i2][1] = (this[i2][1] - box.x) * width2 / box.width + box.x;
        this[i2][2] = (this[i2][2] - box.y) * height2 / box.height + box.y;
      } else if (l2 === "H") {
        this[i2][1] = (this[i2][1] - box.x) * width2 / box.width + box.x;
      } else if (l2 === "V") {
        this[i2][1] = (this[i2][1] - box.y) * height2 / box.height + box.y;
      } else if (l2 === "C" || l2 === "S" || l2 === "Q") {
        this[i2][1] = (this[i2][1] - box.x) * width2 / box.width + box.x;
        this[i2][2] = (this[i2][2] - box.y) * height2 / box.height + box.y;
        this[i2][3] = (this[i2][3] - box.x) * width2 / box.width + box.x;
        this[i2][4] = (this[i2][4] - box.y) * height2 / box.height + box.y;
        if (l2 === "C") {
          this[i2][5] = (this[i2][5] - box.x) * width2 / box.width + box.x;
          this[i2][6] = (this[i2][6] - box.y) * height2 / box.height + box.y;
        }
      } else if (l2 === "A") {
        this[i2][1] = this[i2][1] * width2 / box.width;
        this[i2][2] = this[i2][2] * height2 / box.height;
        this[i2][6] = (this[i2][6] - box.x) * width2 / box.width + box.x;
        this[i2][7] = (this[i2][7] - box.y) * height2 / box.height + box.y;
      }
    }
    return this;
  }
  // Convert array to string
  toString() {
    return arrayToString(this);
  }
};
var getClassForType = (value) => {
  const type = typeof value;
  if (type === "number") {
    return SVGNumber;
  } else if (type === "string") {
    if (Color.isColor(value)) {
      return Color;
    } else if (delimiter.test(value)) {
      return isPathLetter.test(value) ? PathArray : SVGArray;
    } else if (numberAndUnit.test(value)) {
      return SVGNumber;
    } else {
      return NonMorphable;
    }
  } else if (morphableTypes.indexOf(value.constructor) > -1) {
    return value.constructor;
  } else if (Array.isArray(value)) {
    return SVGArray;
  } else if (type === "object") {
    return ObjectBag;
  } else {
    return NonMorphable;
  }
};
var Morphable = class {
  constructor(stepper) {
    this._stepper = stepper || new Ease("-");
    this._from = null;
    this._to = null;
    this._type = null;
    this._context = null;
    this._morphObj = null;
  }
  at(pos) {
    return this._morphObj.morph(this._from, this._to, pos, this._stepper, this._context);
  }
  done() {
    const complete = this._context.map(this._stepper.done).reduce(function(last, curr) {
      return last && curr;
    }, true);
    return complete;
  }
  from(val) {
    if (val == null) {
      return this._from;
    }
    this._from = this._set(val);
    return this;
  }
  stepper(stepper) {
    if (stepper == null)
      return this._stepper;
    this._stepper = stepper;
    return this;
  }
  to(val) {
    if (val == null) {
      return this._to;
    }
    this._to = this._set(val);
    return this;
  }
  type(type) {
    if (type == null) {
      return this._type;
    }
    this._type = type;
    return this;
  }
  _set(value) {
    if (!this._type) {
      this.type(getClassForType(value));
    }
    let result = new this._type(value);
    if (this._type === Color) {
      result = this._to ? result[this._to[4]]() : this._from ? result[this._from[4]]() : result;
    }
    if (this._type === ObjectBag) {
      result = this._to ? result.align(this._to) : this._from ? result.align(this._from) : result;
    }
    result = result.toConsumable();
    this._morphObj = this._morphObj || new this._type();
    this._context = this._context || Array.apply(null, Array(result.length)).map(Object).map(function(o2) {
      o2.done = true;
      return o2;
    });
    return result;
  }
};
var NonMorphable = class {
  constructor(...args) {
    this.init(...args);
  }
  init(val) {
    val = Array.isArray(val) ? val[0] : val;
    this.value = val;
    return this;
  }
  toArray() {
    return [this.value];
  }
  valueOf() {
    return this.value;
  }
};
var TransformBag = class {
  constructor(...args) {
    this.init(...args);
  }
  init(obj) {
    if (Array.isArray(obj)) {
      obj = {
        scaleX: obj[0],
        scaleY: obj[1],
        shear: obj[2],
        rotate: obj[3],
        translateX: obj[4],
        translateY: obj[5],
        originX: obj[6],
        originY: obj[7]
      };
    }
    Object.assign(this, TransformBag.defaults, obj);
    return this;
  }
  toArray() {
    const v2 = this;
    return [v2.scaleX, v2.scaleY, v2.shear, v2.rotate, v2.translateX, v2.translateY, v2.originX, v2.originY];
  }
};
TransformBag.defaults = {
  scaleX: 1,
  scaleY: 1,
  shear: 0,
  rotate: 0,
  translateX: 0,
  translateY: 0,
  originX: 0,
  originY: 0
};
var sortByKey = (a2, b) => {
  return a2[0] < b[0] ? -1 : a2[0] > b[0] ? 1 : 0;
};
var ObjectBag = class {
  constructor(...args) {
    this.init(...args);
  }
  align(other) {
    const values = this.values;
    for (let i2 = 0, il = values.length; i2 < il; ++i2) {
      if (values[i2 + 1] === other[i2 + 1]) {
        if (values[i2 + 1] === Color && other[i2 + 7] !== values[i2 + 7]) {
          const space = other[i2 + 7];
          const color = new Color(this.values.splice(i2 + 3, 5))[space]().toArray();
          this.values.splice(i2 + 3, 0, ...color);
        }
        i2 += values[i2 + 2] + 2;
        continue;
      }
      if (!other[i2 + 1]) {
        return this;
      }
      const defaultObject = new other[i2 + 1]().toArray();
      const toDelete = values[i2 + 2] + 3;
      values.splice(i2, toDelete, other[i2], other[i2 + 1], other[i2 + 2], ...defaultObject);
      i2 += values[i2 + 2] + 2;
    }
    return this;
  }
  init(objOrArr) {
    this.values = [];
    if (Array.isArray(objOrArr)) {
      this.values = objOrArr.slice();
      return;
    }
    objOrArr = objOrArr || {};
    const entries = [];
    for (const i2 in objOrArr) {
      const Type = getClassForType(objOrArr[i2]);
      const val = new Type(objOrArr[i2]).toArray();
      entries.push([i2, Type, val.length, ...val]);
    }
    entries.sort(sortByKey);
    this.values = entries.reduce((last, curr) => last.concat(curr), []);
    return this;
  }
  toArray() {
    return this.values;
  }
  valueOf() {
    const obj = {};
    const arr = this.values;
    while (arr.length) {
      const key = arr.shift();
      const Type = arr.shift();
      const num = arr.shift();
      const values = arr.splice(0, num);
      obj[key] = new Type(values);
    }
    return obj;
  }
};
var morphableTypes = [NonMorphable, TransformBag, ObjectBag];
function registerMorphableType(type = []) {
  morphableTypes.push(...[].concat(type));
}
function makeMorphable() {
  extend(morphableTypes, {
    to(val) {
      return new Morphable().type(this.constructor).from(this.toArray()).to(val);
    },
    fromArray(arr) {
      this.init(arr);
      return this;
    },
    toConsumable() {
      return this.toArray();
    },
    morph(from2, to2, pos, stepper, context) {
      const mapper = function(i2, index3) {
        return stepper.step(i2, to2[index3], pos, context[index3], context);
      };
      return this.fromArray(from2.map(mapper));
    }
  });
}
var Path = class extends Shape {
  // Initialize node
  constructor(node3, attrs2 = node3) {
    super(nodeOrNew("path", node3), attrs2);
  }
  // Get array
  array() {
    return this._array || (this._array = new PathArray(this.attr("d")));
  }
  // Clear array cache
  clear() {
    delete this._array;
    return this;
  }
  // Set height of element
  height(height2) {
    return height2 == null ? this.bbox().height : this.size(this.bbox().width, height2);
  }
  // Move by left top corner
  move(x2, y3) {
    return this.attr("d", this.array().move(x2, y3));
  }
  // Plot new path
  plot(d) {
    return d == null ? this.array() : this.clear().attr("d", typeof d === "string" ? d : this._array = new PathArray(d));
  }
  // Set element size to given width and height
  size(width2, height2) {
    const p2 = proportionalSize(this, width2, height2);
    return this.attr("d", this.array().size(p2.width, p2.height));
  }
  // Set width of element
  width(width2) {
    return width2 == null ? this.bbox().width : this.size(width2, this.bbox().height);
  }
  // Move by left top corner over x-axis
  x(x2) {
    return x2 == null ? this.bbox().x : this.move(x2, this.bbox().y);
  }
  // Move by left top corner over y-axis
  y(y3) {
    return y3 == null ? this.bbox().y : this.move(this.bbox().x, y3);
  }
};
Path.prototype.MorphArray = PathArray;
registerMethods({
  Container: {
    // Create a wrapped path element
    path: wrapWithAttrCheck(function(d) {
      return this.put(new Path()).plot(d || new PathArray());
    })
  }
});
register(Path, "Path");
function array() {
  return this._array || (this._array = new PointArray(this.attr("points")));
}
function clear() {
  delete this._array;
  return this;
}
function move$2(x2, y3) {
  return this.attr("points", this.array().move(x2, y3));
}
function plot(p2) {
  return p2 == null ? this.array() : this.clear().attr("points", typeof p2 === "string" ? p2 : this._array = new PointArray(p2));
}
function size$1(width2, height2) {
  const p2 = proportionalSize(this, width2, height2);
  return this.attr("points", this.array().size(p2.width, p2.height));
}
var poly = {
  __proto__: null,
  array,
  clear,
  move: move$2,
  plot,
  size: size$1
};
var Polygon = class extends Shape {
  // Initialize node
  constructor(node3, attrs2 = node3) {
    super(nodeOrNew("polygon", node3), attrs2);
  }
};
registerMethods({
  Container: {
    // Create a wrapped polygon element
    polygon: wrapWithAttrCheck(function(p2) {
      return this.put(new Polygon()).plot(p2 || new PointArray());
    })
  }
});
extend(Polygon, pointed);
extend(Polygon, poly);
register(Polygon, "Polygon");
var Polyline = class extends Shape {
  // Initialize node
  constructor(node3, attrs2 = node3) {
    super(nodeOrNew("polyline", node3), attrs2);
  }
};
registerMethods({
  Container: {
    // Create a wrapped polygon element
    polyline: wrapWithAttrCheck(function(p2) {
      return this.put(new Polyline()).plot(p2 || new PointArray());
    })
  }
});
extend(Polyline, pointed);
extend(Polyline, poly);
register(Polyline, "Polyline");
var Rect = class extends Shape {
  // Initialize node
  constructor(node3, attrs2 = node3) {
    super(nodeOrNew("rect", node3), attrs2);
  }
};
extend(Rect, {
  rx,
  ry
});
registerMethods({
  Container: {
    // Create a rect element
    rect: wrapWithAttrCheck(function(width2, height2) {
      return this.put(new Rect()).size(width2, height2);
    })
  }
});
register(Rect, "Rect");
var Queue = class {
  constructor() {
    this._first = null;
    this._last = null;
  }
  // Shows us the first item in the list
  first() {
    return this._first && this._first.value;
  }
  // Shows us the last item in the list
  last() {
    return this._last && this._last.value;
  }
  push(value) {
    const item = typeof value.next !== "undefined" ? value : {
      value,
      next: null,
      prev: null
    };
    if (this._last) {
      item.prev = this._last;
      this._last.next = item;
      this._last = item;
    } else {
      this._last = item;
      this._first = item;
    }
    return item;
  }
  // Removes the item that was returned from the push
  remove(item) {
    if (item.prev)
      item.prev.next = item.next;
    if (item.next)
      item.next.prev = item.prev;
    if (item === this._last)
      this._last = item.prev;
    if (item === this._first)
      this._first = item.next;
    item.prev = null;
    item.next = null;
  }
  shift() {
    const remove2 = this._first;
    if (!remove2)
      return null;
    this._first = remove2.next;
    if (this._first)
      this._first.prev = null;
    this._last = this._first ? this._last : null;
    return remove2.value;
  }
};
var Animator = {
  nextDraw: null,
  frames: new Queue(),
  timeouts: new Queue(),
  immediates: new Queue(),
  timer: () => globals.window.performance || globals.window.Date,
  transforms: [],
  frame(fn) {
    const node3 = Animator.frames.push({
      run: fn
    });
    if (Animator.nextDraw === null) {
      Animator.nextDraw = globals.window.requestAnimationFrame(Animator._draw);
    }
    return node3;
  },
  timeout(fn, delay) {
    delay = delay || 0;
    const time = Animator.timer().now() + delay;
    const node3 = Animator.timeouts.push({
      run: fn,
      time
    });
    if (Animator.nextDraw === null) {
      Animator.nextDraw = globals.window.requestAnimationFrame(Animator._draw);
    }
    return node3;
  },
  immediate(fn) {
    const node3 = Animator.immediates.push(fn);
    if (Animator.nextDraw === null) {
      Animator.nextDraw = globals.window.requestAnimationFrame(Animator._draw);
    }
    return node3;
  },
  cancelFrame(node3) {
    node3 != null && Animator.frames.remove(node3);
  },
  clearTimeout(node3) {
    node3 != null && Animator.timeouts.remove(node3);
  },
  cancelImmediate(node3) {
    node3 != null && Animator.immediates.remove(node3);
  },
  _draw(now) {
    let nextTimeout = null;
    const lastTimeout = Animator.timeouts.last();
    while (nextTimeout = Animator.timeouts.shift()) {
      if (now >= nextTimeout.time) {
        nextTimeout.run();
      } else {
        Animator.timeouts.push(nextTimeout);
      }
      if (nextTimeout === lastTimeout)
        break;
    }
    let nextFrame = null;
    const lastFrame = Animator.frames.last();
    while (nextFrame !== lastFrame && (nextFrame = Animator.frames.shift())) {
      nextFrame.run(now);
    }
    let nextImmediate = null;
    while (nextImmediate = Animator.immediates.shift()) {
      nextImmediate();
    }
    Animator.nextDraw = Animator.timeouts.first() || Animator.frames.first() ? globals.window.requestAnimationFrame(Animator._draw) : null;
  }
};
var makeSchedule = function(runnerInfo) {
  const start = runnerInfo.start;
  const duration = runnerInfo.runner.duration();
  const end = start + duration;
  return {
    start,
    duration,
    end,
    runner: runnerInfo.runner
  };
};
var defaultSource = function() {
  const w = globals.window;
  return (w.performance || w.Date).now();
};
var Timeline = class extends EventTarget {
  // Construct a new timeline on the given element
  constructor(timeSource = defaultSource) {
    super();
    this._timeSource = timeSource;
    this._startTime = 0;
    this._speed = 1;
    this._persist = 0;
    this._nextFrame = null;
    this._paused = true;
    this._runners = [];
    this._runnerIds = [];
    this._lastRunnerId = -1;
    this._time = 0;
    this._lastSourceTime = 0;
    this._lastStepTime = 0;
    this._step = this._stepFn.bind(this, false);
    this._stepImmediate = this._stepFn.bind(this, true);
  }
  active() {
    return !!this._nextFrame;
  }
  finish() {
    this.time(this.getEndTimeOfTimeline() + 1);
    return this.pause();
  }
  // Calculates the end of the timeline
  getEndTime() {
    const lastRunnerInfo = this.getLastRunnerInfo();
    const lastDuration = lastRunnerInfo ? lastRunnerInfo.runner.duration() : 0;
    const lastStartTime = lastRunnerInfo ? lastRunnerInfo.start : this._time;
    return lastStartTime + lastDuration;
  }
  getEndTimeOfTimeline() {
    const endTimes = this._runners.map((i2) => i2.start + i2.runner.duration());
    return Math.max(0, ...endTimes);
  }
  getLastRunnerInfo() {
    return this.getRunnerInfoById(this._lastRunnerId);
  }
  getRunnerInfoById(id) {
    return this._runners[this._runnerIds.indexOf(id)] || null;
  }
  pause() {
    this._paused = true;
    return this._continue();
  }
  persist(dtOrForever) {
    if (dtOrForever == null)
      return this._persist;
    this._persist = dtOrForever;
    return this;
  }
  play() {
    this._paused = false;
    return this.updateTime()._continue();
  }
  reverse(yes) {
    const currentSpeed = this.speed();
    if (yes == null)
      return this.speed(-currentSpeed);
    const positive = Math.abs(currentSpeed);
    return this.speed(yes ? -positive : positive);
  }
  // schedules a runner on the timeline
  schedule(runner, delay, when) {
    if (runner == null) {
      return this._runners.map(makeSchedule);
    }
    let absoluteStartTime = 0;
    const endTime = this.getEndTime();
    delay = delay || 0;
    if (when == null || when === "last" || when === "after") {
      absoluteStartTime = endTime;
    } else if (when === "absolute" || when === "start") {
      absoluteStartTime = delay;
      delay = 0;
    } else if (when === "now") {
      absoluteStartTime = this._time;
    } else if (when === "relative") {
      const runnerInfo2 = this.getRunnerInfoById(runner.id);
      if (runnerInfo2) {
        absoluteStartTime = runnerInfo2.start + delay;
        delay = 0;
      }
    } else if (when === "with-last") {
      const lastRunnerInfo = this.getLastRunnerInfo();
      const lastStartTime = lastRunnerInfo ? lastRunnerInfo.start : this._time;
      absoluteStartTime = lastStartTime;
    } else {
      throw new Error('Invalid value for the "when" parameter');
    }
    runner.unschedule();
    runner.timeline(this);
    const persist = runner.persist();
    const runnerInfo = {
      persist: persist === null ? this._persist : persist,
      start: absoluteStartTime + delay,
      runner
    };
    this._lastRunnerId = runner.id;
    this._runners.push(runnerInfo);
    this._runners.sort((a2, b) => a2.start - b.start);
    this._runnerIds = this._runners.map((info) => info.runner.id);
    this.updateTime()._continue();
    return this;
  }
  seek(dt) {
    return this.time(this._time + dt);
  }
  source(fn) {
    if (fn == null)
      return this._timeSource;
    this._timeSource = fn;
    return this;
  }
  speed(speed) {
    if (speed == null)
      return this._speed;
    this._speed = speed;
    return this;
  }
  stop() {
    this.time(0);
    return this.pause();
  }
  time(time) {
    if (time == null)
      return this._time;
    this._time = time;
    return this._continue(true);
  }
  // Remove the runner from this timeline
  unschedule(runner) {
    const index3 = this._runnerIds.indexOf(runner.id);
    if (index3 < 0)
      return this;
    this._runners.splice(index3, 1);
    this._runnerIds.splice(index3, 1);
    runner.timeline(null);
    return this;
  }
  // Makes sure, that after pausing the time doesn't jump
  updateTime() {
    if (!this.active()) {
      this._lastSourceTime = this._timeSource();
    }
    return this;
  }
  // Checks if we are running and continues the animation
  _continue(immediateStep = false) {
    Animator.cancelFrame(this._nextFrame);
    this._nextFrame = null;
    if (immediateStep)
      return this._stepImmediate();
    if (this._paused)
      return this;
    this._nextFrame = Animator.frame(this._step);
    return this;
  }
  _stepFn(immediateStep = false) {
    const time = this._timeSource();
    let dtSource = time - this._lastSourceTime;
    if (immediateStep)
      dtSource = 0;
    const dtTime = this._speed * dtSource + (this._time - this._lastStepTime);
    this._lastSourceTime = time;
    if (!immediateStep) {
      this._time += dtTime;
      this._time = this._time < 0 ? 0 : this._time;
    }
    this._lastStepTime = this._time;
    this.fire("time", this._time);
    for (let k = this._runners.length; k--; ) {
      const runnerInfo = this._runners[k];
      const runner = runnerInfo.runner;
      const dtToStart = this._time - runnerInfo.start;
      if (dtToStart <= 0) {
        runner.reset();
      }
    }
    let runnersLeft = false;
    for (let i2 = 0, len = this._runners.length; i2 < len; i2++) {
      const runnerInfo = this._runners[i2];
      const runner = runnerInfo.runner;
      let dt = dtTime;
      const dtToStart = this._time - runnerInfo.start;
      if (dtToStart <= 0) {
        runnersLeft = true;
        continue;
      } else if (dtToStart < dt) {
        dt = dtToStart;
      }
      if (!runner.active())
        continue;
      const finished = runner.step(dt).done;
      if (!finished) {
        runnersLeft = true;
      } else if (runnerInfo.persist !== true) {
        const endTime = runner.duration() - runner.time() + this._time;
        if (endTime + runnerInfo.persist < this._time) {
          runner.unschedule();
          --i2;
          --len;
        }
      }
    }
    if (runnersLeft && !(this._speed < 0 && this._time === 0) || this._runnerIds.length && this._speed < 0 && this._time > 0) {
      this._continue();
    } else {
      this.pause();
      this.fire("finished");
    }
    return this;
  }
};
registerMethods({
  Element: {
    timeline: function(timeline2) {
      if (timeline2 == null) {
        this._timeline = this._timeline || new Timeline();
        return this._timeline;
      } else {
        this._timeline = timeline2;
        return this;
      }
    }
  }
});
var Runner = class extends EventTarget {
  constructor(options) {
    super();
    this.id = Runner.id++;
    options = options == null ? timeline.duration : options;
    options = typeof options === "function" ? new Controller(options) : options;
    this._element = null;
    this._timeline = null;
    this.done = false;
    this._queue = [];
    this._duration = typeof options === "number" && options;
    this._isDeclarative = options instanceof Controller;
    this._stepper = this._isDeclarative ? options : new Ease();
    this._history = {};
    this.enabled = true;
    this._time = 0;
    this._lastTime = 0;
    this._reseted = true;
    this.transforms = new Matrix();
    this.transformId = 1;
    this._haveReversed = false;
    this._reverse = false;
    this._loopsDone = 0;
    this._swing = false;
    this._wait = 0;
    this._times = 1;
    this._frameId = null;
    this._persist = this._isDeclarative ? true : null;
  }
  static sanitise(duration, delay, when) {
    let times = 1;
    let swing = false;
    let wait = 0;
    duration = duration || timeline.duration;
    delay = delay || timeline.delay;
    when = when || "last";
    if (typeof duration === "object" && !(duration instanceof Stepper)) {
      delay = duration.delay || delay;
      when = duration.when || when;
      swing = duration.swing || swing;
      times = duration.times || times;
      wait = duration.wait || wait;
      duration = duration.duration || timeline.duration;
    }
    return {
      duration,
      delay,
      swing,
      times,
      wait,
      when
    };
  }
  active(enabled) {
    if (enabled == null)
      return this.enabled;
    this.enabled = enabled;
    return this;
  }
  /*
  Private Methods
  ===============
  Methods that shouldn't be used externally
  */
  addTransform(transform2, index3) {
    this.transforms.lmultiplyO(transform2);
    return this;
  }
  after(fn) {
    return this.on("finished", fn);
  }
  animate(duration, delay, when) {
    const o2 = Runner.sanitise(duration, delay, when);
    const runner = new Runner(o2.duration);
    if (this._timeline)
      runner.timeline(this._timeline);
    if (this._element)
      runner.element(this._element);
    return runner.loop(o2).schedule(o2.delay, o2.when);
  }
  clearTransform() {
    this.transforms = new Matrix();
    return this;
  }
  // TODO: Keep track of all transformations so that deletion is faster
  clearTransformsFromQueue() {
    if (!this.done || !this._timeline || !this._timeline._runnerIds.includes(this.id)) {
      this._queue = this._queue.filter((item) => {
        return !item.isTransform;
      });
    }
  }
  delay(delay) {
    return this.animate(0, delay);
  }
  duration() {
    return this._times * (this._wait + this._duration) - this._wait;
  }
  during(fn) {
    return this.queue(null, fn);
  }
  ease(fn) {
    this._stepper = new Ease(fn);
    return this;
  }
  /*
  Runner Definitions
  ==================
  These methods help us define the runtime behaviour of the Runner or they
  help us make new runners from the current runner
  */
  element(element2) {
    if (element2 == null)
      return this._element;
    this._element = element2;
    element2._prepareRunner();
    return this;
  }
  finish() {
    return this.step(Infinity);
  }
  loop(times, swing, wait) {
    if (typeof times === "object") {
      swing = times.swing;
      wait = times.wait;
      times = times.times;
    }
    this._times = times || Infinity;
    this._swing = swing || false;
    this._wait = wait || 0;
    if (this._times === true) {
      this._times = Infinity;
    }
    return this;
  }
  loops(p2) {
    const loopDuration = this._duration + this._wait;
    if (p2 == null) {
      const loopsDone = Math.floor(this._time / loopDuration);
      const relativeTime = this._time - loopsDone * loopDuration;
      const position3 = relativeTime / this._duration;
      return Math.min(loopsDone + position3, this._times);
    }
    const whole = Math.floor(p2);
    const partial = p2 % 1;
    const time = loopDuration * whole + this._duration * partial;
    return this.time(time);
  }
  persist(dtOrForever) {
    if (dtOrForever == null)
      return this._persist;
    this._persist = dtOrForever;
    return this;
  }
  position(p2) {
    const x2 = this._time;
    const d = this._duration;
    const w = this._wait;
    const t2 = this._times;
    const s2 = this._swing;
    const r2 = this._reverse;
    let position3;
    if (p2 == null) {
      const f3 = function(x3) {
        const swinging = s2 * Math.floor(x3 % (2 * (w + d)) / (w + d));
        const backwards = swinging && !r2 || !swinging && r2;
        const uncliped = Math.pow(-1, backwards) * (x3 % (w + d)) / d + backwards;
        const clipped = Math.max(Math.min(uncliped, 1), 0);
        return clipped;
      };
      const endTime = t2 * (w + d) - w;
      position3 = x2 <= 0 ? Math.round(f3(1e-5)) : x2 < endTime ? f3(x2) : Math.round(f3(endTime - 1e-5));
      return position3;
    }
    const loopsDone = Math.floor(this.loops());
    const swingForward = s2 && loopsDone % 2 === 0;
    const forwards = swingForward && !r2 || r2 && swingForward;
    position3 = loopsDone + (forwards ? p2 : 1 - p2);
    return this.loops(position3);
  }
  progress(p2) {
    if (p2 == null) {
      return Math.min(1, this._time / this.duration());
    }
    return this.time(p2 * this.duration());
  }
  /*
  Basic Functionality
  ===================
  These methods allow us to attach basic functions to the runner directly
  */
  queue(initFn, runFn, retargetFn, isTransform) {
    this._queue.push({
      initialiser: initFn || noop,
      runner: runFn || noop,
      retarget: retargetFn,
      isTransform,
      initialised: false,
      finished: false
    });
    const timeline2 = this.timeline();
    timeline2 && this.timeline()._continue();
    return this;
  }
  reset() {
    if (this._reseted)
      return this;
    this.time(0);
    this._reseted = true;
    return this;
  }
  reverse(reverse) {
    this._reverse = reverse == null ? !this._reverse : reverse;
    return this;
  }
  schedule(timeline2, delay, when) {
    if (!(timeline2 instanceof Timeline)) {
      when = delay;
      delay = timeline2;
      timeline2 = this.timeline();
    }
    if (!timeline2) {
      throw Error("Runner cannot be scheduled without timeline");
    }
    timeline2.schedule(this, delay, when);
    return this;
  }
  step(dt) {
    if (!this.enabled)
      return this;
    dt = dt == null ? 16 : dt;
    this._time += dt;
    const position3 = this.position();
    const running = this._lastPosition !== position3 && this._time >= 0;
    this._lastPosition = position3;
    const duration = this.duration();
    const justStarted = this._lastTime <= 0 && this._time > 0;
    const justFinished = this._lastTime < duration && this._time >= duration;
    this._lastTime = this._time;
    if (justStarted) {
      this.fire("start", this);
    }
    const declarative = this._isDeclarative;
    this.done = !declarative && !justFinished && this._time >= duration;
    this._reseted = false;
    let converged = false;
    if (running || declarative) {
      this._initialise(running);
      this.transforms = new Matrix();
      converged = this._run(declarative ? dt : position3);
      this.fire("step", this);
    }
    this.done = this.done || converged && declarative;
    if (justFinished) {
      this.fire("finished", this);
    }
    return this;
  }
  /*
  Runner animation methods
  ========================
  Control how the animation plays
  */
  time(time) {
    if (time == null) {
      return this._time;
    }
    const dt = time - this._time;
    this.step(dt);
    return this;
  }
  timeline(timeline2) {
    if (typeof timeline2 === "undefined")
      return this._timeline;
    this._timeline = timeline2;
    return this;
  }
  unschedule() {
    const timeline2 = this.timeline();
    timeline2 && timeline2.unschedule(this);
    return this;
  }
  // Run each initialise function in the runner if required
  _initialise(running) {
    if (!running && !this._isDeclarative)
      return;
    for (let i2 = 0, len = this._queue.length; i2 < len; ++i2) {
      const current = this._queue[i2];
      const needsIt = this._isDeclarative || !current.initialised && running;
      running = !current.finished;
      if (needsIt && running) {
        current.initialiser.call(this);
        current.initialised = true;
      }
    }
  }
  // Save a morpher to the morpher list so that we can retarget it later
  _rememberMorpher(method, morpher) {
    this._history[method] = {
      morpher,
      caller: this._queue[this._queue.length - 1]
    };
    if (this._isDeclarative) {
      const timeline2 = this.timeline();
      timeline2 && timeline2.play();
    }
  }
  // Try to set the target for a morpher if the morpher exists, otherwise
  // Run each run function for the position or dt given
  _run(positionOrDt) {
    let allfinished = true;
    for (let i2 = 0, len = this._queue.length; i2 < len; ++i2) {
      const current = this._queue[i2];
      const converged = current.runner.call(this, positionOrDt);
      current.finished = current.finished || converged === true;
      allfinished = allfinished && current.finished;
    }
    return allfinished;
  }
  // do nothing and return false
  _tryRetarget(method, target, extra) {
    if (this._history[method]) {
      if (!this._history[method].caller.initialised) {
        const index3 = this._queue.indexOf(this._history[method].caller);
        this._queue.splice(index3, 1);
        return false;
      }
      if (this._history[method].caller.retarget) {
        this._history[method].caller.retarget.call(this, target, extra);
      } else {
        this._history[method].morpher.to(target);
      }
      this._history[method].caller.finished = false;
      const timeline2 = this.timeline();
      timeline2 && timeline2.play();
      return true;
    }
    return false;
  }
};
Runner.id = 0;
var FakeRunner = class {
  constructor(transforms2 = new Matrix(), id = -1, done = true) {
    this.transforms = transforms2;
    this.id = id;
    this.done = done;
  }
  clearTransformsFromQueue() {
  }
};
extend([Runner, FakeRunner], {
  mergeWith(runner) {
    return new FakeRunner(runner.transforms.lmultiply(this.transforms), runner.id);
  }
});
var lmultiply = (last, curr) => last.lmultiplyO(curr);
var getRunnerTransform = (runner) => runner.transforms;
function mergeTransforms() {
  const runners = this._transformationRunners.runners;
  const netTransform = runners.map(getRunnerTransform).reduce(lmultiply, new Matrix());
  this.transform(netTransform);
  this._transformationRunners.merge();
  if (this._transformationRunners.length() === 1) {
    this._frameId = null;
  }
}
var RunnerArray = class {
  constructor() {
    this.runners = [];
    this.ids = [];
  }
  add(runner) {
    if (this.runners.includes(runner))
      return;
    const id = runner.id + 1;
    this.runners.push(runner);
    this.ids.push(id);
    return this;
  }
  clearBefore(id) {
    const deleteCnt = this.ids.indexOf(id + 1) || 1;
    this.ids.splice(0, deleteCnt, 0);
    this.runners.splice(0, deleteCnt, new FakeRunner()).forEach((r2) => r2.clearTransformsFromQueue());
    return this;
  }
  edit(id, newRunner) {
    const index3 = this.ids.indexOf(id + 1);
    this.ids.splice(index3, 1, id + 1);
    this.runners.splice(index3, 1, newRunner);
    return this;
  }
  getByID(id) {
    return this.runners[this.ids.indexOf(id + 1)];
  }
  length() {
    return this.ids.length;
  }
  merge() {
    let lastRunner = null;
    for (let i2 = 0; i2 < this.runners.length; ++i2) {
      const runner = this.runners[i2];
      const condition = lastRunner && runner.done && lastRunner.done && (!runner._timeline || !runner._timeline._runnerIds.includes(runner.id)) && (!lastRunner._timeline || !lastRunner._timeline._runnerIds.includes(lastRunner.id));
      if (condition) {
        this.remove(runner.id);
        const newRunner = runner.mergeWith(lastRunner);
        this.edit(lastRunner.id, newRunner);
        lastRunner = newRunner;
        --i2;
      } else {
        lastRunner = runner;
      }
    }
    return this;
  }
  remove(id) {
    const index3 = this.ids.indexOf(id + 1);
    this.ids.splice(index3, 1);
    this.runners.splice(index3, 1);
    return this;
  }
};
registerMethods({
  Element: {
    animate(duration, delay, when) {
      const o2 = Runner.sanitise(duration, delay, when);
      const timeline2 = this.timeline();
      return new Runner(o2.duration).loop(o2).element(this).timeline(timeline2.play()).schedule(o2.delay, o2.when);
    },
    delay(by, when) {
      return this.animate(0, by, when);
    },
    // this function searches for all runners on the element and deletes the ones
    // which run before the current one. This is because absolute transformations
    // overwfrite anything anyway so there is no need to waste time computing
    // other runners
    _clearTransformRunnersBefore(currentRunner) {
      this._transformationRunners.clearBefore(currentRunner.id);
    },
    _currentTransform(current) {
      return this._transformationRunners.runners.filter((runner) => runner.id <= current.id).map(getRunnerTransform).reduce(lmultiply, new Matrix());
    },
    _addRunner(runner) {
      this._transformationRunners.add(runner);
      Animator.cancelImmediate(this._frameId);
      this._frameId = Animator.immediate(mergeTransforms.bind(this));
    },
    _prepareRunner() {
      if (this._frameId == null) {
        this._transformationRunners = new RunnerArray().add(new FakeRunner(new Matrix(this)));
      }
    }
  }
});
var difference = (a2, b) => a2.filter((x2) => !b.includes(x2));
extend(Runner, {
  attr(a2, v2) {
    return this.styleAttr("attr", a2, v2);
  },
  // Add animatable styles
  css(s2, v2) {
    return this.styleAttr("css", s2, v2);
  },
  styleAttr(type, nameOrAttrs, val) {
    if (typeof nameOrAttrs === "string") {
      return this.styleAttr(type, {
        [nameOrAttrs]: val
      });
    }
    let attrs2 = nameOrAttrs;
    if (this._tryRetarget(type, attrs2))
      return this;
    let morpher = new Morphable(this._stepper).to(attrs2);
    let keys = Object.keys(attrs2);
    this.queue(function() {
      morpher = morpher.from(this.element()[type](keys));
    }, function(pos) {
      this.element()[type](morpher.at(pos).valueOf());
      return morpher.done();
    }, function(newToAttrs) {
      const newKeys = Object.keys(newToAttrs);
      const differences = difference(newKeys, keys);
      if (differences.length) {
        const addedFromAttrs = this.element()[type](differences);
        const oldFromAttrs = new ObjectBag(morpher.from()).valueOf();
        Object.assign(oldFromAttrs, addedFromAttrs);
        morpher.from(oldFromAttrs);
      }
      const oldToAttrs = new ObjectBag(morpher.to()).valueOf();
      Object.assign(oldToAttrs, newToAttrs);
      morpher.to(oldToAttrs);
      keys = newKeys;
      attrs2 = newToAttrs;
    });
    this._rememberMorpher(type, morpher);
    return this;
  },
  zoom(level, point4) {
    if (this._tryRetarget("zoom", level, point4))
      return this;
    let morpher = new Morphable(this._stepper).to(new SVGNumber(level));
    this.queue(function() {
      morpher = morpher.from(this.element().zoom());
    }, function(pos) {
      this.element().zoom(morpher.at(pos), point4);
      return morpher.done();
    }, function(newLevel, newPoint) {
      point4 = newPoint;
      morpher.to(newLevel);
    });
    this._rememberMorpher("zoom", morpher);
    return this;
  },
  /**
   ** absolute transformations
   **/
  //
  // M v -----|-----(D M v = F v)------|----->  T v
  //
  // 1. define the final state (T) and decompose it (once)
  //    t = [tx, ty, the, lam, sy, sx]
  // 2. on every frame: pull the current state of all previous transforms
  //    (M - m can change)
  //   and then write this as m = [tx0, ty0, the0, lam0, sy0, sx0]
  // 3. Find the interpolated matrix F(pos) = m + pos * (t - m)
  //   - Note F(0) = M
  //   - Note F(1) = T
  // 4. Now you get the delta matrix as a result: D = F * inv(M)
  transform(transforms2, relative, affine) {
    relative = transforms2.relative || relative;
    if (this._isDeclarative && !relative && this._tryRetarget("transform", transforms2)) {
      return this;
    }
    const isMatrix = Matrix.isMatrixLike(transforms2);
    affine = transforms2.affine != null ? transforms2.affine : affine != null ? affine : !isMatrix;
    const morpher = new Morphable(this._stepper).type(affine ? TransformBag : Matrix);
    let origin;
    let element2;
    let current;
    let currentAngle;
    let startTransform;
    function setup() {
      element2 = element2 || this.element();
      origin = origin || getOrigin(transforms2, element2);
      startTransform = new Matrix(relative ? void 0 : element2);
      element2._addRunner(this);
      if (!relative) {
        element2._clearTransformRunnersBefore(this);
      }
    }
    function run(pos) {
      if (!relative)
        this.clearTransform();
      const {
        x: x2,
        y: y3
      } = new Point(origin).transform(element2._currentTransform(this));
      let target = new Matrix({
        ...transforms2,
        origin: [x2, y3]
      });
      let start = this._isDeclarative && current ? current : startTransform;
      if (affine) {
        target = target.decompose(x2, y3);
        start = start.decompose(x2, y3);
        const rTarget = target.rotate;
        const rCurrent = start.rotate;
        const possibilities = [rTarget - 360, rTarget, rTarget + 360];
        const distances = possibilities.map((a2) => Math.abs(a2 - rCurrent));
        const shortest = Math.min(...distances);
        const index3 = distances.indexOf(shortest);
        target.rotate = possibilities[index3];
      }
      if (relative) {
        if (!isMatrix) {
          target.rotate = transforms2.rotate || 0;
        }
        if (this._isDeclarative && currentAngle) {
          start.rotate = currentAngle;
        }
      }
      morpher.from(start);
      morpher.to(target);
      const affineParameters = morpher.at(pos);
      currentAngle = affineParameters.rotate;
      current = new Matrix(affineParameters);
      this.addTransform(current);
      element2._addRunner(this);
      return morpher.done();
    }
    function retarget(newTransforms) {
      if ((newTransforms.origin || "center").toString() !== (transforms2.origin || "center").toString()) {
        origin = getOrigin(newTransforms, element2);
      }
      transforms2 = {
        ...newTransforms,
        origin
      };
    }
    this.queue(setup, run, retarget, true);
    this._isDeclarative && this._rememberMorpher("transform", morpher);
    return this;
  },
  // Animatable x-axis
  x(x2, relative) {
    return this._queueNumber("x", x2);
  },
  // Animatable y-axis
  y(y3) {
    return this._queueNumber("y", y3);
  },
  dx(x2 = 0) {
    return this._queueNumberDelta("x", x2);
  },
  dy(y3 = 0) {
    return this._queueNumberDelta("y", y3);
  },
  dmove(x2, y3) {
    return this.dx(x2).dy(y3);
  },
  _queueNumberDelta(method, to2) {
    to2 = new SVGNumber(to2);
    if (this._tryRetarget(method, to2))
      return this;
    const morpher = new Morphable(this._stepper).to(to2);
    let from2 = null;
    this.queue(function() {
      from2 = this.element()[method]();
      morpher.from(from2);
      morpher.to(from2 + to2);
    }, function(pos) {
      this.element()[method](morpher.at(pos));
      return morpher.done();
    }, function(newTo) {
      morpher.to(from2 + new SVGNumber(newTo));
    });
    this._rememberMorpher(method, morpher);
    return this;
  },
  _queueObject(method, to2) {
    if (this._tryRetarget(method, to2))
      return this;
    const morpher = new Morphable(this._stepper).to(to2);
    this.queue(function() {
      morpher.from(this.element()[method]());
    }, function(pos) {
      this.element()[method](morpher.at(pos));
      return morpher.done();
    });
    this._rememberMorpher(method, morpher);
    return this;
  },
  _queueNumber(method, value) {
    return this._queueObject(method, new SVGNumber(value));
  },
  // Animatable center x-axis
  cx(x2) {
    return this._queueNumber("cx", x2);
  },
  // Animatable center y-axis
  cy(y3) {
    return this._queueNumber("cy", y3);
  },
  // Add animatable move
  move(x2, y3) {
    return this.x(x2).y(y3);
  },
  // Add animatable center
  center(x2, y3) {
    return this.cx(x2).cy(y3);
  },
  // Add animatable size
  size(width2, height2) {
    let box;
    if (!width2 || !height2) {
      box = this._element.bbox();
    }
    if (!width2) {
      width2 = box.width / box.height * height2;
    }
    if (!height2) {
      height2 = box.height / box.width * width2;
    }
    return this.width(width2).height(height2);
  },
  // Add animatable width
  width(width2) {
    return this._queueNumber("width", width2);
  },
  // Add animatable height
  height(height2) {
    return this._queueNumber("height", height2);
  },
  // Add animatable plot
  plot(a2, b, c3, d) {
    if (arguments.length === 4) {
      return this.plot([a2, b, c3, d]);
    }
    if (this._tryRetarget("plot", a2))
      return this;
    const morpher = new Morphable(this._stepper).type(this._element.MorphArray).to(a2);
    this.queue(function() {
      morpher.from(this._element.array());
    }, function(pos) {
      this._element.plot(morpher.at(pos));
      return morpher.done();
    });
    this._rememberMorpher("plot", morpher);
    return this;
  },
  // Add leading method
  leading(value) {
    return this._queueNumber("leading", value);
  },
  // Add animatable viewbox
  viewbox(x2, y3, width2, height2) {
    return this._queueObject("viewbox", new Box(x2, y3, width2, height2));
  },
  update(o2) {
    if (typeof o2 !== "object") {
      return this.update({
        offset: arguments[0],
        color: arguments[1],
        opacity: arguments[2]
      });
    }
    if (o2.opacity != null)
      this.attr("stop-opacity", o2.opacity);
    if (o2.color != null)
      this.attr("stop-color", o2.color);
    if (o2.offset != null)
      this.attr("offset", o2.offset);
    return this;
  }
});
extend(Runner, {
  rx,
  ry,
  from,
  to
});
register(Runner, "Runner");
var Svg = class extends Container {
  constructor(node3, attrs2 = node3) {
    super(nodeOrNew("svg", node3), attrs2);
    this.namespace();
  }
  // Creates and returns defs element
  defs() {
    if (!this.isRoot())
      return this.root().defs();
    return adopt(this.node.querySelector("defs")) || this.put(new Defs());
  }
  isRoot() {
    return !this.node.parentNode || !(this.node.parentNode instanceof globals.window.SVGElement) && this.node.parentNode.nodeName !== "#document-fragment";
  }
  // Add namespaces
  namespace() {
    if (!this.isRoot())
      return this.root().namespace();
    return this.attr({
      xmlns: svg,
      version: "1.1"
    }).attr("xmlns:xlink", xlink, xmlns).attr("xmlns:svgjs", svgjs, xmlns);
  }
  removeNamespace() {
    return this.attr({
      xmlns: null,
      version: null
    }).attr("xmlns:xlink", null, xmlns).attr("xmlns:svgjs", null, xmlns);
  }
  // Check if this is a root svg
  // If not, call root() from this element
  root() {
    if (this.isRoot())
      return this;
    return super.root();
  }
};
registerMethods({
  Container: {
    // Create nested svg document
    nested: wrapWithAttrCheck(function() {
      return this.put(new Svg());
    })
  }
});
register(Svg, "Svg", true);
var Symbol2 = class extends Container {
  // Initialize node
  constructor(node3, attrs2 = node3) {
    super(nodeOrNew("symbol", node3), attrs2);
  }
};
registerMethods({
  Container: {
    symbol: wrapWithAttrCheck(function() {
      return this.put(new Symbol2());
    })
  }
});
register(Symbol2, "Symbol");
function plain(text4) {
  if (this._build === false) {
    this.clear();
  }
  this.node.appendChild(globals.document.createTextNode(text4));
  return this;
}
function length() {
  return this.node.getComputedTextLength();
}
function x$1(x2, box = this.bbox()) {
  if (x2 == null) {
    return box.x;
  }
  return this.attr("x", this.attr("x") + x2 - box.x);
}
function y$1(y3, box = this.bbox()) {
  if (y3 == null) {
    return box.y;
  }
  return this.attr("y", this.attr("y") + y3 - box.y);
}
function move$1(x2, y3, box = this.bbox()) {
  return this.x(x2, box).y(y3, box);
}
function cx(x2, box = this.bbox()) {
  if (x2 == null) {
    return box.cx;
  }
  return this.attr("x", this.attr("x") + x2 - box.cx);
}
function cy(y3, box = this.bbox()) {
  if (y3 == null) {
    return box.cy;
  }
  return this.attr("y", this.attr("y") + y3 - box.cy);
}
function center(x2, y3, box = this.bbox()) {
  return this.cx(x2, box).cy(y3, box);
}
function ax(x2) {
  return this.attr("x", x2);
}
function ay(y3) {
  return this.attr("y", y3);
}
function amove(x2, y3) {
  return this.ax(x2).ay(y3);
}
function build(build2) {
  this._build = !!build2;
  return this;
}
var textable = {
  __proto__: null,
  plain,
  length,
  x: x$1,
  y: y$1,
  move: move$1,
  cx,
  cy,
  center,
  ax,
  ay,
  amove,
  build
};
var Text2 = class extends Shape {
  // Initialize node
  constructor(node3, attrs2 = node3) {
    super(nodeOrNew("text", node3), attrs2);
    this.dom.leading = new SVGNumber(1.3);
    this._rebuild = true;
    this._build = false;
  }
  // Set / get leading
  leading(value) {
    if (value == null) {
      return this.dom.leading;
    }
    this.dom.leading = new SVGNumber(value);
    return this.rebuild();
  }
  // Rebuild appearance type
  rebuild(rebuild) {
    if (typeof rebuild === "boolean") {
      this._rebuild = rebuild;
    }
    if (this._rebuild) {
      const self2 = this;
      let blankLineOffset = 0;
      const leading = this.dom.leading;
      this.each(function(i2) {
        const fontSize = globals.window.getComputedStyle(this.node).getPropertyValue("font-size");
        const dy2 = leading * new SVGNumber(fontSize);
        if (this.dom.newLined) {
          this.attr("x", self2.attr("x"));
          if (this.text() === "\n") {
            blankLineOffset += dy2;
          } else {
            this.attr("dy", i2 ? dy2 + blankLineOffset : 0);
            blankLineOffset = 0;
          }
        }
      });
      this.fire("rebuild");
    }
    return this;
  }
  // overwrite method from parent to set data properly
  setData(o2) {
    this.dom = o2;
    this.dom.leading = new SVGNumber(o2.leading || 1.3);
    return this;
  }
  // Set the text content
  text(text4) {
    if (text4 === void 0) {
      const children = this.node.childNodes;
      let firstLine = 0;
      text4 = "";
      for (let i2 = 0, len = children.length; i2 < len; ++i2) {
        if (children[i2].nodeName === "textPath") {
          if (i2 === 0)
            firstLine = 1;
          continue;
        }
        if (i2 !== firstLine && children[i2].nodeType !== 3 && adopt(children[i2]).dom.newLined === true) {
          text4 += "\n";
        }
        text4 += children[i2].textContent;
      }
      return text4;
    }
    this.clear().build(true);
    if (typeof text4 === "function") {
      text4.call(this, this);
    } else {
      text4 = (text4 + "").split("\n");
      for (let j = 0, jl = text4.length; j < jl; j++) {
        this.newLine(text4[j]);
      }
    }
    return this.build(false).rebuild();
  }
};
extend(Text2, textable);
registerMethods({
  Container: {
    // Create text element
    text: wrapWithAttrCheck(function(text4 = "") {
      return this.put(new Text2()).text(text4);
    }),
    // Create plain text element
    plain: wrapWithAttrCheck(function(text4 = "") {
      return this.put(new Text2()).plain(text4);
    })
  }
});
register(Text2, "Text");
var Tspan = class extends Shape {
  // Initialize node
  constructor(node3, attrs2 = node3) {
    super(nodeOrNew("tspan", node3), attrs2);
    this._build = false;
  }
  // Shortcut dx
  dx(dx2) {
    return this.attr("dx", dx2);
  }
  // Shortcut dy
  dy(dy2) {
    return this.attr("dy", dy2);
  }
  // Create new line
  newLine() {
    this.dom.newLined = true;
    const text4 = this.parent();
    if (!(text4 instanceof Text2)) {
      return this;
    }
    const i2 = text4.index(this);
    const fontSize = globals.window.getComputedStyle(this.node).getPropertyValue("font-size");
    const dy2 = text4.dom.leading * new SVGNumber(fontSize);
    return this.dy(i2 ? dy2 : 0).attr("x", text4.x());
  }
  // Set text content
  text(text4) {
    if (text4 == null)
      return this.node.textContent + (this.dom.newLined ? "\n" : "");
    if (typeof text4 === "function") {
      this.clear().build(true);
      text4.call(this, this);
      this.build(false);
    } else {
      this.plain(text4);
    }
    return this;
  }
};
extend(Tspan, textable);
registerMethods({
  Tspan: {
    tspan: wrapWithAttrCheck(function(text4 = "") {
      const tspan = new Tspan();
      if (!this._build) {
        this.clear();
      }
      return this.put(tspan).text(text4);
    })
  },
  Text: {
    newLine: function(text4 = "") {
      return this.tspan(text4).newLine();
    }
  }
});
register(Tspan, "Tspan");
var Circle = class extends Shape {
  constructor(node3, attrs2 = node3) {
    super(nodeOrNew("circle", node3), attrs2);
  }
  radius(r2) {
    return this.attr("r", r2);
  }
  // Radius x value
  rx(rx2) {
    return this.attr("r", rx2);
  }
  // Alias radius x value
  ry(ry2) {
    return this.rx(ry2);
  }
  size(size2) {
    return this.radius(new SVGNumber(size2).divide(2));
  }
};
extend(Circle, {
  x: x$3,
  y: y$3,
  cx: cx$1,
  cy: cy$1,
  width: width$2,
  height: height$2
});
registerMethods({
  Container: {
    // Create circle element
    circle: wrapWithAttrCheck(function(size2 = 0) {
      return this.put(new Circle()).size(size2).move(0, 0);
    })
  }
});
register(Circle, "Circle");
var ClipPath = class extends Container {
  constructor(node3, attrs2 = node3) {
    super(nodeOrNew("clipPath", node3), attrs2);
  }
  // Unclip all clipped elements and remove itself
  remove() {
    this.targets().forEach(function(el2) {
      el2.unclip();
    });
    return super.remove();
  }
  targets() {
    return baseFind('svg [clip-path*="' + this.id() + '"]');
  }
};
registerMethods({
  Container: {
    // Create clipping element
    clip: wrapWithAttrCheck(function() {
      return this.defs().put(new ClipPath());
    })
  },
  Element: {
    // Distribute clipPath to svg element
    clipper() {
      return this.reference("clip-path");
    },
    clipWith(element2) {
      const clipper = element2 instanceof ClipPath ? element2 : this.parent().clip().add(element2);
      return this.attr("clip-path", 'url("#' + clipper.id() + '")');
    },
    // Unclip element
    unclip() {
      return this.attr("clip-path", null);
    }
  }
});
register(ClipPath, "ClipPath");
var ForeignObject = class extends Element {
  constructor(node3, attrs2 = node3) {
    super(nodeOrNew("foreignObject", node3), attrs2);
  }
};
registerMethods({
  Container: {
    foreignObject: wrapWithAttrCheck(function(width2, height2) {
      return this.put(new ForeignObject()).size(width2, height2);
    })
  }
});
register(ForeignObject, "ForeignObject");
function dmove(dx2, dy2) {
  this.children().forEach((child, i2) => {
    let bbox2;
    try {
      bbox2 = child.bbox();
    } catch (e2) {
      return;
    }
    const m3 = new Matrix(child);
    const matrix = m3.translate(dx2, dy2).transform(m3.inverse());
    const p2 = new Point(bbox2.x, bbox2.y).transform(matrix);
    child.move(p2.x, p2.y);
  });
  return this;
}
function dx(dx2) {
  return this.dmove(dx2, 0);
}
function dy(dy2) {
  return this.dmove(0, dy2);
}
function height(height2, box = this.bbox()) {
  if (height2 == null)
    return box.height;
  return this.size(box.width, height2, box);
}
function move(x2 = 0, y3 = 0, box = this.bbox()) {
  const dx2 = x2 - box.x;
  const dy2 = y3 - box.y;
  return this.dmove(dx2, dy2);
}
function size(width2, height2, box = this.bbox()) {
  const p2 = proportionalSize(this, width2, height2, box);
  const scaleX = p2.width / box.width;
  const scaleY = p2.height / box.height;
  this.children().forEach((child, i2) => {
    const o2 = new Point(box).transform(new Matrix(child).inverse());
    child.scale(scaleX, scaleY, o2.x, o2.y);
  });
  return this;
}
function width(width2, box = this.bbox()) {
  if (width2 == null)
    return box.width;
  return this.size(width2, box.height, box);
}
function x(x2, box = this.bbox()) {
  if (x2 == null)
    return box.x;
  return this.move(x2, box.y, box);
}
function y(y3, box = this.bbox()) {
  if (y3 == null)
    return box.y;
  return this.move(box.x, y3, box);
}
var containerGeometry = {
  __proto__: null,
  dmove,
  dx,
  dy,
  height,
  move,
  size,
  width,
  x,
  y
};
var G = class extends Container {
  constructor(node3, attrs2 = node3) {
    super(nodeOrNew("g", node3), attrs2);
  }
};
extend(G, containerGeometry);
registerMethods({
  Container: {
    // Create a group element
    group: wrapWithAttrCheck(function() {
      return this.put(new G());
    })
  }
});
register(G, "G");
var A = class extends Container {
  constructor(node3, attrs2 = node3) {
    super(nodeOrNew("a", node3), attrs2);
  }
  // Link target attribute
  target(target) {
    return this.attr("target", target);
  }
  // Link url
  to(url) {
    return this.attr("href", url, xlink);
  }
};
extend(A, containerGeometry);
registerMethods({
  Container: {
    // Create a hyperlink element
    link: wrapWithAttrCheck(function(url) {
      return this.put(new A()).to(url);
    })
  },
  Element: {
    unlink() {
      const link = this.linker();
      if (!link)
        return this;
      const parent = link.parent();
      if (!parent) {
        return this.remove();
      }
      const index3 = parent.index(link);
      parent.add(this, index3);
      link.remove();
      return this;
    },
    linkTo(url) {
      let link = this.linker();
      if (!link) {
        link = new A();
        this.wrap(link);
      }
      if (typeof url === "function") {
        url.call(link, link);
      } else {
        link.to(url);
      }
      return this;
    },
    linker() {
      const link = this.parent();
      if (link && link.node.nodeName.toLowerCase() === "a") {
        return link;
      }
      return null;
    }
  }
});
register(A, "A");
var Mask = class extends Container {
  // Initialize node
  constructor(node3, attrs2 = node3) {
    super(nodeOrNew("mask", node3), attrs2);
  }
  // Unmask all masked elements and remove itself
  remove() {
    this.targets().forEach(function(el2) {
      el2.unmask();
    });
    return super.remove();
  }
  targets() {
    return baseFind('svg [mask*="' + this.id() + '"]');
  }
};
registerMethods({
  Container: {
    mask: wrapWithAttrCheck(function() {
      return this.defs().put(new Mask());
    })
  },
  Element: {
    // Distribute mask to svg element
    masker() {
      return this.reference("mask");
    },
    maskWith(element2) {
      const masker = element2 instanceof Mask ? element2 : this.parent().mask().add(element2);
      return this.attr("mask", 'url("#' + masker.id() + '")');
    },
    // Unmask element
    unmask() {
      return this.attr("mask", null);
    }
  }
});
register(Mask, "Mask");
var Stop = class extends Element {
  constructor(node3, attrs2 = node3) {
    super(nodeOrNew("stop", node3), attrs2);
  }
  // add color stops
  update(o2) {
    if (typeof o2 === "number" || o2 instanceof SVGNumber) {
      o2 = {
        offset: arguments[0],
        color: arguments[1],
        opacity: arguments[2]
      };
    }
    if (o2.opacity != null)
      this.attr("stop-opacity", o2.opacity);
    if (o2.color != null)
      this.attr("stop-color", o2.color);
    if (o2.offset != null)
      this.attr("offset", new SVGNumber(o2.offset));
    return this;
  }
};
registerMethods({
  Gradient: {
    // Add a color stop
    stop: function(offset, color, opacity) {
      return this.put(new Stop()).update(offset, color, opacity);
    }
  }
});
register(Stop, "Stop");
function cssRule(selector, rule) {
  if (!selector)
    return "";
  if (!rule)
    return selector;
  let ret = selector + "{";
  for (const i2 in rule) {
    ret += unCamelCase(i2) + ":" + rule[i2] + ";";
  }
  ret += "}";
  return ret;
}
var Style2 = class extends Element {
  constructor(node3, attrs2 = node3) {
    super(nodeOrNew("style", node3), attrs2);
  }
  addText(w = "") {
    this.node.textContent += w;
    return this;
  }
  font(name, src, params = {}) {
    return this.rule("@font-face", {
      fontFamily: name,
      src,
      ...params
    });
  }
  rule(selector, obj) {
    return this.addText(cssRule(selector, obj));
  }
};
registerMethods("Dom", {
  style(selector, obj) {
    return this.put(new Style2()).rule(selector, obj);
  },
  fontface(name, src, params) {
    return this.put(new Style2()).font(name, src, params);
  }
});
register(Style2, "Style");
var TextPath = class extends Text2 {
  // Initialize node
  constructor(node3, attrs2 = node3) {
    super(nodeOrNew("textPath", node3), attrs2);
  }
  // return the array of the path track element
  array() {
    const track = this.track();
    return track ? track.array() : null;
  }
  // Plot path if any
  plot(d) {
    const track = this.track();
    let pathArray = null;
    if (track) {
      pathArray = track.plot(d);
    }
    return d == null ? pathArray : this;
  }
  // Get the path element
  track() {
    return this.reference("href");
  }
};
registerMethods({
  Container: {
    textPath: wrapWithAttrCheck(function(text4, path2) {
      if (!(text4 instanceof Text2)) {
        text4 = this.text(text4);
      }
      return text4.path(path2);
    })
  },
  Text: {
    // Create path for text to run on
    path: wrapWithAttrCheck(function(track, importNodes = true) {
      const textPath = new TextPath();
      if (!(track instanceof Path)) {
        track = this.defs().path(track);
      }
      textPath.attr("href", "#" + track, xlink);
      let node3;
      if (importNodes) {
        while (node3 = this.node.firstChild) {
          textPath.node.appendChild(node3);
        }
      }
      return this.put(textPath);
    }),
    // Get the textPath children
    textPath() {
      return this.findOne("textPath");
    }
  },
  Path: {
    // creates a textPath from this path
    text: wrapWithAttrCheck(function(text4) {
      if (!(text4 instanceof Text2)) {
        text4 = new Text2().addTo(this.parent()).text(text4);
      }
      return text4.path(this);
    }),
    targets() {
      return baseFind("svg textPath").filter((node3) => {
        return (node3.attr("href") || "").includes(this.id());
      });
    }
  }
});
TextPath.prototype.MorphArray = PathArray;
register(TextPath, "TextPath");
var Use = class extends Shape {
  constructor(node3, attrs2 = node3) {
    super(nodeOrNew("use", node3), attrs2);
  }
  // Use element as a reference
  use(element2, file) {
    return this.attr("href", (file || "") + "#" + element2, xlink);
  }
};
registerMethods({
  Container: {
    // Create a use element
    use: wrapWithAttrCheck(function(element2, file) {
      return this.put(new Use()).use(element2, file);
    })
  }
});
register(Use, "Use");
var SVG = makeInstance;
extend([Svg, Symbol2, Image2, Pattern, Marker], getMethodsFor("viewbox"));
extend([Line, Polyline, Polygon, Path], getMethodsFor("marker"));
extend(Text2, getMethodsFor("Text"));
extend(Path, getMethodsFor("Path"));
extend(Defs, getMethodsFor("Defs"));
extend([Text2, Tspan], getMethodsFor("Tspan"));
extend([Rect, Ellipse, Gradient, Runner], getMethodsFor("radius"));
extend(EventTarget, getMethodsFor("EventTarget"));
extend(Dom, getMethodsFor("Dom"));
extend(Element, getMethodsFor("Element"));
extend(Shape, getMethodsFor("Shape"));
extend([Container, Fragment], getMethodsFor("Container"));
extend(Gradient, getMethodsFor("Gradient"));
extend(Runner, getMethodsFor("Runner"));
List.extend(getMethodNames());
registerMorphableType([SVGNumber, Color, Box, Matrix, SVGArray, PointArray, PathArray, Point]);
makeMorphable();

// ../simple-mind-map/src/core/render/node/Shape.js
var Shape2 = class {
  constructor(node3) {
    this.node = node3;
  }
  //  形状需要的padding
  getShapePadding(width2, height2, paddingX, paddingY) {
    const shape = this.node.getShape();
    const defaultPaddingX = 15;
    const defaultPaddingY = 5;
    const actWidth = width2 + paddingX * 2;
    const actHeight = height2 + paddingY * 2;
    const actOffset = Math.abs(actWidth - actHeight);
    switch (shape) {
      case CONSTANTS.SHAPE.ROUNDED_RECTANGLE:
        return {
          paddingX: height2 > width2 ? (height2 - width2) / 2 : 0,
          paddingY: 0
        };
      case CONSTANTS.SHAPE.DIAMOND:
        return {
          paddingX: width2 / 2,
          paddingY: height2 / 2
        };
      case CONSTANTS.SHAPE.PARALLELOGRAM:
        return {
          paddingX: paddingX <= 0 ? defaultPaddingX : 0,
          paddingY: 0
        };
      case CONSTANTS.SHAPE.OUTER_TRIANGULAR_RECTANGLE:
        return {
          paddingX: paddingX <= 0 ? defaultPaddingX : 0,
          paddingY: 0
        };
      case CONSTANTS.SHAPE.INNER_TRIANGULAR_RECTANGLE:
        return {
          paddingX: paddingX <= 0 ? defaultPaddingX : 0,
          paddingY: 0
        };
      case CONSTANTS.SHAPE.ELLIPSE:
        return {
          paddingX: paddingX <= 0 ? defaultPaddingX : 0,
          paddingY: paddingY <= 0 ? defaultPaddingY : 0
        };
      case CONSTANTS.SHAPE.CIRCLE:
        return {
          paddingX: actHeight > actWidth ? actOffset / 2 : 0,
          paddingY: actHeight < actWidth ? actOffset / 2 : 0
        };
      default:
        return {
          paddingX: 0,
          paddingY: 0
        };
    }
  }
  //  创建形状节点
  createShape() {
    const shape = this.node.getShape();
    let node3 = null;
    if (shape === CONSTANTS.SHAPE.RECTANGLE) {
      node3 = this.createRect();
    } else if (shape === CONSTANTS.SHAPE.DIAMOND) {
      node3 = this.createDiamond();
    } else if (shape === CONSTANTS.SHAPE.PARALLELOGRAM) {
      node3 = this.createParallelogram();
    } else if (shape === CONSTANTS.SHAPE.ROUNDED_RECTANGLE) {
      node3 = this.createRoundedRectangle();
    } else if (shape === CONSTANTS.SHAPE.OCTAGONAL_RECTANGLE) {
      node3 = this.createOctagonalRectangle();
    } else if (shape === CONSTANTS.SHAPE.OUTER_TRIANGULAR_RECTANGLE) {
      node3 = this.createOuterTriangularRectangle();
    } else if (shape === CONSTANTS.SHAPE.INNER_TRIANGULAR_RECTANGLE) {
      node3 = this.createInnerTriangularRectangle();
    } else if (shape === CONSTANTS.SHAPE.ELLIPSE) {
      node3 = this.createEllipse();
    } else if (shape === CONSTANTS.SHAPE.CIRCLE) {
      node3 = this.createCircle();
    }
    return node3;
  }
  // 获取节点减去节点边框宽度、hover节点边框宽度后的尺寸
  getNodeSize() {
    const borderWidth = this.node.getBorderWidth();
    let { width: width2, height: height2 } = this.node;
    width2 -= borderWidth;
    height2 -= borderWidth;
    return {
      width: width2,
      height: height2
    };
  }
  // 创建矩形
  createRect() {
    let { width: width2, height: height2 } = this.getNodeSize();
    let borderRadius = this.node.style.merge("borderRadius");
    return new Path().plot(`
      M${borderRadius},0
      L${width2 - borderRadius},0
      C${width2 - borderRadius},0 ${width2},${0} ${width2},${borderRadius}
      L${width2},${height2 - borderRadius}
      C${width2},${height2 - borderRadius} ${width2},${height2} ${width2 - borderRadius},${height2}
      L${borderRadius},${height2}
      C${borderRadius},${height2} ${0},${height2} ${0},${height2 - borderRadius}
      L${0},${borderRadius}
      C${0},${borderRadius} ${0},${0} ${borderRadius},${0}
      Z
    `);
  }
  //  创建菱形
  createDiamond() {
    let { width: width2, height: height2 } = this.getNodeSize();
    let halfWidth = width2 / 2;
    let halfHeight = height2 / 2;
    let topX = halfWidth;
    let topY = 0;
    let rightX = width2;
    let rightY = halfHeight;
    let bottomX = halfWidth;
    let bottomY = height2;
    let leftX = 0;
    let leftY = halfHeight;
    return new Polygon().plot([
      [topX, topY],
      [rightX, rightY],
      [bottomX, bottomY],
      [leftX, leftY]
    ]);
  }
  //  创建平行四边形
  createParallelogram() {
    let { paddingX } = this.node.getPaddingVale();
    paddingX = paddingX || this.node.shapePadding.paddingX;
    let { width: width2, height: height2 } = this.getNodeSize();
    return new Polygon().plot([
      [paddingX, 0],
      [width2, 0],
      [width2 - paddingX, height2],
      [0, height2]
    ]);
  }
  //  创建圆角矩形
  createRoundedRectangle() {
    let { width: width2, height: height2 } = this.getNodeSize();
    let halfHeight = height2 / 2;
    return new Path().plot(`
      M${halfHeight},0
      L${width2 - halfHeight},0
      A${height2 / 2},${height2 / 2} 0 0,1 ${width2 - halfHeight},${height2} 
      L${halfHeight},${height2}
      A${height2 / 2},${height2 / 2} 0 0,1 ${halfHeight},${0}
    `);
  }
  //  创建八角矩形
  createOctagonalRectangle() {
    let w = 5;
    let { width: width2, height: height2 } = this.getNodeSize();
    return new Polygon().plot([
      [0, w],
      [w, 0],
      [width2 - w, 0],
      [width2, w],
      [width2, height2 - w],
      [width2 - w, height2],
      [w, height2],
      [0, height2 - w]
    ]);
  }
  //  创建外三角矩形
  createOuterTriangularRectangle() {
    let { paddingX } = this.node.getPaddingVale();
    paddingX = paddingX || this.node.shapePadding.paddingX;
    let { width: width2, height: height2 } = this.getNodeSize();
    return new Polygon().plot([
      [paddingX, 0],
      [width2 - paddingX, 0],
      [width2, height2 / 2],
      [width2 - paddingX, height2],
      [paddingX, height2],
      [0, height2 / 2]
    ]);
  }
  //  创建内三角矩形
  createInnerTriangularRectangle() {
    let { paddingX } = this.node.getPaddingVale();
    paddingX = paddingX || this.node.shapePadding.paddingX;
    let { width: width2, height: height2 } = this.getNodeSize();
    return new Polygon().plot([
      [0, 0],
      [width2, 0],
      [width2 - paddingX / 2, height2 / 2],
      [width2, height2],
      [0, height2],
      [paddingX / 2, height2 / 2]
    ]);
  }
  //  创建椭圆
  createEllipse() {
    let { width: width2, height: height2 } = this.getNodeSize();
    let halfWidth = width2 / 2;
    let halfHeight = height2 / 2;
    return new Path().plot(`
      M${halfWidth},0
      A${halfWidth},${halfHeight} 0 0,1 ${halfWidth},${height2} 
      M${halfWidth},${height2} 
      A${halfWidth},${halfHeight} 0 0,1 ${halfWidth},${0} 
    `);
  }
  //  创建圆
  createCircle() {
    let { width: width2, height: height2 } = this.getNodeSize();
    let halfWidth = width2 / 2;
    let halfHeight = height2 / 2;
    return new Path().plot(`
      M${halfWidth},0
      A${halfWidth},${halfHeight} 0 0,1 ${halfWidth},${height2} 
      M${halfWidth},${height2} 
      A${halfWidth},${halfHeight} 0 0,1 ${halfWidth},${0} 
    `);
  }
};
var shapeList = [
  CONSTANTS.SHAPE.RECTANGLE,
  CONSTANTS.SHAPE.DIAMOND,
  CONSTANTS.SHAPE.PARALLELOGRAM,
  CONSTANTS.SHAPE.ROUNDED_RECTANGLE,
  CONSTANTS.SHAPE.OCTAGONAL_RECTANGLE,
  CONSTANTS.SHAPE.OUTER_TRIANGULAR_RECTANGLE,
  CONSTANTS.SHAPE.INNER_TRIANGULAR_RECTANGLE,
  CONSTANTS.SHAPE.ELLIPSE,
  CONSTANTS.SHAPE.CIRCLE
];

// ../simple-mind-map/src/core/render/node/nodeGeneralization.js
function formatGetGeneralization() {
  const data2 = this.getData("generalization");
  return Array.isArray(data2) ? data2 : data2 ? [data2] : [];
}
function checkHasGeneralization() {
  return this.formatGetGeneralization().length > 0;
}
function checkHasSelfGeneralization() {
  const list2 = this.formatGetGeneralization();
  return !!list2.find((item) => {
    return !item.range || item.range.length <= 0;
  });
}
function getGeneralizationNodeIndex(node3) {
  return this._generalizationList.findIndex((item) => {
    return item.generalizationNode.uid === node3.uid;
  });
}
function createGeneralizationNode() {
  if (this.isGeneralization || !this.checkHasGeneralization()) {
    return;
  }
  let maxWidth = 0;
  let maxHeight = 0;
  const list2 = this.formatGetGeneralization();
  list2.forEach((item, index3) => {
    let cur = this._generalizationList[index3];
    if (!cur) {
      cur = this._generalizationList[index3] = {};
    }
    cur.node = this;
    cur.range = item.range;
    if (!cur.generalizationLine) {
      cur.generalizationLine = this.lineDraw.path();
    }
    if (!cur.generalizationNode) {
      cur.generalizationNode = new Node_default({
        data: {
          data: item
        },
        uid: createUid(),
        renderer: this.renderer,
        mindMap: this.mindMap,
        isGeneralization: true
      });
    }
    cur.generalizationNode.generalizationBelongNode = this;
    if (cur.generalizationNode.width > maxWidth)
      maxWidth = cur.generalizationNode.width;
    if (cur.generalizationNode.height > maxHeight)
      maxHeight = cur.generalizationNode.height;
    if (item.isActive) {
      this.renderer.addNodeToActiveList(cur.generalizationNode);
    }
  });
  this._generalizationNodeWidth = maxWidth;
  this._generalizationNodeHeight = maxHeight;
}
function updateGeneralization() {
  if (this.isGeneralization)
    return;
  this.removeGeneralization();
  this.createGeneralizationNode();
}
function renderGeneralization() {
  if (this.isGeneralization)
    return;
  this.updateGeneralizationData();
  const list2 = this.formatGetGeneralization();
  if (list2.length <= 0 || this.getData("expand") === false) {
    this.removeGeneralization();
    return;
  }
  if (list2.length !== this._generalizationList.length) {
    this.removeGeneralization();
  }
  this.createGeneralizationNode();
  this.renderer.layout.renderGeneralization(this._generalizationList);
  this._generalizationList.forEach((item) => {
    this.style.generalizationLine(item.generalizationLine);
    item.generalizationNode.render();
  });
}
function updateGeneralizationData() {
  const childrenLength = this.children.length;
  const list2 = this.formatGetGeneralization();
  const newList = [];
  list2.forEach((item) => {
    if (!item.range) {
      newList.push(item);
      return;
    }
    if (item.range.length > 0 && item.range[0] <= childrenLength - 1 && item.range[1] <= childrenLength - 1) {
      newList.push(item);
    }
  });
  if (newList.length !== list2.length) {
    this.setData({
      generalization: newList
    });
  }
}
function removeGeneralization() {
  if (this.isGeneralization)
    return;
  this._generalizationList.forEach((item) => {
    if (item.generalizationLine) {
      item.generalizationLine.remove();
      item.generalizationLine = null;
    }
    if (item.generalizationNode) {
      this.renderer.removeNodeFromActiveList(item.generalizationNode);
      item.generalizationNode.remove();
      item.generalizationNode = null;
    }
  });
  this._generalizationList = [];
  if (this.generalizationBelongNode) {
    this.nodeDraw.find(".generalization_" + this.generalizationBelongNode.uid).remove();
  }
}
function hideGeneralization() {
  if (this.isGeneralization)
    return;
  this._generalizationList.forEach((item) => {
    if (item.generalizationLine)
      item.generalizationLine.hide();
    if (item.generalizationNode)
      item.generalizationNode.hide();
  });
}
function showGeneralization() {
  if (this.isGeneralization)
    return;
  this._generalizationList.forEach((item) => {
    if (item.generalizationLine)
      item.generalizationLine.show();
    if (item.generalizationNode)
      item.generalizationNode.show();
  });
}
function setGeneralizationOpacity(val) {
  this._generalizationList.forEach((item) => {
    item.generalizationLine.opacity(val);
    item.generalizationNode.group.opacity(val);
  });
}
function handleGeneralizationMouseenter() {
  const belongNode = this.generalizationBelongNode;
  const list2 = belongNode.formatGetGeneralization();
  const index3 = belongNode.getGeneralizationNodeIndex(this);
  const generalizationData = list2[index3];
  if (Array.isArray(generalizationData.range) && generalizationData.range.length > 0) {
    this.mindMap.renderer.highlightNode(belongNode, generalizationData.range);
  } else {
    this.mindMap.renderer.highlightNode(belongNode);
  }
}
function handleGeneralizationMouseleave() {
  this.mindMap.renderer.closeHighlightNode();
}
var nodeGeneralization_default = {
  formatGetGeneralization,
  checkHasGeneralization,
  checkHasSelfGeneralization,
  getGeneralizationNodeIndex,
  createGeneralizationNode,
  updateGeneralization,
  updateGeneralizationData,
  renderGeneralization,
  removeGeneralization,
  hideGeneralization,
  showGeneralization,
  setGeneralizationOpacity,
  handleGeneralizationMouseenter,
  handleGeneralizationMouseleave
};

// ../simple-mind-map/src/svg/btns.js
var open2 = `<svg t="1618141562310" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="13476" width="200" height="200"><path d="M475.136 327.168v147.968h-147.968v74.24h147.968v147.968h74.24v-147.968h147.968v-74.24h-147.968v-147.968h-74.24z m36.864-222.208c225.28 0 407.04 181.76 407.04 407.04s-181.76 407.04-407.04 407.04-407.04-181.76-407.04-407.04 181.76-407.04 407.04-407.04z m0-74.24c-265.216 0-480.768 215.552-480.768 480.768s215.552 480.768 480.768 480.768 480.768-215.552 480.768-480.768-215.552-480.768-480.768-480.768z" p-id="13477"></path></svg>`;
var close = `<svg t="1618141589243" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="13611" width="200" height="200"><path d="M512 105.472c225.28 0 407.04 181.76 407.04 407.04s-181.76 407.04-407.04 407.04-407.04-181.76-407.04-407.04 181.76-407.04 407.04-407.04z m0-74.24c-265.216 0-480.768 215.552-480.768 480.768s215.552 480.768 480.768 480.768 480.768-215.552 480.768-480.768-215.552-480.768-480.768-480.768z" p-id="13612"></path><path d="M252.928 474.624h518.144v74.24h-518.144z" p-id="13613"></path></svg>`;
var remove = `<svg width="14px" height="14px" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="13611" width="200" height="200"><path fill="#ffffff" d="M512 105.472c225.28 0 407.04 181.76 407.04 407.04s-181.76 407.04-407.04 407.04-407.04-181.76-407.04-407.04 181.76-407.04 407.04-407.04z m0-74.24c-265.216 0-480.768 215.552-480.768 480.768s215.552 480.768 480.768 480.768 480.768-215.552 480.768-480.768-215.552-480.768-480.768-480.768z" p-id="13612"></path><path fill="#ffffff" d="M252.928 474.624h518.144v74.24h-518.144z" p-id="13613"></path></svg>`;
var imgAdjust = `<svg width="12px" height="12px" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg"><path fill="#ffffff" d="M1008.128 614.4a25.6 25.6 0 0 0-27.648 5.632l-142.848 142.848L259.072 186.88 401.92 43.52A25.6 25.6 0 0 0 384 0h-358.4a25.6 25.6 0 0 0-25.6 25.6v358.4a25.6 25.6 0 0 0 43.52 17.92l143.36-142.848 578.048 578.048-142.848 142.848a25.6 25.6 0 0 0 17.92 43.52h358.4a25.6 25.6 0 0 0 25.6-25.6v-358.4a25.6 25.6 0 0 0-15.872-25.088z"  /></svg>`;
var btns_default = {
  open: open2,
  close,
  remove,
  imgAdjust
};

// ../simple-mind-map/src/core/render/node/nodeExpandBtn.js
function createExpandNodeContent() {
  if (this._openExpandNode) {
    return;
  }
  let { close: close3, open: open4 } = this.mindMap.opt.expandBtnIcon || {};
  if (this.mindMap.opt.isShowExpandNum) {
    this._openExpandNode = SVG().text().size(this.expandBtnSize, this.expandBtnSize);
    this._openExpandNode.attr({
      "text-anchor": "middle",
      "dominant-baseline": "middle",
      x: this.expandBtnSize / 2,
      y: 2
    });
  } else {
    this._openExpandNode = SVG(open4 || btns_default.open).size(
      this.expandBtnSize,
      this.expandBtnSize
    );
    this._openExpandNode.x(0).y(-this.expandBtnSize / 2);
  }
  this._closeExpandNode = SVG(close3 || btns_default.close).size(
    this.expandBtnSize,
    this.expandBtnSize
  );
  this._closeExpandNode.x(0).y(-this.expandBtnSize / 2);
  this._fillExpandNode = new Circle().size(this.expandBtnSize);
  this._fillExpandNode.x(0).y(-this.expandBtnSize / 2);
  this.style.iconBtn(
    this._openExpandNode,
    this._closeExpandNode,
    this._fillExpandNode
  );
}
function sumNode(data2 = []) {
  return data2.reduce(
    (total, cur) => total + this.sumNode(cur.children || []),
    data2.length
  );
}
function updateExpandBtnNode() {
  let { expand } = this.getData();
  if (expand === this._lastExpandBtnType)
    return;
  if (this._expandBtn) {
    this._expandBtn.clear();
  }
  this.createExpandNodeContent();
  let node3;
  if (expand === false) {
    node3 = this._openExpandNode;
    this._lastExpandBtnType = false;
  } else {
    node3 = this._closeExpandNode;
    this._lastExpandBtnType = true;
  }
  if (this._expandBtn) {
    let { isShowExpandNum, expandBtnStyle, expandBtnNumHandler } = this.mindMap.opt;
    if (isShowExpandNum) {
      if (!expand) {
        this._fillExpandNode.stroke({
          color: expandBtnStyle.strokeColor
        });
        let count = this.sumNode(this.nodeData.children);
        count = expandBtnNumHandler(count);
        node3.text(count);
      } else {
        this._fillExpandNode.stroke("none");
      }
    }
    this._expandBtn.add(this._fillExpandNode).add(node3);
  }
}
function updateExpandBtnPos() {
  if (!this._expandBtn) {
    return;
  }
  this.renderer.layout.renderExpandBtn(this, this._expandBtn);
}
function renderExpandBtn() {
  if (!this.nodeData.children || this.nodeData.children.length <= 0 || this.isRoot) {
    return;
  }
  if (this._expandBtn) {
    this.group.add(this._expandBtn);
  } else {
    this._expandBtn = new G();
    this._expandBtn.on("mouseover", (e2) => {
      e2.stopPropagation();
      this._expandBtn.css({
        cursor: "pointer"
      });
    });
    this._expandBtn.on("mouseout", (e2) => {
      e2.stopPropagation();
      this._expandBtn.css({
        cursor: "auto"
      });
    });
    this._expandBtn.on("click", (e2) => {
      e2.stopPropagation();
      this.mindMap.execCommand(
        "SET_NODE_EXPAND",
        this,
        !this.getData("expand")
      );
      this.mindMap.emit("expand_btn_click", this);
    });
    this._expandBtn.on("dblclick", (e2) => {
      e2.stopPropagation();
    });
    this._expandBtn.addClass("smm-expand-btn");
    this.group.add(this._expandBtn);
  }
  this._showExpandBtn = true;
  this.updateExpandBtnNode();
  this.updateExpandBtnPos();
}
function removeExpandBtn() {
  if (this._expandBtn && this._showExpandBtn) {
    this._expandBtn.remove();
    this._showExpandBtn = false;
  }
}
function showExpandBtn() {
  if (this.mindMap.opt.alwaysShowExpandBtn)
    return;
  setTimeout(() => {
    this.renderExpandBtn();
  }, 0);
}
function hideExpandBtn() {
  if (this.mindMap.opt.alwaysShowExpandBtn || this._isMouseenter)
    return;
  let { isActive, expand } = this.getData();
  if (!isActive && expand) {
    setTimeout(() => {
      this.removeExpandBtn();
    }, 0);
  }
}
var nodeExpandBtn_default = {
  createExpandNodeContent,
  updateExpandBtnNode,
  updateExpandBtnPos,
  renderExpandBtn,
  removeExpandBtn,
  showExpandBtn,
  hideExpandBtn,
  sumNode
};

// ../simple-mind-map/src/core/render/node/nodeCommandWraps.js
function setData(data2 = {}) {
  this.mindMap.execCommand("SET_NODE_DATA", this, data2);
}
function setText(text4, richText, resetRichText) {
  this.mindMap.execCommand("SET_NODE_TEXT", this, text4, richText, resetRichText);
}
function setImage(imgData) {
  this.mindMap.execCommand("SET_NODE_IMAGE", this, imgData);
}
function setIcon(icons) {
  this.mindMap.execCommand("SET_NODE_ICON", this, icons);
}
function setHyperlink(link, title) {
  this.mindMap.execCommand("SET_NODE_HYPERLINK", this, link, title);
}
function setNote(note2) {
  this.mindMap.execCommand("SET_NODE_NOTE", this, note2);
}
function setTag(tag) {
  this.mindMap.execCommand("SET_NODE_TAG", this, tag);
}
function setShape(shape) {
  this.mindMap.execCommand("SET_NODE_SHAPE", this, shape);
}
function setStyle(prop, value) {
  this.mindMap.execCommand("SET_NODE_STYLE", this, prop, value);
}
function setStyles(style) {
  this.mindMap.execCommand("SET_NODE_STYLES", this, style);
}
var nodeCommandWraps_default = {
  setData,
  setText,
  setImage,
  setIcon,
  setHyperlink,
  setNote,
  setTag,
  setShape,
  setStyle,
  setStyles
};

// ../simple-mind-map/src/svg/icons.js
var hyperlink = '<svg t="1624174958075" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="7982" ><path d="M435.484444 251.733333v68.892445L295.822222 320.682667a168.504889 168.504889 0 0 0-2.844444 336.952889h142.506666v68.892444H295.822222a237.397333 237.397333 0 0 1 0-474.794667h139.662222z m248.945778 0a237.397333 237.397333 0 0 1 0 474.851556H544.654222v-69.006222l139.776 0.056889a168.504889 168.504889 0 0 0 2.844445-336.952889H544.597333V251.676444h139.776z m-25.827555 203.946667a34.474667 34.474667 0 0 1 0 68.892444H321.649778a34.474667 34.474667 0 0 1 0-68.892444h336.952889z" p-id="7983"></path></svg>';
var note = '<svg t="1624195132675" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="8792" ><path d="M152.768 985.984 152.768 49.856l434.56 0 66.816 0 234.048 267.392 0 66.816 0 601.92L152.768 985.984 152.768 985.984zM654.144 193.088l0 124.16 108.736 0L654.144 193.088 654.144 193.088zM821.312 384.064l-167.168 0L587.328 384.064 587.328 317.312 587.328 116.736 219.584 116.736 219.584 919.04l601.728 0L821.312 384.064 821.312 384.064zM386.688 517.888 319.808 517.888 319.808 450.944l66.816 0L386.624 517.888 386.688 517.888zM386.688 651.584 319.808 651.584 319.808 584.704l66.816 0L386.624 651.584 386.688 651.584zM386.688 785.344 319.808 785.344l0-66.88 66.816 0L386.624 785.344 386.688 785.344zM721.024 517.888 453.632 517.888 453.632 450.944l267.392 0L721.024 517.888 721.024 517.888zM654.144 651.584 453.632 651.584 453.632 584.704l200.512 0L654.144 651.584 654.144 651.584zM620.672 785.344l-167.04 0 0-66.88 167.04 0L620.672 785.344 620.672 785.344z" p-id="8793"></path></svg>';
var nodeIconList = [
  {
    name: "\u4F18\u5148\u7EA7\u56FE\u6807",
    type: "priority",
    list: [
      {
        name: "1",
        icon: `<svg viewBox="0 0 1024 1024"><path d="M512.042667 1024C229.248 1024 0 794.794667 0 511.957333 0 229.205333 229.248 0 512.042667 0 794.752 0 1024 229.205333 1024 511.957333 1024 794.794667 794.752 1024 512.042667 1024z" fill="#E93B30"></path><path d="M580.309333 256h-75.52c-10.666667 29.824-30.165333 55.765333-58.709333 78.165333-28.416 22.314667-54.869333 37.418667-79.146667 45.397334v84.608a320 320 0 0 0 120.234667-70.698667v352.085333H580.266667V256z" fill="#FFFFFF"></path></svg>`
      },
      {
        name: "2",
        icon: `<svg viewBox="0 0 1024 1024"><path d="M511.957333 1024C229.248 1024 0 794.752 0 512S229.248 0 511.957333 0C794.752 0 1024 229.248 1024 512s-229.248 512-512.042667 512z" fill="#FA8D2E"></path><path d="M667.946667 658.602667h-185.301334c4.864-8.533333 11.178667-17.066667 19.072-25.984 7.808-8.874667 26.453333-26.837333 55.936-53.888 29.525333-27.008 49.877333-47.786667 61.226667-62.165334 16.981333-21.717333 29.44-42.453333 37.290667-62.293333 7.808-19.84 11.776-40.746667 11.776-62.677333 0-38.570667-13.738667-70.741333-41.088-96.725334C599.466667 268.928 561.706667 256 513.834667 256c-43.690667 0-80.128 11.136-109.354667 33.578667-29.098667 22.4-46.506667 59.306667-52.010667 110.805333l93.184 9.301333c1.792-27.349333 8.405333-46.890667 19.754667-58.624 11.434667-11.776 26.837333-17.664 46.165333-17.664 19.541333 0 34.858667 5.589333 45.909334 16.768 11.136 11.264 16.682667 27.221333 16.682666 48.042667 0 18.858667-6.4 37.930667-19.242666 57.258667-9.472 14.037333-35.157333 40.533333-77.098667 79.872-52.096 48.554667-87.04 87.509333-104.704 116.821333A226.688 226.688 0 0 0 341.333333 745.429333h326.613334v-86.826666z" fill="#FFFFFF"></path></svg>`
      },
      {
        name: "3",
        icon: `<svg viewBox="0 0 1024 1024"><path d="M512 0C229.248 0 0 229.248 0 512s229.248 512 512 512 512-229.248 512-512S794.752 0 512 0z" fill="#2E66FA"></path><path d="M627.754667 731.733333c-29.354667 25.088-66.901333 37.632-112.725334 37.632-44.928 0-81.792-11.52-110.592-34.773333-33.066667-26.538667-49.877333-64.469333-50.304-114.133333h92.16c0.426667 21.76 7.552 38.314667 21.333334 49.664 12.288 10.88 28.117333 16.341333 47.402666 16.341333 20.309333 0 36.778667-6.101333 49.322667-18.432 12.544-12.330667 18.773333-29.568 18.773333-51.797333 0-21.290667-6.229333-38.186667-18.773333-50.773334-12.544-12.501333-29.866667-18.773333-52.138667-18.773333h-13.525333v-80.042667H512c42.112 0 63.274667-21.034667 63.274667-63.146666 0-20.309333-5.888-36.096-17.706667-47.445334a60.757333 60.757333 0 0 0-43.818667-17.066666c-17.493333 0-32 5.504-43.434666 16.298666-11.562667 10.88-17.792 25.728-18.773334 44.714667H359.68c0.981333-43.946667 16.042667-78.976 45.397333-104.96 29.354667-25.941333 65.706667-39.04 109.226667-39.04 44.928 0 81.792 13.525333 110.592 40.490667 28.8 26.922667 43.306667 61.610667 43.306667 104.149333 0 48.213333-19.413333 82.688-58.154667 103.552 43.52 23.125333 65.28 61.44 65.28 114.858667 0 48.128-15.957333 85.76-47.573333 112.682666z" fill="#FFFFFF"></path></svg>`
      },
      {
        name: "4",
        icon: `<svg viewBox="0 0 1024 1024"><path d="M512.042667 1024C229.248 1024 0 794.794667 0 512.042667 0 229.205333 229.248 0 512.042667 0 794.752 0 1024 229.205333 1024 512.042667 1024 794.794667 794.752 1024 512.042667 1024z" fill="#6D768D"></path><path d="M600.96 256v309.802667h60.117333v81.536h-60.16v98.218666h-90.154666v-98.218666H311.466667v-81.237334L522.666667 256h78.293333zM510.72 399.104l-112.042667 166.698667h112.042667V399.104z" fill="#FFFFFF"></path></svg>`
      },
      {
        name: "5",
        icon: `<svg viewBox="0 0 1024 1024"><path d="M512.042667 1024C229.248 1024 0 794.794667 0 512.042667 0 229.205333 229.248 0 512.042667 0 794.752 0 1024 229.205333 1024 512.042667 1024 794.794667 794.752 1024 512.042667 1024z" fill="#6D768D"></path><path d="M470.912 343.552h175.786667V256H400.256l-47.786667 253.952 75.434667 10.837333c21.205333-23.552 45.269333-35.413333 72.021333-35.413333 21.546667 0 38.997333 7.509333 52.437334 22.4 13.312 15.018667 20.053333 37.418667 20.053333 67.328 0 31.872-6.741333 55.765333-20.181333 71.552-13.397333 15.872-29.866667 23.765333-49.237334 23.765333-17.066667 0-32.085333-6.186667-45.013333-18.432-13.013333-12.373333-20.821333-29.013333-23.466667-50.133333L341.333333 611.498667c5.546667 40.874667 22.485333 73.429333 50.730667 97.621333 28.330667 24.32 64.938667 36.437333 109.866667 36.437333 56.149333 0 100.053333-21.546667 131.754666-64.554666a176.64 176.64 0 0 0 34.816-107.52c0-48.042667-14.378667-87.210667-43.221333-117.333334-28.8-30.208-63.957333-45.312-105.514667-45.312-21.674667 0-42.922667 5.248-63.829333 15.616l14.976-82.901333z" fill="#FFFFFF"></path></svg>`
      },
      {
        name: "6",
        icon: `<svg viewBox="0 0 1024 1024"><path d="M512 1024C229.248 1024 0 794.794667 0 512.042667 0 229.205333 229.248 0 512 0c282.88 0 512 229.205333 512 512.042667C1024 794.794667 794.88 1024 512 1024z" fill="#6D768D"></path><path d="M519.210667 256c36.992 0 67.626667 10.368 91.776 31.189333 24.192 20.821333 39.68 51.029333 46.293333 90.709334l-90.197333 9.984c-2.176-18.56-7.978667-32.298667-17.28-41.173334-9.258667-8.874667-21.418667-13.226667-36.224-13.226666-19.754667 0-36.437333 8.789333-50.048 26.453333-13.696 17.664-22.314667 54.613333-25.856 110.549333 23.296-27.52 52.138667-41.258667 86.656-41.258666 38.997333 0 72.362667 14.805333 100.181333 44.544 27.733333 29.696 41.685333 68.010667 41.685333 114.858666 0 49.877333-14.634667 89.856-43.818666 119.936-29.226667 30.208-66.730667 45.226667-112.554667 45.226667-49.066667 0-89.429333-19.072-121.130667-57.344C357.12 658.218667 341.333333 595.541333 341.333333 508.416c0-89.344 16.469333-153.813333 49.493334-193.194667C423.722667 275.754667 466.56 256 519.168 256z m-9.472 241.834667c-17.962667 0-33.066667 6.997333-45.525334 21.12-12.330667 14.037333-18.56 34.858667-18.56 62.293333 0 30.421333 6.912 53.76 20.906667 70.4 13.952 16.469333 29.866667 24.746667 47.786667 24.746667 17.28 0 31.701333-6.826667 43.178666-20.309334 11.52-13.525333 17.237333-35.669333 17.237334-66.56 0-31.658667-6.186667-54.869333-18.517334-69.546666a58.197333 58.197333 0 0 0-46.506666-22.144z" fill="#FFFFFF"></path></svg>`
      },
      {
        name: "7",
        icon: `<svg viewBox="0 0 1024 1024"><path d="M512.042667 1024C229.248 1024 0 794.752 0 512S229.248 0 512.042667 0C794.752 0 1024 229.248 1024 512s-229.248 512-511.957333 512z" fill="#6D768D"></path><path d="M673.024 273.066667H354.133333v86.869333h212.224a691.2 691.2 0 0 0-104.746666 187.989333c-26.026667 70.101333-39.978667 138.88-41.429334 206.293334h89.6c-0.298667-42.922667 6.698667-91.776 21.034667-146.474667a654.72 654.72 0 0 1 62.08-154.965333c27.136-48.554667 53.888-85.76 80.128-111.701334V273.066667z" fill="#FFFFFF"></path></svg>`
      },
      {
        name: "8",
        icon: `<svg viewBox="0 0 1024 1024"><path d="M512 1024C229.248 1024 0 794.752 0 512S229.248 0 512 0s512 229.248 512 512-229.248 512-512 512z" fill="#6D768D"></path><path d="M512.426667 256c46.208 0 82.048 11.861333 107.605333 35.541333 25.6 23.68 38.314667 53.674667 38.314667 89.898667 0 22.613333-5.802667 42.666667-17.578667 60.330667a111.445333 111.445333 0 0 1-49.450667 40.277333c26.965333 10.837333 47.36 26.752 61.312 47.658667 13.994667 20.906667 21.034667 45.013333 21.034667 72.362666 0 45.098667-14.336 81.834667-42.965333 109.952-28.586667 28.245333-66.602667 42.368-114.090667 42.368-44.245333 0-81.066667-11.648-110.464-34.986666-34.645333-27.52-52.010667-65.28-52.010667-113.365334 0-26.368 6.528-50.645333 19.626667-72.746666 13.056-22.144 33.578667-39.210667 61.696-51.242667-24.064-10.154667-41.557333-24.192-52.48-41.941333a109.824 109.824 0 0 1-16.512-58.666667c0-36.224 12.757333-66.218667 37.973333-89.898667 25.386667-23.68 61.354667-35.541333 108.032-35.541333z m1.28 265.429333c-22.784 0-39.722667 7.978667-50.901334 23.893334-11.136 15.786667-16.64 33.066667-16.64 51.498666 0 25.984 6.485333 46.208 19.712 60.714667 13.098667 14.506667 29.525333 21.802667 49.152 21.802667 19.242667 0 35.157333-6.997333 47.786667-20.992 12.629333-13.909333 18.858667-34.048 18.858667-60.416 0-23.082667-6.314667-41.557333-19.2-55.466667a63.274667 63.274667 0 0 0-48.725334-21.034667z m-0.341334-191.488c-17.792 0-32 5.333333-42.581333 16-10.538667 10.666667-15.872 24.746667-15.872 42.325334 0 18.645333 5.248 33.152 15.701333 43.648 10.453333 10.453333 24.362667 15.658667 41.770667 15.658666 17.664 0 31.658667-5.290667 42.24-15.872 10.538667-10.581333 15.872-25.173333 15.872-43.818666 0-17.493333-5.248-31.573333-15.701333-42.154667s-24.277333-15.786667-41.429334-15.786667z" fill="#FFFFFF"></path></svg>`
      },
      {
        name: "9",
        icon: `<svg viewBox="0 0 1024 1024"><path d="M512 1024C229.248 1024 0 794.794667 0 512.042667 0 229.333333 229.248 0 512 0c282.88 0 512 229.333333 512 512.042667C1024 794.794667 794.88 1024 512 1024z" fill="#6D768D"></path><path d="M497.28 256c49.365333 0 89.856 19.157333 121.429333 57.429333 31.701333 38.229333 47.488 101.205333 47.488 188.842667 0 89.173333-16.384 153.386667-49.365333 192.853333-32.853333 39.594667-75.605333 59.264-128.426667 59.264-37.888 0-68.608-10.154667-91.989333-30.506666s-38.4-50.816-45.013333-91.306667l90.112-9.984c2.261333 18.474667 8.021333 32.085333 17.28 41.088 9.173333 8.874667 21.418667 13.312 36.608 13.312 19.2 0 35.541333-8.874667 48.981333-26.752 13.44-17.749333 22.016-54.613333 25.770667-110.549333-23.466667 27.264-52.821333 40.874667-88.064 40.874666-38.314667 0-71.253333-14.72-99.114667-44.330666C355.242667 506.709333 341.333333 468.224 341.333333 420.864c0-49.493333 14.592-89.258667 43.946667-119.466667C414.549333 271.104 451.925333 256 497.237333 256z m-4.352 77.482667c-17.237333 0-31.658667 6.826667-43.008 20.437333-11.477333 13.653333-17.194667 35.84-17.194667 66.816 0 31.402667 6.229333 54.485333 18.645334 69.205333 12.458667 14.72 27.946667 22.101333 46.592 22.101334 18.005333 0 33.066667-7.082667 45.44-21.205334 12.330667-14.208 18.432-35.029333 18.432-62.506666 0-29.994667-6.912-53.376-20.821334-69.973334-13.824-16.597333-29.866667-24.874667-48.085333-24.874666z" fill="#FFFFFF"></path></svg>`
      },
      {
        name: "10",
        icon: `<svg viewBox="0 0 1024 1024"><path d="M512.042667 1024C229.248 1024 0 794.794667 0 511.957333 0 229.205333 229.248 0 512.042667 0 794.752 0 1024 229.205333 1024 511.957333 1024 794.794667 794.752 1024 512.042667 1024z" fill="#6D768D"></path><path d="M619.946667 273.066667c46.976 0 83.754667 16.042667 110.250666 48.042666 31.573333 37.973333 47.36 100.864 47.36 188.672 0 87.722667-15.829333 150.698667-47.658666 189.056-26.325333 31.616-62.976 47.36-109.952 47.36-47.274667 0-85.418667-17.237333-114.346667-51.968-28.885333-34.602667-43.392-96.426667-43.392-185.386666 0-87.168 15.872-150.016 47.701333-188.416 26.282667-31.488 62.933333-47.36 110.037334-47.36z m-207.488 12.8v452.266666H325.504V411.690667A299.904 299.904 0 0 1 213.333333 476.373333V398.933333c22.656-7.296 47.36-21.12 73.856-41.514666 26.624-20.522667 44.842667-44.288 54.784-71.552h70.485334z m207.488 60.842666c-11.306667 0-21.461333 3.413333-30.336 10.24-8.874667 6.826667-15.786667 19.157333-20.693334 36.864-6.4 22.997333-9.642667 61.653333-9.642666 115.968 0 54.442667 2.944 91.733333 8.661333 112.128 5.802667 20.352 13.098667 33.877333 21.845333 40.618667 8.789333 6.741333 18.858667 10.154667 30.165334 10.154667 11.349333 0 21.376-3.498667 30.250666-10.325334 8.874667-6.826667 15.786667-19.157333 20.693334-36.778666 6.4-22.826667 9.642667-61.354667 9.642666-115.797334 0-54.314667-2.858667-91.648-8.661333-112.042666-5.802667-20.352-13.013333-33.962667-21.76-40.789334a47.616 47.616 0 0 0-30.165333-10.24z" fill="#FFFFFF"></path></svg>`
      }
    ]
  },
  {
    name: "\u8FDB\u5EA6\u56FE\u6807",
    type: "progress",
    list: [
      {
        name: "1",
        icon: `<svg viewBox="0 0 1024 1024"><path d="M512 0C229.248 0 0 229.248 0 512s229.248 512 512 512 512-229.248 512-512S794.752 0 512 0z" fill="#12BB37"></path><path d="M512 928c-229.76 0-416-186.24-416-416S282.24 96 512 96V512l294.144-294.144A414.72 414.72 0 0 1 928 512c0 229.76-186.24 416-416 416z" fill="#FFFFFF"></path></svg>`
      },
      {
        name: "2",
        icon: `<svg viewBox="0 0 1024 1024"><path d="M512 0C229.248 0 0 229.248 0 512s229.248 512 512 512 512-229.248 512-512S794.752 0 512 0z" fill="#12BB37"></path><path d="M512 928c-229.76 0-416-186.24-416-416S282.24 96 512 96V512h416c0 229.76-186.24 416-416 416z" fill="#FFFFFF"></path></svg>`
      },
      {
        name: "3",
        icon: `<svg viewBox="0 0 1024 1024"><path d="M512 0C229.248 0 0 229.248 0 512s229.248 512 512 512 512-229.248 512-512S794.752 0 512 0z" fill="#12BB37"></path><path d="M512 928c-229.76 0-416-186.24-416-416S282.24 96 512 96V512l294.144 294.144A414.72 414.72 0 0 1 512 928z" fill="#FFFFFF"></path></svg>`
      },
      {
        name: "4",
        icon: `<svg viewBox="0 0 1024 1024"><path d="M512 0C229.248 0 0 229.248 0 512s229.248 512 512 512 512-229.248 512-512S794.752 0 512 0z" fill="#12BB37"></path><path d="M512 928c-229.76 0-416-186.24-416-416S282.24 96 512 96v832z" fill="#FFFFFF"></path></svg>`
      },
      {
        name: "5",
        icon: `<svg viewBox="0 0 1024 1024"><path d="M512 0C229.248 0 0 229.248 0 512s229.248 512 512 512 512-229.248 512-512S794.752 0 512 0z" fill="#12BB37"></path><path d="M512 512l-294.144 294.144A414.72 414.72 0 0 1 96 512c0-229.76 186.24-416 416-416V512z" fill="#FFFFFF"></path></svg>`
      },
      {
        name: "6",
        icon: `<svg viewBox="0 0 1024 1024"><path d="M512 0C229.248 0 0 229.248 0 512s229.248 512 512 512 512-229.248 512-512S794.752 0 512 0z" fill="#12BB37"></path><path d="M512 512H96c0-229.76 186.24-416 416-416V512z" fill="#FFFFFF"></path></svg>`
      },
      {
        name: "7",
        icon: `<svg viewBox="0 0 1024 1024"><path d="M512 0C229.248 0 0 229.248 0 512s229.248 512 512 512 512-229.248 512-512S794.752 0 512 0z" fill="#12BB37"></path><path d="M512 512L217.856 217.856A414.72 414.72 0 0 1 512 96V512z" fill="#FFFFFF"></path></svg>`
      },
      {
        name: "8",
        icon: `<svg viewBox="0 0 1024 1024"><path d="M0 512c0 282.752 229.248 512 512 512s512-229.248 512-512S794.752 0 512 0 0 229.248 0 512z" fill="#12BB37"></path><path d="M716.629333 341.333333h-51.328a35.072 35.072 0 0 0-28.330666 14.293334l-171.989334 233.984-77.909333-106.026667a35.2 35.2 0 0 0-28.330667-14.293333H307.413333c-7.082667 0-11.264 7.936-7.082666 13.653333l136.32 185.472a35.2 35.2 0 0 0 56.533333 0l230.4-313.429333a8.533333 8.533333 0 0 0-6.954667-13.653334z" fill="#FFFFFF"></path></svg>`
      }
    ]
  },
  {
    name: "\u8868\u60C5\u56FE\u6807",
    type: "expression",
    list: [
      {
        name: "1",
        icon: `<svg t="1624457751393" class="icon" viewBox="0 0 1026 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="12255"><path d="M1.097856 1.097642h1021.804717v1021.804716H1.097856z" fill="#F09495" p-id="12256"></path><path d="M1024.000214 1024H0.000214V0h1024v1024z m-1021.804716-2.195284h1019.609433V2.195284H2.195498v1019.609432z" fill="#FFFFFF" p-id="12257"></path><path d="M234.695985 335.179887m-27.341259 0a27.341259 27.341259 0 1 0 54.682518 0 27.341259 27.341259 0 1 0-54.682518 0Z" fill="#040000" p-id="12258"></path><path d="M234.695985 363.519002c-15.666342 0-28.339115-12.772559-28.339115-28.339115 0-15.666342 12.772559-28.339115 28.339115-28.339115s28.339115 12.772559 28.339115 28.339115c0.099786 15.666342-12.672773 28.339115-28.339115 28.339115z m0-54.582732c-14.468914 0-26.243617 11.774703-26.243617 26.243617s11.774703 26.243617 26.243617 26.243617 26.243617-11.774703 26.243617-26.243617-11.774703-26.243617-26.243617-26.243617z" fill="#FFFFFF" p-id="12259"></path><path d="M776.232528 335.179887m-27.341259 0a27.341259 27.341259 0 1 0 54.682518 0 27.341259 27.341259 0 1 0-54.682518 0Z" fill="#040000" p-id="12260"></path><path d="M776.232528 363.519002c-15.666342 0-28.339115-12.772559-28.339115-28.339115 0-15.666342 12.772559-28.339115 28.339115-28.339115 15.666342 0 28.339115 12.772559 28.339115 28.339115 0 15.666342-12.772559 28.339115-28.339115 28.339115z m0-54.582732c-14.468914 0-26.243617 11.774703-26.243617 26.243617s11.774703 26.243617 26.243617 26.243617 26.243617-11.774703 26.243617-26.243617c-0.099786-14.468914-11.874488-26.243617-26.243617-26.243617z" fill="#FFFFFF" p-id="12261"></path><path d="M512.000214 671.656987c-52.58702 0-105.872539-17.961411-105.872539-52.387449S459.413194 566.882089 512.000214 566.882089s105.872539 17.961411 105.87254 52.387449S564.587234 671.656987 512.000214 671.656987z m0-74.240499c-21.952836 0-43.207172 3.592282-58.2748 9.77899-13.870201 5.68778-17.06334 11.275775-17.06334 12.07406s3.19314 6.386279 17.06334 12.07406c15.067628 6.186708 36.321965 9.77899 58.2748 9.77899s43.207172-3.592282 58.274801-9.77899c13.870201-5.68778 17.06334-11.275775 17.06334-12.07406s-3.19314-6.386279-17.06334-12.07406c-15.067628-6.286494-36.321965-9.77899-58.274801-9.77899z" fill="#040000" p-id="12262"></path></svg>`
      },
      {
        name: "2",
        icon: `<svg t="1624457767572" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1048"><path d="M0 0h1024v1024H0z" fill="#E6A6C9" p-id="1049"></path><path d="M315.1 368.1c-23.9 0-43.3-19.4-43.3-43.3s19.4-43.3 43.3-43.3 43.3 19.4 43.3 43.3-19.4 43.3-43.3 43.3z m0-74.7c-17.3 0-31.3 14.1-31.3 31.3 0 17.3 14.1 31.3 31.3 31.3 17.3 0 31.3-14.1 31.3-31.3 0-17.2-14-31.3-31.3-31.3zM738.7 368.1c-23.9 0-43.3-19.4-43.3-43.3s19.4-43.3 43.3-43.3 43.3 19.4 43.3 43.3-19.4 43.3-43.3 43.3z m0-74.7c-17.3 0-31.3 14.1-31.3 31.3 0 17.3 14.1 31.3 31.3 31.3 17.3 0 31.3-14.1 31.3-31.3 0-17.2-14-31.3-31.3-31.3zM293.5 698.8l-14.5-1.3c0.1-0.6 1.5-14.6 15.1-27.9 17.2-16.7 45-24.8 82.7-24 4.9-0.1 10.9-10.5 16.1-19.6 8.4-14.7 19-33.1 37.9-34.3 19.4-1.2 42.2 16.4 71.5 55.4 9.9 5.2 16.5 11.2 21.8 16.1 8.4 7.7 13.1 11.9 25.1 10.8 14.9-1.4 38.9-11.1 77.5-31.4 26.8-28.4 56.4-41.4 83.5-36.6 27.9 4.9 50.6 27.6 67.5 67.5l-13.4 5.7c-14.7-34.5-34.3-54.9-56.7-58.8-22.3-3.9-47.6 7.8-71.2 33.1l-0.8 0.9-1.1 0.6c-85.6 45.1-99.4 38-120.2 19.1-5.5-5-11.2-10.2-20.1-14.7l-1.5-0.8-1-1.4c-32.2-43.2-50.4-51.6-60-51-11.1 0.7-18.8 14-26.2 27-7.6 13.2-15.4 26.9-28.8 26.9h-0.2c-78.4-1.6-83 38.3-83 38.7z" fill="#040000" p-id="1050"></path></svg>`
      },
      {
        name: "3",
        icon: `<svg t="1624457776082" class="icon" viewBox="0 0 1026 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1204" ><path d="M1.1 1.097642h1021.804716v1021.804716H1.1z" fill="#F7E983" p-id="1205"></path><path d="M1024.002358 1024H0.002358V0h1024v1024z m-1021.804716-2.195284h1019.609433V2.195284H2.197642v1019.609432z" fill="#FFFFFF" p-id="1206"></path><path d="M329.174412 344.491728a38.118106 10.277919 57.6 1 0 17.355867-11.014369 38.118106 10.277919 57.6 1 0-17.355867 11.014369Z" fill="#040000" p-id="1207"></path><path d="M644.769475 355.956059a11.175989 36.321965 30 1 0 36.321965-62.911488 11.175989 36.321965 30 1 0-36.321965 62.911488Z" fill="#040000" p-id="1208"></path><path d="M569.678445 671.158059c-26.343403 0-51.190021-5.288638-70.049503-14.967843-20.755408-10.577275-32.230754-25.445332-32.230755-41.710388 0-16.265056 11.475346-31.133112 32.230755-41.710387 18.859482-9.579419 43.805886-14.967843 70.049503-14.967843s51.190021 5.288638 70.049503 14.967843c20.755408 10.577275 32.230754 25.445332 32.230754 41.710387 0 16.265056-11.475346 31.133112-32.230754 41.710388-18.859482 9.679205-43.805886 14.967843-70.049503 14.967843z m0-95.095693c-49.693237 0-84.318846 20.356266-84.318846 38.517248s34.625609 38.517248 84.318846 38.517248 84.318846-20.356266 84.318846-38.517248-34.725395-38.517248-84.318846-38.517248z" fill="#040000" p-id="1209"></path></svg>`
      },
      {
        name: "4",
        icon: `<svg t="1624457781889" class="icon" viewBox="0 0 1026 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1363" ><path d="M1.1 1.097642h1021.804716v1021.804716H1.1z" fill="#A6D9E2" p-id="1364"></path><path d="M1024.002358 1024H0.002358V0h1024v1024z m-1021.804716-2.195284h1019.609433V2.195284H2.197642v1019.609432z" fill="#FFFFFF" p-id="1365"></path><path d="M376.194134 348.950302m-23.44962 0a23.44962 23.44962 0 1 0 46.89924 0 23.44962 23.44962 0 1 0-46.89924 0Z" fill="#040000" p-id="1366"></path><path d="M629.150672 348.950302m-24.647047 0a24.647047 24.647047 0 1 0 49.294095 0 24.647047 24.647047 0 1 0-49.294095 0Z" fill="#040000" p-id="1367"></path><path d="M397.847613 603.503411c13.471058 8.282206 28.738258 14.468914 43.7061 19.458195 29.835899 9.978562 62.266225 14.169558 93.299551 7.483921 21.054765-4.490353 40.213604-14.369129 56.778016-28.039758 6.785422-5.587995-2.893783-15.167414-9.579419-9.579419-46.999026 38.916391-112.258819 31.033327-163.847983 6.086922-4.590138-2.195284-9.080491-4.490353-13.371272-7.184564-7.583707-4.590138-14.468914 7.184564-6.984993 11.774703z" fill="#040000" p-id="1368"></path><path d="M627.753674 534.052621c-31.033327 24.048334-58.474371 68.253362-37.419607 106.970182 10.577275 19.35841 29.835899 32.629897 48.795167 42.708244 7.982849 4.190996 15.067628-7.883064 7.084779-12.07406-25.245761-13.271487-53.485091-35.324108-49.094524-66.557006 2.793997-20.156695 15.766127-37.319821 29.736114-51.190022 3.392711-3.392711 6.984993-6.785422 10.776847-9.77899 2.993569-2.295069 2.394855-7.483921 0-9.878776-2.893783-3.19314-6.885208-2.49464-9.878776-0.199572z" fill="#040000" p-id="1369"></path></svg>`
      },
      {
        name: "5",
        icon: `<svg t="1624457787809" class="icon" viewBox="0 0 1026 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1523" ><path d="M1.1 1.097642h1021.804716v1021.804716H1.1z" fill="#AD6F59" p-id="1524"></path><path d="M1024.002358 1024H0.002358V0h1024v1024z m-1021.804716-2.195284h1019.609433V2.195284H2.197642v1019.609432z" fill="#FFFFFF" p-id="1525"></path><path d="M411.829832 330.730879a38.118106 10.277919 57.6 1 0 17.355867-11.014368 38.118106 10.277919 57.6 1 0-17.355867 11.014368Z" fill="#040000" p-id="1526"></path><path d="M480.669675 609.989476c11.774703-25.844475 27.740401-51.788735 44.60417-73.342429 13.770415-17.462483 29.237186-33.92711 47.897096-44.803742 17.262912-10.078347 35.324108-13.67063 54.283376-6.58585 11.974274 4.390567 23.948548 14.468914 33.128825 24.547261 14.369129 15.865913 25.145975 34.625609 34.725394 53.684662 4.290782 8.581563 17.262912 0.997856 12.972131-7.583707-15.167414-30.334828-35.224323-63.763009-66.157864-80.327421-21.054765-11.37556-44.504385-11.475346-66.157864-1.895927-21.054765 9.280062-38.617034 25.644904-53.485091 42.907815-14.468914 16.863769-27.041902 35.324108-38.217891 54.582733-5.887351 10.178133-11.674917 20.555837-16.464627 31.232898-1.696355 3.692068-0.997856 7.982849 2.694212 10.277918 3.19314 1.895927 8.581563 0.898071 10.178133-2.694211z" fill="#040000" p-id="1527"></path><path d="M663.863649 338.091735a14.468914 33.727538 30 1 0 33.727538-58.417811 14.468914 33.727538 30 1 0-33.727538 58.417811Z" fill="#040000" p-id="1528"></path></svg>`
      },
      {
        name: "6",
        icon: `<svg t="1624457794933" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1680" ><path d="M762.9 77.4H261.1L10.2 512l250.9 434.6h501.8L1013.8 512z" fill="#83CEE3" p-id="1681"></path><path d="M369 375.8m-34.6 0a34.6 34.6 0 1 0 69.2 0 34.6 34.6 0 1 0-69.2 0Z" fill="#040000" p-id="1682"></path><path d="M369 411.7c-19.8 0-36-16.1-36-36s16.1-36 36-36 36 16.1 36 36-16.1 36-36 36z m0-69.1c-18.3 0-33.2 14.9-33.2 33.2S350.7 409 369 409s33.2-14.9 33.2-33.2-14.9-33.2-33.2-33.2z" fill="#FFFFFF" p-id="1683"></path><path d="M672.2 333.6c-15.1 7.6-30.2 15.6-44.3 25-5.9 3.9-17 10.4-14.6 19.1 1.8 6.5 12 11.2 17.3 14.3 15.7 9.3 32.1 17.6 48.3 25.9 8.6 4.4 16.2-8.5 7.6-13-14.1-7.3-28.3-14.5-42.1-22.3-3.9-2.2-7.9-4.5-11.7-6.9-1.2-0.8-2.4-1.5-3.5-2.4-0.6-0.4-1.1-0.8-1.6-1.2 2.2 1.7-0.3-0.3-0.3-0.3-0.9 0.1-1.5-3.2-0.2 0.5 0.9 2.4 1.1 3.8 0.3 5.8 0.6-1.5-0.9 0.8-0.1 0 0.5-0.5 1-1.1 1.6-1.6 0.5-0.5 1-0.9 1.6-1.3 0.6-0.5 0 0 1.2-0.9 1.7-1.3 3.5-2.5 5.3-3.6 8.4-5.5 17.2-10.4 26-15.2 5.6-3 11.2-6 16.8-8.9 8.6-4.4 1-17.3-7.6-13zM578.2 720.9c-12.5-96.7-33.3-154.7-55.6-155.6-8.8 3.9-22.3 17.5-37.7 60.1-10.8 29.8-18.4 62.2-23 81.6-1.2 5.1-2.1 9.1-2.9 11.8l-9.3-2.4c0.7-2.6 1.6-6.6 2.8-11.6 14.9-63 36-136.8 67.5-148.8l0.8-0.3h0.8c18.2-0.4 33.2 19.5 45.8 60.8 10.2 33.3 16.7 74.6 20.5 103.3l-9.7 1.1z" fill="#040000" p-id="1684"></path></svg>`
      },
      {
        name: "7",
        icon: `<svg t="1624457802025" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1838" ><path d="M762.9 77.4H261.1L10.2 512l250.9 434.6h501.8L1013.8 512z" fill="#8CC66D" p-id="1839"></path><path d="M375.778679 404.47473a14.5 33.8 30 1 0 33.8-58.543317 14.5 33.8 30 1 0-33.8 58.543317Z" fill="#040000" p-id="1840"></path><path d="M627.220263 374.211388a43.1 11.6 57.6 1 0 19.588408-12.431182 43.1 11.6 57.6 1 0-19.588408 12.431182Z" fill="#040000" p-id="1841"></path><path d="M451.1 548.5c17.6-9.3 63.9-30 105.3-16.2 17 20.3 32.7 98.8 28.8 138.1-27.5 10.2-82.5 10.2-106.1 5.8-8.3-10.5-32.7-81.8-35.3-114.6-0.4-5.5 2.5-10.6 7.3-13.1z" fill="#040000" p-id="1842"></path></svg>`
      },
      {
        name: "8",
        icon: `<svg t="1624457816632" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1996" ><path d="M762.9 77.4H261.1L10.2 512l250.9 434.6h501.8L1013.8 512z" fill="#5A74B8" p-id="1997"></path><path d="M357.7 400m-34.6 0a34.6 34.6 0 1 0 69.2 0 34.6 34.6 0 1 0-69.2 0Z" fill="#040000" p-id="1998"></path><path d="M357.7 436c-19.8 0-36-16.1-36-36s16.1-36 36-36 36 16.1 36 36-16.2 36-36 36z m0-69.2c-18.3 0-33.2 14.9-33.2 33.2s14.9 33.2 33.2 33.2 33.2-14.9 33.2-33.2-14.9-33.2-33.2-33.2z" fill="#FFFFFF" p-id="1999"></path><path d="M676 400m-34.6 0a34.6 34.6 0 1 0 69.2 0 34.6 34.6 0 1 0-69.2 0Z" fill="#040000" p-id="2000"></path><path d="M676 436c-19.8 0-36-16.1-36-36s16.1-36 36-36 36 16.1 36 36-16.2 36-36 36z m0-69.2c-18.3 0-33.2 14.9-33.2 33.2s14.9 33.2 33.2 33.2c18.3 0 33.2-14.9 33.2-33.2s-14.9-33.2-33.2-33.2z" fill="#FFFFFF" p-id="2001"></path><path d="M347.6 684.1c0.3-0.9 0.6-1.7 0.9-2.6 0.2-0.5 1.4-3.2 0.3-0.8 0.6-1.4 1.3-2.9 2-4.3 3.2-6.3 6-10.7 10.9-15.3 4.3-4 10.8-7.5 17.1-6.1 3.9 0.9 7.9 4.9 11.1 7.2 3.1 2.2 6.3 4.5 9.7 6.2 7.5 3.8 15.3 4.4 23.4 1.9 4.7-1.5 9.2-3.6 13.6-5.9 5-2.6 10.7-5 14.2-9.5 4.5-5.7 6.1-8.5 11.4-14.1 1-1 2-2 3.1-3 0.2-0.2 2.2-1.7 0.6-0.5 0.6-0.4 1.2-0.9 1.8-1.3 1-0.6 2.1-1.3 3.2-1.7-2 0.8 0.2 0 0.6-0.1 2.3-0.7-0.3-0.2 1.2-0.3 2.8-0.1 3.6 0 5.5 1 3.8 1.9 6.6 4.7 9.5 7.8 4.5 5 7.5 11.1 11.7 16.2 1.8 2.2 3.7 4.3 5.4 6.5 8.1 10.3 17.7 22.2 32.2 22 8.8-0.1 16.6-5.2 22.6-11.2 4.2-4.1 7.7-8.9 11-13.7 2.9-4.2 4.6-9.9 6.2-13.5 3.2-7.1 7.2-13.1 13-18.1 4.8-4.2 11.1-6.5 16.7-5.3 10.5 2.4 17.2 12.1 23.1 20.2 4.7 6.5 9.8 13 16 18.2 7.8 6.4 17.1 11.4 27.5 11.1 14.1-0.4 25.5-9.5 34.2-19.9 3-3.6 3.6-8.8 0-12.4-3.1-3.1-9.4-3.7-12.4 0-6.3 7.6-14.7 15.9-24.9 14.7-2.2-0.3-5.3-1.5-7.9-3.1-3.5-2.1-6.1-4.4-9.1-7.5-4.9-5.1-6.8-8.1-10.9-13.8-7.3-10.1-16.1-19.6-28.2-23.7-18.5-6.3-35.7 5.6-46 20.1-2.4 3.3-4.4 6.9-6.1 10.6-1.8 3.9-2.7 8.5-5.2 11.9-3.1 4.4-6.2 8.8-10.2 12.5-3 2.8-5.7 4.4-8.6 5.1-0.4 0.1-1.7 0.1 0.1 0h-2.2c2.1 0.1 0 0-0.5-0.1-0.7-0.2-1.4-0.4-2-0.6 1.8 0.7-1.8-1.1-2.4-1.5l-1.2-0.9c1.5 1.2-0.9-0.9-1.2-1.1-4.7-4.3-8.4-9.5-12.3-14.4-10.9-13.6-20.9-34-41-34.9-14.2-0.6-24.5 10.6-32.4 20.8-1.2 1.6-2.5 3.2-3.7 4.8-1.5 1.9 1.1-1.4-0.4 0.5-0.4 0.5-0.8 1.2-1.3 1.6-1.7 1.4-4.6 2.6-6.6 3.6-2.9 1.6-5.9 3.2-9 4.5-1.6 0.7-3.4 1.2-5.1 1.7-2.2 0.6-0.7 0.5-2.8 0.4-2.8 0-3.9-0.4-6.6-1.9-3.9-2.2-7.5-4.9-11.1-7.5-5.6-4-10-6.9-17-7.5-10.5-0.9-20.3 3.2-28.2 9.9-9.4 8.1-16.4 20.2-20.1 32-3.6 11.2 13.3 15.8 16.8 5.1z" fill="#040000" p-id="2002"></path></svg>`
      },
      {
        name: "9",
        icon: `<svg t="1624457826949" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2156" ><path d="M762.9 77.4H261.1L10.2 512l250.9 434.6h501.8L1013.8 512z" fill="#F0884F" p-id="2157"></path><path d="M287.2 382c6.4 2.3 11.6-3.7 15.4-7.9 5.1-5.5 10.2-11 16-15.9 0.8-0.7 1.7-1.4 2.5-2.1 1.2-0.9-1.7 1.3 0.2-0.2l1.2-0.9c2.1-1.5 4.3-2.9 6.5-4.3 2-1.2 4-2.2 6.1-3.2 0.6-0.3 1.2-0.6 1.9-0.9-0.3 0.2-1.5 0.6 0.2-0.1 1.3-0.5 2.6-1 4-1.5 11.2-3.7 21.8-4 33.4-1.1 19.5 4.9 36.4 17 51.2 30.2 8.6 7.7 21.4-5 12.7-12.7-25.2-22.6-57.1-42.1-92.2-36.2-20.4 3.4-37.7 16.1-51.6 30.9-2.3 2.4-4.5 5-6.8 7.4-0.7 0.7-1.9 1.5-2.4 2.4-0.5 0.8 2.3-1.5 0.8-0.7 1.3-0.7 3.9-1.4 5.8-0.7-11.1-3.7-15.8 13.7-4.9 17.5zM598 382c6.4 2.3 11.6-3.7 15.4-7.9 5.1-5.5 10.2-11 16-15.9 0.8-0.7 1.7-1.4 2.5-2.1 1.2-0.9-1.7 1.3 0.2-0.2l1.2-0.9c2.1-1.5 4.3-2.9 6.5-4.3 2-1.2 4-2.2 6.1-3.2 0.6-0.3 1.2-0.6 1.9-0.9-0.3 0.2-1.5 0.6 0.2-0.1 1.3-0.5 2.6-1 4-1.5 11.2-3.7 21.8-4 33.4-1.1 19.5 4.9 36.4 17 51.2 30.2 8.6 7.7 21.4-5 12.7-12.7-25.2-22.6-57.1-42.1-92.2-36.2-20.4 3.4-37.7 16.1-51.6 30.9-2.3 2.4-4.5 5-6.8 7.4-0.7 0.7-1.9 1.5-2.4 2.4-0.5 0.8 2.3-1.5 0.8-0.7 1.3-0.7 3.9-1.4 5.8-0.7-11.1-3.7-15.8 13.7-4.9 17.5zM505.9 527.1c3.4 0.7 6.8 1.7 10.2 2.8 6.7 2.2 10.4 3.5 16.6 7.7 1.6 1.1-0.5-0.5 0.6 0.5 0.6 0.5 1.1 1.1 1.7 1.6 1.5 1.4-0.1-0.4 0.5 0.6 0.4 0.6 0.7 1.2 1 1.8-1-2 0.1 0 0 0.5 0.1-2-0.1 0-0.1 0-0.1 0.8 0 0.7 0.1-0.5-0.1 0.4-0.1 0.7-0.3 1.1-0.6 1 0.7-0.9-0.4 1-1.6 2.5-4.6 5.4-8.1 7.8-6.8 4.6-14.4 8.2-22 11.4-7 3-7.4 11.9 0 14.8 7.4 2.8 15 5.3 22.4 8.1 3.1 1.1 4.2 1.5 6.9 2.9 1.1 0.6 2.1 1.2 3.2 1.8 1.2 0.8-0.7-0.5 0.1 0 0.4 0.3 0.8 0.7 1.1 1.1 0.6 0.8-1.1-1.2-0.2-0.2 0.8 0.9-0.3-1.4-0.1-0.2 0.1 0.9 0.2-1.9 0-0.9-0.1 0.5-0.8 1.8 0 0.2-0.2 0.5-0.5 1-0.8 1.4-0.3 0.3-0.9 1.3-0.3 0.5-0.5 0.7-1.1 1.3-1.7 1.9-6.9 7.3-15.9 12.8-24.4 18.1-8.3 5.3-0.6 18.5 7.7 13.2 9.9-6.3 20.9-12.8 28.6-21.8 4.8-5.5 8.1-12.9 4.2-19.9-3.4-6-10.5-8.9-16.6-11.4-8.6-3.5-17.5-6.2-26.2-9.5v14.8c14.4-6.1 47.2-18.8 41.2-40.3-3.5-12.9-19.4-18.9-30.8-22.6-3.4-1.1-6.9-2.1-10.5-2.9-9.1-2.2-13.3 12.5-3.6 14.6z" fill="#040000" p-id="2158"></path></svg>`
      },
      {
        name: "10",
        icon: `<svg t="1624457835383" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2312" ><path d="M762.9 77.4H261.1L10.2 512l250.9 434.6h501.8L1013.8 512z" fill="#F6F180" p-id="2313"></path><path d="M342.9 400.6m-29.5 0a29.5 29.5 0 1 0 59 0 29.5 29.5 0 1 0-59 0Z" fill="#040000" p-id="2314"></path><path d="M342.9 431.3c-16.9 0-30.7-13.8-30.7-30.7s13.8-30.7 30.7-30.7 30.7 13.8 30.7 30.7-13.7 30.7-30.7 30.7z m0-59c-15.6 0-28.3 12.7-28.3 28.3s12.7 28.3 28.3 28.3 28.3-12.7 28.3-28.3-12.6-28.3-28.3-28.3z" fill="#FFFFFF" p-id="2315"></path><path d="M702 400.6m-29.5 0a29.5 29.5 0 1 0 59 0 29.5 29.5 0 1 0-59 0Z" fill="#040000" p-id="2316"></path><path d="M702 431.3c-16.9 0-30.7-13.8-30.7-30.7s13.8-30.7 30.7-30.7 30.7 13.8 30.7 30.7-13.8 30.7-30.7 30.7z m0-59c-15.6 0-28.3 12.7-28.3 28.3s12.7 28.3 28.3 28.3 28.3-12.7 28.3-28.3-12.7-28.3-28.3-28.3z" fill="#FFFFFF" p-id="2317"></path><path d="M358.7 519.9c20 22 45.5 40.4 71.3 54.8 51.2 28.5 111.7 39.9 168 19.5 44.3-16.1 80.7-47.8 110.2-83.9 3-3.7 3.6-8.9 0-12.5-3.1-3.1-9.5-3.7-12.5 0-25.5 31.4-56.2 59.7-93.7 76-27.1 11.7-56.6 15.7-85.8 12.2-24.7-2.9-49.5-11.8-71.5-23.4-18.7-9.8-36.6-22.2-51.1-34.3-7.8-6.5-15.5-13.3-22.4-20.9-7.7-8.5-20.1 4.1-12.5 12.5z" p-id="2318"></path></svg>`
      },
      {
        name: "11",
        icon: `<svg t="1624457841751" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2472" ><path d="M48.2 844.9c-68.5-210.6 186-782.1 409.1-795.4 6.3-0.4 12.5 0.2 18.6 1.6C665.1 94.6 985.4 515 987.1 821.3c0.1 20-12.9 37.9-22.4 43.1-162.7 89.8-605.8 179.7-884.4 30.9-15-7.9-24.2-26.1-32.1-50.4z" fill="#F0884F" p-id="2473"></path><path d="M401 352.1m-52.4 0a52.4 52.4 0 1 0 104.8 0 52.4 52.4 0 1 0-104.8 0Z" fill="#FFFFFF" p-id="2474"></path><path d="M408.7 329m-29.3 0a29.3 29.3 0 1 0 58.6 0 29.3 29.3 0 1 0-58.6 0Z" fill="#040000" p-id="2475"></path><path d="M527.5 352.1m-52.4 0a52.4 52.4 0 1 0 104.8 0 52.4 52.4 0 1 0-104.8 0Z" fill="#FFFFFF" p-id="2476"></path><path d="M527.5 329m-29.3 0a29.3 29.3 0 1 0 58.6 0 29.3 29.3 0 1 0-58.6 0Z" fill="#040000" p-id="2477"></path><path d="M450.7 517c1.1-8.2 3.2-16.4 6.1-24.1 0.1-0.3 1-2.5 0.5-1.4s0.3-0.7 0.5-1c0.7-1.4 1.4-2.8 2.2-4.1 0.4-0.8 2.8-3.9 1.3-2.1 0.8-1 1.7-1.9 2.6-2.8 1-1-1.5 1 0.1 0 0.5-0.3 1-0.6 1.5-0.8-1.3 0.7-1.2 0.3 0 0.1 1.9-0.3-1.8 0.3 0.1 0 1.2-0.2 1.5 0.3 0-0.1 0.6 0.2 1.3 0.3 1.9 0.5 0.3 0.1-1.3-0.7 0.2 0.1 0.8 0.5 1.6 0.9 2.4 1.4 1.4 1 0-0.1 1.4 1.1 0.9 0.8 1.8 1.7 2.6 2.6 1.8 1.9 3.5 3.9 5 6.1 5.1 7.1 9.3 14.8 13.2 22.6 3.5 6.9 13.7 4.7 15.8-2.1 2.6-8.7 4.8-17.4 7.4-26.1 0.9-3.2 1.9-6.4 3.2-9.4-0.7 1.6 0.8-1.6 1.2-2.2l0.9-1.5c0.7-1.2-1.4 0.7 0.1-0.1 1.7-0.9-1.2 0.3-0.3 0.1 0.8-0.2 1-1.2 0.3-0.3-0.6 0.8 0.6 0-0.5 0.2-2 0.3 2.4 0.5-1.1 0 0.5 0.1 1.2 0.2 1.6 0.4-1.1-0.8-0.8-0.4 0.2 0.2 0.7 0.4 3.4 2.3 2.7 1.8 8.9 7.1 15.9 16.9 22.5 26 2.8 3.8 7.5 5.6 11.8 3.1 3.7-2.2 5.9-8 3.1-11.8-8.2-11.1-16.6-23-27.7-31.4-6.3-4.7-14.5-7.6-21.7-3-6.7 4.2-9.6 12.5-11.9 19.6-3.2 9.9-5.5 20-8.6 29.9 5.3-0.7 10.5-1.4 15.8-2.1-7.8-15.5-24.8-50.1-48-41.7-14.1 5.1-19.7 23-22.9 36.2-0.9 3.8-1.8 7.7-2.3 11.6-0.6 4.6 1.1 9.3 6 10.6 4.2 1 10.2-1.5 10.8-6.1z" fill="#040000" p-id="2478"></path></svg>`
      },
      {
        name: "12",
        icon: `<svg t="1624457847424" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2632" ><path d="M485.538528 993.072489a362.00362 481.804818 3.149 1 0 52.933731-962.15464 362.00362 481.804818 3.149 1 0-52.933731 962.15464Z" fill="#AADCF0" p-id="2633"></path><path d="M688.2 334.1c-15.1 7.6-30.2 15.6-44.3 25-5.9 3.9-17 10.4-14.6 19.1 1.8 6.5 12 11.2 17.3 14.3 15.7 9.3 32.1 17.6 48.3 25.9 8.6 4.4 16.2-8.5 7.6-13-14.1-7.3-28.3-14.5-42.1-22.3-3.9-2.2-7.9-4.5-11.7-6.9-1.2-0.8-2.4-1.5-3.5-2.4-0.6-0.4-1.1-0.8-1.6-1.2 2.2 1.7-0.3-0.3-0.3-0.3-0.9 0.1-1.5-3.2-0.2 0.5 0.9 2.4 1.1 3.8 0.3 5.8 0.6-1.5-0.9 0.8-0.1 0 0.5-0.5 1-1.1 1.6-1.6 0.5-0.5 1-0.9 1.6-1.3 0.6-0.5 0 0 1.2-0.9 1.7-1.3 3.5-2.5 5.3-3.6 8.4-5.5 17.2-10.4 26-15.2 5.6-3 11.2-6 16.8-8.9 8.6-4.4 1-17.4-7.6-13zM375.8 347c13.4 6.8 26.7 14 39.5 21.9 1.8 1.2 3.7 2.3 5.5 3.5 0.9 0.6 1.7 1.2 2.6 1.8 0.9 0.6 1.9 1.4 1.6 1.1 1.1 0.9 2.1 1.9 3.1 2.8 1.2 1 0-0.3 0.1 0 0-0.2-0.8-2.4-0.3-4.1 1.5-5.5 2.3-2.7 0.8-2-0.4 0.2-0.9 0.8-1.3 1.1 1.7-1.4-1.6 1.1-2.3 1.6-3.4 2.3-6.9 4.4-10.4 6.4-14.9 8.6-30.3 16.4-45.6 24.3-8.6 4.4-1 17.4 7.6 13 15-7.7 30.1-15.4 44.8-23.8 6.2-3.6 13.8-7.3 18.7-12.7 7.6-8.3-3.8-16.6-9.9-20.9-8.7-6.1-18-11.3-27.3-16.4-6.5-3.6-13-7.1-19.6-10.4-8.6-4.5-16.3 8.5-7.6 12.8zM412.8 570.9c13.5 7.7 28.5 13.3 43.3 17.9 29.8 9.2 61.7 13.1 92.6 7.3 20.6-3.9 40-12.5 56.6-25.2 2.8-2.2 4.3-5.6 2.3-9-1.6-2.8-6.2-4.5-9-2.3-48.3 36.9-113.3 30-165.6 6.7-4.6-2.1-9.2-4.2-13.7-6.7-7.3-4.2-13.9 7.2-6.5 11.3z" fill="#040000" p-id="2634"></path><path d="M644.6 505.2c-30.1 21.5-60.6 62.5-39.1 99.8 10.7 18.6 30.3 30.9 49.1 40.1 7.8 3.8 14.6-7.9 6.8-11.7-23.6-11.5-53.7-31.4-49.4-60.9 2.8-18.9 15.8-34.6 29.5-47.2 2.5-2.3 5.1-4.6 7.8-6.7 0.5-0.4 0.9-0.7 1.4-1.1-0.4 0.3-1.2 0.9-0.1 0.1l0.9-0.6c6.9-5.1 0.2-16.8-6.9-11.8z" fill="#040000" p-id="2635"></path></svg>`
      },
      {
        name: "13",
        icon: `<svg t="1624457855182" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2789" ><path d="M235.1 76.9c75.6-26.5 297.3-90.1 514.2-16.6 16.3 5.5 29.8 17.4 37.1 33 57.5 122.4 127.1 602.1 62.1 785.6a62.58 62.58 0 0 1-32.5 35.8c-109.5 51.8-428.1 136.7-609.3 37.2-14.4-7.9-25-21.3-29.7-37.1-41.9-140.6-37-627.7 19.1-798 6.1-18.7 20.5-33.4 39-39.9z" fill="#F9DABD" p-id="2790"></path><path d="M392.2 360.2m-35.2 0a35.2 35.2 0 1 0 70.4 0 35.2 35.2 0 1 0-70.4 0Z" fill="#040000" p-id="2791"></path><path d="M618.6 360.2m-35.2 0a35.2 35.2 0 1 0 70.4 0 35.2 35.2 0 1 0-70.4 0Z" fill="#040000" p-id="2792"></path><path d="M512 562.6c-36 0-65.3-29.3-65.3-65.3S476 432 512 432s65.3 29.3 65.3 65.3-29.3 65.3-65.3 65.3z m0-122.9c-31.7 0-57.6 25.8-57.6 57.6s25.8 57.6 57.6 57.6c31.7 0 57.6-25.8 57.6-57.6s-25.9-57.6-57.6-57.6z" fill="#040000" p-id="2793"></path></svg>`
      },
      {
        name: "14",
        icon: `<svg t="1624457863444" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2947" ><path d="M178.1 971.5c38.1 15.9 98.7 26.6 171.3-12.3 3.7-2 8.4-1.6 11.6 1.1 43.3 35.9 123.3 80.8 236 10.9 3.8-2.4 8.7-2.4 12.6-0.2 41.8 23.9 191.6 58.2 246.6 14.2 4.4-3.5 9.1-6.6 14.5-8.5C1065 909.5 678.2-652 194.3 351c-37.5 77.8-38.4 94.1-71.9 211.3-27.6 96.3-29.1 231.3 1.4 348.1 7.2 27.3 27.3 49.9 54.3 61.1z" fill="#ABAAAA" p-id="2948"></path><path d="M468.9 349H418c-6.1 0-11.1-5-11.1-11.1V336c0-6.1 5-11.1 11.1-11.1h50.9c6.1 0 11.1 5 11.1 11.1v1.9c0 6.1-5 11.1-11.1 11.1zM643 471.9H390c-6.6 0-12-5.4-12-12s5.4-12 12-12h253c6.6 0 12 5.4 12 12s-5.4 12-12 12zM609 349h-61.2c-6 0-11-4.9-11-11v-2.1c0-6 4.9-11 11-11H609c6 0 11 4.9 11 11v2.1c0 6.1-4.9 11-11 11z" fill="#040000" p-id="2949"></path></svg>`
      },
      {
        name: "15",
        icon: `<svg t="1624457870536" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3103" ><path d="M673.1 318.7c3.7-17.5 5.6-35.7 5.6-54.4 0-137.9-105.5-249.7-235.6-249.7S207.4 126.4 207.4 264.3c0 55.4 17.1 106.7 45.9 148.1-55.2 63.3-88.6 145.9-88.6 236.3 0 199.2 162.1 360.6 362.1 360.6 200 0 362.1-161.5 362.1-360.6 0.1-147.3-88.7-274-215.8-330z" fill="#4F8A54" p-id="3104"></path><path d="M392 246.2m-47.1 0a47.1 47.1 0 1 0 94.2 0 47.1 47.1 0 1 0-94.2 0Z" fill="#FFFFFF" p-id="3105"></path><path d="M386 252.8m-26.4 0a26.4 26.4 0 1 0 52.8 0 26.4 26.4 0 1 0-52.8 0Z" fill="#040000" p-id="3106"></path><path d="M505.6 246.2m-47.1 0a47.1 47.1 0 1 0 94.2 0 47.1 47.1 0 1 0-94.2 0Z" fill="#FFFFFF" p-id="3107"></path><path d="M501.4 252.8m-26.4 0a26.4 26.4 0 1 0 52.8 0 26.4 26.4 0 1 0-52.8 0Z" fill="#040000" p-id="3108"></path><path d="M474.3 364.8h-50.9c-6.1 0-11.1-5-11.1-11.1v-1.9c0-6.1 5-11.1 11.1-11.1h50.9c6.1 0 11.1 5 11.1 11.1v1.9c0 6.2-5 11.1-11.1 11.1z" fill="#040000" p-id="3109"></path></svg>`
      },
      {
        name: "16",
        icon: `<svg t="1624457876371" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3263" ><path d="M246.4 227.6c-166.9 101.1-461.9 344 87 564.1 1.5 0.6 2.9 1.1 4.4 1.6 80.7 27.7 392.8 165.4 641-198.1 40-58.6 38.5-136.2-3.7-193.3C892 289.5 727 201.1 429.1 182.7c-64.1-4-127.8 11.6-182.7 44.9z" fill="#CF92BE" p-id="3264"></path><path d="M617.1 393.4c-17.4 8.8-34.9 18.1-51.2 28.9-6.9 4.6-20.3 12.3-17.4 22.6 1.2 4.3 5.6 7 9 9.5 3.7 2.7 7.6 5 11.5 7.3 18.2 10.8 37.1 20.3 55.9 30 10 5.1 18.9-10 8.8-15.1-16.4-8.4-32.9-16.9-49-26-4.5-2.6-9.1-5.2-13.5-8l-4.5-3c-0.7-0.5-1.3-1-2-1.5 1.6 1.2 0.7 0.4-0.2-0.2-1.3-0.9-0.3-0.9-0.5-0.3 0.2 0.2 0.4 0.5 0.6 0.7 1 1.9 1.3 3.7 0.8 5.7 0.1-0.6 0.7-1.4-0.6 1.3 0.7-1.5-0.1 0-0.2 0.1 0.6-0.6 1.2-1.3 1.9-1.9l1.8-1.5c1.8-1.6-0.6 0.3 1.2-0.9 2-1.5 4.1-2.9 6.2-4.3 10-6.5 20.4-12.4 30.9-18 6.5-3.5 13.1-7 19.7-10.4 9.6-5 0.8-20.1-9.2-15zM323.1 408.5c15.9 8.1 31.7 16.5 46.8 26 2.2 1.4 4.3 2.8 6.5 4.2 1 0.7 1.9 1.3 2.8 2 0.5 0.3 1 0.7 1.4 1.1-1.1-0.9-0.3-0.3 0.3 0.3 1.1 1 2.2 2.2 3.3 3.1 1.4 1.1-1-1.7-0.1-0.1-0.6-1.1-0.9-4.1 0.3-6.7 2.2-4.8 0.7 0.1 0-0.5 0 0-1.1 0.9-1.3 1 2.3-1.9 0 0-0.5 0.4-0.8 0.5-1.5 1.1-2.3 1.6-4 2.7-8.1 5.1-12.3 7.5-17.3 10-35.1 19.1-52.8 28.2-10 5.1-1.2 20.2 8.8 15.1 17.5-9 35-17.9 52-27.7 7.3-4.2 15.9-8.6 21.8-14.7 9.3-9.7-4.3-19.7-11.5-24.7-10.1-7.1-20.9-13.1-31.7-19-7.6-4.2-15.2-8.2-22.9-12.1-9.7-5.2-18.6 9.9-8.6 15zM513 592.1c-12.2 0-24.6-1.4-36.3-4.3-8-2-13.9-8.2-15.4-16.2s1.7-15.8 8.4-20.5c23.2-16.3 60.5-31.9 106.2-13 6.4 2.6 11 8.3 12.3 15.1 1.3 6.7-0.8 13.6-5.7 18.3-13.5 13.1-40.9 20.6-69.5 20.6z m-37.4-32.5c-3.4 2.4-4.9 6.2-4.2 10.2 0.8 4.1 3.6 7.1 7.7 8.1 39.1 9.7 81.2 0.7 96.1-13.7 2.4-2.3 3.4-5.6 2.7-8.9-0.7-3.4-2.9-6.2-6.1-7.5-41.2-17.2-75.1-3.1-96.2 11.8z" fill="#040000" p-id="3265"></path></svg>`
      },
      {
        name: "17",
        icon: `<svg t="1624457881793" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3419" ><path d="M1008.6 465.7c0-124.9-95.5-226.2-213.4-226.2-12 0-23.8 1.1-35.2 3.1v-3.1c0-124.9-95.5-226.2-213.4-226.2S333.4 114.6 333.4 239.5c0 2.4 0 4.8 0.1 7.2-17.1-4.7-35-7.2-53.4-7.2-117.8 0-213.4 101.3-213.4 226.2 0 92.1 51.9 171.3 126.3 206.6-13.7 29.9-21.4 63.4-21.4 98.8 0 124.9 95.5 226.2 213.4 226.2 68.8 0 130-34.5 169-88.1 39 53.6 100.2 88.1 169 88.1 117.8 0 213.4-101.3 213.4-226.2 0-41.2-10.4-79.9-28.6-113.1 60.5-39.9 100.8-111.1 100.8-192.3z" fill="#8CC66D" p-id="3420"></path><path d="M437.8 400.7m-24.7 0a24.7 24.7 0 1 0 49.4 0 24.7 24.7 0 1 0-49.4 0Z" fill="#040000" p-id="3421"></path><path d="M649.7 400.7m-24.7 0a24.7 24.7 0 1 0 49.4 0 24.7 24.7 0 1 0-49.4 0Z" fill="#040000" p-id="3422"></path><path d="M527.3 625.9c6.3-14.2 13.1-28.3 17.9-43 6.2-19 8.3-38.6 10.5-58.3l2.1-19.2c0.7-6.2-9-6.1-9.7 0-1.7 16.3-2.8 32.8-5.7 48.9-4.2 23.7-13.8 45-23.5 66.7-2.5 5.6 5.9 10.5 8.4 4.9z" fill="#252525" p-id="3423"></path><path d="M447.7 522.3c20.3-0.1 40.6-0.2 61-0.4l96.6-0.6c7.5 0 14.9-0.1 22.4-0.1 16.6-0.1 16.7-25.9 0-25.8-20.3 0.1-40.6 0.2-61 0.4l-96.6 0.6c-7.5 0-14.9 0.1-22.4 0.1-16.6 0.1-16.7 25.9 0 25.8z" fill="#040000" p-id="3424"></path><path d="M495.4 508.2c-10.3 3.8-9.2 20.9-9.2 29.5 0.1 16 2.1 32.3 6.1 47.8 3.5 13.7 8.7 29.9 20.6 38.7 12.9 9.5 27.6 2.1 37.6-7.9 10.2-10.3 17.8-23 24.7-35.6 11.6-21.3 20.9-43.8 29.7-66.4 3-7.8-9.5-11.1-12.5-3.4-7.4 19.1-15.3 38.1-24.7 56.4-5.9 11.5-12.2 23-20.3 33.1-2.8 3.5-5.8 6.9-9.2 9.8-1.9 1.7-1.4 1.3-3.3 2.5-1.3 0.8-2.6 1.6-3.9 2.2-0.7 0.3 1-0.2-0.8 0.3-0.6 0.2-1.2 0.3-1.8 0.5-1.1 0.3-1.2 0.2-0.5 0.1-0.6 0-1.3 0-1.9 0.1-2.2 0.1 0.6 0.5-1.8-0.2l-1.8-0.6c1.5 0.5 0.2 0.1-0.5-0.3-0.8-0.5-2.9-2.1-1.7-1.1-1-0.9-2-1.7-2.8-2.7-0.4-0.5-0.9-1-1.3-1.5 0.4 0.5 0.1 0.2-0.5-0.7-0.8-1.3-1.7-2.5-2.4-3.9-0.7-1.3-1.4-2.5-2-3.8-0.4-0.8-0.8-1.6-1.1-2.4-0.1-0.2-0.5-1.1 0 0l-0.6-1.5a86.8 86.8 0 0 1-3.3-9.8c-4.4-14.9-6.2-27.9-6.8-42.8-0.3-6.6-0.3-13.1 0.4-19.7 0.2-1.5-0.3 1.5 0.1-0.5l0.3-1.8c0.2-0.9 0.5-1.8 0.7-2.8 0.4-1.9-0.7 1.1 0.3-0.7 0.5-1-1.3 1.2-0.3 0.5-0.3 0.3-1.1 0.8-2 1.1 7.7-2.9 4.3-15.4-3.5-12.5z" fill="#040000" p-id="3425"></path></svg>`
      },
      {
        name: "18",
        icon: `<svg t="1624457899440" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3579" ><path d="M75.4 739.8c-78.7-134.4-194-455.7 401.4-579.6 9.8-2 19.2-6.2 29.2-7.5C656.8 133 947.3 205 1000.1 578.4c42.6 223.8 29.7 392.1-822 233.6-43.1-8-80.6-34.4-102.7-72.2z" fill="#F09495" p-id="3580"></path><path d="M704.6 875.4c-129 0-301.8-20.5-526.6-62.3-43.5-8.1-81.2-34.6-103.5-72.7-19.3-32.9-44.8-84.3-57.1-142.5-13.9-65.1-8.8-125.3 15.1-179.2 54.3-122.3 203.7-209.6 444-259.6 4.1-0.9 8.3-2.1 12.3-3.4 5.5-1.7 11.1-3.4 16.9-4.2 29-3.8 75.7-5.9 133.8 5.7 54.5 10.9 105.3 31 150.8 59.9C843.7 251 888.2 296 922.7 351c39.7 63.1 66.1 139.6 78.5 227.3 8.1 42.4 15.2 87.3 12.5 127.9-2.8 42.6-16.4 75.5-41.5 100.7-42.5 42.7-120.3 65-237.8 68.1-9.6 0.2-19.6 0.4-29.8 0.4zM76.3 739.3c22 37.6 59.2 63.7 102.1 71.7 242.5 45.1 424.4 65.3 556.1 61.9 116.9-3.1 194.1-25.2 236.3-67.5 55.4-55.6 44.4-142.5 28.3-226.7C976 415.8 903.4 291.5 789.2 219c-124-78.7-248.1-69.9-283.2-65.3-5.6 0.7-11.2 2.4-16.6 4.1-4.1 1.2-8.3 2.5-12.5 3.4C237.3 211.1 88.5 298 34.5 419.6c-54.6 122.8 2.8 253 41.8 319.7z" fill="#FFFFFF" p-id="3581"></path><path d="M424.1 442.5m-24.7 0a24.7 24.7 0 1 0 49.4 0 24.7 24.7 0 1 0-49.4 0Z" fill="#040000" p-id="3582"></path><path d="M635.9 442.5m-24.7 0a24.7 24.7 0 1 0 49.4 0 24.7 24.7 0 1 0-49.4 0Z" fill="#040000" p-id="3583"></path><path d="M426.2 543.3c17.1 7.9 36.6 26 25.5 46.1-6.9 12.5-19.8 21.2-31.7 28.4-4.5 2.7-0.4 9.8 4.1 7.1 17.4-10.5 41.6-27.6 39-51.1-1.6-14-12.4-24.8-23.5-32.3-3-2-6.1-3.9-9.3-5.4-4.8-2.1-8.9 5-4.1 7.2zM629.5 535.4c-21.8 11.7-40.6 37-25.7 61.3 8.2 13.4 22.2 22.7 35.7 30.3 4.7 2.7 8.9-4.6 4.2-7.2-15.5-8.7-39.9-23.9-36.9-45.2 1.6-11.4 10.7-20.7 19.6-27.2 2.4-1.7 4.8-3.4 7.4-4.8 4.7-2.5 0.4-9.8-4.3-7.2z" fill="#040000" p-id="3584"></path><path d="M457.2 584.6c25.6 25.6 66.7 41 101.8 28.3 18.2-6.6 33.2-19.1 45.5-33.8 4.2-5.1-3-12.4-7.3-7.3-18.5 22-43.3 38.1-73 35-18.6-1.9-36.2-10.8-50.9-22-2.9-2.2-6.1-4.8-8.8-7.5-4.7-4.7-12 2.6-7.3 7.3z" fill="#040000" p-id="3585"></path></svg>`
      },
      {
        name: "19",
        icon: `<svg t="1624457904464" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3739" ><path d="M915.9 510.5c8.4-19 13.1-39.8 13.1-61.7 0-90-78.9-162.9-176.2-162.9-3.2 0-6.3 0.1-9.5 0.2v-0.2c0-94.8-116.2-171.6-259.6-171.6S224 191.2 224 286v2c-96.2 0-174.1 72-174.1 160.9 0 38 14.3 73 38.2 100.5-41.8 29.4-68.8 75.9-68.8 128.2 0 88.9 78 160.9 174.1 160.9 17.1 0 33.6-2.3 49.3-6.5 28.9 46.1 88.7 77.7 157.6 77.7 49.4 0 94-16.2 126-42.3 32 26.1 76.6 42.3 126 42.3 77.3 0 143-39.7 166.7-95 3.1 0.2 6.3 0.2 9.5 0.2 97.3 0 176.2-72.9 176.2-162.9 0-60.6-35.7-113.4-88.8-141.5z" fill="#5A74B8" p-id="3740"></path><path d="M357.6 449.5a46.6 73.2 0 1 0 93.2 0 46.6 73.2 0 1 0-93.2 0Z" fill="#FEFEFD" p-id="3741"></path><path d="M357.5 449.5a25.1 39.4 0 1 0 50.2 0 25.1 39.4 0 1 0-50.2 0Z" fill="#040000" p-id="3742"></path><path d="M531.3 449.5a46.6 73.2 0 1 0 93.2 0 46.6 73.2 0 1 0-93.2 0Z" fill="#FEFEFD" p-id="3743"></path><path d="M531.2 449.5a25.1 39.4 0 1 0 50.2 0 25.1 39.4 0 1 0-50.2 0Z" fill="#040000" p-id="3744"></path><path d="M426.7 574.6c20.9 29.9 59.7 52.2 96.2 38.6 19.2-7.2 34.7-21.2 47.6-36.9 2.8-3.5 3.4-8.3 0-11.7-2.9-2.9-8.9-3.5-11.7 0-16.5 20.2-40.9 40.9-68.1 35.5-17.3-3.4-31-13.2-42.9-25.9-2-2.2-3.9-4.4-5.8-6.7-1.6-1.9 1.1 1.5-0.4-0.6-0.2-0.2-0.3-0.5-0.5-0.7-6.2-8.7-20.6-0.4-14.4 8.4z" fill="#040000" p-id="3745"></path></svg>`
      },
      {
        name: "20",
        icon: `<svg t="1624457910321" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3899" ><path d="M792.8 301.4c-8.2 0-16.2 0.4-24.2 1.3-12.3-81.8-129.2-145.9-271.8-145.9-137.1 0-250.5 59.3-269.9 136.6C105.3 295.5 7.4 391.2 7.4 508.9c0 119.1 100.2 215.6 223.7 215.6 5.3 0 10.6-0.2 15.8-0.5 14.4 80.5 130.4 143.2 271.3 143.2 135.9 0 248.6-58.3 269.4-134.6 1.7 0 3.4 0.1 5.1 0.1 123.6 0 223.7-96.5 223.7-215.6s-100-215.7-223.6-215.7z" fill="#F6CD50" p-id="3900"></path><path d="M435.9 431.5m-52.2 0a52.2 52.2 0 1 0 104.4 0 52.2 52.2 0 1 0-104.4 0Z" fill="#FAFAFA" p-id="3901"></path><path d="M588.1 431.5m-52.2 0a52.2 52.2 0 1 0 104.4 0 52.2 52.2 0 1 0-104.4 0Z" fill="#FAFAFA" p-id="3902"></path><path d="M435.9 431.5m-27.8 0a27.8 27.8 0 1 0 55.6 0 27.8 27.8 0 1 0-55.6 0Z" fill="#040000" p-id="3903"></path><path d="M601.9 407.4c-5.7 2.9-11.3 5.9-16.9 9-6.8 3.8-15.3 7.8-20.5 13.8-5.6 6.5 1.6 11.1 6.7 14.4 11.2 7.1 23.3 13 35.1 19 5.7 2.9 10.8-5.7 5.1-8.6-10.9-5.6-21.9-11.1-32.4-17.4-2.4-1.4-4.6-3.1-7-4.6 1 0.6-0.4-0.4-0.4-0.4-1.9-0.3-0.5 4.2 0.5 4.1-0.1 0-0.6 0.3 0.3-0.3 0.5-0.3 1-0.9 1.5-1.3 9.7-7.9 21.9-13.5 33.1-19.2 5.7-2.7 0.6-11.4-5.1-8.5zM406.6 547.6c11.5 14.4 27 26.7 42.7 36.3 32.2 19.8 71.2 27.2 107.6 15.4 29.5-9.6 54.6-29.1 75.5-51.6 10.8-11.6-6.6-29.1-17.5-17.5-9.4 10.1-19.5 19.7-30.8 27.7-4.6 3.2-9.3 6.2-14.2 8.9-5 2.8-9.9 5.1-14.1 6.7-4.6 1.7-9.3 3.2-14.1 4.4-2.2 0.5-4.4 1-6.6 1.4-1 0.2-2 0.3-2.9 0.5 2.6-0.4-2.1 0.2-2.5 0.3-4.1 0.4-8.3 0.5-12.5 0.4-2.2-0.1-4.4-0.2-6.6-0.4-1.1-0.1-2.2-0.2-3.2-0.3-1.5-0.2-1.4-0.2 0.1 0l-2.1-0.3c-7.8-1.3-15.4-3.4-22.8-6.2-0.9-0.4-1.8-0.7-2.8-1.1-3.1-1.2 2.3 1.1-0.7-0.3-1.5-0.7-2.9-1.3-4.4-2-3.7-1.8-7.2-3.7-10.8-5.8-5.7-3.4-11.1-7.1-16.4-11.1 3 2.3-1.1-0.9-1.8-1.5-1.1-0.9-2.1-1.7-3.1-2.6-2.1-1.8-4.2-3.7-6.3-5.6-4.4-4.1-8.7-8.4-12.4-13.1-4.2-5.2-13.1-4.3-17.5 0-5 5.1-4 12.2 0.2 17.4z" fill="#040000" p-id="3904"></path></svg>`
      }
    ]
  },
  {
    name: "\u6807\u8BB0\u56FE\u6807",
    type: "sign",
    list: [
      {
        name: "1",
        icon: `<svg viewBox="0 0 1024 1024"><path d="M512 512m-512 0a512 512 0 1 0 1024 0 512 512 0 1 0-1024 0Z" fill="#6D768D"></path><path d="M809.728 429.696a18.901333 18.901333 0 0 0-15.274667-12.885333l-183.466666-26.624-81.92-166.272a18.901333 18.901333 0 0 0-34.005334 0l-81.92 166.272-183.594666 26.624a19.029333 19.029333 0 0 0-10.496 32.298666l132.693333 129.536-31.274667 182.741334a18.816 18.816 0 0 0 27.477334 19.84l164.138666-86.186667 164.096 86.058667a18.773333 18.773333 0 1 0 27.434667-19.84l-31.36-182.741334 132.693333-129.408a18.901333 18.901333 0 0 0 4.778667-19.413333z" fill="#FFFFFF"></path></svg>`
      },
      {
        name: "2",
        icon: `<svg viewBox="0 0 1024 1024"><path d="M512 512m-512 0a512 512 0 1 0 1024 0 512 512 0 1 0-1024 0Z" fill="#6D768D"></path><path d="M644.565333 306.901333c32.128 0 65.834667-5.76 101.077334-17.237333a17.066667 17.066667 0 0 1 22.357333 16.213333v328.32c-1.109333 0.768 10.325333 27.093333-99.370667 19.84-109.653333-7.210667-181.76-45.098667-246.869333-45.098666-65.152 0-49.322667 2.688-74.154667 8.405333v168.064a24.746667 24.746667 0 0 1-24.490666 25.258667 22.528 22.528 0 0 1-17.28-7.253334 24.149333 24.149333 0 0 1-7.168-18.005333V281.258667C299.776 280.490667 328.106667 256 421.76 256s164.437333 50.901333 222.805333 50.901333z" fill="#FFFFFF"></path></svg>`
      },
      {
        name: "3",
        icon: `<svg viewBox="0 0 1024 1024"><path d="M512 512m-512 0a512 512 0 1 0 1024 0 512 512 0 1 0-1024 0Z" fill="#6D768D"></path><path d="M524.074667 225.408l274.517333 274.517333a17.066667 17.066667 0 0 1 0 24.149334l-274.517333 274.517333a17.066667 17.066667 0 0 1-24.149334 0l-274.517333-274.517333a17.066667 17.066667 0 0 1 0-24.149334l274.517333-274.517333a17.066667 17.066667 0 0 1 24.149334 0z" fill="#FFFFFF"></path></svg>`
      },
      {
        name: "4",
        icon: `<svg viewBox="0 0 1024 1024"><path d="M512 512m-512 0a512 512 0 1 0 1024 0 512 512 0 1 0-1024 0Z" fill="#6D768D"></path><path d="M317.866667 300.8h388.266666c9.386667 0 17.066667 7.68 17.066667 17.066667v388.266666a17.066667 17.066667 0 0 1-17.066667 17.066667h-388.266666a17.066667 17.066667 0 0 1-17.066667-17.066667v-388.266666c0-9.386667 7.68-17.066667 17.066667-17.066667z" fill="#FFFFFF"></path></svg>`
      },
      {
        name: "5",
        icon: `<svg viewBox="0 0 1024 1024"><path d="M512 512m-512 0a512 512 0 1 0 1024 0 512 512 0 1 0-1024 0Z" fill="#6D768D"></path><path d="M498.346667 279.082667L248.789333 701.44a15.829333 15.829333 0 0 0 13.653334 23.893333h499.114666a15.829333 15.829333 0 0 0 13.653334-23.893333l-249.6-422.357333a15.829333 15.829333 0 0 0-27.264 0z" fill="#FFFFFF"></path></svg>`
      },
      {
        name: "6",
        icon: `<svg viewBox="0 0 1024 1024"><path d="M512 512m-512 0a512 512 0 1 0 1024 0 512 512 0 1 0-1024 0Z" fill="#6D768D"></path><path d="M497.749333 798.549333l-31.445333-28.501333C313.941333 631.722667 213.333333 540.501333 213.333333 428.8a160.981333 160.981333 0 0 1 162.730667-162.730667c51.498667 0 100.906667 23.978667 133.12 61.696a177.536 177.536 0 0 1 133.162667-61.696 160.981333 160.981333 0 0 1 162.730666 162.730667c0 111.701333-100.608 202.965333-252.970666 341.333333l-31.445334 28.458667a17.066667 17.066667 0 0 1-22.912 0z" fill="#FFFFFF"></path><path d="M634.538667 487.808L555.050667 426.24 507.306667 256a201.002667 201.002667 0 0 0-23.594667 20.394667l-0.256-0.256L525.653333 426.666667l-133.290666 59.946666a14.08 14.08 0 0 0-8.021334 15.957334l28.757334 126.378666a14.208 14.208 0 0 0 27.733333-6.229333l-26.24-115.114667 126.037333-56.704 76.416 59.136a14.250667 14.250667 0 0 0 19.968-2.474666 14.08 14.08 0 0 0-2.474666-19.797334z" fill="#6D768D"></path></svg>`
      },
      {
        name: "7",
        icon: `<svg viewBox="0 0 1024 1024"><path d="M512 512m-512 0a512 512 0 1 0 1024 0 512 512 0 1 0-1024 0Z" fill="#6D768D"></path><path d="M497.749333 798.549333l-31.445333-28.501333C313.941333 631.722667 213.333333 540.501333 213.333333 428.8a160.981333 160.981333 0 0 1 162.730667-162.730667c51.498667 0 100.906667 23.978667 133.12 61.696a177.536 177.536 0 0 1 133.162667-61.696 160.981333 160.981333 0 0 1 162.730666 162.730667c0 111.701333-100.608 202.965333-252.970666 341.333333l-31.445334 28.458667a17.066667 17.066667 0 0 1-22.912 0z" fill="#FFFFFF"></path></svg>`
      },
      {
        name: "8",
        icon: `<svg viewBox="0 0 1024 1024"><path d="M512 512m-512 0a512 512 0 1 0 1024 0 512 512 0 1 0-1024 0Z" fill="#6D768D"></path><path d="M374.656 273.194667c5.973333 4.48 12.117333 9.6 18.346667 15.36 6.272 5.717333 11.904 12.373333 16.896 19.84 2.517333 4.010667 5.504 8.490667 9.002666 13.482666a529.493333 529.493333 0 0 1 20.266667 32.213334h155.221333a169.813333 169.813333 0 0 0 9.770667-15.744c2.474667-4.48 5.248-8.96 8.234667-13.482667a460.842667 460.842667 0 0 1 23.253333-31.829333c4.992-6.229333 12.245333-12.373333 21.76-18.346667a34.261333 34.261333 0 0 0 10.112-9.728 31.274667 31.274667 0 0 0 5.248-11.989333 18.56 18.56 0 0 0-1.536-11.605334 17.664 17.664 0 0 0-10.112-8.618666c-4.48-1.493333-8.362667-2.005333-11.605333-1.493334a46.933333 46.933333 0 0 0-9.770667 2.602667c-3.242667 1.28-6.613333 2.645333-10.112 4.138667a32.426667 32.426667 0 0 1-12.757333 2.261333 26.026667 26.026667 0 0 1-12.373334-2.645333 45.653333 45.653333 0 0 1-8.96-6.357334l-8.661333-7.850666a30.336 30.336 0 0 0-11.989333-6.4c-9.984-3.968-18.005333-4.693333-24.021334-2.218667-5.973333 2.474667-11.946667 6.485333-17.962666 11.946667a88.618667 88.618667 0 0 1-11.989334 10.496 7.338667 7.338667 0 0 1-3.754666 1.493333 46.165333 46.165333 0 0 1-8.277334-5.205333 71.808 71.808 0 0 1-7.125333-4.906667 37.973333 37.973333 0 0 1-6.4-6.357333c-3.968-3.968-9.941333-6.613333-17.92-7.850667a31.061333 31.061333 0 0 0-21.76 4.138667c-8.533333 5.461333-14.506667 10.069333-18.048 13.824a29.354667 29.354667 0 0 1-15.744 7.893333 23.978667 23.978667 0 0 1-13.098667-0.768 987.733333 987.733333 0 0 0-14.634666-4.48 80.725333 80.725333 0 0 0-14.250667-2.986667 16.768 16.768 0 0 0-11.989333 2.986667c-6.997333 5.461333-9.258667 12.074667-6.741334 19.84a34.56 34.56 0 0 0 13.482667 18.346667z" fill="#FFFFFF"></path><path d="M780.757333 545.152a219.306667 219.306667 0 0 0-19.882666-65.536 224.981333 224.981333 0 0 0-33.365334-49.792 430.336 430.336 0 0 0-37.12-37.12c-14.506667-11.946667-27.264-23.296-38.272-34.048a544.512 544.512 0 0 1-27.733333-28.842667 305.28 305.28 0 0 1-22.485333-26.197333h-168.746667c-6.485333 8.490667-13.994667 17.493333-22.485333 26.965333a360.96 360.96 0 0 1-26.24 28.074667c-10.538667 10.24-22.272 21.12-35.285334 32.597333a305.493333 305.493333 0 0 0-41.6 44.16 250.026667 250.026667 0 0 0-49.493333 117.589334 216.106667 216.106667 0 0 0 1.877333 70.4 220.586667 220.586667 0 0 0 75.349334 126.549333c21.248 18.005333 47.146667 32.597333 77.653333 43.818667 30.464 11.264 65.493333 16.853333 104.96 16.853333 38.528 0 72.874667-4.864 103.125333-14.592a265.045333 265.045333 0 0 0 78.378667-39.338667c21.973333-16.469333 39.594667-35.797333 52.864-58.026666 13.226667-22.186667 22.101333-45.824 26.624-70.784 4.992-30.421333 5.632-58.026667 1.877333-82.773334z" fill="#FFFFFF"></path><path d="M593.322667 647.509333a20.48 20.48 0 0 1-11.861334 3.2h-50.133333v14.165334c0 4.266667-1.792 8.362667-5.376 12.373333a15.914667 15.914667 0 0 1-13.952 5.333333 24.917333 24.917333 0 0 1-14.336-3.882666c-3.84-2.602667-5.973333-7.210667-6.4-13.824v-14.165334h-48.725333a17.792 17.792 0 0 1-11.818667-3.882666 10.24 10.24 0 0 1-3.968-9.6c0-4.266667 1.578667-7.68 4.693333-10.24a16.768 16.768 0 0 1 11.093334-3.925334h48.682666v-24.789333h-48.682666a15.573333 15.573333 0 0 1-11.52-4.266667 13.525333 13.525333 0 0 1-4.266667-9.941333 15.36 15.36 0 0 1 4.693333-10.624 14.72 14.72 0 0 1 11.093334-4.949333h48.682666l0.725334-14.890667a1053.568 1053.568 0 0 1-40.832-42.538667l-10.752-9.898666a41.216 41.216 0 0 1-6.442667-11.690667c-1.92-4.992-0.938667-10.069333 2.858667-15.274667a13.653333 13.653333 0 0 1 15.786666-3.84c6.186667 2.090667 11.221333 4.821333 15.018667 8.106667 1.92 2.389333 5.248 5.888 10.026667 10.666667l15.061333 14.848 19.328 19.157333 22.186667-20.565333a987.605333 987.605333 0 0 1 29.397333-25.514667 21.162667 21.162667 0 0 1 14.293333-5.674667c5.290667 0 9.557333 2.133333 12.928 6.4 6.186667 7.082667 3.84 15.36-7.168 24.789334a179.072 179.072 0 0 0-12.885333 12.373333c-5.76 5.973333-11.52 11.733333-17.194667 17.408-6.698667 7.082667-14.08 14.378667-22.186666 21.973333v13.44h46.506666c6.698667 0 11.605333 1.536 14.72 4.608a14.165333 14.165333 0 0 1 4.650667 10.282667c0 4.266667-1.450667 7.936-4.309333 11.008-2.858667 3.029333-7.637333 4.352-14.336 3.84l-46.506667 0.768-0.768 24.064h45.866667c13.354667 0 20.053333 4.992 20.053333 14.933333 0.469333 4.693333-0.853333 8.106667-3.925333 10.24z" fill="#6D768D"></path></svg>`
      },
      {
        name: "9",
        icon: `<svg viewBox="0 0 1024 1024"><path d="M512 512m-512 0a512 512 0 1 0 1024 0 512 512 0 1 0-1024 0Z" fill="#6D768D"></path><path d="M512 213.333333l234.666667 341.333334h-128v213.333333h-213.333334v-213.333333h-128L512 213.333333z" fill="#FFFFFF"></path></svg>`
      },
      {
        name: "10",
        icon: `<svg viewBox="0 0 1024 1024"><path d="M512 512m-512 0a512 512 0 1 0 1024 0 512 512 0 1 0-1024 0Z" fill="#6D768D"></path><path d="M533.333333 810.666667L298.666667 469.333333h128V256h213.333333v213.333333h128l-234.666667 341.333334z" fill="#FFFFFF"></path></svg>`
      },
      {
        name: "11",
        icon: `<svg viewBox="0 0 1024 1024"><path d="M512 512m-512 0a512 512 0 1 0 1024 0 512 512 0 1 0-1024 0Z" fill="#6D768D"></path><path d="M213.333333 533.333333L554.666667 298.666667v128h213.333333v213.333333h-213.333333v128l-341.333334-234.666667z" fill="#FFFFFF"></path></svg>`
      },
      {
        name: "12",
        icon: `<svg viewBox="0 0 1024 1024"><path d="M512 512m-512 0a512 512 0 1 0 1024 0 512 512 0 1 0-1024 0Z" fill="#6D768D"></path><path d="M810.666667 533.333333L469.333333 768v-128H256v-213.333333h213.333333V298.666667l341.333334 234.666666z" fill="#FFFFFF"></path></svg>`
      },
      {
        name: "13",
        icon: `<svg viewBox="0 0 1024 1024"><path d="M0 512c0 282.752 229.248 512 512 512s512-229.248 512-512S794.752 0 512 0 0 229.248 0 512z" fill="#6D768D"></path><path d="M571.349333 508.586667l162.389334-162.346667a44.330667 44.330667 0 1 0-62.72-62.72l-162.389334 162.389333-162.517333-162.389333a44.330667 44.330667 0 1 0-62.72 62.72l162.389333 162.389333-162.389333 162.474667a44.330667 44.330667 0 1 0 62.72 62.72l162.389333-162.346667 162.389334 162.389334a44.330667 44.330667 0 1 0 62.72-62.72l-162.261334-162.56z" fill="#FFFFFF"></path></svg>`
      },
      {
        name: "14",
        icon: `<svg viewBox="0 0 1024 1024"><path d="M512 0C233.386667 0 0 225.877333 0 512s225.877333 512 512 512 512-225.877333 512-512S790.613333 0 512 0z" fill="#6D768D"></path><path d="M726.144 311.210667l-277.333333 305.066666-124.8-124.8c-13.866667-13.866667-41.6-13.866667-55.466667 0-13.866667 13.866667-13.866667 41.6 0 55.466667l159.445333 152.533333c13.866667 13.866667 41.6 13.866667 55.466667 0l305.066667-332.8c13.866667-13.866667 13.866667-41.6 0-55.466666-20.778667-13.866667-48.512-13.866667-62.378667 0z" fill="#FFFFFF"></path></svg>`
      },
      {
        name: "15",
        icon: `<svg viewBox="0 0 1024 1024"><path d="M512 512m-512 0a512 512 0 1 0 1024 0 512 512 0 1 0-1024 0Z" fill="#6D768D"></path><path d="M541.952 755.626667a40.618667 40.618667 0 0 1-29.824 12.373333 41.344 41.344 0 0 1-30.122667-12.373333 40.106667 40.106667 0 0 1-12.672-30.122667c0-11.605333 4.096-21.845333 12.672-30.122667a40.405333 40.405333 0 0 1 30.122667-12.714666c11.605333 0 21.546667 4.138667 29.824 12.714666a40.32 40.32 0 0 1 12.714667 30.122667c0 11.861333-4.096 21.76-12.714667 30.122667zM450.986667 241.28A77.866667 77.866667 0 0 1 512.256 213.333333c24.874667 0 45.354667 8.917333 61.354667 27.946667 15.488 18.432 23.722667 41.685333 23.722666 69.674667 0 23.765333-33.152 200.533333-44.672 329.045333h-80.128C463.146667 511.402667 426.666667 334.677333 426.666667 310.954667c0-27.392 8.277333-50.645333 24.32-69.674667z" fill="#FFFFFF"></path></svg>`
      },
      {
        name: "16",
        icon: `<svg viewBox="0 0 1024 1024"><path d="M512 0C229.248 0 0 229.248 0 512s229.248 512 512 512 512-229.248 512-512S794.794667 0 512 0z" fill="#6D768D"></path><path d="M490.666667 682.666667a64 64 0 1 1 0 128 64 64 0 0 1 0-128z m13.994666-490.752c61.397333 0 112.341333 14.634667 153.002667 43.946666 40.533333 29.269333 60.885333 72.618667 60.885333 130.133334 0 35.242667-12.373333 64.938667-29.952 89.045333-10.282667 14.677333-33.664 33.408-62.890666 56.192l-32.426667 22.357333c-15.701333 12.202667-29.696 26.453333-34.858667 42.666667-1.706667 5.546667-3.072 14.677333-3.968 24.533333-0.426667 4.949333-4.864 15.018667-15.232 15.018667h-83.328c-13.568 0-15.957333-10.581333-15.744-15.786667 1.493333-34.005333 4.608-64.213333 18.474667-80.469333 28.074667-32.896 91.904-73.813333 91.904-73.813333a104.106667 104.106667 0 0 0 23.552-24.021334c10.837333-14.933333 19.797333-31.317333 19.797333-49.237333 0-20.565333-6.016-39.338667-18.090666-56.32-12.032-16.938667-34.090667-25.386667-66.005334-25.386667-31.445333 0-53.76 10.410667-66.901333 31.274667-9.685333 15.445333-15.786667 29.610667-18.346667 45.013333-0.853333 5.461333-4.394667 16.981333-16.042666 16.981334H327.210667c-17.322667 0-21.12-11.221333-20.650667-16.64 6.272-68.138667 32.896-114.688 80-144.597334 32-20.565333 71.381333-30.890667 118.101333-30.890666z" fill="#FFFFFF"></path></svg>`
      },
      {
        name: "17",
        icon: `<svg viewBox="0 0 1024 1024"><path d="M512 512m-512 0a512 512 0 1 0 1024 0 512 512 0 1 0-1024 0Z" fill="#6D768D"></path><path d="M336.256 410.026667H253.312a40.021333 40.021333 0 0 0-39.850667 43.264l23.296 278.101333c1.706667 20.693333 19.072 36.608 39.850667 36.608h59.648c11.050667 0 20.010667-8.96 20.010667-19.968v-318.037333a19.968 19.968 0 0 0-20.010667-19.968z m434.432 0h-178.944C653.312 182.314667 548.949333 170.666667 548.949333 170.666667c-44.288 0-35.114667 34.986667-38.442666 40.832 0 84.48-68.010667 155.093333-101.034667 184.362666a39.552 39.552 0 0 0-13.226667 29.653334v322.56c0 11.008 8.96 19.925333 20.010667 19.925333h233.728c30.378667 0 58.154667-17.152 71.68-44.373333 18.176-36.736 40.448-90.112 54.656-133.973334 13.781333-42.410667 26.24-94.976 33.578667-131.968a39.850667 39.850667 0 0 0-39.253334-47.658666z" fill="#FFFFFF"></path></svg>`
      },
      {
        name: "18",
        icon: `<svg viewBox="0 0 1024 1024"><path d="M512 512m-512 0a512 512 0 1 0 1024 0 512 512 0 1 0-1024 0Z" fill="#6D768D"></path><path d="M796.16 413.909333c-31.146667-0.298667-115.626667-0.085333-146.858667-0.085333h-158.464c8.533333-7.68 15.914667-14.506667 23.594667-20.906667 29.781333-24.874667 25.813333-71.082667-14.208-88.874666-22.954667-10.24-44.970667-5.632-64 11.52-34.944 31.274667-69.632 62.677333-104.277333 93.994666a15.488 15.488 0 0 1-11.178667 4.437334c-11.221333-0.085333-26.88-0.128-46.933333-0.170667a17.066667 17.066667 0 0 0-17.109334 17.066667L256 719.701333a17.066667 17.066667 0 0 0 17.066667 17.152l49.578666-0.085333c3.968 0 7.466667 0.768 10.88 2.602667 15.829333 8.832 31.701333 17.493333 47.616 26.24a18.133333 18.133333 0 0 0 9.301334 2.346666h168.405333c6.186667 0 11.946667-0.981333 17.834667-2.56 29.44-7.253333 40.021333-30.293333 38.528-52.565333-0.768-9.728-4.266667-18.346667-9.984-26.24 19.626667-5.76 35.114667-16.213333 42.112-36.096 7.125333-20.394667 1.621333-38.4-12.672-53.333333 28.16-19.754667 34.858667-44.672 18.645333-75.648h140.458667c6.570667 0 13.013333-0.597333 19.370666-2.645334 31.957333-9.813333 48.810667-42.88 35.626667-71.552-10.154667-22.186667-28.629333-33.152-52.608-33.450666z" fill="#FFFFFF"></path></svg>`
      },
      {
        name: "19",
        icon: `<svg viewBox="0 0 1024 1024"><path d="M512 512m-512 0a512 512 0 1 0 1024 0 512 512 0 1 0-1024 0Z" fill="#6D768D"></path><path d="M270.506667 413.909333c31.146667-0.298667 115.626667-0.085333 146.858666-0.085333h158.464c-8.533333-7.68-15.914667-14.506667-23.594666-20.906667-29.781333-24.874667-25.813333-71.082667 14.208-88.874666 22.954667-10.24 44.970667-5.632 64 11.52 34.944 31.274667 69.632 62.677333 104.277333 93.994666 3.413333 2.986667 6.528 4.437333 11.178667 4.437334 11.221333-0.085333 26.88-0.128 46.933333-0.170667a17.066667 17.066667 0 0 1 17.109333 17.066667l0.682667 288.853333a17.066667 17.066667 0 0 1-17.066667 17.152l-49.578666-0.085333a22.101333 22.101333 0 0 0-10.88 2.602666c-15.829333 8.832-31.701333 17.493333-47.616 26.24a18.133333 18.133333 0 0 1-9.301334 2.346667h-168.405333a68.693333 68.693333 0 0 1-17.834667-2.56c-29.44-7.253333-40.021333-30.293333-38.528-52.565333 0.768-9.728 4.266667-18.346667 9.984-26.24-19.626667-5.76-35.114667-16.213333-42.112-36.096-7.125333-20.394667-1.621333-38.4 12.672-53.333334-28.16-19.754667-34.858667-44.672-18.645333-75.648H272.853333c-6.570667 0-13.013333-0.597333-19.370666-2.645333-31.957333-9.813333-48.810667-42.88-35.626667-71.552 10.154667-22.186667 28.629333-33.152 52.608-33.450667z" fill="#FFFFFF"></path></svg>`
      },
      {
        name: "20",
        icon: `<svg viewBox="0 0 1024 1024"><path d="M512 512m-512 0a512 512 0 1 0 1024 0 512 512 0 1 0-1024 0Z" fill="#6D768D"></path><path d="M667.733333 480.128H400v-111.36a97.706667 97.706667 0 0 1 97.621333-97.621333 97.706667 97.706667 0 0 1 97.578667 97.621333 28.885333 28.885333 0 0 0 57.813333 0A155.605333 155.605333 0 0 0 497.621333 213.333333a155.605333 155.605333 0 0 0-155.392 155.434667v111.36h-14.677333A28.885333 28.885333 0 0 0 298.666667 509.013333v292.010667a28.885333 28.885333 0 0 0 28.885333 28.885333h340.138667a28.885333 28.885333 0 0 0 28.928-28.885333V509.013333a28.885333 28.885333 0 0 0-28.928-28.885333z" fill="#FFFFFF"></path></svg>`
      },
      {
        name: "21",
        icon: `<svg viewBox="0 0 1024 1024"><path d="M512 512m-512 0a512 512 0 1 0 1024 0 512 512 0 1 0-1024 0Z" fill="#6D768D"></path><path d="M400.042667 437.461333v-111.36a97.706667 97.706667 0 0 1 97.621333-97.621333 97.706667 97.706667 0 0 1 97.578667 97.621333 28.885333 28.885333 0 0 0 57.813333 0A155.605333 155.605333 0 0 0 497.621333 170.666667a155.605333 155.605333 0 0 0-155.392 155.434666v111.36h-14.677333A28.885333 28.885333 0 0 0 298.666667 466.346667v292.010666a28.885333 28.885333 0 0 0 28.885333 28.885334h340.138667a28.885333 28.885333 0 0 0 28.928-28.885334V466.346667a28.885333 28.885333 0 0 0-28.928-28.885334H400.042667z" fill="#FFFFFF"></path><path d="M595.242667 437.461333v-111.36a97.706667 97.706667 0 0 0-97.621334-97.621333 97.706667 97.706667 0 0 0-97.578666 97.621333 28.885333 28.885333 0 0 1-57.813334 0A155.605333 155.605333 0 0 1 497.621333 170.666667a155.605333 155.605333 0 0 1 155.434667 155.434666v111.36h14.634667c16 0 28.928 12.928 28.928 28.885334v292.010666a28.885333 28.885333 0 0 1-28.928 28.885334H327.552A28.885333 28.885333 0 0 1 298.666667 758.357333V466.346667c0-15.957333 12.928-28.885333 28.885333-28.885334h267.690667z" fill="#FFFFFF"></path></svg>`
      },
      {
        name: "22",
        icon: `<svg viewBox="0 0 1024 1024"><path d="M511.999787 512.000213m-511.999787 0a511.999787 511.999787 0 1 0 1023.999573 0 511.999787 511.999787 0 1 0-1023.999573 0Z" fill="#6D768D"></path><path d="M381.354508 364.586941c0 54.015977 29.013321 103.935957 75.946635 130.986613a152.53327 152.53327 0 0 0 151.935936 0 151.12527 151.12527 0 0 0 75.946636-130.986613A151.594604 151.594604 0 0 0 533.333111 213.333671a151.594604 151.594604 0 0 0-151.89327 151.25327zM660.479725 498.901552a185.258589 185.258589 0 0 1-127.146614 50.346646c-49.066646 0-93.866628-19.199992-127.06128-50.346646C317.141201 544.853533 255.999893 637.440161 255.999893 744.106783c0 13.183995 10.709329 23.850657 23.978657 23.850657h506.709122a23.893323 23.893323 0 0 0 23.978657-23.893323c0-106.538622-61.098641-199.25325-150.186604-245.205232z" fill="#FFFFFF"></path></svg>`
      },
      {
        name: "23",
        icon: `<svg viewBox="0 0 1024 1024"><path d="M512 512m-512 0a512 512 0 1 0 1024 0 512 512 0 1 0-1024 0Z" fill="#6D768D"></path><path d="M445.610667 401.578667a129.322667 129.322667 0 1 0 258.645333 0 129.322667 129.322667 0 0 0-258.645333 0z m237.568 114.901333a157.354667 157.354667 0 0 1-216.362667 0 236.373333 236.373333 0 0 0-127.957333 209.706667c0 11.264 9.130667 20.394667 20.394666 20.394666h431.402667a20.394667 20.394667 0 0 0 20.394667-20.394666 236.373333 236.373333 0 0 0-127.872-209.706667zM409.813333 401.578667c0-40.362667 14.592-77.397333 38.698667-106.112a112.725333 112.725333 0 0 0-29.013333-3.925334 112.64 112.64 0 0 0-112.426667 112.469334 112.64 112.64 0 0 0 144.853333 107.648 164.693333 164.693333 0 0 1-42.112-110.08z m-18.602666 136.704a136.533333 136.533333 0 0 1-65.706667-34.474667 205.44 205.44 0 0 0-111.232 182.4c0 9.813333 7.936 17.706667 17.706667 17.706667H303.36a273.621333 273.621333 0 0 1 87.893333-165.632z" fill="#FFFFFF"></path></svg>`
      }
    ]
  }
];
var getNodeIconListIcon = (name, extendIconList = []) => {
  let arr = name.split("_");
  const iconList = mergerIconList([...nodeIconList, ...extendIconList]);
  let typeData = iconList.find((item) => {
    return item.type === arr[0];
  });
  if (typeData) {
    let typeName = typeData.list.find((item) => {
      return item.name === arr[1];
    });
    if (typeName) {
      return typeName.icon;
    }
    return "";
  } else {
    return "";
  }
};
var icons_default = {
  hyperlink,
  note,
  nodeIconList,
  getNodeIconListIcon
};

// ../simple-mind-map/src/core/render/node/nodeCreateContents.js
function createImgNode() {
  const img = this.getData("image");
  if (!img) {
    return;
  }
  const imgSize = this.getImgShowSize();
  const node3 = new Image2().load(img).size(...imgSize);
  const { defaultNodeImage } = this.mindMap.opt;
  if (defaultNodeImage) {
    const imgEl = new Image();
    imgEl.onerror = () => {
      node3.load(defaultNodeImage);
    };
    imgEl.src = img;
  }
  if (this.getData("imageTitle")) {
    node3.attr("title", this.getData("imageTitle"));
  }
  node3.on("dblclick", (e2) => {
    this.mindMap.emit("node_img_dblclick", this, e2);
  });
  node3.on("mouseenter", (e2) => {
    this.mindMap.emit("node_img_mouseenter", this, node3, e2);
  });
  node3.on("mouseleave", (e2) => {
    this.mindMap.emit("node_img_mouseleave", this, node3, e2);
  });
  node3.on("mousemove", (e2) => {
    this.mindMap.emit("node_img_mousemove", this, node3, e2);
  });
  return {
    node: node3,
    width: imgSize[0],
    height: imgSize[1]
  };
}
function getImgShowSize() {
  const { custom, width: width2, height: height2 } = this.getData("imageSize");
  if (custom)
    return [width2, height2];
  return resizeImgSize(
    width2,
    height2,
    this.mindMap.themeConfig.imgMaxWidth,
    this.mindMap.themeConfig.imgMaxHeight
  );
}
function createIconNode() {
  let _data = this.getData();
  if (!_data.icon || _data.icon.length <= 0) {
    return [];
  }
  let iconSize = this.mindMap.themeConfig.iconSize;
  return _data.icon.map((item) => {
    let src = icons_default.getNodeIconListIcon(
      item,
      this.mindMap.opt.iconList || []
    );
    let node3 = null;
    if (/^<svg/.test(src)) {
      node3 = SVG(src);
    } else {
      node3 = new Image2().load(src);
    }
    node3.size(iconSize, iconSize);
    node3.on("click", (e2) => {
      this.mindMap.emit("node_icon_click", this, item, e2);
    });
    return {
      node: node3,
      width: iconSize,
      height: iconSize
    };
  });
}
function createRichTextNode() {
  const { textAutoWrapWidth } = this.mindMap.opt;
  let g = new G();
  let recoverText = false;
  if (this.getData("resetRichText")) {
    delete this.nodeData.data.resetRichText;
    recoverText = true;
  }
  if ([CONSTANTS.CHANGE_THEME].includes(this.mindMap.renderer.renderSource)) {
    if (!this.hasCustomStyle()) {
      recoverText = true;
    }
  }
  let text4 = this.getData("text");
  if (recoverText && !isUndef(text4)) {
    let isRichText = checkIsRichText(text4);
    let style = this.style.createStyleText();
    if (isRichText) {
      text4 = removeHtmlStyle(text4);
      text4 = addHtmlStyle(text4, "span", style);
    } else {
      text4 = `<p><span style="${style}">${text4}</span></p>`;
    }
    this.setData({
      text: text4
    });
  }
  let html2 = `<div>${this.getData("text")}</div>`;
  if (!commonCaches.measureRichtextNodeTextSizeEl) {
    commonCaches.measureRichtextNodeTextSizeEl = document.createElement("div");
    commonCaches.measureRichtextNodeTextSizeEl.style.position = "fixed";
    commonCaches.measureRichtextNodeTextSizeEl.style.left = "-999999px";
    this.mindMap.el.appendChild(commonCaches.measureRichtextNodeTextSizeEl);
  }
  let div = commonCaches.measureRichtextNodeTextSizeEl;
  div.innerHTML = html2;
  let el2 = div.children[0];
  el2.classList.add("smm-richtext-node-wrap");
  el2.setAttribute("xmlns", "http://www.w3.org/1999/xhtml");
  el2.style.maxWidth = textAutoWrapWidth + "px";
  let { width: width2, height: height2 } = el2.getBoundingClientRect();
  if (height2 <= 0) {
    div.innerHTML = "<p>abc123\u6211\u548C\u4F60</p>";
    let elTmp = div.children[0];
    elTmp.classList.add("smm-richtext-node-wrap");
    height2 = elTmp.getBoundingClientRect().height;
    div.innerHTML = html2;
  }
  width2 = Math.ceil(width2) + 1;
  height2 = Math.ceil(height2);
  g.attr("data-width", width2);
  g.attr("data-height", height2);
  let foreignObject = new ForeignObject();
  foreignObject.width(width2);
  foreignObject.height(height2);
  foreignObject.add(div.children[0]);
  g.add(foreignObject);
  return {
    node: g,
    width: width2,
    height: height2
  };
}
function createTextNode() {
  if (this.getData("richText")) {
    return this.createRichTextNode();
  }
  let g = new G();
  let fontSize = this.getStyle("fontSize", false);
  let lineHeight = this.getStyle("lineHeight", false);
  let textStyle = this.style.getTextFontStyle();
  let textArr = [];
  if (!isUndef(this.getData("text"))) {
    textArr = String(this.getData("text")).split(/\n/gim);
  }
  let maxWidth = this.mindMap.opt.textAutoWrapWidth;
  let isMultiLine = false;
  textArr.forEach((item, index3) => {
    let arr = item.split("");
    let lines = [];
    let line = [];
    while (arr.length) {
      let str = arr.shift();
      let text4 = [...line, str].join("");
      if (measureText(text4, textStyle).width <= maxWidth) {
        line.push(str);
      } else {
        lines.push(line.join(""));
        line = [str];
      }
    }
    if (line.length > 0) {
      lines.push(line.join(""));
    }
    if (lines.length > 1) {
      isMultiLine = true;
    }
    textArr[index3] = lines.join("\n");
  });
  textArr = textArr.join("\n").split(/\n/gim);
  textArr.forEach((item, index3) => {
    let node3 = new Text2().text(item);
    this.style.text(node3);
    node3.y(fontSize * lineHeight * index3);
    g.add(node3);
  });
  let { width: width2, height: height2 } = g.bbox();
  width2 = Math.ceil(width2);
  height2 = Math.ceil(height2);
  g.attr("data-width", width2);
  g.attr("data-height", height2);
  g.attr("data-ismultiLine", isMultiLine || textArr.length > 1);
  return {
    node: g,
    width: width2,
    height: height2
  };
}
function createHyperlinkNode() {
  let { hyperlink: hyperlink2, hyperlinkTitle } = this.getData();
  if (!hyperlink2) {
    return;
  }
  let iconSize = this.mindMap.themeConfig.iconSize;
  let node3 = new SVG();
  let a2 = new A().to(hyperlink2).target("_blank");
  a2.node.addEventListener("click", (e2) => {
    e2.stopPropagation();
  });
  if (hyperlinkTitle) {
    a2.attr("title", hyperlinkTitle);
  }
  a2.rect(iconSize, iconSize).fill({ color: "transparent" });
  let iconNode = SVG(icons_default.hyperlink).size(iconSize, iconSize);
  this.style.iconNode(iconNode);
  a2.add(iconNode);
  node3.add(a2);
  return {
    node: node3,
    width: iconSize,
    height: iconSize
  };
}
function createTagNode() {
  let tagData = this.getData("tag");
  if (!tagData || tagData.length <= 0) {
    return [];
  }
  let nodes = [];
  tagData.slice(0, this.mindMap.opt.maxTag).forEach((item, index3) => {
    let tag = new G();
    let text4 = new Text2().text(item).x(8).cy(8);
    this.style.tagText(text4, index3);
    let { width: width2 } = text4.bbox();
    let rect = new Rect().size(width2 + 16, 20);
    const tagsColorList = this.mindMap.opt.tagsColorMap || {};
    const color = tagsColorList[text4.node.textContent];
    this.style.tagRect(rect, text4, color);
    tag.add(rect).add(text4);
    nodes.push({
      node: tag,
      width: width2 + 16,
      height: 20
    });
  });
  return nodes;
}
function createNoteNode() {
  if (!this.getData("note")) {
    return null;
  }
  let iconSize = this.mindMap.themeConfig.iconSize;
  let node3 = new SVG().attr("cursor", "pointer");
  node3.add(new Rect().size(iconSize, iconSize).fill({ color: "transparent" }));
  let iconNode = SVG(icons_default.note).size(iconSize, iconSize);
  this.style.iconNode(iconNode);
  node3.add(iconNode);
  if (!this.mindMap.opt.customNoteContentShow) {
    if (!this.noteEl) {
      this.noteEl = document.createElement("div");
      this.noteEl.style.cssText = `
          position: fixed;
          padding: 10px;
          border-radius: 5px;
          box-shadow: 0 2px 5px rgb(0 0 0 / 10%);
          display: none;
          background-color: #fff;
          z-index: ${this.mindMap.opt.nodeNoteTooltipZIndex}
      `;
      const targetNode = this.mindMap.opt.customInnerElsAppendTo || document.body;
      targetNode.appendChild(this.noteEl);
    }
    this.noteEl.innerText = this.getData("note");
  }
  node3.on("mouseover", () => {
    const { left, top } = this.getNoteContentPosition();
    if (!this.mindMap.opt.customNoteContentShow) {
      this.noteEl.style.left = left + "px";
      this.noteEl.style.top = top + "px";
      this.noteEl.style.display = "block";
    } else {
      this.mindMap.opt.customNoteContentShow.show(
        this.getData("note"),
        left,
        top,
        this
      );
    }
  });
  node3.on("mouseout", () => {
    if (!this.mindMap.opt.customNoteContentShow) {
      this.noteEl.style.display = "none";
    } else {
      this.mindMap.opt.customNoteContentShow.hide();
    }
  });
  return {
    node: node3,
    width: iconSize,
    height: iconSize
  };
}
function getNoteContentPosition() {
  const iconSize = this.mindMap.themeConfig.iconSize;
  const { scaleY } = this.mindMap.view.getTransformData().transform;
  const iconSizeAddScale = iconSize * scaleY;
  let { left, top } = this._noteData.node.node.getBoundingClientRect();
  top += iconSizeAddScale;
  return {
    left,
    top
  };
}
function measureCustomNodeContentSize(content3) {
  if (!commonCaches.measureCustomNodeContentSizeEl) {
    commonCaches.measureCustomNodeContentSizeEl = document.createElement("div");
    commonCaches.measureCustomNodeContentSizeEl.style.cssText = `
      position: fixed;
      left: -99999px;
      top: -99999px;
    `;
    this.mindMap.el.appendChild(commonCaches.measureCustomNodeContentSizeEl);
  }
  commonCaches.measureCustomNodeContentSizeEl.innerHTML = "";
  commonCaches.measureCustomNodeContentSizeEl.appendChild(content3);
  let rect = commonCaches.measureCustomNodeContentSizeEl.getBoundingClientRect();
  return {
    width: rect.width,
    height: rect.height
  };
}
function isUseCustomNodeContent() {
  return !!this._customNodeContent;
}
var nodeCreateContents_default = {
  createImgNode,
  getImgShowSize,
  createIconNode,
  createRichTextNode,
  createTextNode,
  createHyperlinkNode,
  createTagNode,
  createNoteNode,
  getNoteContentPosition,
  measureCustomNodeContentSize,
  isUseCustomNodeContent
};

// ../simple-mind-map/src/core/render/node/nodeExpandBtnPlaceholderRect.js
function renderExpandBtnPlaceholderRect() {
  if (!this.nodeData.children || this.nodeData.children.length <= 0 || this.isRoot) {
    return;
  }
  if (!this.mindMap.opt.alwaysShowExpandBtn) {
    let { width: width2, height: height2 } = this;
    if (!this._unVisibleRectRegionNode) {
      this._unVisibleRectRegionNode = new Rect();
      this._unVisibleRectRegionNode.fill({
        color: "transparent"
      });
    }
    this.group.add(this._unVisibleRectRegionNode);
    this.renderer.layout.renderExpandBtnRect(
      this._unVisibleRectRegionNode,
      this.expandBtnSize,
      width2,
      height2,
      this
    );
  }
}
function clearExpandBtnPlaceholderRect() {
  if (!this._unVisibleRectRegionNode) {
    return;
  }
  this._unVisibleRectRegionNode.remove();
  this._unVisibleRectRegionNode = null;
}
function updateExpandBtnPlaceholderRect() {
  if (this.needRerenderExpandBtnPlaceholderRect) {
    this.needRerenderExpandBtnPlaceholderRect = false;
    this.renderExpandBtnPlaceholderRect();
  }
  if (this.nodeData.children && this.nodeData.children.length > 0) {
    if (!this._unVisibleRectRegionNode) {
      this.renderExpandBtnPlaceholderRect();
    }
  } else {
    if (this._unVisibleRectRegionNode) {
      this.clearExpandBtnPlaceholderRect();
    }
  }
}
var nodeExpandBtnPlaceholderRect_default = {
  renderExpandBtnPlaceholderRect,
  clearExpandBtnPlaceholderRect,
  updateExpandBtnPlaceholderRect
};

// ../simple-mind-map/src/core/render/node/nodeCooperate.js
function createUserListNode() {
  if (!this.mindMap.cooperate)
    return;
  this._userListGroup = new G();
  this.group.add(this._userListGroup);
}
function createTextAvatar(item) {
  const { avatarSize, fontSize } = this.mindMap.opt.cooperateStyle;
  const g = new G();
  const str = item.isMore ? item.name : String(item.name)[0];
  const circle = new Circle().size(avatarSize, avatarSize);
  circle.fill({
    color: item.color || generateColorByContent(str)
  });
  const text4 = new Text2().text(str).fill({
    color: "#fff"
  }).css({
    "font-size": fontSize
  }).dx(-fontSize / 2).dy((avatarSize - fontSize) / 2);
  g.add(circle).add(text4);
  return g;
}
function createImageAvatar(item) {
  const { avatarSize } = this.mindMap.opt.cooperateStyle;
  return new Image2().load(item.avatar).size(avatarSize, avatarSize);
}
function updateUserListNode() {
  if (!this._userListGroup)
    return;
  const { avatarSize } = this.mindMap.opt.cooperateStyle;
  this._userListGroup.clear();
  const length2 = this.userList.length;
  const maxShowCount = Math.floor(this.width / avatarSize);
  const list2 = [];
  if (length2 > maxShowCount) {
    list2.push(...this.userList.slice(0, maxShowCount - 1), {
      isMore: true,
      name: "+" + (length2 - maxShowCount + 1)
    });
  } else {
    list2.push(...this.userList);
  }
  list2.forEach((item, index3) => {
    let node3 = null;
    if (item.avatar) {
      node3 = this.createImageAvatar(item);
    } else {
      node3 = this.createTextAvatar(item);
    }
    node3.x(index3 * avatarSize).cy(-avatarSize / 2);
    this._userListGroup.add(node3);
  });
}
function addUser(userInfo) {
  if (this.userList.find((item) => {
    return item.id == userInfo.id;
  }))
    return;
  this.userList.push(userInfo);
  this.updateUserListNode();
}
function removeUser(userInfo) {
  const index3 = this.userList.findIndex((item) => {
    return item.id == userInfo.id;
  });
  if (index3 === -1)
    return;
  this.userList.splice(index3, 1);
  this.updateUserListNode();
}
var nodeCooperate_default = {
  createUserListNode,
  updateUserListNode,
  createTextAvatar,
  createImageAvatar,
  addUser,
  removeUser
};

// ../simple-mind-map/src/core/render/node/Node.js
var Node2 = class {
  //  构造函数
  constructor(opt = {}) {
    this.nodeData = this.handleData(opt.data || {});
    this.uid = opt.uid;
    this.mindMap = opt.mindMap;
    this.renderer = opt.renderer;
    this.draw = this.mindMap.draw;
    this.nodeDraw = this.mindMap.nodeDraw;
    this.lineDraw = this.mindMap.lineDraw;
    this.style = new Style_default(this);
    this.shapeInstance = new Shape2(this);
    this.shapePadding = {
      paddingX: 0,
      paddingY: 0
    };
    this.isRoot = opt.isRoot === void 0 ? false : opt.isRoot;
    this.isGeneralization = opt.isGeneralization === void 0 ? false : opt.isGeneralization;
    this.generalizationBelongNode = null;
    this.layerIndex = opt.layerIndex === void 0 ? 0 : opt.layerIndex;
    this.width = opt.width || 0;
    this.height = opt.height || 0;
    this._left = opt.left || 0;
    this._top = opt.top || 0;
    this.customLeft = opt.data.data.customLeft || void 0;
    this.customTop = opt.data.data.customTop || void 0;
    this.isDrag = false;
    this.parent = opt.parent || null;
    this.children = opt.children || [];
    this.userList = [];
    this.group = null;
    this.shapeNode = null;
    this.hoverNode = null;
    this._customNodeContent = null;
    this._imgData = null;
    this._iconData = null;
    this._textData = null;
    this._hyperlinkData = null;
    this._tagData = null;
    this._noteData = null;
    this.noteEl = null;
    this.noteContentIsShow = false;
    this._expandBtn = null;
    this._lastExpandBtnType = null;
    this._showExpandBtn = false;
    this._openExpandNode = null;
    this._closeExpandNode = null;
    this._fillExpandNode = null;
    this._userListGroup = null;
    this._lines = [];
    this._generalizationList = [];
    this._unVisibleRectRegionNode = null;
    this._isMouseenter = false;
    this._rectInfo = {
      imgContentWidth: 0,
      imgContentHeight: 0,
      textContentWidth: 0,
      textContentHeight: 0
    };
    this._generalizationNodeWidth = 0;
    this._generalizationNodeHeight = 0;
    this.textContentItemMargin = this.mindMap.opt.textContentMargin;
    this.blockContentMargin = this.mindMap.opt.imgTextMargin;
    this.expandBtnSize = this.mindMap.opt.expandBtnSize;
    this.isMultipleChoice = false;
    this.needLayout = false;
    this.isHide = false;
    Object.keys(nodeGeneralization_default).forEach((item) => {
      this[item] = nodeGeneralization_default[item].bind(this);
    });
    Object.keys(nodeExpandBtn_default).forEach((item) => {
      this[item] = nodeExpandBtn_default[item].bind(this);
    });
    Object.keys(nodeExpandBtnPlaceholderRect_default).forEach((item) => {
      this[item] = nodeExpandBtnPlaceholderRect_default[item].bind(this);
    });
    Object.keys(nodeCommandWraps_default).forEach((item) => {
      this[item] = nodeCommandWraps_default[item].bind(this);
    });
    Object.keys(nodeCreateContents_default).forEach((item) => {
      this[item] = nodeCreateContents_default[item].bind(this);
    });
    if (this.mindMap.cooperate) {
      Object.keys(nodeCooperate_default).forEach((item) => {
        this[item] = nodeCooperate_default[item].bind(this);
      });
    }
    this.getSize();
  }
  // 支持自定义位置
  get left() {
    return this.customLeft || this._left;
  }
  set left(val) {
    this._left = val;
  }
  get top() {
    return this.customTop || this._top;
  }
  set top(val) {
    this._top = val;
  }
  //  复位部分布局时会重新设置的数据
  reset() {
    this.children = [];
    this.parent = null;
    this.isRoot = false;
    this.layerIndex = 0;
    this.left = 0;
    this.top = 0;
  }
  // 节点被删除时需要复位的数据
  resetWhenDelete() {
    this._isMouseenter = false;
  }
  //  处理数据
  handleData(data2) {
    data2.data.expand = data2.data.expand === false ? false : true;
    data2.data.isActive = data2.data.isActive === true ? true : false;
    data2.children = data2.children || [];
    return data2;
  }
  //  创建节点的各个内容对象数据
  createNodeData() {
    let { isUseCustomNodeContent: isUseCustomNodeContent2, customCreateNodeContent } = this.mindMap.opt;
    if (isUseCustomNodeContent2 && customCreateNodeContent) {
      this._customNodeContent = customCreateNodeContent(this);
    }
    if (this._customNodeContent) {
      this._customNodeContent.setAttribute(
        "xmlns",
        "http://www.w3.org/1999/xhtml"
      );
      return;
    }
    this._imgData = this.createImgNode();
    this._iconData = this.createIconNode();
    this._textData = this.createTextNode();
    this._hyperlinkData = this.createHyperlinkNode();
    this._tagData = this.createTagNode();
    this._noteData = this.createNoteNode();
  }
  //  计算节点的宽高
  getSize() {
    this.updateGeneralization();
    this.createNodeData();
    let { width: width2, height: height2 } = this.getNodeRect();
    let changed = this.width !== width2 || this.height !== height2;
    this.width = width2;
    this.height = height2;
    return changed;
  }
  //  计算节点尺寸信息
  getNodeRect() {
    if (this.isUseCustomNodeContent()) {
      let rect = this.measureCustomNodeContentSize(this._customNodeContent);
      return {
        width: rect.width,
        height: rect.height
      };
    }
    let imgContentWidth = 0;
    let imgContentHeight = 0;
    let textContentWidth = 0;
    let textContentHeight = 0;
    if (this._imgData) {
      this._rectInfo.imgContentWidth = imgContentWidth = this._imgData.width;
      this._rectInfo.imgContentHeight = imgContentHeight = this._imgData.height;
    }
    if (this._iconData.length > 0) {
      textContentWidth += this._iconData.reduce((sum, cur) => {
        textContentHeight = Math.max(textContentHeight, cur.height);
        return sum += cur.width + this.textContentItemMargin;
      }, 0);
    }
    if (this._textData) {
      textContentWidth += this._textData.width;
      textContentHeight = Math.max(textContentHeight, this._textData.height);
    }
    if (this._hyperlinkData) {
      textContentWidth += this._hyperlinkData.width;
      textContentHeight = Math.max(
        textContentHeight,
        this._hyperlinkData.height
      );
    }
    if (this._tagData.length > 0) {
      textContentWidth += this._tagData.reduce((sum, cur) => {
        textContentHeight = Math.max(textContentHeight, cur.height);
        return sum += cur.width + this.textContentItemMargin;
      }, 0);
    }
    if (this._noteData) {
      textContentWidth += this._noteData.width;
      textContentHeight = Math.max(textContentHeight, this._noteData.height);
    }
    this._rectInfo.textContentWidth = textContentWidth;
    this._rectInfo.textContentHeight = textContentHeight;
    let margin = imgContentHeight > 0 && textContentHeight > 0 ? this.blockContentMargin : 0;
    let { paddingX, paddingY } = this.getPaddingVale();
    let _width = Math.max(imgContentWidth, textContentWidth);
    let _height = imgContentHeight + textContentHeight;
    let { paddingX: shapePaddingX, paddingY: shapePaddingY } = this.shapeInstance.getShapePadding(_width, _height, paddingX, paddingY);
    this.shapePadding.paddingX = shapePaddingX;
    this.shapePadding.paddingY = shapePaddingY;
    const borderWidth = this.getBorderWidth();
    return {
      width: _width + paddingX * 2 + shapePaddingX * 2 + borderWidth,
      height: _height + paddingY * 2 + margin + shapePaddingY * 2 + borderWidth
    };
  }
  //  定位节点内容
  layout() {
    this.group.clear();
    const { hoverRectPadding } = this.mindMap.opt;
    let { width: width2, height: height2, textContentItemMargin } = this;
    let { paddingY } = this.getPaddingVale();
    const halfBorderWidth = this.getBorderWidth() / 2;
    paddingY += this.shapePadding.paddingY + halfBorderWidth;
    this.shapeNode = this.shapeInstance.createShape();
    this.shapeNode.addClass("smm-node-shape");
    this.shapeNode.translate(halfBorderWidth, halfBorderWidth);
    this.style.shape(this.shapeNode);
    this.group.add(this.shapeNode);
    this.renderExpandBtnPlaceholderRect();
    if (this.createUserListNode)
      this.createUserListNode();
    if (this.isGeneralization && this.generalizationBelongNode) {
      this.group.addClass("generalization_" + this.generalizationBelongNode.uid);
    }
    const addHoverNode = () => {
      this.hoverNode = new Rect().size(width2 + hoverRectPadding * 2, height2 + hoverRectPadding * 2).x(-hoverRectPadding).y(-hoverRectPadding);
      this.hoverNode.addClass("smm-hover-node");
      this.style.hoverNode(this.hoverNode, width2, height2);
      this.group.add(this.hoverNode);
    };
    if (this.isUseCustomNodeContent()) {
      let foreignObject = new ForeignObject();
      foreignObject.width(width2);
      foreignObject.height(height2);
      foreignObject.add(this._customNodeContent);
      this.group.add(foreignObject);
      addHoverNode();
      return;
    }
    let imgHeight = 0;
    if (this._imgData) {
      imgHeight = this._imgData.height;
      this.group.add(this._imgData.node);
      this._imgData.node.cx(width2 / 2).y(paddingY);
    }
    let textContentNested = new G();
    let textContentOffsetX = 0;
    let iconNested = new G();
    if (this._iconData && this._iconData.length > 0) {
      let iconLeft = 0;
      this._iconData.forEach((item) => {
        item.node.x(textContentOffsetX + iconLeft).y((this._rectInfo.textContentHeight - item.height) / 2);
        iconNested.add(item.node);
        iconLeft += item.width + textContentItemMargin;
      });
      textContentNested.add(iconNested);
      textContentOffsetX += iconLeft;
    }
    if (this._textData) {
      this._textData.node.attr("data-offsetx", textContentOffsetX);
      this._textData.node.x(textContentOffsetX).y(0);
      textContentNested.add(this._textData.node);
      textContentOffsetX += this._textData.width + textContentItemMargin;
    }
    if (this._hyperlinkData) {
      this._hyperlinkData.node.x(textContentOffsetX).y((this._rectInfo.textContentHeight - this._hyperlinkData.height) / 2);
      textContentNested.add(this._hyperlinkData.node);
      textContentOffsetX += this._hyperlinkData.width + textContentItemMargin;
    }
    let tagNested = new G();
    if (this._tagData && this._tagData.length > 0) {
      let tagLeft = 0;
      this._tagData.forEach((item) => {
        item.node.x(textContentOffsetX + tagLeft).y((this._rectInfo.textContentHeight - item.height) / 2);
        tagNested.add(item.node);
        tagLeft += item.width + textContentItemMargin;
      });
      textContentNested.add(tagNested);
      textContentOffsetX += tagLeft;
    }
    if (this._noteData) {
      this._noteData.node.x(textContentOffsetX).y((this._rectInfo.textContentHeight - this._noteData.height) / 2);
      textContentNested.add(this._noteData.node);
      textContentOffsetX += this._noteData.width;
    }
    textContentNested.translate(
      width2 / 2 - textContentNested.bbox().width / 2,
      imgHeight + paddingY + (imgHeight > 0 && this._rectInfo.textContentHeight > 0 ? this.blockContentMargin : 0)
    );
    this.group.add(textContentNested);
    addHoverNode();
  }
  // 给节点绑定事件
  bindGroupEvent() {
    this.group.on("click", (e2) => {
      this.mindMap.emit("node_click", this, e2);
      if (this.isMultipleChoice) {
        e2.stopPropagation();
        this.isMultipleChoice = false;
        return;
      }
      this.active(e2);
    });
    this.group.on("mousedown", (e2) => {
      const {
        readonly,
        enableCtrlKeyNodeSelection,
        useLeftKeySelectionRightKeyDrag
      } = this.mindMap.opt;
      if (!readonly) {
        if (this.isRoot) {
          if (e2.which === 3 && !useLeftKeySelectionRightKeyDrag) {
            e2.stopPropagation();
          }
        } else {
          if (e2.which !== 2) {
            e2.stopPropagation();
          }
        }
      }
      if (e2.ctrlKey && enableCtrlKeyNodeSelection) {
        this.isMultipleChoice = true;
        let isActive = this.getData("isActive");
        if (!isActive)
          this.mindMap.emit(
            "before_node_active",
            this,
            this.renderer.activeNodeList
          );
        this.mindMap.renderer[isActive ? "removeNodeFromActiveList" : "addNodeToActiveList"](this);
        this.renderer.emitNodeActiveEvent(isActive ? null : this);
      }
      this.mindMap.emit("node_mousedown", this, e2);
    });
    this.group.on("mouseup", (e2) => {
      if (!this.isRoot && e2.which !== 2 && !this.mindMap.opt.readonly) {
        e2.stopPropagation();
      }
      this.mindMap.emit("node_mouseup", this, e2);
    });
    this.group.on("mouseenter", (e2) => {
      if (this.isDrag)
        return;
      this._isMouseenter = true;
      this.showExpandBtn();
      if (this.isGeneralization) {
        this.handleGeneralizationMouseenter();
      }
      this.mindMap.emit("node_mouseenter", this, e2);
    });
    this.group.on("mouseleave", (e2) => {
      if (!this._isMouseenter)
        return;
      this._isMouseenter = false;
      this.hideExpandBtn();
      if (this.isGeneralization) {
        this.handleGeneralizationMouseleave();
      }
      this.mindMap.emit("node_mouseleave", this, e2);
    });
    this.group.on("dblclick", (e2) => {
      if (this.mindMap.opt.readonly || e2.ctrlKey) {
        return;
      }
      e2.stopPropagation();
      this.mindMap.emit("node_dblclick", this, e2);
    });
    this.group.on("contextmenu", (e2) => {
      const { readonly, useLeftKeySelectionRightKeyDrag } = this.mindMap.opt;
      if (readonly || e2.ctrlKey) {
        return;
      }
      e2.stopPropagation();
      e2.preventDefault();
      if (this.mindMap.select && !useLeftKeySelectionRightKeyDrag && this.mindMap.select.hasSelectRange()) {
        return;
      }
      if (!(this.getData("isActive") && this.renderer.activeNodeList.length === 1)) {
        this.renderer.clearActiveNodeList();
        this.active(e2);
      }
      this.mindMap.emit("node_contextmenu", e2, this);
    });
  }
  //  激活节点
  active(e2) {
    if (this.mindMap.opt.readonly) {
      return;
    }
    e2 && e2.stopPropagation();
    if (this.getData("isActive")) {
      return;
    }
    this.mindMap.emit("before_node_active", this, this.renderer.activeNodeList);
    this.renderer.clearActiveNodeList();
    this.renderer.addNodeToActiveList(this);
    this.renderer.emitNodeActiveEvent(this);
  }
  //  更新节点
  update() {
    if (!this.group) {
      return;
    }
    this.updateNodeActiveClass();
    let { alwaysShowExpandBtn } = this.mindMap.opt;
    if (alwaysShowExpandBtn) {
      if (this._expandBtn && this.nodeData.children.length <= 0) {
        this.removeExpandBtn();
      } else {
        this.renderExpandBtn();
      }
    } else {
      let { isActive, expand } = this.getData();
      if (expand && !isActive && !this._isMouseenter) {
        this.hideExpandBtn();
      } else {
        this.showExpandBtn();
      }
    }
    this.renderGeneralization();
    if (this.updateUserListNode)
      this.updateUserListNode();
    let t2 = this.group.transform();
    if (this.left === t2.translateX && this.top === t2.translateY)
      return;
    this.group.translate(this.left - t2.translateX, this.top - t2.translateY);
  }
  // 获取节点相当于画布的位置
  getNodePosInClient(_left, _top) {
    let drawTransform = this.mindMap.draw.transform();
    let { scaleX, scaleY, translateX, translateY } = drawTransform;
    let left = _left * scaleX + translateX;
    let top = _top * scaleY + translateY;
    return {
      left,
      top
    };
  }
  // 重新渲染节点，即重新创建节点内容、计算节点大小、计算节点内容布局、更新展开收起按钮，概要及位置
  reRender() {
    let sizeChange = this.getSize();
    this.layout();
    this.update();
    return sizeChange;
  }
  // 更新节点激活状态
  updateNodeActiveClass() {
    if (!this.group)
      return;
    const isActive = this.getData("isActive");
    this.group[isActive ? "addClass" : "removeClass"]("active");
  }
  // 根据是否激活更新节点
  updateNodeByActive(active) {
    if (this.group) {
      if (active) {
        this.showExpandBtn();
      } else {
        this.hideExpandBtn();
      }
      this.updateNodeActiveClass();
    }
  }
  //  递归渲染
  render(callback = () => {
  }) {
    this.renderLine();
    if (!this.group) {
      this.group = new G();
      this.group.addClass("smm-node");
      this.group.css({
        cursor: "default"
      });
      this.bindGroupEvent();
      this.nodeDraw.add(this.group);
      this.layout();
      this.update();
    } else {
      this.nodeDraw.add(this.group);
      if (this.needLayout) {
        this.needLayout = false;
        this.layout();
      }
      this.updateExpandBtnPlaceholderRect();
      this.update();
    }
    if (this.children && this.children.length && this.getData("expand") !== false) {
      let index3 = 0;
      this.children.forEach((item) => {
        item.render(() => {
          index3++;
          if (index3 >= this.children.length) {
            callback();
          }
        });
      });
    } else {
      callback();
    }
    if (this.nodeData.inserting) {
      delete this.nodeData.inserting;
      this.active();
      setTimeout(() => {
        this.mindMap.emit("node_dblclick", this, null, true);
      }, 0);
    }
  }
  //  递归删除，只是从画布删除，节点容器还在，后续还可以重新插回画布
  remove() {
    if (!this.group)
      return;
    this.group.remove();
    this.removeGeneralization();
    this.removeLine();
    if (this.children && this.children.length) {
      this.children.forEach((item) => {
        item.remove();
      });
    }
  }
  // 销毁节点，不但会从画布删除，而且原节点直接置空，后续无法再插回画布
  destroy() {
    if (!this.group)
      return;
    this.resetWhenDelete();
    this.group.remove();
    this.removeGeneralization();
    this.removeLine();
    this.group = null;
    if (this.parent) {
      this.parent.removeLine();
    }
  }
  //  隐藏节点
  hide() {
    this.group.hide();
    this.hideGeneralization();
    if (this.parent) {
      let index3 = this.parent.children.indexOf(this);
      this.parent._lines[index3] && this.parent._lines[index3].hide();
      this._lines.forEach((item) => {
        item.hide();
      });
    }
    if (this.children && this.children.length) {
      this.children.forEach((item) => {
        item.hide();
      });
    }
  }
  //  显示节点
  show() {
    if (!this.group) {
      return;
    }
    this.group.show();
    this.showGeneralization();
    if (this.parent) {
      let index3 = this.parent.children.indexOf(this);
      this.parent._lines[index3] && this.parent._lines[index3].show();
      this._lines.forEach((item) => {
        item.show();
      });
    }
    if (this.children && this.children.length) {
      this.children.forEach((item) => {
        item.show();
      });
    }
  }
  // 设置节点透明度
  // 包括连接线和下级节点
  setOpacity(val) {
    this.group.opacity(val);
    this._lines.forEach((line) => {
      line.opacity(val);
    });
    this.children.forEach((item) => {
      item.setOpacity(val);
    });
    this.setGeneralizationOpacity(val);
  }
  // 隐藏子节点
  hideChildren() {
    this._lines.forEach((item) => {
      item.hide();
    });
    if (this.children && this.children.length) {
      this.children.forEach((item) => {
        item.hide();
      });
    }
  }
  // 显示子节点
  showChildren() {
    this._lines.forEach((item) => {
      item.show();
    });
    if (this.children && this.children.length) {
      this.children.forEach((item) => {
        item.show();
      });
    }
  }
  // 被拖拽中
  startDrag() {
    this.isDrag = true;
    this.group.addClass("smm-node-dragging");
  }
  // 拖拽结束
  endDrag() {
    this.isDrag = false;
    this.group.removeClass("smm-node-dragging");
  }
  //  连线
  renderLine(deep = false) {
    if (this.getData("expand") === false) {
      return;
    }
    let childrenLen = this.nodeData.children.length;
    if (this.mindMap.opt.layout === CONSTANTS.LAYOUT.FISHBONE && (this.isRoot || this.layerIndex === 1)) {
      childrenLen = 0;
    }
    if (childrenLen > this._lines.length) {
      new Array(childrenLen - this._lines.length).fill(0).forEach(() => {
        this._lines.push(this.lineDraw.path());
      });
    } else if (childrenLen < this._lines.length) {
      this._lines.slice(childrenLen).forEach((line) => {
        line.remove();
      });
      this._lines = this._lines.slice(0, childrenLen);
    }
    this.renderer.layout.renderLine(
      this,
      this._lines,
      (...args) => {
        this.styleLine(...args);
      },
      this.style.getStyle("lineStyle", true)
    );
    if (deep && this.children && this.children.length > 0) {
      this.children.forEach((item) => {
        item.renderLine(deep);
      });
    }
  }
  //  获取节点形状
  getShape() {
    return this.mindMap.themeConfig.nodeUseLineStyle ? CONSTANTS.SHAPE.RECTANGLE : this.style.getStyle("shape", false, false);
  }
  //  检查节点是否存在自定义数据
  hasCustomPosition() {
    return this.customLeft !== void 0 && this.customTop !== void 0;
  }
  //  检查节点是否存在自定义位置的祖先节点，包含自身
  ancestorHasCustomPosition() {
    let node3 = this;
    while (node3) {
      if (node3.hasCustomPosition()) {
        return true;
      }
      node3 = node3.parent;
    }
    return false;
  }
  //  检查是否存在有概要的祖先节点
  ancestorHasGeneralization() {
    let node3 = this.parent;
    while (node3) {
      if (node3.checkHasGeneralization()) {
        return true;
      }
      node3 = node3.parent;
    }
    return false;
  }
  //  添加子节点
  addChildren(node3) {
    this.children.push(node3);
  }
  //  设置连线样式
  styleLine(line, childNode, enableMarker) {
    const width2 = childNode.getSelfInhertStyle("lineWidth") || childNode.getStyle("lineWidth", true);
    const color = childNode.getSelfInhertStyle("lineColor") || childNode.getStyle("lineColor", true);
    const dasharray = childNode.getSelfInhertStyle("lineDasharray") || childNode.getStyle("lineDasharray", true);
    this.style.line(
      line,
      {
        width: width2,
        color,
        dasharray
      },
      enableMarker,
      childNode
    );
  }
  //  移除连线
  removeLine() {
    this._lines.forEach((line) => {
      line.remove();
    });
    this._lines = [];
  }
  //  检测当前节点是否是某个节点的祖先节点
  isAncestor(node3) {
    if (this.uid === node3.uid) {
      return false;
    }
    let parent = node3.parent;
    while (parent) {
      if (this.uid === parent.uid) {
        return true;
      }
      parent = parent.parent;
    }
    return false;
  }
  // 检查当前节点是否是某个节点的父节点
  isParent(node3) {
    if (this.uid === node3.uid) {
      return false;
    }
    const parent = node3.parent;
    if (parent && this.uid === parent.uid) {
      return true;
    }
    return false;
  }
  //  检测当前节点是否是某个节点的兄弟节点
  isBrother(node3) {
    if (!this.parent || this.uid === node3.uid) {
      return false;
    }
    return this.parent.children.find((item) => {
      return item.uid === node3.uid;
    });
  }
  // 获取该节点在兄弟节点列表中的索引
  getIndexInBrothers() {
    return this.parent && this.parent.children ? this.parent.children.findIndex((item) => {
      return item.uid === this.uid;
    }) : -1;
  }
  //  获取padding值
  getPaddingVale() {
    let { isActive } = this.getData();
    return {
      paddingX: this.getStyle("paddingX", true, isActive),
      paddingY: this.getStyle("paddingY", true, isActive)
    };
  }
  //  获取某个样式
  getStyle(prop, root2) {
    let v2 = this.style.merge(prop, root2);
    return v2 === void 0 ? "" : v2;
  }
  //  获取自定义样式
  getSelfStyle(prop) {
    return this.style.getSelfStyle(prop);
  }
  //   获取最近一个存在自身自定义样式的祖先节点的自定义样式
  getParentSelfStyle(prop) {
    if (this.parent) {
      return this.parent.getSelfStyle(prop) || this.parent.getParentSelfStyle(prop);
    }
    return null;
  }
  //  获取自身可继承的自定义样式
  getSelfInhertStyle(prop) {
    return this.getSelfStyle(prop) || // 自身
    this.getParentSelfStyle(prop);
  }
  // 获取节点非节点状态的边框大小
  getBorderWidth() {
    return this.style.merge("borderWidth", false) || 0;
  }
  //  获取数据
  getData(key) {
    return key ? this.nodeData.data[key] : this.nodeData.data;
  }
  // 获取该节点的纯数据，即不包含对节点实例的引用
  getPureData(removeActiveState = true, removeId = false) {
    return copyNodeTree({}, this, removeActiveState, removeId);
  }
  // 是否存在自定义样式
  hasCustomStyle() {
    return this.style.hasCustomStyle();
  }
  // 获取节点的尺寸和位置信息，宽高是应用了缩放效果后的实际宽高，位置是相对于浏览器窗口左上角的位置
  getRect() {
    return this.group.rbox();
  }
  // 获取节点的尺寸和位置信息，宽高是应用了缩放效果后的实际宽高，位置信息相对于画布
  getRectInSvg() {
    let { scaleX, scaleY, translateX, translateY } = this.mindMap.draw.transform();
    let { left, top, width: width2, height: height2 } = this;
    let right = (left + width2) * scaleX + translateX;
    let bottom = (top + height2) * scaleY + translateY;
    left = left * scaleX + translateX;
    top = top * scaleY + translateY;
    return {
      left,
      right,
      top,
      bottom,
      width: width2 * scaleX,
      height: height2 * scaleY
    };
  }
};
var Node_default = Node2;

// ../simple-mind-map/src/utils/Lru.js
var Lru = class {
  constructor(max2) {
    this.max = max2 || 1e3;
    this.size = 0;
    this.pool = /* @__PURE__ */ new Map();
  }
  add(key, value) {
    const isExist = this.has(key);
    if (!isExist && this.size >= this.max) {
      return false;
    }
    this.delete(key);
    this.pool.set(key, value);
    this.size++;
    return true;
  }
  delete(key) {
    if (this.pool.has(key)) {
      this.pool.delete(key);
      this.size--;
    }
  }
  has(key) {
    return this.pool.has(key);
  }
  get(key) {
    if (this.pool.has(key)) {
      return this.pool.get(key);
    }
  }
  clear() {
    this.size = 0;
    this.pool = /* @__PURE__ */ new Map();
  }
};

// ../simple-mind-map/src/layouts/Base.js
var Base2 = class {
  //  构造函数
  constructor(renderer) {
    this.renderer = renderer;
    this.mindMap = renderer.mindMap;
    this.draw = this.mindMap.draw;
    this.lineDraw = this.mindMap.lineDraw;
    this.root = null;
    this.lru = new Lru(this.mindMap.opt.maxNodeCacheCount);
    this.rootNodeCenterOffset = null;
  }
  //  计算节点位置
  doLayout() {
    throw new Error("\u3010computed\u3011\u65B9\u6CD5\u4E3A\u5FC5\u8981\u65B9\u6CD5\uFF0C\u9700\u8981\u5B50\u7C7B\u8FDB\u884C\u91CD\u5199\uFF01");
  }
  //  连线
  renderLine() {
    throw new Error("\u3010renderLine\u3011\u65B9\u6CD5\u4E3A\u5FC5\u8981\u65B9\u6CD5\uFF0C\u9700\u8981\u5B50\u7C7B\u8FDB\u884C\u91CD\u5199\uFF01");
  }
  //  定位展开收缩按钮
  renderExpandBtn() {
    throw new Error("\u3010renderExpandBtn\u3011\u65B9\u6CD5\u4E3A\u5FC5\u8981\u65B9\u6CD5\uFF0C\u9700\u8981\u5B50\u7C7B\u8FDB\u884C\u91CD\u5199\uFF01");
  }
  //  概要节点
  renderGeneralization() {
  }
  // 通过uid缓存节点
  cacheNode(uid, node3) {
    this.renderer.nodeCache[uid] = node3;
    this.lru.add(uid, node3);
  }
  // 检查当前来源是否需要重新计算节点大小
  checkIsNeedResizeSources() {
    return [
      CONSTANTS.CHANGE_THEME,
      CONSTANTS.TRANSFORM_TO_NORMAL_NODE
    ].includes(this.renderer.renderSource);
  }
  // 层级类型改变
  checkIsLayerTypeChange(oldIndex, newIndex) {
    if (oldIndex >= 2 && newIndex >= 2)
      return false;
    if (oldIndex >= 2 && newIndex < 2)
      return true;
    if (oldIndex < 2 && newIndex >= 2)
      return true;
  }
  // 检查是否是结构布局改变重新渲染展开收起按钮占位元素
  checkIsLayoutChangeRerenderExpandBtnPlaceholderRect(node3) {
    if (this.renderer.renderSource === CONSTANTS.CHANGE_LAYOUT) {
      node3.needRerenderExpandBtnPlaceholderRect = true;
    }
  }
  //  创建节点实例
  createNode(data2, parent, isRoot, layerIndex) {
    const uid = data2.data.uid;
    let newNode = null;
    if (data2 && data2._node && !this.renderer.reRender) {
      newNode = data2._node;
      const isLayerTypeChange = this.checkIsLayerTypeChange(
        newNode.layerIndex,
        layerIndex
      );
      newNode.reset();
      newNode.layerIndex = layerIndex;
      this.cacheNode(data2._node.uid, newNode);
      this.checkIsLayoutChangeRerenderExpandBtnPlaceholderRect(newNode);
      if (this.checkIsNeedResizeSources() || isLayerTypeChange) {
        newNode.getSize();
        newNode.needLayout = true;
      }
    } else if ((this.lru.has(uid) || this.renderer.lastNodeCache[uid]) && !this.renderer.reRender) {
      newNode = this.lru.get(uid) || this.renderer.lastNodeCache[uid];
      const lastData = JSON.stringify(newNode.getData());
      const isLayerTypeChange = this.checkIsLayerTypeChange(
        newNode.layerIndex,
        layerIndex
      );
      newNode.reset();
      newNode.nodeData = newNode.handleData(data2 || {});
      newNode.layerIndex = layerIndex;
      this.cacheNode(uid, newNode);
      this.checkIsLayoutChangeRerenderExpandBtnPlaceholderRect(newNode);
      data2._node = newNode;
      const isResizeSource = this.checkIsNeedResizeSources();
      const isNodeDataChange = lastData !== JSON.stringify(data2.data);
      if (isResizeSource || isNodeDataChange || isLayerTypeChange) {
        newNode.getSize();
        newNode.needLayout = true;
      }
    } else {
      const newUid = uid || createUid();
      newNode = new Node_default({
        data: data2,
        uid: newUid,
        renderer: this.renderer,
        mindMap: this.mindMap,
        draw: this.draw,
        layerIndex
      });
      data2.data.uid = newUid;
      this.cacheNode(newUid, newNode);
      data2._node = newNode;
      if (data2.data.isActive) {
        this.renderer.addNodeToActiveList(newNode);
      }
    }
    if (this.mindMap.renderer.findActiveNodeIndex(newNode) !== -1) {
      newNode.setData({
        isActive: true
      });
    }
    if (isRoot) {
      newNode.isRoot = true;
      this.root = newNode;
    } else {
      newNode.parent = parent._node;
      parent._node.addChildren(newNode);
    }
    return newNode;
  }
  // 格式化节点位置
  formatPosition(value, size2, nodeSize) {
    if (typeof value === "number") {
      return value;
    } else if (initRootNodePositionMap[value] !== void 0) {
      return size2 * initRootNodePositionMap[value];
    } else if (/^\d\d*%$/.test(value)) {
      return Number.parseFloat(value) / 100 * size2;
    } else {
      return (size2 - nodeSize) / 2;
    }
  }
  // 规范initRootNodePosition配置
  formatInitRootNodePosition(pos) {
    const { CENTER } = CONSTANTS.INIT_ROOT_NODE_POSITION;
    if (!pos || !Array.isArray(pos) || pos.length < 2) {
      pos = [CENTER, CENTER];
    }
    return pos;
  }
  //  定位节点到画布中间
  setNodeCenter(node3, position3) {
    let { initRootNodePosition } = this.mindMap.opt;
    initRootNodePosition = this.formatInitRootNodePosition(
      position3 || initRootNodePosition
    );
    node3.left = this.formatPosition(
      initRootNodePosition[0],
      this.mindMap.width,
      node3.width
    );
    node3.top = this.formatPosition(
      initRootNodePosition[1],
      this.mindMap.height,
      node3.height
    );
  }
  // 当initRootNodePosition配置不为默认的['center','center']时，计算当前配置和默认配置情况下，根节点位置的差值
  getRootCenterOffset(width2, height2) {
    if (this.rootNodeCenterOffset)
      return this.rootNodeCenterOffset;
    let { initRootNodePosition } = this.mindMap.opt;
    const { CENTER } = CONSTANTS.INIT_ROOT_NODE_POSITION;
    initRootNodePosition = this.formatInitRootNodePosition(initRootNodePosition);
    if (initRootNodePosition[0] === CENTER && initRootNodePosition[1] === CENTER) {
      this.rootNodeCenterOffset = {
        x: 0,
        y: 0
      };
    } else {
      const tmpNode = {
        width: width2,
        height: height2
      };
      const tmpNode2 = {
        width: width2,
        height: height2
      };
      this.setNodeCenter(tmpNode, [CENTER, CENTER]);
      this.setNodeCenter(tmpNode2);
      this.rootNodeCenterOffset = {
        x: tmpNode2.left - tmpNode.left,
        y: tmpNode2.top - tmpNode.top
      };
    }
    return this.rootNodeCenterOffset;
  }
  //  更新子节点属性
  updateChildren(children, prop, offset) {
    children.forEach((item) => {
      item[prop] += offset;
      if (item.children && item.children.length && !item.hasCustomPosition()) {
        this.updateChildren(item.children, prop, offset);
      }
    });
  }
  //  更新子节点多个属性
  updateChildrenPro(children, props) {
    children.forEach((item) => {
      Object.keys(props).forEach((prop) => {
        item[prop] += props[prop];
      });
      if (item.children && item.children.length && !item.hasCustomPosition()) {
        this.updateChildrenPro(item.children, props);
      }
    });
  }
  //  递归计算节点的宽度
  getNodeAreaWidth(node3, withGeneralization = false) {
    let widthArr = [];
    let totalGeneralizationNodeWidth = 0;
    let loop = (node4, width2) => {
      if (withGeneralization && node4.checkHasGeneralization()) {
        totalGeneralizationNodeWidth += node4._generalizationNodeWidth;
      }
      if (node4.children.length) {
        width2 += node4.width / 2;
        node4.children.forEach((item) => {
          loop(item, width2);
        });
      } else {
        width2 += node4.width;
        widthArr.push(width2);
      }
    };
    loop(node3, 0);
    return Math.max(...widthArr) + totalGeneralizationNodeWidth;
  }
  //  二次贝塞尔曲线
  quadraticCurvePath(x1, y1, x2, y22) {
    let cx2 = x1 + (x2 - x1) * 0.2;
    let cy2 = y1 + (y22 - y1) * 0.8;
    return `M ${x1},${y1} Q ${cx2},${cy2} ${x2},${y22}`;
  }
  //  三次贝塞尔曲线
  cubicBezierPath(x1, y1, x2, y22) {
    let cx1 = x1 + (x2 - x1) / 2;
    let cy1 = y1;
    let cx2 = cx1;
    let cy2 = y22;
    return `M ${x1},${y1} C ${cx1},${cy1} ${cx2},${cy2} ${x2},${y22}`;
  }
  //   获取节点的marginX
  getMarginX(layerIndex) {
    const { themeConfig, opt } = this.mindMap;
    const { second, node: node3 } = themeConfig;
    const hoverRectPadding = opt.hoverRectPadding * 2;
    return layerIndex === 1 ? second.marginX + hoverRectPadding : node3.marginX + hoverRectPadding;
  }
  //  获取节点的marginY
  getMarginY(layerIndex) {
    const { themeConfig, opt } = this.mindMap;
    const { second, node: node3 } = themeConfig;
    const hoverRectPadding = opt.hoverRectPadding * 2;
    return layerIndex === 1 ? second.marginY + hoverRectPadding : node3.marginY + hoverRectPadding;
  }
  //  获取节点包括概要在内的宽度
  getNodeWidthWithGeneralization(node3) {
    return Math.max(
      node3.width,
      node3.checkHasGeneralization() ? node3._generalizationNodeWidth : 0
    );
  }
  //  获取节点包括概要在内的高度
  getNodeHeightWithGeneralization(node3) {
    return Math.max(
      node3.height,
      node3.checkHasGeneralization() ? node3._generalizationNodeHeight : 0
    );
  }
  //  获取节点的边界值
  /**
   * dir：生长方向，h（水平）、v（垂直）
   * isLeft：是否向左生长
   */
  getNodeBoundaries(node3, dir) {
    let { generalizationLineMargin, generalizationNodeMargin } = this.mindMap.themeConfig;
    let walk2 = (root2) => {
      let _left = Infinity;
      let _right = -Infinity;
      let _top = Infinity;
      let _bottom = -Infinity;
      if (root2.children && root2.children.length > 0) {
        root2.children.forEach((child) => {
          let { left: left2, right: right2, top: top2, bottom: bottom2 } = walk2(child);
          let generalizationWidth = child.checkHasGeneralization() && child.getData("expand") ? child._generalizationNodeWidth + generalizationNodeMargin : 0;
          let generalizationHeight = child.checkHasGeneralization() && child.getData("expand") ? child._generalizationNodeHeight + generalizationNodeMargin : 0;
          if (left2 - (dir === "h" ? generalizationWidth : 0) < _left) {
            _left = left2 - (dir === "h" ? generalizationWidth : 0);
          }
          if (right2 + (dir === "h" ? generalizationWidth : 0) > _right) {
            _right = right2 + (dir === "h" ? generalizationWidth : 0);
          }
          if (top2 < _top) {
            _top = top2;
          }
          if (bottom2 + (dir === "v" ? generalizationHeight : 0) > _bottom) {
            _bottom = bottom2 + (dir === "v" ? generalizationHeight : 0);
          }
        });
      }
      let cur = {
        left: root2.left,
        right: root2.left + root2.width,
        top: root2.top,
        bottom: root2.top + root2.height
      };
      return {
        left: cur.left < _left ? cur.left : _left,
        right: cur.right > _right ? cur.right : _right,
        top: cur.top < _top ? cur.top : _top,
        bottom: cur.bottom > _bottom ? cur.bottom : _bottom
      };
    };
    let { left, right, top, bottom } = walk2(node3);
    return {
      left,
      right,
      top,
      bottom,
      generalizationLineMargin,
      generalizationNodeMargin
    };
  }
  // 获取指定索引区间的子节点的边界范围
  getChildrenBoundaries(node3, dir, startIndex = 0, endIndex) {
    let { generalizationLineMargin, generalizationNodeMargin } = this.mindMap.themeConfig;
    const children = node3.children.slice(startIndex, endIndex + 1);
    let left = Infinity;
    let right = -Infinity;
    let top = Infinity;
    let bottom = -Infinity;
    children.forEach((item) => {
      const cur = this.getNodeBoundaries(item, dir);
      left = cur.left < left ? cur.left : left;
      right = cur.right > right ? cur.right : right;
      top = cur.top < top ? cur.top : top;
      bottom = cur.bottom > bottom ? cur.bottom : bottom;
    });
    return {
      left,
      right,
      top,
      bottom,
      generalizationLineMargin,
      generalizationNodeMargin
    };
  }
  // 获取节点概要的渲染边界
  getNodeGeneralizationRenderBoundaries(item, dir) {
    let res = null;
    if (item.range) {
      res = this.getChildrenBoundaries(
        item.node,
        dir,
        item.range[0],
        item.range[1]
      );
    } else {
      res = this.getNodeBoundaries(item.node, dir);
    }
    return res;
  }
  // 获取节点实际存在几个子节点
  getNodeActChildrenLength(node3) {
    return node3.nodeData.children && node3.nodeData.children.length;
  }
  // 设置连线样式
  setLineStyle(style, line, path2, childNode) {
    line.plot(path2);
    style && style(line, childNode, true);
  }
};
var Base_default = Base2;

// ../simple-mind-map/src/layouts/LogicalStructure.js
var LogicalStructure = class extends Base_default {
  //  构造函数
  constructor(opt = {}) {
    super(opt);
  }
  //  布局
  doLayout(callback) {
    let task = [
      () => {
        this.computedBaseValue();
      },
      () => {
        this.computedTopValue();
      },
      () => {
        this.adjustTopValue();
      },
      () => {
        callback(this.root);
      }
    ];
    asyncRun(task);
  }
  //  遍历数据计算节点的left、width、height
  computedBaseValue() {
    walk(
      this.renderer.renderTree,
      null,
      (cur, parent, isRoot, layerIndex) => {
        let newNode = this.createNode(cur, parent, isRoot, layerIndex);
        if (isRoot) {
          this.setNodeCenter(newNode);
        } else {
          newNode.left = parent._node.left + parent._node.width + this.getMarginX(layerIndex);
        }
        if (!cur.data.expand) {
          return true;
        }
      },
      (cur, parent, isRoot, layerIndex) => {
        let len = cur.data.expand === false ? 0 : cur._node.children.length;
        cur._node.childrenAreaHeight = len ? cur._node.children.reduce((h2, item) => {
          return h2 + item.height;
        }, 0) + (len + 1) * this.getMarginY(layerIndex + 1) : 0;
        let generalizationNodeHeight = cur._node.checkHasGeneralization() ? cur._node._generalizationNodeHeight + this.getMarginY(layerIndex + 1) : 0;
        cur._node.childrenAreaHeight2 = Math.max(
          cur._node.childrenAreaHeight,
          generalizationNodeHeight
        );
      },
      true,
      0
    );
  }
  //  遍历节点树计算节点的top
  computedTopValue() {
    walk(
      this.root,
      null,
      (node3, parent, isRoot, layerIndex) => {
        if (node3.getData("expand") && node3.children && node3.children.length) {
          let marginY = this.getMarginY(layerIndex + 1);
          let top = node3.top + node3.height / 2 - node3.childrenAreaHeight / 2;
          let totalTop = top + marginY;
          node3.children.forEach((cur) => {
            cur.top = totalTop;
            totalTop += cur.height + marginY;
          });
        }
      },
      null,
      true
    );
  }
  //  调整节点top
  adjustTopValue() {
    walk(
      this.root,
      null,
      (node3, parent, isRoot, layerIndex) => {
        if (!node3.getData("expand")) {
          return;
        }
        let difference2 = node3.childrenAreaHeight2 - this.getMarginY(layerIndex + 1) * 2 - node3.height;
        if (difference2 > 0) {
          this.updateBrothers(node3, difference2 / 2);
        }
      },
      null,
      true
    );
  }
  //  更新兄弟节点的top
  updateBrothers(node3, addHeight) {
    if (node3.parent) {
      let childrenList = node3.parent.children;
      let index3 = getNodeIndexInNodeList(node3, childrenList);
      childrenList.forEach((item, _index) => {
        if (item.uid === node3.uid || item.hasCustomPosition()) {
          return;
        }
        let _offset = 0;
        if (_index < index3) {
          _offset = -addHeight;
        } else if (_index > index3) {
          _offset = addHeight;
        }
        item.top += _offset;
        if (item.children && item.children.length) {
          this.updateChildren(item.children, "top", _offset);
        }
      });
      this.updateBrothers(node3.parent, addHeight);
    }
  }
  //  绘制连线，连接该节点到其子节点
  renderLine(node3, lines, style, lineStyle) {
    if (lineStyle === "curve") {
      this.renderLineCurve(node3, lines, style);
    } else if (lineStyle === "direct") {
      this.renderLineDirect(node3, lines, style);
    } else {
      this.renderLineStraight(node3, lines, style);
    }
  }
  //  直线风格连线
  renderLineStraight(node3, lines, style) {
    if (node3.children.length <= 0) {
      return [];
    }
    let { left, top, width: width2, height: height2, expandBtnSize } = node3;
    if (!this.mindMap.opt.alwaysShowExpandBtn) {
      expandBtnSize = 0;
    }
    let marginX = this.getMarginX(node3.layerIndex + 1);
    let s1 = (marginX - expandBtnSize) * 0.6;
    let nodeUseLineStyle = this.mindMap.themeConfig.nodeUseLineStyle;
    node3.children.forEach((item, index3) => {
      let x1 = node3.layerIndex === 0 ? left + width2 : left + width2 + expandBtnSize;
      let y1 = top + height2 / 2;
      let x2 = item.left;
      let y22 = item.top + item.height / 2;
      let nodeUseLineStyleOffset = nodeUseLineStyle ? item.width : 0;
      y1 = nodeUseLineStyle && !node3.isRoot ? y1 + height2 / 2 : y1;
      y22 = nodeUseLineStyle ? y22 + item.height / 2 : y22;
      let path2 = `M ${x1},${y1} L ${x1 + s1},${y1} L ${x1 + s1},${y22} L ${x2 + nodeUseLineStyleOffset},${y22}`;
      this.setLineStyle(style, lines[index3], path2, item);
    });
  }
  //  直连风格
  renderLineDirect(node3, lines, style) {
    if (node3.children.length <= 0) {
      return [];
    }
    let { left, top, width: width2, height: height2, expandBtnSize } = node3;
    if (!this.mindMap.opt.alwaysShowExpandBtn) {
      expandBtnSize = 0;
    }
    let nodeUseLineStyle = this.mindMap.themeConfig.nodeUseLineStyle;
    node3.children.forEach((item, index3) => {
      let x1 = node3.layerIndex === 0 ? left + width2 / 2 : left + width2 + expandBtnSize;
      let y1 = top + height2 / 2;
      let x2 = item.left;
      let y22 = item.top + item.height / 2;
      y1 = nodeUseLineStyle && !node3.isRoot ? y1 + height2 / 2 : y1;
      y22 = nodeUseLineStyle ? y22 + item.height / 2 : y22;
      let nodeUseLineStylePath = nodeUseLineStyle ? ` L ${item.left + item.width},${y22}` : "";
      let path2 = `M ${x1},${y1} L ${x2},${y22}` + nodeUseLineStylePath;
      this.setLineStyle(style, lines[index3], path2, item);
    });
  }
  //  曲线风格连线
  renderLineCurve(node3, lines, style) {
    if (node3.children.length <= 0) {
      return [];
    }
    let { left, top, width: width2, height: height2, expandBtnSize } = node3;
    if (!this.mindMap.opt.alwaysShowExpandBtn) {
      expandBtnSize = 0;
    }
    let nodeUseLineStyle = this.mindMap.themeConfig.nodeUseLineStyle;
    node3.children.forEach((item, index3) => {
      let x1 = node3.layerIndex === 0 ? left + width2 / 2 : left + width2 + expandBtnSize;
      let y1 = top + height2 / 2;
      let x2 = item.left;
      let y22 = item.top + item.height / 2;
      let path2 = "";
      y1 = nodeUseLineStyle && !node3.isRoot ? y1 + height2 / 2 : y1;
      y22 = nodeUseLineStyle ? y22 + item.height / 2 : y22;
      let nodeUseLineStylePath = nodeUseLineStyle ? ` L ${item.left + item.width},${y22}` : "";
      if (node3.isRoot && !this.mindMap.themeConfig.rootLineKeepSameInCurve) {
        path2 = this.quadraticCurvePath(x1, y1, x2, y22) + nodeUseLineStylePath;
      } else {
        path2 = this.cubicBezierPath(x1, y1, x2, y22) + nodeUseLineStylePath;
      }
      this.setLineStyle(style, lines[index3], path2, item);
    });
  }
  //  渲染按钮
  renderExpandBtn(node3, btn) {
    let { width: width2, height: height2 } = node3;
    let { translateX, translateY } = btn.transform();
    let nodeUseLineStyleOffset = this.mindMap.themeConfig.nodeUseLineStyle ? height2 / 2 : 0;
    let _x = width2;
    let _y = height2 / 2 + nodeUseLineStyleOffset;
    if (_x === translateX && _y === translateY) {
      return;
    }
    btn.translate(_x - translateX, _y - translateY);
  }
  //  创建概要节点
  renderGeneralization(list2) {
    list2.forEach((item) => {
      let {
        top,
        bottom,
        right,
        generalizationLineMargin,
        generalizationNodeMargin
      } = this.getNodeGeneralizationRenderBoundaries(item, "h");
      let x1 = right + generalizationLineMargin;
      let y1 = top;
      let x2 = right + generalizationLineMargin;
      let y22 = bottom;
      let cx2 = x1 + 20;
      let cy2 = y1 + (y22 - y1) / 2;
      let path2 = `M ${x1},${y1} Q ${cx2},${cy2} ${x2},${y22}`;
      item.generalizationLine.plot(path2);
      item.generalizationNode.left = right + generalizationNodeMargin;
      item.generalizationNode.top = top + (bottom - top - item.generalizationNode.height) / 2;
    });
  }
  // 渲染展开收起按钮的隐藏占位元素
  renderExpandBtnRect(rect, expandBtnSize, width2, height2, node3) {
    rect.size(expandBtnSize, height2).x(width2).y(0);
  }
};
var LogicalStructure_default = LogicalStructure;

// ../simple-mind-map/src/layouts/MindMap.js
var MindMap = class extends Base_default {
  //  构造函数
  // 在逻辑结构图的基础上增加一个变量来记录生长方向，向左还是向右，同时在计算left的时候根据方向来计算、调整top时只考虑同方向的节点即可
  constructor(opt = {}) {
    super(opt);
  }
  //  布局
  doLayout(callback) {
    let task = [
      () => {
        this.computedBaseValue();
      },
      () => {
        this.computedTopValue();
      },
      () => {
        this.adjustTopValue();
      },
      () => {
        callback(this.root);
      }
    ];
    asyncRun(task);
  }
  //  遍历数据计算节点的left、width、height
  computedBaseValue() {
    walk(
      this.renderer.renderTree,
      null,
      (cur, parent, isRoot, layerIndex, index3) => {
        let newNode = this.createNode(cur, parent, isRoot, layerIndex);
        if (isRoot) {
          this.setNodeCenter(newNode);
        } else {
          if (parent._node.dir) {
            newNode.dir = parent._node.dir;
          } else {
            newNode.dir = index3 % 2 === 0 ? CONSTANTS.LAYOUT_GROW_DIR.RIGHT : CONSTANTS.LAYOUT_GROW_DIR.LEFT;
          }
          newNode.left = newNode.dir === CONSTANTS.LAYOUT_GROW_DIR.RIGHT ? parent._node.left + parent._node.width + this.getMarginX(layerIndex) : parent._node.left - this.getMarginX(layerIndex) - newNode.width;
        }
        if (!cur.data.expand) {
          return true;
        }
      },
      (cur, parent, isRoot, layerIndex) => {
        if (!cur.data.expand) {
          cur._node.leftChildrenAreaHeight = 0;
          cur._node.rightChildrenAreaHeight = 0;
          return;
        }
        let leftLen = 0;
        let rightLen = 0;
        let leftChildrenAreaHeight = 0;
        let rightChildrenAreaHeight = 0;
        cur._node.children.forEach((item) => {
          if (item.dir === CONSTANTS.LAYOUT_GROW_DIR.LEFT) {
            leftLen++;
            leftChildrenAreaHeight += item.height;
          } else {
            rightLen++;
            rightChildrenAreaHeight += item.height;
          }
        });
        cur._node.leftChildrenAreaHeight = leftChildrenAreaHeight + (leftLen + 1) * this.getMarginY(layerIndex + 1);
        cur._node.rightChildrenAreaHeight = rightChildrenAreaHeight + (rightLen + 1) * this.getMarginY(layerIndex + 1);
        let generalizationNodeHeight = cur._node.checkHasGeneralization() ? cur._node._generalizationNodeHeight + this.getMarginY(layerIndex + 1) : 0;
        cur._node.leftChildrenAreaHeight2 = Math.max(
          cur._node.leftChildrenAreaHeight,
          generalizationNodeHeight
        );
        cur._node.rightChildrenAreaHeight2 = Math.max(
          cur._node.rightChildrenAreaHeight,
          generalizationNodeHeight
        );
      },
      true,
      0
    );
  }
  //  遍历节点树计算节点的top
  computedTopValue() {
    walk(
      this.root,
      null,
      (node3, parent, isRoot, layerIndex) => {
        if (node3.getData("expand") && node3.children && node3.children.length) {
          let marginY = this.getMarginY(layerIndex + 1);
          let baseTop = node3.top + node3.height / 2 + marginY;
          let leftTotalTop = baseTop - node3.leftChildrenAreaHeight / 2;
          let rightTotalTop = baseTop - node3.rightChildrenAreaHeight / 2;
          node3.children.forEach((cur) => {
            if (cur.dir === CONSTANTS.LAYOUT_GROW_DIR.LEFT) {
              cur.top = leftTotalTop;
              leftTotalTop += cur.height + marginY;
            } else {
              cur.top = rightTotalTop;
              rightTotalTop += cur.height + marginY;
            }
          });
        }
      },
      null,
      true
    );
  }
  //  调整节点top
  adjustTopValue() {
    walk(
      this.root,
      null,
      (node3, parent, isRoot, layerIndex) => {
        if (!node3.getData("expand")) {
          return;
        }
        let base = this.getMarginY(layerIndex + 1) * 2 + node3.height;
        let leftDifference = node3.leftChildrenAreaHeight2 - base;
        let rightDifference = node3.rightChildrenAreaHeight2 - base;
        if (leftDifference > 0 || rightDifference > 0) {
          this.updateBrothers(node3, leftDifference / 2, rightDifference / 2);
        }
      },
      null,
      true
    );
  }
  //  更新兄弟节点的top
  updateBrothers(node3, leftAddHeight, rightAddHeight) {
    if (node3.parent) {
      let childrenList = node3.parent.children.filter((item) => {
        return item.dir === node3.dir;
      });
      let index3 = getNodeIndexInNodeList(node3, childrenList);
      childrenList.forEach((item, _index) => {
        if (item.hasCustomPosition()) {
          return;
        }
        let _offset = 0;
        let addHeight = item.dir === CONSTANTS.LAYOUT_GROW_DIR.LEFT ? leftAddHeight : rightAddHeight;
        if (_index < index3) {
          _offset = -addHeight;
        } else if (_index > index3) {
          _offset = addHeight;
        }
        item.top += _offset;
        if (item.children && item.children.length) {
          this.updateChildren(item.children, "top", _offset);
        }
      });
      this.updateBrothers(node3.parent, leftAddHeight, rightAddHeight);
    }
  }
  //  绘制连线，连接该节点到其子节点
  renderLine(node3, lines, style, lineStyle) {
    if (lineStyle === "curve") {
      this.renderLineCurve(node3, lines, style);
    } else if (lineStyle === "direct") {
      this.renderLineDirect(node3, lines, style);
    } else {
      this.renderLineStraight(node3, lines, style);
    }
  }
  //  直线风格连线
  renderLineStraight(node3, lines, style) {
    if (node3.children.length <= 0) {
      return [];
    }
    let { left, top, width: width2, height: height2, expandBtnSize } = node3;
    if (!this.mindMap.opt.alwaysShowExpandBtn) {
      expandBtnSize = 0;
    }
    let marginX = this.getMarginX(node3.layerIndex + 1);
    let s1 = (marginX - expandBtnSize) * 0.6;
    let nodeUseLineStyle = this.mindMap.themeConfig.nodeUseLineStyle;
    node3.children.forEach((item, index3) => {
      let x1 = 0;
      let _s = 0;
      let nodeUseLineStyleOffset = nodeUseLineStyle ? item.width : 0;
      if (item.dir === CONSTANTS.LAYOUT_GROW_DIR.LEFT) {
        _s = -s1;
        x1 = node3.layerIndex === 0 ? left : left - expandBtnSize;
        nodeUseLineStyleOffset = -nodeUseLineStyleOffset;
      } else {
        _s = s1;
        x1 = node3.layerIndex === 0 ? left + width2 : left + width2 + expandBtnSize;
      }
      let y1 = top + height2 / 2;
      let x2 = item.dir === CONSTANTS.LAYOUT_GROW_DIR.LEFT ? item.left + item.width : item.left;
      let y22 = item.top + item.height / 2;
      y1 = nodeUseLineStyle && !node3.isRoot ? y1 + height2 / 2 : y1;
      y22 = nodeUseLineStyle ? y22 + item.height / 2 : y22;
      let path2 = `M ${x1},${y1} L ${x1 + _s},${y1} L ${x1 + _s},${y22} L ${x2 + nodeUseLineStyleOffset},${y22}`;
      this.setLineStyle(style, lines[index3], path2, item);
    });
  }
  //  直连风格
  renderLineDirect(node3, lines, style) {
    if (node3.children.length <= 0) {
      return [];
    }
    let { left, top, width: width2, height: height2, expandBtnSize } = node3;
    if (!this.mindMap.opt.alwaysShowExpandBtn) {
      expandBtnSize = 0;
    }
    let nodeUseLineStyle = this.mindMap.themeConfig.nodeUseLineStyle;
    node3.children.forEach((item, index3) => {
      let x1 = node3.layerIndex === 0 ? left + width2 / 2 : item.dir === CONSTANTS.LAYOUT_GROW_DIR.LEFT ? left - expandBtnSize : left + width2 + expandBtnSize;
      let y1 = top + height2 / 2;
      let x2 = item.dir === CONSTANTS.LAYOUT_GROW_DIR.LEFT ? item.left + item.width : item.left;
      let y22 = item.top + item.height / 2;
      y1 = nodeUseLineStyle && !node3.isRoot ? y1 + height2 / 2 : y1;
      y22 = nodeUseLineStyle ? y22 + item.height / 2 : y22;
      let nodeUseLineStylePath = "";
      if (nodeUseLineStyle) {
        if (item.dir === CONSTANTS.LAYOUT_GROW_DIR.LEFT) {
          nodeUseLineStylePath = ` L ${item.left},${y22}`;
        } else {
          nodeUseLineStylePath = ` L ${item.left + item.width},${y22}`;
        }
      }
      let path2 = `M ${x1},${y1} L ${x2},${y22}` + nodeUseLineStylePath;
      this.setLineStyle(style, lines[index3], path2, item);
    });
  }
  //  曲线风格连线
  renderLineCurve(node3, lines, style) {
    if (node3.children.length <= 0) {
      return [];
    }
    let { left, top, width: width2, height: height2, expandBtnSize } = node3;
    if (!this.mindMap.opt.alwaysShowExpandBtn) {
      expandBtnSize = 0;
    }
    let nodeUseLineStyle = this.mindMap.themeConfig.nodeUseLineStyle;
    node3.children.forEach((item, index3) => {
      let x1 = node3.layerIndex === 0 ? left + width2 / 2 : item.dir === CONSTANTS.LAYOUT_GROW_DIR.LEFT ? left - expandBtnSize : left + width2 + expandBtnSize;
      let y1 = top + height2 / 2;
      let x2 = item.dir === CONSTANTS.LAYOUT_GROW_DIR.LEFT ? item.left + item.width : item.left;
      let y22 = item.top + item.height / 2;
      let path2 = "";
      y1 = nodeUseLineStyle && !node3.isRoot ? y1 + height2 / 2 : y1;
      y22 = nodeUseLineStyle ? y22 + item.height / 2 : y22;
      let nodeUseLineStylePath = "";
      if (this.mindMap.themeConfig.nodeUseLineStyle) {
        if (item.dir === CONSTANTS.LAYOUT_GROW_DIR.LEFT) {
          nodeUseLineStylePath = ` L ${item.left},${y22}`;
        } else {
          nodeUseLineStylePath = ` L ${item.left + item.width},${y22}`;
        }
      }
      if (node3.isRoot && !this.mindMap.themeConfig.rootLineKeepSameInCurve) {
        path2 = this.quadraticCurvePath(x1, y1, x2, y22) + nodeUseLineStylePath;
      } else {
        path2 = this.cubicBezierPath(x1, y1, x2, y22) + nodeUseLineStylePath;
      }
      this.setLineStyle(style, lines[index3], path2, item);
    });
  }
  //  渲染按钮
  renderExpandBtn(node3, btn) {
    let { width: width2, height: height2, expandBtnSize } = node3;
    let { translateX, translateY } = btn.transform();
    let nodeUseLineStyleOffset = this.mindMap.themeConfig.nodeUseLineStyle ? height2 / 2 : 0;
    let _x = node3.dir === CONSTANTS.LAYOUT_GROW_DIR.LEFT ? 0 - expandBtnSize : width2;
    let _y = height2 / 2 + nodeUseLineStyleOffset;
    if (_x === translateX && _y === translateY) {
      return;
    }
    let x2 = _x - translateX;
    let y3 = _y - translateY;
    btn.translate(x2, y3);
  }
  //  创建概要节点
  renderGeneralization(list2) {
    list2.forEach((item) => {
      let isLeft = item.node.dir === CONSTANTS.LAYOUT_GROW_DIR.LEFT;
      let {
        top,
        bottom,
        left,
        right,
        generalizationLineMargin,
        generalizationNodeMargin
      } = this.getNodeGeneralizationRenderBoundaries(item, "h");
      let x2 = isLeft ? left - generalizationLineMargin : right + generalizationLineMargin;
      let x1 = x2;
      let y1 = top;
      let x22 = x2;
      let y22 = bottom;
      let cx2 = x1 + (isLeft ? -20 : 20);
      let cy2 = y1 + (y22 - y1) / 2;
      let path2 = `M ${x1},${y1} Q ${cx2},${cy2} ${x22},${y22}`;
      item.generalizationLine.plot(path2);
      item.generalizationNode.left = x2 + (isLeft ? -generalizationNodeMargin : generalizationNodeMargin) - (isLeft ? item.generalizationNode.width : 0);
      item.generalizationNode.top = top + (bottom - top - item.generalizationNode.height) / 2;
    });
  }
  // 渲染展开收起按钮的隐藏占位元素
  renderExpandBtnRect(rect, expandBtnSize, width2, height2, node3) {
    if (node3.dir === CONSTANTS.LAYOUT_GROW_DIR.LEFT) {
      rect.size(expandBtnSize, height2).x(-expandBtnSize).y(0);
    } else {
      rect.size(expandBtnSize, height2).x(width2).y(0);
    }
  }
};
var MindMap_default = MindMap;

// ../simple-mind-map/src/layouts/CatalogOrganization.js
var CatalogOrganization = class extends Base_default {
  //  构造函数
  constructor(opt = {}) {
    super(opt);
  }
  //  布局
  doLayout(callback) {
    let task = [
      () => {
        this.computedBaseValue();
      },
      () => {
        this.computedLeftTopValue();
      },
      () => {
        this.adjustLeftTopValue();
      },
      () => {
        callback(this.root);
      }
    ];
    asyncRun(task);
  }
  //  遍历数据计算节点的left、width、height
  computedBaseValue() {
    walk(
      this.renderer.renderTree,
      null,
      (cur, parent, isRoot, layerIndex) => {
        let newNode = this.createNode(cur, parent, isRoot, layerIndex);
        if (isRoot) {
          this.setNodeCenter(newNode);
        } else {
          if (parent._node.isRoot) {
            newNode.top = parent._node.top + parent._node.height + this.getMarginX(layerIndex);
          }
        }
        if (!cur.data.expand) {
          return true;
        }
      },
      (cur, parent, isRoot, layerIndex) => {
        if (isRoot) {
          let len = cur.data.expand === false ? 0 : cur._node.children.length;
          cur._node.childrenAreaWidth = len ? cur._node.children.reduce((h2, item) => {
            return h2 + item.width;
          }, 0) + (len + 1) * this.getMarginX(layerIndex + 1) : 0;
        }
      },
      true,
      0
    );
  }
  //  遍历节点树计算节点的left、top
  computedLeftTopValue() {
    walk(
      this.root,
      null,
      (node3, parent, isRoot, layerIndex) => {
        if (node3.getData("expand") && node3.children && node3.children.length) {
          let marginX = this.getMarginX(layerIndex + 1);
          let marginY = this.getMarginY(layerIndex + 1);
          if (isRoot) {
            let left = node3.left + node3.width / 2 - node3.childrenAreaWidth / 2;
            let totalLeft = left + marginX;
            node3.children.forEach((cur) => {
              cur.left = totalLeft;
              totalLeft += cur.width + marginX;
            });
          } else {
            let totalTop = node3.top + this.getNodeHeightWithGeneralization(node3) + marginY + (this.getNodeActChildrenLength(node3) > 0 ? node3.expandBtnSize : 0);
            node3.children.forEach((cur) => {
              cur.left = node3.left + node3.width * 0.5;
              cur.top = totalTop;
              totalTop += this.getNodeHeightWithGeneralization(cur) + marginY + (this.getNodeActChildrenLength(cur) > 0 ? cur.expandBtnSize : 0);
            });
          }
        }
      },
      null,
      true
    );
  }
  //  调整节点left、top
  adjustLeftTopValue() {
    walk(
      this.root,
      null,
      (node3, parent, isRoot, layerIndex) => {
        if (!node3.getData("expand")) {
          return;
        }
        if (parent && parent.isRoot) {
          let areaWidth = this.getNodeAreaWidth(node3, true);
          let difference2 = areaWidth - node3.width;
          if (difference2 > 0) {
            this.updateBrothersLeft(node3, difference2);
          }
        }
        let len = node3.children.length;
        if (parent && !parent.isRoot && len > 0) {
          let marginY = this.getMarginY(layerIndex + 1);
          let totalHeight = node3.children.reduce((h2, item) => {
            return h2 + this.getNodeHeightWithGeneralization(item) + (this.getNodeActChildrenLength(item) > 0 ? item.expandBtnSize : 0);
          }, 0) + len * marginY;
          this.updateBrothersTop(node3, totalHeight);
        }
      },
      (node3, parent, isRoot) => {
        if (isRoot) {
          let { right, left } = this.getNodeBoundaries(node3, "h");
          let childrenWidth = right - left;
          let offset = node3.left - left - (childrenWidth - node3.width) / 2;
          this.updateChildren(node3.children, "left", offset);
        }
      },
      true
    );
  }
  //  调整兄弟节点的left
  updateBrothersLeft(node3, addWidth) {
    if (node3.parent) {
      let childrenList = node3.parent.children;
      let index3 = getNodeIndexInNodeList(node3, childrenList);
      childrenList.forEach((item, _index) => {
        if (item.hasCustomPosition() || _index <= index3) {
          return;
        }
        item.left += addWidth;
        if (item.children && item.children.length) {
          this.updateChildren(item.children, "left", addWidth);
        }
      });
      this.updateBrothersLeft(node3.parent, addWidth);
    }
  }
  //  调整兄弟节点的top
  updateBrothersTop(node3, addHeight) {
    if (node3.parent && !node3.parent.isRoot) {
      let childrenList = node3.parent.children;
      let index3 = getNodeIndexInNodeList(node3, childrenList);
      childrenList.forEach((item, _index) => {
        if (item.hasCustomPosition()) {
          return;
        }
        let _offset = 0;
        if (_index > index3) {
          _offset = addHeight;
        }
        item.top += _offset;
        if (item.children && item.children.length) {
          this.updateChildren(item.children, "top", _offset);
        }
      });
      this.updateBrothersTop(node3.parent, addHeight);
    }
  }
  //  绘制连线，连接该节点到其子节点
  renderLine(node3, lines, style) {
    if (node3.children.length <= 0) {
      return [];
    }
    let { left, top, width: width2, height: height2, expandBtnSize } = node3;
    if (!this.mindMap.opt.alwaysShowExpandBtn) {
      expandBtnSize = 0;
    }
    let len = node3.children.length;
    let marginX = this.getMarginX(node3.layerIndex + 1);
    if (node3.isRoot) {
      let x1 = left + width2 / 2;
      let y1 = top + height2;
      let s1 = marginX * 0.7;
      let minx = Infinity;
      let maxx = -Infinity;
      node3.children.forEach((item, index3) => {
        let x2 = item.left + item.width / 2;
        let y22 = item.top;
        if (x2 < minx) {
          minx = x2;
        }
        if (x2 > maxx) {
          maxx = x2;
        }
        let nodeUseLineStylePath = this.mindMap.themeConfig.nodeUseLineStyle ? ` L ${item.left},${y22} L ${item.left + item.width},${y22}` : "";
        let path2 = `M ${x2},${y1 + s1} L ${x2},${y1 + s1 > y22 ? y22 + item.height : y22}` + nodeUseLineStylePath;
        this.setLineStyle(style, lines[index3], path2, item);
      });
      minx = Math.min(minx, x1);
      maxx = Math.max(maxx, x1);
      let line1 = this.lineDraw.path();
      node3.style.line(line1);
      line1.plot(`M ${x1},${y1} L ${x1},${y1 + s1}`);
      node3._lines.push(line1);
      style && style(line1, node3);
      if (len > 0) {
        let lin2 = this.lineDraw.path();
        node3.style.line(lin2);
        lin2.plot(`M ${minx},${y1 + s1} L ${maxx},${y1 + s1}`);
        node3._lines.push(lin2);
        style && style(lin2, node3);
      }
    } else {
      let y1 = top + height2;
      let maxy = -Infinity;
      let x2 = node3.left + node3.width * 0.3;
      node3.children.forEach((item, index3) => {
        let y22 = item.top + item.height / 2;
        if (y22 > maxy) {
          maxy = y22;
        }
        let path2 = "";
        let _left = item.left;
        let _isLeft = item.left + item.width < x2;
        let _isXCenter = false;
        if (_isLeft) {
          _left = item.left + item.width;
        } else if (item.left < x2 && item.left + item.width > x2) {
          _isXCenter = true;
          y22 = item.top;
          maxy = y22;
        }
        if (y22 > top && y22 < y1) {
          path2 = `M ${_isLeft ? node3.left : node3.left + node3.width},${y22} L ${_left},${y22}`;
        } else if (y22 < y1) {
          if (_isXCenter) {
            y22 = item.top + item.height;
            _left = x2;
          }
          path2 = `M ${x2},${top} L ${x2},${y22} L ${_left},${y22}`;
        } else {
          if (_isXCenter) {
            _left = x2;
          }
          path2 = `M ${x2},${y22} L ${_left},${y22}`;
        }
        let nodeUseLineStylePath = this.mindMap.themeConfig.nodeUseLineStyle ? ` L ${_left},${y22 - item.height / 2} L ${_left},${y22 + item.height / 2}` : "";
        path2 += nodeUseLineStylePath;
        this.setLineStyle(style, lines[index3], path2, item);
      });
      if (len > 0) {
        let lin2 = this.lineDraw.path();
        expandBtnSize = len > 0 ? expandBtnSize : 0;
        node3.style.line(lin2);
        if (maxy < y1 + expandBtnSize) {
          lin2.hide();
        } else {
          lin2.plot(`M ${x2},${y1 + expandBtnSize} L ${x2},${maxy}`);
          lin2.show();
        }
        node3._lines.push(lin2);
        style && style(lin2, node3);
      }
    }
  }
  //  渲染按钮
  renderExpandBtn(node3, btn) {
    let { width: width2, height: height2, expandBtnSize, isRoot } = node3;
    if (!isRoot) {
      let { translateX, translateY } = btn.transform();
      btn.translate(
        width2 * 0.3 - expandBtnSize / 2 - translateX,
        height2 + expandBtnSize / 2 - translateY
      );
    }
  }
  //  创建概要节点
  renderGeneralization(list2) {
    list2.forEach((item) => {
      let {
        top,
        bottom,
        right,
        generalizationLineMargin,
        generalizationNodeMargin
      } = this.getNodeGeneralizationRenderBoundaries(item, "h");
      let x1 = right + generalizationLineMargin;
      let y1 = top;
      let x2 = right + generalizationLineMargin;
      let y22 = bottom;
      let cx2 = x1 + 20;
      let cy2 = y1 + (y22 - y1) / 2;
      let path2 = `M ${x1},${y1} Q ${cx2},${cy2} ${x2},${y22}`;
      item.generalizationLine.plot(path2);
      item.generalizationNode.left = right + generalizationNodeMargin;
      item.generalizationNode.top = top + (bottom - top - item.generalizationNode.height) / 2;
    });
  }
  // 渲染展开收起按钮的隐藏占位元素
  renderExpandBtnRect(rect, expandBtnSize, width2, height2, node3) {
    rect.size(width2, expandBtnSize).x(0).y(height2);
  }
};
var CatalogOrganization_default = CatalogOrganization;

// ../simple-mind-map/src/layouts/OrganizationStructure.js
var OrganizationStructure = class extends Base_default {
  //  构造函数
  constructor(opt = {}) {
    super(opt);
  }
  //  布局
  doLayout(callback) {
    let task = [
      () => {
        this.computedBaseValue();
      },
      () => {
        this.computedLeftValue();
      },
      () => {
        this.adjustLeftValue();
      },
      () => {
        callback(this.root);
      }
    ];
    asyncRun(task);
  }
  //  遍历数据计算节点的left、width、height
  computedBaseValue() {
    walk(
      this.renderer.renderTree,
      null,
      (cur, parent, isRoot, layerIndex) => {
        let newNode = this.createNode(cur, parent, isRoot, layerIndex);
        if (isRoot) {
          this.setNodeCenter(newNode);
        } else {
          newNode.top = parent._node.top + parent._node.height + this.getMarginX(layerIndex);
        }
        if (!cur.data.expand) {
          return true;
        }
      },
      (cur, parent, isRoot, layerIndex) => {
        let len = cur.data.expand === false ? 0 : cur._node.children.length;
        cur._node.childrenAreaWidth = len ? cur._node.children.reduce((h2, item) => {
          return h2 + item.width;
        }, 0) + (len + 1) * this.getMarginY(layerIndex + 1) : 0;
        let generalizationNodeWidth = cur._node.checkHasGeneralization() ? cur._node._generalizationNodeWidth + this.getMarginY(layerIndex + 1) : 0;
        cur._node.childrenAreaWidth2 = Math.max(
          cur._node.childrenAreaWidth,
          generalizationNodeWidth
        );
      },
      true,
      0
    );
  }
  //  遍历节点树计算节点的left
  computedLeftValue() {
    walk(
      this.root,
      null,
      (node3, parent, isRoot, layerIndex) => {
        if (node3.getData("expand") && node3.children && node3.children.length) {
          let marginX = this.getMarginY(layerIndex + 1);
          let left = node3.left + node3.width / 2 - node3.childrenAreaWidth / 2;
          let totalLeft = left + marginX;
          node3.children.forEach((cur) => {
            cur.left = totalLeft;
            totalLeft += cur.width + marginX;
          });
        }
      },
      null,
      true
    );
  }
  //  调整节点left
  adjustLeftValue() {
    walk(
      this.root,
      null,
      (node3, parent, isRoot, layerIndex) => {
        if (!node3.getData("expand")) {
          return;
        }
        let difference2 = node3.childrenAreaWidth2 - this.getMarginY(layerIndex + 1) * 2 - node3.width;
        if (difference2 > 0) {
          this.updateBrothers(node3, difference2 / 2);
        }
      },
      null,
      true
    );
  }
  //  更新兄弟节点的left
  updateBrothers(node3, addWidth) {
    if (node3.parent) {
      let childrenList = node3.parent.children;
      let index3 = getNodeIndexInNodeList(node3, childrenList);
      childrenList.forEach((item, _index) => {
        if (item.hasCustomPosition()) {
          return;
        }
        let _offset = 0;
        if (_index < index3) {
          _offset = -addWidth;
        } else if (_index > index3) {
          _offset = addWidth;
        }
        item.left += _offset;
        if (item.children && item.children.length) {
          this.updateChildren(item.children, "left", _offset);
        }
      });
      this.updateBrothers(node3.parent, addWidth);
    }
  }
  //  绘制连线，连接该节点到其子节点
  renderLine(node3, lines, style, lineStyle) {
    if (lineStyle === "direct") {
      this.renderLineDirect(node3, lines, style);
    } else {
      this.renderLineStraight(node3, lines, style);
    }
  }
  //  直连风格
  renderLineDirect(node3, lines, style) {
    if (node3.children.length <= 0) {
      return [];
    }
    let { left, top, width: width2, height: height2 } = node3;
    let x1 = left + width2 / 2;
    let y1 = top + height2;
    node3.children.forEach((item, index3) => {
      let x2 = item.left + item.width / 2;
      let y22 = item.top;
      let nodeUseLineStylePath = this.mindMap.themeConfig.nodeUseLineStyle ? ` L ${item.left},${y22} L ${item.left + item.width},${y22}` : "";
      let path2 = `M ${x1},${y1} L ${x2},${y22}` + nodeUseLineStylePath;
      this.setLineStyle(style, lines[index3], path2, item);
    });
  }
  //  直线风格连线
  renderLineStraight(node3, lines, style) {
    if (node3.children.length <= 0) {
      return [];
    }
    let { left, top, width: width2, height: height2, expandBtnSize, isRoot } = node3;
    if (!this.mindMap.opt.alwaysShowExpandBtn) {
      expandBtnSize = 0;
    }
    let x1 = left + width2 / 2;
    let y1 = top + height2;
    let marginX = this.getMarginX(node3.layerIndex + 1);
    let s1 = marginX * 0.7;
    let minx = Infinity;
    let maxx = -Infinity;
    let len = node3.children.length;
    node3.children.forEach((item, index3) => {
      let x2 = item.left + item.width / 2;
      let y22 = y1 + s1 > item.top ? item.top + item.height : item.top;
      if (x2 < minx) {
        minx = x2;
      }
      if (x2 > maxx) {
        maxx = x2;
      }
      let nodeUseLineStylePath = this.mindMap.themeConfig.nodeUseLineStyle ? ` L ${item.left},${y22} L ${item.left + item.width},${y22}` : "";
      let path2 = `M ${x2},${y1 + s1} L ${x2},${y22}` + nodeUseLineStylePath;
      this.setLineStyle(style, lines[index3], path2, item);
    });
    minx = Math.min(x1, minx);
    maxx = Math.max(x1, maxx);
    let line1 = this.lineDraw.path();
    node3.style.line(line1);
    expandBtnSize = len > 0 && !isRoot ? expandBtnSize : 0;
    line1.plot(`M ${x1},${y1 + expandBtnSize} L ${x1},${y1 + s1}`);
    node3._lines.push(line1);
    style && style(line1, node3);
    if (len > 0) {
      let lin2 = this.lineDraw.path();
      node3.style.line(lin2);
      lin2.plot(`M ${minx},${y1 + s1} L ${maxx},${y1 + s1}`);
      node3._lines.push(lin2);
      style && style(lin2, node3);
    }
  }
  //  渲染按钮
  renderExpandBtn(node3, btn) {
    let { width: width2, height: height2, expandBtnSize } = node3;
    let { translateX, translateY } = btn.transform();
    btn.translate(
      width2 / 2 - expandBtnSize / 2 - translateX,
      height2 + expandBtnSize / 2 - translateY
    );
  }
  //  创建概要节点
  renderGeneralization(list2) {
    list2.forEach((item) => {
      let {
        bottom,
        left,
        right,
        generalizationLineMargin,
        generalizationNodeMargin
      } = this.getNodeGeneralizationRenderBoundaries(item, "v");
      let x1 = left;
      let y1 = bottom + generalizationLineMargin;
      let x2 = right;
      let y22 = bottom + generalizationLineMargin;
      let cx2 = x1 + (x2 - x1) / 2;
      let cy2 = y1 + 20;
      let path2 = `M ${x1},${y1} Q ${cx2},${cy2} ${x2},${y22}`;
      item.generalizationLine.plot(path2);
      item.generalizationNode.top = bottom + generalizationNodeMargin;
      item.generalizationNode.left = left + (right - left - item.generalizationNode.width) / 2;
    });
  }
  // 渲染展开收起按钮的隐藏占位元素
  renderExpandBtnRect(rect, expandBtnSize, width2, height2, node3) {
    rect.size(width2, expandBtnSize).x(0).y(height2);
  }
};
var OrganizationStructure_default = OrganizationStructure;

// ../simple-mind-map/src/layouts/Timeline.js
var Timeline2 = class extends Base_default {
  //  构造函数
  constructor(opt = {}, layout) {
    super(opt);
    this.layout = layout;
  }
  //  布局
  doLayout(callback) {
    let task = [
      () => {
        this.computedBaseValue();
      },
      () => {
        this.computedLeftTopValue();
      },
      () => {
        this.adjustLeftTopValue();
      },
      () => {
        callback(this.root);
      }
    ];
    asyncRun(task);
  }
  //  遍历数据创建节点、计算根节点的位置，计算根节点的子节点的top值
  computedBaseValue() {
    walk(
      this.renderer.renderTree,
      null,
      (cur, parent, isRoot, layerIndex, index3) => {
        let newNode = this.createNode(cur, parent, isRoot, layerIndex);
        if (isRoot) {
          this.setNodeCenter(newNode);
        } else {
          if (this.layout === CONSTANTS.LAYOUT.TIMELINE2) {
            if (parent._node.dir) {
              newNode.dir = parent._node.dir;
            } else {
              newNode.dir = index3 % 2 === 0 ? CONSTANTS.LAYOUT_GROW_DIR.BOTTOM : CONSTANTS.LAYOUT_GROW_DIR.TOP;
            }
          } else {
            newNode.dir = "";
          }
          if (parent._node.isRoot) {
            newNode.top = parent._node.top + (cur._node.height > parent._node.height ? -(cur._node.height - parent._node.height) / 2 : (parent._node.height - cur._node.height) / 2);
          }
        }
        if (!cur.data.expand) {
          return true;
        }
      },
      null,
      true,
      0
    );
  }
  //  遍历节点树计算节点的left、top
  computedLeftTopValue() {
    walk(
      this.root,
      null,
      (node3, parent, isRoot, layerIndex, index3) => {
        if (node3.getData("expand") && node3.children && node3.children.length) {
          let marginX = this.getMarginX(layerIndex + 1);
          let marginY = this.getMarginY(layerIndex + 1);
          if (isRoot) {
            let left = node3.left + node3.width;
            let totalLeft = left + marginX;
            node3.children.forEach((cur) => {
              cur.left = totalLeft;
              totalLeft += cur.width + marginX;
            });
          } else {
            let totalTop = node3.top + node3.height + marginY + (this.getNodeActChildrenLength(node3) > 0 ? node3.expandBtnSize : 0);
            node3.children.forEach((cur) => {
              cur.left = node3.left + node3.width * 0.5;
              cur.top = totalTop;
              totalTop += cur.height + marginY + (this.getNodeActChildrenLength(cur) > 0 ? cur.expandBtnSize : 0);
            });
          }
        }
      },
      null,
      true
    );
  }
  //  调整节点left、top
  adjustLeftTopValue() {
    walk(
      this.root,
      null,
      (node3, parent, isRoot, layerIndex) => {
        if (!node3.getData("expand")) {
          return;
        }
        if (node3.isRoot) {
          this.updateBrothersLeft(node3);
        }
        let len = node3.children.length;
        if (parent && !parent.isRoot && len > 0) {
          let marginY = this.getMarginY(layerIndex + 1);
          let totalHeight = node3.children.reduce((h2, item) => {
            return h2 + item.height + (this.getNodeActChildrenLength(item) > 0 ? item.expandBtnSize : 0);
          }, 0) + len * marginY;
          this.updateBrothersTop(node3, totalHeight);
        }
      },
      (node3, parent, isRoot, layerIndex) => {
        if (parent && parent.isRoot && node3.dir === CONSTANTS.LAYOUT_GROW_DIR.TOP) {
          node3.children.forEach((item) => {
            let totalHeight = this.getNodeAreaHeight(item);
            let _top = item.top;
            item.top = node3.top - (item.top - node3.top) - totalHeight + node3.height;
            this.updateChildren(item.children, "top", item.top - _top);
          });
        }
      },
      true
    );
  }
  //  递归计算节点的宽度
  getNodeAreaHeight(node3) {
    let totalHeight = 0;
    let loop = (node4) => {
      totalHeight += node4.height + (this.getNodeActChildrenLength(node4) > 0 ? node4.expandBtnSize : 0) + this.getMarginY(node4.layerIndex);
      if (node4.children.length) {
        node4.children.forEach((item) => {
          loop(item);
        });
      }
    };
    loop(node3);
    return totalHeight;
  }
  //  调整兄弟节点的left
  updateBrothersLeft(node3) {
    let childrenList = node3.children;
    let totalAddWidth = 0;
    childrenList.forEach((item) => {
      item.left += totalAddWidth;
      if (item.children && item.children.length) {
        this.updateChildren(item.children, "left", totalAddWidth);
      }
      let { left, right } = this.getNodeBoundaries(item, "h");
      let areaWidth = right - left;
      let difference2 = areaWidth - item.width;
      if (difference2 > 0) {
        totalAddWidth += difference2;
      }
    });
  }
  //  调整兄弟节点的top
  updateBrothersTop(node3, addHeight) {
    if (node3.parent && !node3.parent.isRoot) {
      let childrenList = node3.parent.children;
      let index3 = getNodeIndexInNodeList(node3, childrenList);
      childrenList.forEach((item, _index) => {
        if (item.hasCustomPosition()) {
          return;
        }
        let _offset = 0;
        if (_index > index3) {
          _offset = addHeight;
        }
        item.top += _offset;
        if (item.children && item.children.length) {
          this.updateChildren(item.children, "top", _offset);
        }
      });
      this.updateBrothersTop(node3.parent, addHeight);
    }
  }
  //  绘制连线，连接该节点到其子节点
  renderLine(node3, lines, style) {
    if (node3.children.length <= 0) {
      return [];
    }
    let { left, top, width: width2, height: height2, expandBtnSize } = node3;
    if (!this.mindMap.opt.alwaysShowExpandBtn) {
      expandBtnSize = 0;
    }
    let len = node3.children.length;
    if (node3.isRoot) {
      let prevBother = node3;
      node3.children.forEach((item, index3) => {
        let x1 = prevBother.left + prevBother.width;
        let x2 = item.left;
        let y3 = node3.top + node3.height / 2;
        let path2 = `M ${x1},${y3} L ${x2},${y3}`;
        this.setLineStyle(style, lines[index3], path2, item);
        prevBother = item;
      });
    } else {
      let maxy = -Infinity;
      let miny = Infinity;
      let x2 = node3.left + node3.width * 0.3;
      node3.children.forEach((item, index3) => {
        let y3 = item.top + item.height / 2;
        if (y3 > maxy) {
          maxy = y3;
        }
        if (y3 < miny) {
          miny = y3;
        }
        let path2 = `M ${x2},${y3} L ${item.left},${y3}`;
        this.setLineStyle(style, lines[index3], path2, item);
      });
      if (len > 0) {
        let line = this.lineDraw.path();
        expandBtnSize = len > 0 ? expandBtnSize : 0;
        if (node3.parent && node3.parent.isRoot && node3.dir === CONSTANTS.LAYOUT_GROW_DIR.TOP) {
          line.plot(`M ${x2},${top} L ${x2},${miny}`);
        } else {
          line.plot(`M ${x2},${top + height2 + expandBtnSize} L ${x2},${maxy}`);
        }
        node3.style.line(line);
        node3._lines.push(line);
        style && style(line, node3);
      }
    }
  }
  //  渲染按钮
  renderExpandBtn(node3, btn) {
    let { width: width2, height: height2, expandBtnSize, isRoot } = node3;
    if (!isRoot) {
      let { translateX, translateY } = btn.transform();
      if (node3.parent && node3.parent.isRoot && node3.dir === CONSTANTS.LAYOUT_GROW_DIR.TOP) {
        btn.translate(
          width2 * 0.3 - expandBtnSize / 2 - translateX,
          -expandBtnSize / 2 - translateY
        );
      } else {
        btn.translate(
          width2 * 0.3 - expandBtnSize / 2 - translateX,
          height2 + expandBtnSize / 2 - translateY
        );
      }
    }
  }
  //  创建概要节点
  renderGeneralization(list2) {
    list2.forEach((item) => {
      let {
        top,
        bottom,
        right,
        generalizationLineMargin,
        generalizationNodeMargin
      } = this.getNodeGeneralizationRenderBoundaries(item, "h");
      let x1 = right + generalizationLineMargin;
      let y1 = top;
      let x2 = right + generalizationLineMargin;
      let y22 = bottom;
      let cx2 = x1 + 20;
      let cy2 = y1 + (y22 - y1) / 2;
      let path2 = `M ${x1},${y1} Q ${cx2},${cy2} ${x2},${y22}`;
      item.generalizationLine.plot(path2);
      item.generalizationNode.left = right + generalizationNodeMargin;
      item.generalizationNode.top = top + (bottom - top - item.generalizationNode.height) / 2;
    });
  }
  // 渲染展开收起按钮的隐藏占位元素
  renderExpandBtnRect(rect, expandBtnSize, width2, height2, node3) {
    if (this.layout === CONSTANTS.LAYOUT.TIMELINE) {
      rect.size(width2, expandBtnSize).x(0).y(height2);
    } else {
      let dir = "";
      if (node3.dir === CONSTANTS.LAYOUT_GROW_DIR.TOP) {
        dir = node3.layerIndex === 1 ? CONSTANTS.LAYOUT_GROW_DIR.TOP : CONSTANTS.LAYOUT_GROW_DIR.BOTTOM;
      } else {
        dir = CONSTANTS.LAYOUT_GROW_DIR.BOTTOM;
      }
      if (dir === CONSTANTS.LAYOUT_GROW_DIR.TOP) {
        rect.size(width2, expandBtnSize).x(0).y(-expandBtnSize);
      } else {
        rect.size(width2, expandBtnSize).x(0).y(height2);
      }
    }
  }
};
var Timeline_default = Timeline2;

// ../simple-mind-map/src/layouts/VerticalTimeline.js
var VerticalTimeline = class extends Base_default {
  //  构造函数
  constructor(opt = {}, layout) {
    super(opt);
    this.layout = layout;
  }
  //  布局
  doLayout(callback) {
    let task = [
      () => {
        this.computedBaseValue();
      },
      () => {
        this.computedTopValue();
      },
      () => {
        this.adjustLeftTopValue();
      },
      () => {
        callback(this.root);
      }
    ];
    asyncRun(task);
  }
  //  遍历数据创建节点、计算根节点的位置，计算根节点的子节点的top值
  computedBaseValue() {
    walk(
      this.renderer.renderTree,
      null,
      (cur, parent, isRoot, layerIndex, index3) => {
        let newNode = this.createNode(cur, parent, isRoot, layerIndex);
        if (isRoot) {
          this.setNodeCenter(newNode);
        } else {
          if (parent._node.dir) {
            newNode.dir = parent._node.dir;
          } else {
            newNode.dir = index3 % 2 === 0 ? CONSTANTS.LAYOUT_GROW_DIR.RIGHT : CONSTANTS.LAYOUT_GROW_DIR.LEFT;
          }
          if (parent._node.isRoot) {
            newNode.left = parent._node.left + (cur._node.width > parent._node.width ? -(cur._node.width - parent._node.width) / 2 : (parent._node.width - cur._node.width) / 2);
          } else {
            newNode.left = newNode.dir === CONSTANTS.LAYOUT_GROW_DIR.RIGHT ? parent._node.left + parent._node.width + this.getMarginX(layerIndex) : parent._node.left - this.getMarginX(layerIndex) - newNode.width;
          }
        }
        if (!cur.data.expand) {
          return true;
        }
      },
      (cur, parent, isRoot, layerIndex) => {
        if (isRoot) {
          return;
        }
        let len = cur.data.expand === false ? 0 : cur._node.children.length;
        cur._node.childrenAreaHeight = len ? cur._node.children.reduce((h2, item) => {
          return h2 + item.height;
        }, 0) + (len + 1) * this.getMarginY(layerIndex + 1) : 0;
      },
      true,
      0
    );
  }
  //  遍历节点树计算节点的top
  computedTopValue() {
    walk(
      this.root,
      null,
      (node3, parent, isRoot, layerIndex, index3) => {
        if (node3.getData("expand") && node3.children && node3.children.length) {
          let marginY = this.getMarginY(layerIndex + 1);
          if (isRoot) {
            let top = node3.top + node3.height;
            let totalTop = top + marginY;
            node3.children.forEach((cur) => {
              cur.top = totalTop;
              totalTop += cur.height + marginY;
            });
          } else {
            let marginY2 = this.getMarginY(layerIndex + 1);
            let baseTop = node3.top + node3.height / 2 + marginY2;
            let totalTop = baseTop - node3.childrenAreaHeight / 2;
            node3.children.forEach((cur) => {
              cur.top = totalTop;
              totalTop += cur.height + marginY2;
            });
          }
        }
      },
      null,
      true
    );
  }
  //  调整节点left、top
  adjustLeftTopValue() {
    walk(
      this.root,
      null,
      (node3, parent, isRoot, layerIndex) => {
        if (!node3.getData("expand")) {
          return;
        }
        if (isRoot)
          return;
        let base = this.getMarginY(layerIndex + 1) * 2 + node3.height;
        let difference2 = node3.childrenAreaHeight - base;
        if (difference2 > 0) {
          this.updateBrothers(node3, difference2 / 2);
        }
      },
      null,
      true
    );
  }
  //  更新兄弟节点的top
  updateBrothers(node3, addHeight) {
    if (node3.parent) {
      let childrenList = node3.parent.children;
      let index3 = getNodeIndexInNodeList(node3, childrenList);
      childrenList.forEach((item, _index) => {
        if (item.hasCustomPosition())
          return;
        if (!node3.parent.isRoot && item.uid === node3.uid)
          return;
        let _offset = 0;
        if (node3.parent.isRoot) {
          if (_index < index3) {
            _offset = 0;
          } else if (_index > index3) {
            _offset = addHeight * 2;
          } else {
            _offset = addHeight;
          }
        } else {
          if (_index < index3) {
            _offset = -addHeight;
          } else if (_index > index3) {
            _offset = addHeight;
          }
        }
        item.top += _offset;
        if (item.children && item.children.length) {
          this.updateChildren(item.children, "top", _offset);
        }
      });
      this.updateBrothers(node3.parent, addHeight);
    }
  }
  //  调整兄弟节点的top
  updateBrothersTop(node3, addHeight) {
    if (node3.parent && !node3.parent.isRoot) {
      let childrenList = node3.parent.children;
      let index3 = getNodeIndexInNodeList(node3, childrenList);
      childrenList.forEach((item, _index) => {
        if (item.hasCustomPosition()) {
          return;
        }
        let _offset = 0;
        if (_index > index3) {
          _offset = addHeight;
        }
        item.top += _offset;
        if (item.children && item.children.length) {
          this.updateChildren(item.children, "top", _offset);
        }
      });
      this.updateBrothersTop(node3.parent, addHeight);
    }
  }
  //  绘制连线，连接该节点到其子节点
  renderLine(node3, lines, style, lineStyle) {
    if (lineStyle === "curve") {
      this.renderLineCurve(node3, lines, style);
    } else if (lineStyle === "direct") {
      this.renderLineDirect(node3, lines, style);
    } else {
      this.renderLineStraight(node3, lines, style);
    }
  }
  // 直线连接
  renderLineStraight(node3, lines, style) {
    if (node3.children.length <= 0) {
      return [];
    }
    let { expandBtnSize } = node3;
    if (!this.mindMap.opt.alwaysShowExpandBtn) {
      expandBtnSize = 0;
    }
    if (node3.isRoot) {
      let prevBother = node3;
      node3.children.forEach((item, index3) => {
        let y1 = prevBother.top + prevBother.height;
        let y22 = item.top;
        let x2 = node3.left + node3.width / 2;
        let path2 = `M ${x2},${y1} L ${x2},${y22}`;
        this.setLineStyle(style, lines[index3], path2, item);
        prevBother = item;
      });
    } else {
      if (node3.dir === CONSTANTS.LAYOUT_GROW_DIR.RIGHT) {
        let nodeRight = node3.left + node3.width;
        let nodeYCenter = node3.top + node3.height / 2;
        let marginX = this.getMarginX(node3.layerIndex + 1);
        let offset = (marginX - expandBtnSize) * 0.6;
        node3.children.forEach((item, index3) => {
          let itemLeft = item.left;
          let itemYCenter = item.top + item.height / 2;
          let path2 = `
            M ${nodeRight},${nodeYCenter} 
            L ${nodeRight + offset},${nodeYCenter} 
            L ${nodeRight + offset},${itemYCenter} 
            L ${itemLeft},${itemYCenter}`;
          this.setLineStyle(style, lines[index3], path2, item);
        });
      } else {
        let nodeLeft = node3.left;
        let nodeYCenter = node3.top + node3.height / 2;
        let marginX = this.getMarginX(node3.layerIndex + 1);
        let offset = (marginX - expandBtnSize) * 0.6;
        node3.children.forEach((item, index3) => {
          let itemRight = item.left + item.width;
          let itemYCenter = item.top + item.height / 2;
          let path2 = `
            M ${nodeLeft},${nodeYCenter} 
            L ${nodeLeft - offset},${nodeYCenter} 
            L ${nodeLeft - offset},${itemYCenter} 
            L ${itemRight},${itemYCenter}`;
          this.setLineStyle(style, lines[index3], path2, item);
        });
      }
    }
  }
  // 直连
  renderLineDirect(node3, lines, style) {
    if (node3.children.length <= 0) {
      return [];
    }
    let { left, top, width: width2, height: height2, expandBtnSize } = node3;
    if (!this.mindMap.opt.alwaysShowExpandBtn) {
      expandBtnSize = 0;
    }
    node3.children.forEach((item, index3) => {
      if (node3.isRoot) {
        let prevBother = node3;
        node3.children.forEach((item2, index4) => {
          let y1 = prevBother.top + prevBother.height;
          let y22 = item2.top;
          let x2 = node3.left + node3.width / 2;
          let path2 = `M ${x2},${y1} L ${x2},${y22}`;
          this.setLineStyle(style, lines[index4], path2, item2);
          prevBother = item2;
        });
      } else {
        let x1 = item.dir === CONSTANTS.LAYOUT_GROW_DIR.LEFT ? left - expandBtnSize : left + width2 + expandBtnSize;
        let y1 = top + height2 / 2;
        let x2 = item.dir === CONSTANTS.LAYOUT_GROW_DIR.LEFT ? item.left + item.width : item.left;
        let y22 = item.top + item.height / 2;
        let path2 = `M ${x1},${y1} L ${x2},${y22}`;
        this.setLineStyle(style, lines[index3], path2, item);
      }
    });
  }
  //  曲线风格连线
  renderLineCurve(node3, lines, style) {
    if (node3.children.length <= 0) {
      return [];
    }
    let { left, top, width: width2, height: height2, expandBtnSize } = node3;
    if (!this.mindMap.opt.alwaysShowExpandBtn) {
      expandBtnSize = 0;
    }
    node3.children.forEach((item, index3) => {
      if (node3.isRoot) {
        let prevBother = node3;
        node3.children.forEach((item2, index4) => {
          let y1 = prevBother.top + prevBother.height;
          let y22 = item2.top;
          let x2 = node3.left + node3.width / 2;
          let path2 = `M ${x2},${y1} L ${x2},${y22}`;
          this.setLineStyle(style, lines[index4], path2, item2);
          prevBother = item2;
        });
      } else {
        let x1 = item.dir === CONSTANTS.LAYOUT_GROW_DIR.LEFT ? left - expandBtnSize : left + width2 + expandBtnSize;
        let y1 = top + height2 / 2;
        let x2 = item.dir === CONSTANTS.LAYOUT_GROW_DIR.LEFT ? item.left + item.width : item.left;
        let y22 = item.top + item.height / 2;
        let path2 = this.cubicBezierPath(x1, y1, x2, y22);
        this.setLineStyle(style, lines[index3], path2, item);
      }
    });
  }
  //  渲染按钮
  renderExpandBtn(node3, btn) {
    let { width: width2, height: height2, expandBtnSize, isRoot } = node3;
    if (!isRoot) {
      let { translateX, translateY } = btn.transform();
      if (node3.dir === CONSTANTS.LAYOUT_GROW_DIR.RIGHT) {
        btn.translate(width2 - translateX, height2 / 2 - translateY);
      } else {
        btn.translate(-expandBtnSize - translateX, height2 / 2 - translateY);
      }
    }
  }
  //  创建概要节点
  renderGeneralization(list2) {
    list2.forEach((item) => {
      let isLeft = item.node.dir === CONSTANTS.LAYOUT_GROW_DIR.LEFT;
      let {
        top,
        bottom,
        left,
        right,
        generalizationLineMargin,
        generalizationNodeMargin
      } = this.getNodeGeneralizationRenderBoundaries(item, "h");
      let x2 = isLeft ? left - generalizationLineMargin : right + generalizationLineMargin;
      let x1 = x2;
      let y1 = top;
      let x22 = x2;
      let y22 = bottom;
      let cx2 = x1 + (isLeft ? -20 : 20);
      let cy2 = y1 + (y22 - y1) / 2;
      let path2 = `M ${x1},${y1} Q ${cx2},${cy2} ${x22},${y22}`;
      item.generalizationLine.plot(path2);
      item.generalizationNode.left = x2 + (isLeft ? -generalizationNodeMargin : generalizationNodeMargin) - (isLeft ? item.generalizationNode.width : 0);
      item.generalizationNode.top = top + (bottom - top - item.generalizationNode.height) / 2;
    });
  }
  // 渲染展开收起按钮的隐藏占位元素
  renderExpandBtnRect(rect, expandBtnSize, width2, height2, node3) {
    if (node3.dir === CONSTANTS.LAYOUT_GROW_DIR.LEFT) {
      rect.size(expandBtnSize, height2).x(-expandBtnSize).y(0);
    } else {
      rect.size(expandBtnSize, height2).x(width2).y(0);
    }
  }
};
var VerticalTimeline_default = VerticalTimeline;

// ../simple-mind-map/src/layouts/fishboneUtils.js
var fishboneUtils_default = {
  top: {
    renderExpandBtn({
      node: node3,
      btn,
      expandBtnSize,
      translateX,
      translateY,
      width: width2,
      height: height2
    }) {
      if (node3.parent && node3.parent.isRoot) {
        btn.translate(
          width2 * 0.3 - expandBtnSize / 2 - translateX,
          -expandBtnSize / 2 - translateY
        );
      } else {
        btn.translate(
          width2 * 0.3 - expandBtnSize / 2 - translateX,
          height2 + expandBtnSize / 2 - translateY
        );
      }
    },
    renderLine({
      node: node3,
      line,
      top,
      x: x2,
      lineLength,
      height: height2,
      expandBtnSize,
      maxy,
      ctx
    }) {
      if (node3.parent && node3.parent.isRoot) {
        line.plot(
          `M ${x2},${top} L ${x2 + lineLength},${top - Math.tan(degToRad(ctx.mindMap.opt.fishboneDeg)) * lineLength}`
        );
      } else {
        line.plot(`M ${x2},${top + height2 + expandBtnSize} L ${x2},${maxy}`);
      }
    },
    computedLeftTopValue({ layerIndex, node: node3, ctx }) {
      if (layerIndex >= 1 && node3.children) {
        let marginY = ctx.getMarginY(layerIndex + 1);
        let startLeft = node3.left + node3.width * ctx.childIndent;
        let totalTop = node3.top + node3.height + (ctx.getNodeActChildrenLength(node3) > 0 ? node3.expandBtnSize : 0) + marginY;
        node3.children.forEach((item) => {
          item.left = startLeft;
          item.top += totalTop;
          totalTop += item.height + (ctx.getNodeActChildrenLength(item) > 0 ? item.expandBtnSize : 0) + marginY;
        });
      }
    },
    adjustLeftTopValueBefore({ node: node3, parent, ctx, layerIndex }) {
      let len = node3.children.length;
      let marginY = ctx.getMarginY(layerIndex + 1);
      if (parent && !parent.isRoot && len > 0) {
        let totalHeight = node3.children.reduce((h2, item) => {
          return h2 + item.height + (ctx.getNodeActChildrenLength(item) > 0 ? item.expandBtnSize : 0) + marginY;
        }, 0);
        ctx.updateBrothersTop(node3, totalHeight);
      }
    },
    adjustLeftTopValueAfter({ parent, node: node3, ctx }) {
      if (parent && parent.isRoot) {
        let marginY = ctx.getMarginY(node3.layerIndex + 1);
        let totalHeight = node3.expandBtnSize + marginY;
        node3.children.forEach((item) => {
          let nodeTotalHeight = ctx.getNodeAreaHeight(item);
          let _top = item.top;
          let _left = item.left;
          item.top = node3.top - (item.top - node3.top) - nodeTotalHeight + node3.height;
          item.left = node3.left + node3.width * ctx.indent + (nodeTotalHeight + totalHeight) / Math.tan(degToRad(ctx.mindMap.opt.fishboneDeg));
          totalHeight += nodeTotalHeight;
          ctx.updateChildrenPro(item.children, {
            top: item.top - _top,
            left: item.left - _left
          });
        });
      }
    }
  },
  bottom: {
    renderExpandBtn({
      node: node3,
      btn,
      expandBtnSize,
      translateX,
      translateY,
      width: width2,
      height: height2
    }) {
      if (node3.parent && node3.parent.isRoot) {
        btn.translate(
          width2 * 0.3 - expandBtnSize / 2 - translateX,
          height2 + expandBtnSize / 2 - translateY
        );
      } else {
        btn.translate(
          width2 * 0.3 - expandBtnSize / 2 - translateX,
          -expandBtnSize / 2 - translateY
        );
      }
    },
    renderLine({ node: node3, line, top, x: x2, lineLength, height: height2, miny, ctx }) {
      if (node3.parent && node3.parent.isRoot) {
        line.plot(
          `M ${x2},${top + height2} L ${x2 + lineLength},${top + height2 + Math.tan(degToRad(ctx.mindMap.opt.fishboneDeg)) * lineLength}`
        );
      } else {
        line.plot(`M ${x2},${top} L ${x2},${miny}`);
      }
    },
    computedLeftTopValue({ layerIndex, node: node3, ctx }) {
      let marginY = ctx.getMarginY(layerIndex + 1);
      if (layerIndex === 1 && node3.children) {
        let startLeft = node3.left + node3.width * ctx.childIndent;
        let totalTop = node3.top + node3.height + (ctx.getNodeActChildrenLength(node3) > 0 ? node3.expandBtnSize : 0) + marginY;
        node3.children.forEach((item) => {
          item.left = startLeft;
          item.top = totalTop + (ctx.getNodeActChildrenLength(item) > 0 ? item.expandBtnSize : 0);
          totalTop += item.height + (ctx.getNodeActChildrenLength(item) > 0 ? item.expandBtnSize : 0) + marginY;
        });
      }
      if (layerIndex > 1 && node3.children) {
        let startLeft = node3.left + node3.width * ctx.childIndent;
        let totalTop = node3.top - (ctx.getNodeActChildrenLength(node3) > 0 ? node3.expandBtnSize : 0) - marginY;
        node3.children.forEach((item) => {
          item.left = startLeft;
          item.top = totalTop - item.height;
          totalTop -= item.height + (ctx.getNodeActChildrenLength(item) > 0 ? item.expandBtnSize : 0) + marginY;
        });
      }
    },
    adjustLeftTopValueBefore({ node: node3, ctx, layerIndex }) {
      let marginY = ctx.getMarginY(layerIndex + 1);
      let len = node3.children.length;
      if (layerIndex > 2 && len > 0) {
        let totalHeight = node3.children.reduce((h2, item) => {
          return h2 + item.height + (ctx.getNodeActChildrenLength(item) > 0 ? item.expandBtnSize : 0) + marginY;
        }, 0);
        ctx.updateBrothersTop(node3, -totalHeight);
      }
    },
    adjustLeftTopValueAfter({ parent, node: node3, ctx }) {
      if (parent && parent.isRoot) {
        let marginY = ctx.getMarginY(node3.layerIndex + 1);
        let totalHeight = 0;
        let totalHeight2 = node3.expandBtnSize;
        node3.children.forEach((item) => {
          let hasChildren = ctx.getNodeActChildrenLength(item) > 0;
          let nodeTotalHeight = ctx.getNodeAreaHeight(item);
          let offset = hasChildren ? nodeTotalHeight - item.height - (hasChildren ? item.expandBtnSize : 0) : 0;
          offset -= hasChildren ? marginY : 0;
          let _top = totalHeight + offset;
          let _left = item.left;
          item.top += _top;
          item.left = node3.left + node3.width * ctx.indent + (nodeTotalHeight + totalHeight2) / Math.tan(degToRad(ctx.mindMap.opt.fishboneDeg));
          totalHeight += offset;
          totalHeight2 += nodeTotalHeight;
          ctx.updateChildrenPro(item.children, {
            top: _top,
            left: item.left - _left
          });
        });
      }
    }
  }
};

// ../simple-mind-map/src/layouts/Fishbone.js
var Fishbone = class extends Base_default {
  //  构造函数
  constructor(opt = {}) {
    super(opt);
    this.indent = 0.3;
    this.childIndent = 0.5;
  }
  //  布局
  doLayout(callback) {
    let task = [
      () => {
        this.computedBaseValue();
      },
      () => {
        this.computedLeftTopValue();
      },
      () => {
        this.adjustLeftTopValue();
      },
      () => {
        callback(this.root);
      }
    ];
    asyncRun(task);
  }
  //  遍历数据创建节点、计算根节点的位置，计算根节点的子节点的top值
  computedBaseValue() {
    walk(
      this.renderer.renderTree,
      null,
      (node3, parent, isRoot, layerIndex, index3) => {
        let newNode = this.createNode(node3, parent, isRoot, layerIndex);
        if (isRoot) {
          this.setNodeCenter(newNode);
        } else {
          if (parent._node.dir) {
            newNode.dir = parent._node.dir;
          } else {
            newNode.dir = index3 % 2 === 0 ? CONSTANTS.LAYOUT_GROW_DIR.TOP : CONSTANTS.LAYOUT_GROW_DIR.BOTTOM;
          }
          if (parent._node.isRoot) {
            let marginY = this.getMarginY(layerIndex);
            if (this.checkIsTop(newNode)) {
              newNode.top = parent._node.top - newNode.height - marginY;
            } else {
              newNode.top = parent._node.top + parent._node.height + marginY;
            }
          }
        }
        if (!node3.data.expand) {
          return true;
        }
      },
      null,
      true,
      0
    );
  }
  //  遍历节点树计算节点的left、top
  computedLeftTopValue() {
    walk(
      this.root,
      null,
      (node3, parent, isRoot, layerIndex) => {
        if (node3.isRoot) {
          let marginX = this.getMarginX(layerIndex + 1);
          let topTotalLeft = node3.left + node3.width + node3.height + marginX;
          let bottomTotalLeft = node3.left + node3.width + node3.height + marginX;
          node3.children.forEach((item) => {
            if (this.checkIsTop(item)) {
              item.left = topTotalLeft;
              topTotalLeft += item.width + marginX;
            } else {
              item.left = bottomTotalLeft + 20;
              bottomTotalLeft += item.width + marginX;
            }
          });
        }
        let params = { layerIndex, node: node3, ctx: this };
        if (this.checkIsTop(node3)) {
          fishboneUtils_default.top.computedLeftTopValue(params);
        } else {
          fishboneUtils_default.bottom.computedLeftTopValue(params);
        }
      },
      null,
      true
    );
  }
  //  调整节点left、top
  adjustLeftTopValue() {
    walk(
      this.root,
      null,
      (node3, parent, isRoot, layerIndex) => {
        if (!node3.getData("expand")) {
          return;
        }
        let params = { node: node3, parent, layerIndex, ctx: this };
        if (this.checkIsTop(node3)) {
          fishboneUtils_default.top.adjustLeftTopValueBefore(params);
        } else {
          fishboneUtils_default.bottom.adjustLeftTopValueBefore(params);
        }
      },
      (node3, parent) => {
        let params = { parent, node: node3, ctx: this };
        if (this.checkIsTop(node3)) {
          fishboneUtils_default.top.adjustLeftTopValueAfter(params);
        } else {
          fishboneUtils_default.bottom.adjustLeftTopValueAfter(params);
        }
        if (node3.isRoot) {
          let topTotalLeft = 0;
          let bottomTotalLeft = 0;
          node3.children.forEach((item) => {
            if (this.checkIsTop(item)) {
              item.left += topTotalLeft;
              this.updateChildren(item.children, "left", topTotalLeft);
              let { left, right } = this.getNodeBoundaries(item, "h");
              topTotalLeft += right - left;
            } else {
              item.left += bottomTotalLeft;
              this.updateChildren(item.children, "left", bottomTotalLeft);
              let { left, right } = this.getNodeBoundaries(item, "h");
              bottomTotalLeft += right - left;
            }
          });
        }
      },
      true
    );
  }
  //  递归计算节点的宽度
  getNodeAreaHeight(node3) {
    let totalHeight = 0;
    let loop = (node4) => {
      let marginY = this.getMarginY(node4.layerIndex);
      totalHeight += node4.height + (this.getNodeActChildrenLength(node4) > 0 ? node4.expandBtnSize : 0) + marginY;
      if (node4.children.length) {
        node4.children.forEach((item) => {
          loop(item);
        });
      }
    };
    loop(node3);
    return totalHeight;
  }
  //  调整兄弟节点的left
  updateBrothersLeft(node3) {
    let childrenList = node3.children;
    let totalAddWidth = 0;
    childrenList.forEach((item) => {
      item.left += totalAddWidth;
      if (item.children && item.children.length) {
        this.updateChildren(item.children, "left", totalAddWidth);
      }
      let { left, right } = this.getNodeBoundaries(item, "h");
      let areaWidth = right - left;
      let difference2 = areaWidth - item.width;
      if (difference2 > 0) {
        totalAddWidth += difference2;
      }
    });
  }
  //  调整兄弟节点的top
  updateBrothersTop(node3, addHeight) {
    if (node3.parent && !node3.parent.isRoot) {
      let childrenList = node3.parent.children;
      let index3 = getNodeIndexInNodeList(node3, childrenList);
      childrenList.forEach((item, _index) => {
        if (item.hasCustomPosition()) {
          return;
        }
        let _offset = 0;
        if (_index > index3) {
          _offset = addHeight;
        }
        item.top += _offset;
        if (item.children && item.children.length) {
          this.updateChildren(item.children, "top", _offset);
        }
      });
      if (this.checkIsTop(node3)) {
        this.updateBrothersTop(node3.parent, addHeight);
      } else {
        this.updateBrothersTop(
          node3.parent,
          node3.layerIndex === 3 ? 0 : addHeight
        );
      }
    }
  }
  // 检查节点是否是上方节点
  checkIsTop(node3) {
    return node3.dir === CONSTANTS.LAYOUT_GROW_DIR.TOP;
  }
  //  绘制连线，连接该节点到其子节点
  renderLine(node3, lines, style) {
    if (node3.layerIndex !== 1 && node3.children.length <= 0) {
      return [];
    }
    let { top, height: height2, expandBtnSize } = node3;
    if (!this.mindMap.opt.alwaysShowExpandBtn) {
      expandBtnSize = 0;
    }
    let len = node3.children.length;
    if (node3.isRoot) {
      let maxx = -Infinity;
      node3.children.forEach((item) => {
        if (item.left > maxx) {
          maxx = item.left;
        }
        let marginY = this.getMarginY(item.layerIndex);
        let nodeLineX = item.left;
        let offset2 = node3.height / 2 + marginY;
        let offsetX = offset2 / Math.tan(degToRad(this.mindMap.opt.fishboneDeg));
        let line2 = this.lineDraw.path();
        if (this.checkIsTop(item)) {
          line2.plot(
            `M ${nodeLineX - offsetX},${item.top + item.height + offset2} L ${item.left},${item.top + item.height}`
          );
        } else {
          line2.plot(
            `M ${nodeLineX - offsetX},${item.top - offset2} L ${nodeLineX},${item.top}`
          );
        }
        node3.style.line(line2);
        node3._lines.push(line2);
        style && style(line2, node3);
      });
      let nodeHalfTop = node3.top + node3.height / 2;
      let offset = node3.height / 2 + this.getMarginY(node3.layerIndex + 1);
      let line = this.lineDraw.path();
      line.plot(
        `M ${node3.left + node3.width},${nodeHalfTop} L ${maxx - offset / Math.tan(degToRad(this.mindMap.opt.fishboneDeg))},${nodeHalfTop}`
      );
      node3.style.line(line);
      node3._lines.push(line);
      style && style(line, node3);
    } else {
      let maxy = -Infinity;
      let miny = Infinity;
      let maxx = -Infinity;
      let x2 = node3.left + node3.width * this.indent;
      node3.children.forEach((item, index3) => {
        if (item.left > maxx) {
          maxx = item.left;
        }
        let y3 = item.top + item.height / 2;
        if (y3 > maxy) {
          maxy = y3;
        }
        if (y3 < miny) {
          miny = y3;
        }
        if (node3.layerIndex > 1) {
          let path2 = `M ${x2},${y3} L ${item.left},${y3}`;
          this.setLineStyle(style, lines[index3], path2, item);
        }
      });
      if (len >= 0) {
        let line = this.lineDraw.path();
        expandBtnSize = len > 0 ? expandBtnSize : 0;
        let lineLength = maxx - node3.left - node3.width * this.indent;
        lineLength = Math.max(lineLength, 0);
        let params = {
          node: node3,
          line,
          top,
          x: x2,
          lineLength,
          height: height2,
          expandBtnSize,
          maxy,
          miny,
          ctx: this
        };
        if (this.checkIsTop(node3)) {
          fishboneUtils_default.top.renderLine(params);
        } else {
          fishboneUtils_default.bottom.renderLine(params);
        }
        node3.style.line(line);
        node3._lines.push(line);
        style && style(line, node3);
      }
    }
  }
  //  渲染按钮
  renderExpandBtn(node3, btn) {
    let { width: width2, height: height2, expandBtnSize, isRoot } = node3;
    if (!isRoot) {
      let { translateX, translateY } = btn.transform();
      let params = {
        node: node3,
        btn,
        expandBtnSize,
        translateX,
        translateY,
        width: width2,
        height: height2
      };
      if (this.checkIsTop(node3)) {
        fishboneUtils_default.top.renderExpandBtn(params);
      } else {
        fishboneUtils_default.bottom.renderExpandBtn(params);
      }
    }
  }
  //  创建概要节点
  renderGeneralization(list2) {
    list2.forEach((item) => {
      let {
        top,
        bottom,
        right,
        generalizationLineMargin,
        generalizationNodeMargin
      } = this.getNodeGeneralizationRenderBoundaries(item, "h");
      let x1 = right + generalizationLineMargin;
      let y1 = top;
      let x2 = right + generalizationLineMargin;
      let y22 = bottom;
      let cx2 = x1 + 20;
      let cy2 = y1 + (y22 - y1) / 2;
      let path2 = `M ${x1},${y1} Q ${cx2},${cy2} ${x2},${y22}`;
      item.generalizationLine.plot(path2);
      item.generalizationNode.left = right + generalizationNodeMargin;
      item.generalizationNode.top = top + (bottom - top - item.generalizationNode.height) / 2;
    });
  }
  // 渲染展开收起按钮的隐藏占位元素
  renderExpandBtnRect(rect, expandBtnSize, width2, height2, node3) {
    let dir = "";
    if (node3.dir === CONSTANTS.LAYOUT_GROW_DIR.TOP) {
      dir = node3.layerIndex === 1 ? CONSTANTS.LAYOUT_GROW_DIR.TOP : CONSTANTS.LAYOUT_GROW_DIR.BOTTOM;
    } else {
      dir = node3.layerIndex === 1 ? CONSTANTS.LAYOUT_GROW_DIR.BOTTOM : CONSTANTS.LAYOUT_GROW_DIR.TOP;
    }
    if (dir === CONSTANTS.LAYOUT_GROW_DIR.TOP) {
      rect.size(width2, expandBtnSize).x(0).y(-expandBtnSize);
    } else {
      rect.size(width2, expandBtnSize).x(0).y(height2);
    }
  }
};
var Fishbone_default = Fishbone;

// ../simple-mind-map/src/core/render/TextEdit.js
var TextEdit = class {
  //  构造函数
  constructor(renderer) {
    this.renderer = renderer;
    this.mindMap = renderer.mindMap;
    this.currentNode = null;
    this.textEditNode = null;
    this.showTextEdit = false;
    this.cacheEditingText = "";
    this.hasBodyMousedown = false;
    this.bindEvent();
  }
  //  事件
  bindEvent() {
    this.show = this.show.bind(this);
    this.onScale = this.onScale.bind(this);
    this.onKeydown = this.onKeydown.bind(this);
    this.mindMap.on("node_dblclick", (node3, e2, isInserting) => {
      this.show({ node: node3, e: e2, isInserting });
    });
    this.mindMap.on("draw_click", () => {
      this.hideEditTextBox();
    });
    this.mindMap.on("body_mousedown", () => {
      this.hasBodyMousedown = true;
    });
    this.mindMap.on("body_click", () => {
      if (!this.hasBodyMousedown)
        return;
      this.hasBodyMousedown = false;
      if (this.mindMap.opt.isEndNodeTextEditOnClickOuter) {
        this.hideEditTextBox();
      }
    });
    this.mindMap.on("svg_mousedown", () => {
      this.hideEditTextBox();
    });
    this.mindMap.on("expand_btn_click", () => {
      this.hideEditTextBox();
    });
    this.mindMap.on("before_node_active", () => {
      this.hideEditTextBox();
    });
    this.mindMap.on("mousewheel", () => {
      if (this.mindMap.opt.mousewheelAction === CONSTANTS.MOUSE_WHEEL_ACTION.MOVE) {
        this.hideEditTextBox();
      }
    });
    this.mindMap.keyCommand.addShortcut("F2", () => {
      if (this.renderer.activeNodeList.length <= 0) {
        return;
      }
      this.show({
        node: this.renderer.activeNodeList[0]
      });
    });
    this.mindMap.on("scale", this.onScale);
    if (this.mindMap.opt.enableAutoEnterTextEditWhenKeydown) {
      window.addEventListener("keydown", this.onKeydown);
    }
    this.mindMap.on("beforeDestroy", () => {
      this.unBindEvent();
    });
  }
  // 解绑事件
  unBindEvent() {
    window.removeEventListener("keydown", this.onKeydown);
  }
  // 按键事件
  onKeydown(e2) {
    const activeNodeList = this.mindMap.renderer.activeNodeList;
    if (activeNodeList.length <= 0 || activeNodeList.length > 1)
      return;
    const node3 = activeNodeList[0];
    if (node3 && this.checkIsAutoEnterTextEditKey(e2)) {
      this.show({
        node: node3,
        e: e2,
        isInserting: false,
        isFromKeyDown: true
      });
    }
  }
  // 判断是否是自动进入文本编模式的按钮
  checkIsAutoEnterTextEditKey(e2) {
    const keyCode = e2.keyCode;
    return (keyCode === 229 || keyCode >= 65 && keyCode <= 90 || keyCode >= 48 && keyCode <= 57) && !this.mindMap.keyCommand.hasCombinationKey(e2);
  }
  //  注册临时快捷键
  registerTmpShortcut() {
    this.mindMap.keyCommand.addShortcut("Enter", () => {
      this.hideEditTextBox();
    });
    this.mindMap.keyCommand.addShortcut("Tab", () => {
      this.hideEditTextBox();
    });
  }
  // 获取当前文本编辑框是否处于显示状态，也就是是否处在文本编辑状态
  isShowTextEdit() {
    if (this.mindMap.richText) {
      return this.mindMap.richText.showTextEdit;
    }
    return this.showTextEdit;
  }
  //  显示文本编辑框
  // isInserting：是否是刚创建的节点
  // isFromKeyDown：是否是在按键事件进入的编辑
  async show({
    node: node3,
    isInserting = false,
    isFromKeyDown = false,
    isFromScale = false
  }) {
    if (node3.isUseCustomNodeContent()) {
      return;
    }
    const { beforeTextEdit } = this.mindMap.opt;
    if (typeof beforeTextEdit === "function") {
      let isShow = false;
      try {
        isShow = await beforeTextEdit(node3, isInserting);
      } catch (error) {
        isShow = false;
        this.mindMap.opt.errorHandler(ERROR_TYPES.BEFORE_TEXT_EDIT_ERROR, error);
      }
      if (!isShow)
        return;
    }
    this.currentNode = node3;
    const { offsetLeft, offsetTop } = checkNodeOuter(this.mindMap, node3);
    this.mindMap.view.translateXY(offsetLeft, offsetTop);
    const rect = node3._textData.node.node.getBoundingClientRect();
    const params = {
      node: node3,
      rect,
      isInserting,
      isFromKeyDown,
      isFromScale
    };
    if (this.mindMap.richText) {
      this.mindMap.richText.showEditText(params);
      return;
    }
    this.showEditTextBox(params);
  }
  // 处理画布缩放
  onScale() {
    if (!this.currentNode)
      return;
    if (this.mindMap.richText) {
      this.mindMap.richText.cacheEditingText = this.mindMap.richText.getEditText();
      this.mindMap.richText.showTextEdit = false;
    } else {
      this.cacheEditingText = this.getEditText();
      this.showTextEdit = false;
    }
    this.show({
      node: this.currentNode,
      isFromScale: true
    });
  }
  //  显示文本编辑框
  showEditTextBox({ node: node3, rect, isInserting, isFromKeyDown, isFromScale }) {
    if (this.showTextEdit)
      return;
    const { nodeTextEditZIndex, textAutoWrapWidth, selectTextOnEnterEditText } = this.mindMap.opt;
    if (!isFromScale) {
      this.mindMap.emit("before_show_text_edit");
    }
    this.registerTmpShortcut();
    if (!this.textEditNode) {
      this.textEditNode = document.createElement("div");
      this.textEditNode.style.cssText = `position:fixed;box-sizing: border-box;background-color:#fff;box-shadow: 0 0 20px rgba(0,0,0,.5);padding: 3px 5px;margin-left: -5px;margin-top: -3px;outline: none; word-break: break-all;`;
      this.textEditNode.setAttribute("contenteditable", true);
      this.textEditNode.addEventListener("keyup", (e2) => {
        e2.stopPropagation();
      });
      this.textEditNode.addEventListener("click", (e2) => {
        e2.stopPropagation();
      });
      this.textEditNode.addEventListener("mousedown", (e2) => {
        e2.stopPropagation();
      });
      this.textEditNode.addEventListener("keydown", (e2) => {
        if (this.checkIsAutoEnterTextEditKey(e2)) {
          e2.stopPropagation();
        }
      });
      const targetNode = this.mindMap.opt.customInnerElsAppendTo || document.body;
      targetNode.appendChild(this.textEditNode);
    }
    let scale3 = this.mindMap.view.scale;
    let lineHeight = node3.style.merge("lineHeight");
    let fontSize = node3.style.merge("fontSize");
    let textLines = (this.cacheEditingText || node3.getData("text")).split(/\n/gim).map((item) => {
      return htmlEscape(item);
    });
    let isMultiLine = node3._textData.node.attr("data-ismultiLine") === "true";
    node3.style.domText(this.textEditNode, scale3, isMultiLine);
    this.textEditNode.style.zIndex = nodeTextEditZIndex;
    this.textEditNode.innerHTML = textLines.join("<br>");
    this.textEditNode.style.minWidth = rect.width + 10 + "px";
    this.textEditNode.style.minHeight = rect.height + 6 + "px";
    this.textEditNode.style.left = rect.left + "px";
    this.textEditNode.style.top = rect.top + "px";
    this.textEditNode.style.display = "block";
    this.textEditNode.style.maxWidth = textAutoWrapWidth * scale3 + "px";
    if (isMultiLine && lineHeight !== 1) {
      this.textEditNode.style.transform = `translateY(${-((lineHeight * fontSize - fontSize) / 2) * scale3}px)`;
    }
    this.showTextEdit = true;
    if (isInserting || selectTextOnEnterEditText && !isFromKeyDown) {
      selectAllInput(this.textEditNode);
    } else {
      focusInput(this.textEditNode);
    }
    this.cacheEditingText = "";
  }
  // 获取当前正在编辑的内容
  getEditText() {
    return getStrWithBrFromHtml(this.textEditNode.innerHTML);
  }
  //  隐藏文本编辑框
  hideEditTextBox() {
    this.currentNode = null;
    if (this.mindMap.richText) {
      return this.mindMap.richText.hideEditText();
    }
    if (!this.showTextEdit) {
      return;
    }
    this.renderer.activeNodeList.forEach((node3) => {
      let str = this.getEditText();
      this.mindMap.execCommand("SET_NODE_TEXT", node3, str);
      if (node3.isGeneralization) {
        node3.generalizationBelongNode.updateGeneralization();
      }
      this.mindMap.render();
    });
    this.mindMap.emit(
      "hide_text_edit",
      this.textEditNode,
      this.renderer.activeNodeList
    );
    this.textEditNode.style.display = "none";
    this.textEditNode.innerHTML = "";
    this.textEditNode.style.fontFamily = "inherit";
    this.textEditNode.style.fontSize = "inherit";
    this.textEditNode.style.fontWeight = "normal";
    this.textEditNode.style.transform = "translateY(0)";
    this.showTextEdit = false;
  }
};

// ../simple-mind-map/src/themes/default.js
var default_exports = {};
__export(default_exports, {
  checkIsNodeSizeIndependenceConfig: () => checkIsNodeSizeIndependenceConfig,
  default: () => default_default,
  lineStyleProps: () => lineStyleProps,
  supportActiveStyle: () => supportActiveStyle
});
var default_default = {
  // 节点内边距
  paddingX: 15,
  paddingY: 5,
  // 图片显示的最大宽度
  imgMaxWidth: 100,
  // 图片显示的最大高度
  imgMaxHeight: 100,
  // icon的大小
  iconSize: 20,
  // 连线的粗细
  lineWidth: 1,
  // 连线的颜色
  lineColor: "#549688",
  // 连线样式
  lineDasharray: "none",
  // 连线风格
  lineStyle: "straight",
  // 针对logicalStructure、mindMap两种结构。曲线（curve）、直线（straight）、直连（direct）
  // 曲线连接时，根节点和其他节点的连接线样式保持统一，默认根节点为 ( 型，其他节点为 { 型，设为true后，都为 { 型
  rootLineKeepSameInCurve: true,
  // 连线尾部是否显示标记，目前只支持箭头
  showLineMarker: false,
  // 概要连线的粗细
  generalizationLineWidth: 1,
  // 概要连线的颜色
  generalizationLineColor: "#549688",
  // 概要曲线距节点的距离
  generalizationLineMargin: 0,
  // 概要节点距节点的距离
  generalizationNodeMargin: 20,
  // 关联线默认状态的粗细
  associativeLineWidth: 2,
  // 关联线默认状态的颜色
  associativeLineColor: "rgb(51, 51, 51)",
  // 关联线激活状态的粗细
  associativeLineActiveWidth: 8,
  // 关联线激活状态的颜色
  associativeLineActiveColor: "rgba(2, 167, 240, 1)",
  // 关联线文字颜色
  associativeLineTextColor: "rgb(51, 51, 51)",
  // 关联线文字大小
  associativeLineTextFontSize: 14,
  // 关联线文字行高
  associativeLineTextLineHeight: 1.2,
  // 关联线文字字体
  associativeLineTextFontFamily: "\u5FAE\u8F6F\u96C5\u9ED1, Microsoft YaHei",
  // 背景颜色
  backgroundColor: "#fafafa",
  // 背景图片
  backgroundImage: "none",
  // 背景重复
  backgroundRepeat: "no-repeat",
  // 设置背景图像的起始位置
  backgroundPosition: "center center",
  // 设置背景图片大小
  backgroundSize: "cover",
  // 节点使用横线样式
  nodeUseLineStyle: false,
  // 根节点样式
  root: {
    shape: "rectangle",
    fillColor: "#549688",
    fontFamily: "\u5FAE\u8F6F\u96C5\u9ED1, Microsoft YaHei",
    color: "#fff",
    fontSize: 16,
    fontWeight: "bold",
    fontStyle: "normal",
    lineHeight: 1.5,
    borderColor: "transparent",
    borderWidth: 0,
    borderDasharray: "none",
    borderRadius: 5,
    textDecoration: "none"
  },
  // 二级节点样式
  second: {
    shape: "rectangle",
    marginX: 100,
    marginY: 40,
    fillColor: "#fff",
    fontFamily: "\u5FAE\u8F6F\u96C5\u9ED1, Microsoft YaHei",
    color: "#565656",
    fontSize: 16,
    fontWeight: "noraml",
    fontStyle: "normal",
    lineHeight: 1.5,
    borderColor: "#549688",
    borderWidth: 1,
    borderDasharray: "none",
    borderRadius: 5,
    textDecoration: "none"
  },
  // 三级及以下节点样式
  node: {
    shape: "rectangle",
    marginX: 50,
    marginY: 0,
    fillColor: "transparent",
    fontFamily: "\u5FAE\u8F6F\u96C5\u9ED1, Microsoft YaHei",
    color: "#6a6d6c",
    fontSize: 14,
    fontWeight: "noraml",
    fontStyle: "normal",
    lineHeight: 1.5,
    borderColor: "transparent",
    borderWidth: 0,
    borderRadius: 5,
    borderDasharray: "none",
    textDecoration: "none"
  },
  // 概要节点样式
  generalization: {
    shape: "rectangle",
    marginX: 100,
    marginY: 40,
    fillColor: "#fff",
    fontFamily: "\u5FAE\u8F6F\u96C5\u9ED1, Microsoft YaHei",
    color: "#565656",
    fontSize: 16,
    fontWeight: "noraml",
    fontStyle: "normal",
    lineHeight: 1.5,
    borderColor: "#549688",
    borderWidth: 1,
    borderDasharray: "none",
    borderRadius: 5,
    textDecoration: "none"
  }
};
var supportActiveStyle = [
  "fillColor",
  "borderColor",
  "borderWidth",
  "borderDasharray",
  "borderRadius"
];
var nodeSizeIndependenceList = [
  "lineWidth",
  "lineColor",
  "lineDasharray",
  "lineStyle",
  "generalizationLineWidth",
  "generalizationLineColor",
  "associativeLineWidth",
  "associativeLineColor",
  "associativeLineActiveWidth",
  "associativeLineActiveColor",
  "associativeLineTextColor",
  "associativeLineTextFontSize",
  "associativeLineTextLineHeight",
  "associativeLineTextFontFamily",
  "backgroundColor",
  "backgroundImage",
  "backgroundRepeat",
  "backgroundPosition",
  "backgroundSize",
  "rootLineKeepSameInCurve",
  "showLineMarker"
];
var checkIsNodeSizeIndependenceConfig = (config) => {
  let keys = Object.keys(config);
  for (let i2 = 0; i2 < keys.length; i2++) {
    if (!nodeSizeIndependenceList.find((item) => {
      return item === keys[i2];
    })) {
      return false;
    }
  }
  return true;
};
var lineStyleProps = ["lineColor", "lineDasharray", "lineWidth"];

// ../simple-mind-map/src/core/render/Render.js
var layouts = {
  // 逻辑结构图
  [CONSTANTS.LAYOUT.LOGICAL_STRUCTURE]: LogicalStructure_default,
  // 思维导图
  [CONSTANTS.LAYOUT.MIND_MAP]: MindMap_default,
  // 目录组织图
  [CONSTANTS.LAYOUT.CATALOG_ORGANIZATION]: CatalogOrganization_default,
  // 组织结构图
  [CONSTANTS.LAYOUT.ORGANIZATION_STRUCTURE]: OrganizationStructure_default,
  // 时间轴
  [CONSTANTS.LAYOUT.TIMELINE]: Timeline_default,
  // 时间轴2
  [CONSTANTS.LAYOUT.TIMELINE2]: Timeline_default,
  // 竖向时间轴
  [CONSTANTS.LAYOUT.VERTICAL_TIMELINE]: VerticalTimeline_default,
  // 鱼骨图
  [CONSTANTS.LAYOUT.FISHBONE]: Fishbone_default
};
var Render = class {
  //  构造函数
  constructor(opt = {}) {
    this.opt = opt;
    this.mindMap = opt.mindMap;
    this.themeConfig = this.mindMap.themeConfig;
    this.renderTree = (0, import_deepmerge.default)({}, this.mindMap.opt.data || {});
    this.reRender = false;
    this.isRendering = false;
    this.hasWaitRendering = false;
    this.waitRenderingParams = [];
    this.nodeCache = {};
    this.lastNodeCache = {};
    this.renderSource = "";
    this.activeNodeList = [];
    this.root = null;
    this.textEdit = new TextEdit(this);
    this.lastBeingCopyData = null;
    this.beingCopyData = null;
    this.beingPasteText = "";
    this.beingPasteImgSize = 0;
    this.currentBeingPasteType = "";
    this.highlightBoxNode = null;
    this.lastActiveNode = null;
    this.lastActiveNodeList = [];
    this.setLayout();
    this.bindEvent();
    this.registerCommands();
    this.registerShortcutKeys();
  }
  //  设置布局结构
  setLayout() {
    this.layout = new (layouts[this.mindMap.opt.layout] ? layouts[this.mindMap.opt.layout] : layouts[CONSTANTS.LAYOUT.LOGICAL_STRUCTURE])(this, this.mindMap.opt.layout);
  }
  // 重新设置思维导图数据
  setData(data2) {
    if (this.mindMap.richText) {
      this.renderTree = this.mindMap.richText.handleSetData(data2);
    } else {
      this.renderTree = data2;
    }
  }
  //   绑定事件
  bindEvent() {
    this.mindMap.on("draw_click", (e2) => {
      this.clearActiveNodeListOnDrawClick(e2, "click");
    });
    this.mindMap.on("contextmenu", (e2) => {
      this.clearActiveNodeListOnDrawClick(e2, "contextmenu");
    });
    this.mindMap.svg.on("dblclick", () => {
      if (!this.mindMap.opt.enableDblclickBackToRootNode)
        return;
      this.setRootNodeCenter();
    });
  }
  //  注册命令
  registerCommands() {
    this.selectAll = this.selectAll.bind(this);
    this.mindMap.command.add("SELECT_ALL", this.selectAll);
    this.back = this.back.bind(this);
    this.mindMap.command.add("BACK", this.back);
    this.forward = this.forward.bind(this);
    this.mindMap.command.add("FORWARD", this.forward);
    this.insertNode = this.insertNode.bind(this);
    this.mindMap.command.add("INSERT_NODE", this.insertNode);
    this.insertMultiNode = this.insertMultiNode.bind(this);
    this.mindMap.command.add("INSERT_MULTI_NODE", this.insertMultiNode);
    this.insertChildNode = this.insertChildNode.bind(this);
    this.mindMap.command.add("INSERT_CHILD_NODE", this.insertChildNode);
    this.insertMultiChildNode = this.insertMultiChildNode.bind(this);
    this.mindMap.command.add(
      "INSERT_MULTI_CHILD_NODE",
      this.insertMultiChildNode
    );
    this.insertParentNode = this.insertParentNode.bind(this);
    this.mindMap.command.add("INSERT_PARENT_NODE", this.insertParentNode);
    this.upNode = this.upNode.bind(this);
    this.mindMap.command.add("UP_NODE", this.upNode);
    this.downNode = this.downNode.bind(this);
    this.mindMap.command.add("DOWN_NODE", this.downNode);
    this.insertAfter = this.insertAfter.bind(this);
    this.mindMap.command.add("INSERT_AFTER", this.insertAfter);
    this.insertBefore = this.insertBefore.bind(this);
    this.mindMap.command.add("INSERT_BEFORE", this.insertBefore);
    this.moveNodeTo = this.moveNodeTo.bind(this);
    this.mindMap.command.add("MOVE_NODE_TO", this.moveNodeTo);
    this.removeNode = this.removeNode.bind(this);
    this.mindMap.command.add("REMOVE_NODE", this.removeNode);
    this.removeCurrentNode = this.removeCurrentNode.bind(this);
    this.mindMap.command.add("REMOVE_CURRENT_NODE", this.removeCurrentNode);
    this.pasteNode = this.pasteNode.bind(this);
    this.mindMap.command.add("PASTE_NODE", this.pasteNode);
    this.cutNode = this.cutNode.bind(this);
    this.mindMap.command.add("CUT_NODE", this.cutNode);
    this.setNodeStyle = this.setNodeStyle.bind(this);
    this.mindMap.command.add("SET_NODE_STYLE", this.setNodeStyle);
    this.setNodeStyles = this.setNodeStyles.bind(this);
    this.mindMap.command.add("SET_NODE_STYLES", this.setNodeStyles);
    this.setNodeActive = this.setNodeActive.bind(this);
    this.mindMap.command.add("SET_NODE_ACTIVE", this.setNodeActive);
    this.clearActiveNode = this.clearActiveNode.bind(this);
    this.mindMap.command.add("CLEAR_ACTIVE_NODE", this.clearActiveNode);
    this.setNodeExpand = this.setNodeExpand.bind(this);
    this.mindMap.command.add("SET_NODE_EXPAND", this.setNodeExpand);
    this.expandAllNode = this.expandAllNode.bind(this);
    this.mindMap.command.add("EXPAND_ALL", this.expandAllNode);
    this.unexpandAllNode = this.unexpandAllNode.bind(this);
    this.mindMap.command.add("UNEXPAND_ALL", this.unexpandAllNode);
    this.expandToLevel = this.expandToLevel.bind(this);
    this.mindMap.command.add("UNEXPAND_TO_LEVEL", this.expandToLevel);
    this.setNodeData = this.setNodeData.bind(this);
    this.mindMap.command.add("SET_NODE_DATA", this.setNodeData);
    this.setNodeText = this.setNodeText.bind(this);
    this.mindMap.command.add("SET_NODE_TEXT", this.setNodeText);
    this.setNodeImage = this.setNodeImage.bind(this);
    this.mindMap.command.add("SET_NODE_IMAGE", this.setNodeImage);
    this.setNodeIcon = this.setNodeIcon.bind(this);
    this.mindMap.command.add("SET_NODE_ICON", this.setNodeIcon);
    this.setNodeHyperlink = this.setNodeHyperlink.bind(this);
    this.mindMap.command.add("SET_NODE_HYPERLINK", this.setNodeHyperlink);
    this.setNodeNote = this.setNodeNote.bind(this);
    this.mindMap.command.add("SET_NODE_NOTE", this.setNodeNote);
    this.setNodeTag = this.setNodeTag.bind(this);
    this.mindMap.command.add("SET_NODE_TAG", this.setNodeTag);
    this.insertFormula = this.insertFormula.bind(this);
    this.mindMap.command.add("INSERT_FORMULA", this.insertFormula);
    this.addGeneralization = this.addGeneralization.bind(this);
    this.mindMap.command.add("ADD_GENERALIZATION", this.addGeneralization);
    this.removeGeneralization = this.removeGeneralization.bind(this);
    this.mindMap.command.add("REMOVE_GENERALIZATION", this.removeGeneralization);
    this.setNodeCustomPosition = this.setNodeCustomPosition.bind(this);
    this.mindMap.command.add(
      "SET_NODE_CUSTOM_POSITION",
      this.setNodeCustomPosition
    );
    this.resetLayout = this.resetLayout.bind(this);
    this.mindMap.command.add("RESET_LAYOUT", this.resetLayout);
    this.setNodeShape = this.setNodeShape.bind(this);
    this.mindMap.command.add("SET_NODE_SHAPE", this.setNodeShape);
    this.goTargetNode = this.goTargetNode.bind(this);
    this.mindMap.command.add("GO_TARGET_NODE", this.goTargetNode);
  }
  //  注册快捷键
  registerShortcutKeys() {
    this.mindMap.keyCommand.addShortcut("Tab", () => {
      this.mindMap.execCommand("INSERT_CHILD_NODE");
    });
    this.mindMap.keyCommand.addShortcut("Enter", () => {
      this.mindMap.execCommand("INSERT_NODE");
    });
    this.mindMap.keyCommand.addShortcut("Shift+Tab", () => {
      this.mindMap.execCommand("INSERT_PARENT_NODE");
    });
    this.mindMap.keyCommand.addShortcut("Control+g", () => {
      this.mindMap.execCommand("ADD_GENERALIZATION");
    });
    this.toggleActiveExpand = this.toggleActiveExpand.bind(this);
    this.mindMap.keyCommand.addShortcut("/", this.toggleActiveExpand);
    this.mindMap.keyCommand.addShortcut("Del|Backspace", () => {
      this.mindMap.execCommand("REMOVE_NODE");
    });
    this.mindMap.keyCommand.addShortcut("Shift+Backspace", () => {
      this.mindMap.execCommand("REMOVE_CURRENT_NODE");
    });
    this.mindMap.on("before_show_text_edit", () => {
      this.startTextEdit();
    });
    this.mindMap.on("hide_text_edit", () => {
      this.endTextEdit();
    });
    this.mindMap.keyCommand.addShortcut("Control+a", () => {
      this.mindMap.execCommand("SELECT_ALL");
    });
    this.mindMap.keyCommand.addShortcut("Control+l", () => {
      this.mindMap.execCommand("RESET_LAYOUT", this.resetLayout);
    });
    this.mindMap.keyCommand.addShortcut("Control+Up", () => {
      this.mindMap.execCommand("UP_NODE");
    });
    this.mindMap.keyCommand.addShortcut("Control+Down", () => {
      this.mindMap.execCommand("DOWN_NODE");
    });
    this.mindMap.keyCommand.addShortcut("Control+c", () => {
      this.copy();
    });
    this.mindMap.keyCommand.addShortcut("Control+x", () => {
      this.cut();
    });
    this.mindMap.keyCommand.addShortcut("Control+v", () => {
      this.paste();
    });
    this.mindMap.keyCommand.addShortcut("Control+Enter", () => {
      this.setRootNodeCenter();
    });
  }
  // 派发节点激活事件
  emitNodeActiveEvent(node3 = null, activeNodeList = [...this.activeNodeList]) {
    let isChange = false;
    isChange = this.lastActiveNode !== node3;
    if (!isChange) {
      isChange = !checkNodeListIsEqual(this.lastActiveNodeList, activeNodeList);
    }
    if (!isChange)
      return;
    this.lastActiveNode = node3;
    this.lastActiveNodeList = [...activeNodeList];
    this.mindMap.batchExecution.push("emitNodeActiveEvent", () => {
      this.mindMap.emit("node_active", node3, activeNodeList);
    });
  }
  // 鼠标点击画布时清空当前激活节点列表
  clearActiveNodeListOnDrawClick(e2, eventType) {
    if (this.activeNodeList.length <= 0)
      return;
    let isTrueClick = true;
    const { useLeftKeySelectionRightKeyDrag } = this.mindMap.opt;
    if (eventType === "contextmenu" ? !useLeftKeySelectionRightKeyDrag : useLeftKeySelectionRightKeyDrag) {
      const mousedownPos = this.mindMap.event.mousedownPos;
      isTrueClick = Math.abs(e2.clientX - mousedownPos.x) <= 5 && Math.abs(e2.clientY - mousedownPos.y) <= 5;
    }
    if (isTrueClick) {
      this.mindMap.execCommand("CLEAR_ACTIVE_NODE");
    }
  }
  //  开启文字编辑，会禁用回车键和删除键相关快捷键防止冲突
  startTextEdit() {
    this.mindMap.keyCommand.save();
  }
  //  结束文字编辑，会恢复回车键和删除键相关快捷键
  endTextEdit() {
    this.mindMap.keyCommand.restore();
  }
  // 清空节点缓存池
  clearCache() {
    this.layout.lru.clear();
    this.nodeCache = {};
    this.lastNodeCache = {};
  }
  //   渲染
  render(callback = () => {
  }, source) {
    if (this.isRendering) {
      this.hasWaitRendering = true;
      this.waitRenderingParams = [callback, source];
      return;
    }
    this.isRendering = true;
    this.renderSource = source;
    this.lastNodeCache = this.nodeCache;
    this.nodeCache = {};
    if (this.reRender) {
      this.clearActiveNodeList();
    }
    this.layout.doLayout((root2) => {
      Object.keys(this.lastNodeCache).forEach((uid) => {
        if (!this.nodeCache[uid]) {
          this.removeNodeFromActiveList(this.lastNodeCache[uid]);
          this.emitNodeActiveEvent();
          this.lastNodeCache[uid].destroy();
        }
      });
      this.root = root2;
      this.root.render(() => {
        this.isRendering = false;
        this.mindMap.emit("node_tree_render_end");
        callback && callback();
        if (this.hasWaitRendering) {
          const params = this.waitRenderingParams;
          this.hasWaitRendering = false;
          this.waitRenderingParams = [];
          this.render(...params);
        } else {
          if (this.reRender) {
            this.reRender = false;
          }
          if (this.mindMap.richText && [CONSTANTS.CHANGE_THEME, CONSTANTS.SET_DATA].includes(source)) {
            this.mindMap.command.addHistory();
          }
        }
      });
    });
    this.emitNodeActiveEvent();
  }
  //  清除当前所有激活节点，并会触发事件
  clearActiveNode() {
    if (this.activeNodeList.length <= 0) {
      return;
    }
    this.clearActiveNodeList();
    this.emitNodeActiveEvent(null, []);
  }
  //  清除当前激活的节点列表
  clearActiveNodeList() {
    this.activeNodeList.forEach((item) => {
      this.mindMap.execCommand("SET_NODE_ACTIVE", item, false);
    });
    this.activeNodeList = [];
  }
  // 添加节点到激活列表里
  addNodeToActiveList(node3) {
    const index3 = this.findActiveNodeIndex(node3);
    if (index3 === -1) {
      this.mindMap.execCommand("SET_NODE_ACTIVE", node3, true);
      this.activeNodeList.push(node3);
    }
  }
  // 在激活列表里移除某个节点
  removeNodeFromActiveList(node3) {
    let index3 = this.findActiveNodeIndex(node3);
    if (index3 === -1) {
      return;
    }
    this.mindMap.execCommand("SET_NODE_ACTIVE", node3, false);
    this.activeNodeList.splice(index3, 1);
  }
  //  检索某个节点在激活列表里的索引
  findActiveNodeIndex(node3) {
    return getNodeIndexInNodeList(node3, this.activeNodeList);
  }
  //  全选
  selectAll() {
    if (this.mindMap.opt.readonly)
      return;
    walk(
      this.root,
      null,
      (node3) => {
        if (!node3.getData("isActive")) {
          this.addNodeToActiveList(node3);
        }
      },
      null,
      true,
      0,
      0
    );
    this.emitNodeActiveEvent();
  }
  //  回退
  back(step) {
    this.backForward("back", step);
  }
  //  前进
  forward(step) {
    this.backForward("forward", step);
  }
  // 前进回退
  backForward(type, step) {
    this.mindMap.execCommand("CLEAR_ACTIVE_NODE");
    const data2 = this.mindMap.command[type](step);
    if (data2) {
      this.renderTree = data2;
      this.mindMap.render();
    }
  }
  // 获取创建新节点的行为
  getNewNodeBehavior(openEdit = false, handleMultiNodes = false) {
    const { createNewNodeBehavior } = this.mindMap.opt;
    let focusNewNode = false;
    let inserting = false;
    switch (createNewNodeBehavior) {
      case CONSTANTS.CREATE_NEW_NODE_BEHAVIOR.DEFAULT:
        focusNewNode = handleMultiNodes || !openEdit;
        inserting = handleMultiNodes ? false : openEdit;
        break;
      case CONSTANTS.CREATE_NEW_NODE_BEHAVIOR.NOT_ACTIVE:
        focusNewNode = false;
        inserting = false;
        break;
      case CONSTANTS.CREATE_NEW_NODE_BEHAVIOR.ACTIVE_ONLY:
        focusNewNode = true;
        inserting = false;
        break;
      default:
        break;
    }
    return {
      focusNewNode,
      inserting
    };
  }
  //  插入同级节点
  insertNode(openEdit = true, appointNodes = [], appointData = null, appointChildren = []) {
    appointNodes = formatDataToArray(appointNodes);
    if (this.activeNodeList.length <= 0 && appointNodes.length <= 0) {
      return;
    }
    this.textEdit.hideEditTextBox();
    const {
      defaultInsertSecondLevelNodeText,
      defaultInsertBelowSecondLevelNodeText
    } = this.mindMap.opt;
    const list2 = appointNodes.length > 0 ? appointNodes : this.activeNodeList;
    const handleMultiNodes = list2.length > 1;
    const isRichText = !!this.mindMap.richText;
    const { focusNewNode, inserting } = this.getNewNodeBehavior(
      openEdit,
      handleMultiNodes
    );
    const params = {
      expand: true,
      richText: isRichText,
      resetRichText: isRichText,
      isActive: focusNewNode
      // 如果同时对多个节点插入子节点，那么需要把新增的节点设为激活状态。如果不进入编辑状态，那么也需要手动设为激活状态
    };
    appointChildren = addDataToAppointNodes(appointChildren, {
      ...params
    });
    list2.forEach((node3) => {
      if (node3.isGeneralization || node3.isRoot) {
        return;
      }
      const parent = node3.parent;
      const isOneLayer = node3.layerIndex === 1;
      const text4 = isOneLayer ? defaultInsertSecondLevelNodeText : defaultInsertBelowSecondLevelNodeText;
      const index3 = getNodeDataIndex(node3);
      const newNodeData = {
        inserting,
        data: {
          text: text4,
          ...params,
          uid: createUid(),
          ...appointData || {}
        },
        children: [...createUidForAppointNodes(appointChildren, true)]
      };
      parent.nodeData.children.splice(index3 + 1, 0, newNodeData);
    });
    if (focusNewNode) {
      this.clearActiveNodeList();
    }
    this.mindMap.render();
  }
  // 插入多个同级节点
  insertMultiNode(appointNodes, nodeList) {
    if (!nodeList || nodeList.length <= 0)
      return;
    appointNodes = formatDataToArray(appointNodes);
    if (this.activeNodeList.length <= 0 && appointNodes.length <= 0) {
      return;
    }
    this.textEdit.hideEditTextBox();
    const list2 = appointNodes.length > 0 ? appointNodes : this.activeNodeList;
    const isRichText = !!this.mindMap.richText;
    const { focusNewNode } = this.getNewNodeBehavior(false, true);
    const params = {
      expand: true,
      richText: isRichText,
      resetRichText: isRichText,
      isActive: focusNewNode
    };
    nodeList = addDataToAppointNodes(nodeList, params);
    list2.forEach((node3) => {
      if (node3.isGeneralization || node3.isRoot) {
        return;
      }
      const parent = node3.parent;
      const index3 = getNodeDataIndex(node3);
      const newNodeList = createUidForAppointNodes(
        simpleDeepClone(nodeList),
        true
      );
      parent.nodeData.children.splice(index3 + 1, 0, ...newNodeList);
    });
    if (focusNewNode) {
      this.clearActiveNodeList();
    }
    this.mindMap.render();
  }
  //  插入子节点
  insertChildNode(openEdit = true, appointNodes = [], appointData = null, appointChildren = []) {
    appointNodes = formatDataToArray(appointNodes);
    if (this.activeNodeList.length <= 0 && appointNodes.length <= 0) {
      return;
    }
    this.textEdit.hideEditTextBox();
    const {
      defaultInsertSecondLevelNodeText,
      defaultInsertBelowSecondLevelNodeText
    } = this.mindMap.opt;
    const list2 = appointNodes.length > 0 ? appointNodes : this.activeNodeList;
    const handleMultiNodes = list2.length > 1;
    const isRichText = !!this.mindMap.richText;
    const { focusNewNode, inserting } = this.getNewNodeBehavior(
      openEdit,
      handleMultiNodes
    );
    const params = {
      expand: true,
      richText: isRichText,
      resetRichText: isRichText,
      isActive: focusNewNode
    };
    appointChildren = addDataToAppointNodes(appointChildren, {
      ...params
    });
    list2.forEach((node3) => {
      if (node3.isGeneralization) {
        return;
      }
      if (!node3.nodeData.children) {
        node3.nodeData.children = [];
      }
      const text4 = node3.isRoot ? defaultInsertSecondLevelNodeText : defaultInsertBelowSecondLevelNodeText;
      const newNode = {
        inserting,
        data: {
          text: text4,
          uid: createUid(),
          ...params,
          ...appointData || {}
        },
        children: [...createUidForAppointNodes(appointChildren, true)]
      };
      node3.nodeData.children.push(newNode);
      node3.setData({
        expand: true
      });
    });
    if (focusNewNode) {
      this.clearActiveNodeList();
    }
    this.mindMap.render();
  }
  // 插入多个子节点
  insertMultiChildNode(appointNodes, childList) {
    if (!childList || childList.length <= 0)
      return;
    appointNodes = formatDataToArray(appointNodes);
    if (this.activeNodeList.length <= 0 && appointNodes.length <= 0) {
      return;
    }
    this.textEdit.hideEditTextBox();
    const list2 = appointNodes.length > 0 ? appointNodes : this.activeNodeList;
    const isRichText = !!this.mindMap.richText;
    const { focusNewNode } = this.getNewNodeBehavior(false, true);
    const params = {
      expand: true,
      richText: isRichText,
      resetRichText: isRichText,
      isActive: focusNewNode
    };
    childList = addDataToAppointNodes(childList, params);
    list2.forEach((node3) => {
      if (node3.isGeneralization) {
        return;
      }
      if (!node3.nodeData.children) {
        node3.nodeData.children = [];
      }
      childList = createUidForAppointNodes(childList, true);
      node3.nodeData.children.push(...childList);
      node3.setData({
        expand: true
      });
    });
    if (focusNewNode) {
      this.clearActiveNodeList();
    }
    this.mindMap.render();
  }
  // 插入父节点
  insertParentNode(openEdit = true, appointNodes, appointData) {
    appointNodes = formatDataToArray(appointNodes);
    if (this.activeNodeList.length <= 0 && appointNodes.length <= 0) {
      return;
    }
    this.textEdit.hideEditTextBox();
    const {
      defaultInsertSecondLevelNodeText,
      defaultInsertBelowSecondLevelNodeText
    } = this.mindMap.opt;
    const list2 = appointNodes.length > 0 ? appointNodes : this.activeNodeList;
    const handleMultiNodes = list2.length > 1;
    const isRichText = !!this.mindMap.richText;
    const { focusNewNode, inserting } = this.getNewNodeBehavior(
      openEdit,
      handleMultiNodes
    );
    const params = {
      expand: true,
      richText: isRichText,
      resetRichText: isRichText,
      isActive: focusNewNode
    };
    list2.forEach((node3) => {
      if (node3.isGeneralization || node3.isRoot) {
        return;
      }
      const text4 = node3.layerIndex === 1 ? defaultInsertSecondLevelNodeText : defaultInsertBelowSecondLevelNodeText;
      const newNode = {
        inserting,
        data: {
          text: text4,
          uid: createUid(),
          ...params,
          ...appointData || {}
        },
        children: [node3.nodeData]
      };
      const parent = node3.parent;
      const index3 = getNodeDataIndex(node3);
      parent.nodeData.children.splice(index3, 1, newNode);
    });
    if (focusNewNode) {
      this.clearActiveNodeList();
    }
    this.mindMap.render();
  }
  //  上移节点，多个节点只会操作第一个节点
  upNode() {
    if (this.activeNodeList.length <= 0) {
      return;
    }
    let node3 = this.activeNodeList[0];
    if (node3.isRoot) {
      return;
    }
    let parent = node3.parent;
    let childList = parent.children;
    let index3 = getNodeIndexInNodeList(node3, childList);
    if (index3 === -1 || index3 === 0) {
      return;
    }
    let insertIndex = index3 - 1;
    childList.splice(index3, 1);
    childList.splice(insertIndex, 0, node3);
    parent.nodeData.children.splice(index3, 1);
    parent.nodeData.children.splice(insertIndex, 0, node3.nodeData);
    this.mindMap.render();
  }
  //  下移节点，多个节点只会操作第一个节点
  downNode() {
    if (this.activeNodeList.length <= 0) {
      return;
    }
    let node3 = this.activeNodeList[0];
    if (node3.isRoot) {
      return;
    }
    let parent = node3.parent;
    let childList = parent.children;
    let index3 = getNodeIndexInNodeList(node3, childList);
    if (index3 === -1 || index3 === childList.length - 1) {
      return;
    }
    let insertIndex = index3 + 1;
    childList.splice(index3, 1);
    childList.splice(insertIndex, 0, node3);
    parent.nodeData.children.splice(index3, 1);
    parent.nodeData.children.splice(insertIndex, 0, node3.nodeData);
    this.mindMap.render();
  }
  // 复制节点
  copy() {
    this.beingCopyData = this.copyNode();
    if (!this.beingCopyData)
      return;
    setDataToClipboard({
      simpleMindMap: true,
      data: this.beingCopyData
    });
  }
  // 剪切节点
  cut() {
    this.mindMap.execCommand("CUT_NODE", (copyData) => {
      this.beingCopyData = copyData;
      setDataToClipboard({
        simpleMindMap: true,
        data: copyData
      });
    });
  }
  // 粘贴
  async paste() {
    const {
      errorHandler,
      handleIsSplitByWrapOnPasteCreateNewNode,
      handleNodePasteImg
    } = this.mindMap.opt;
    let text4 = null;
    let img = null;
    try {
      const res = await getDataFromClipboard();
      text4 = res.text;
      img = res.img;
    } catch (error) {
      errorHandler(ERROR_TYPES.READ_CLIPBOARD_ERROR, error);
    }
    const imgSize = img ? img.size : 0;
    if (this.beingPasteText !== text4 || this.beingPasteImgSize !== imgSize) {
      this.currentBeingPasteType = CONSTANTS.PASTE_TYPE.CLIP_BOARD;
      this.beingPasteText = text4;
      this.beingPasteImgSize = imgSize;
    }
    if (this.lastBeingCopyData !== this.beingCopyData) {
      this.lastBeingCopyData = this.beingCopyData;
      this.currentBeingPasteType = CONSTANTS.PASTE_TYPE.CANVAS;
    }
    if (this.currentBeingPasteType === CONSTANTS.PASTE_TYPE.CLIP_BOARD) {
      if (text4) {
        let smmData = null;
        let useDefault = true;
        if (this.mindMap.opt.customHandleClipboardText) {
          try {
            const res = await this.mindMap.opt.customHandleClipboardText(text4);
            if (!isUndef(res)) {
              useDefault = false;
              if (typeof res === "object" && res.simpleMindMap) {
                smmData = res.data;
              } else {
                text4 = String(res);
              }
            }
          } catch (error) {
            errorHandler(ERROR_TYPES.CUSTOM_HANDLE_CLIPBOARD_TEXT_ERROR, error);
          }
        }
        if (useDefault) {
          try {
            const parsedData = JSON.parse(text4);
            if (parsedData && parsedData.simpleMindMap) {
              smmData = parsedData.data;
            }
          } catch (error) {
            errorHandler(ERROR_TYPES.PARSE_PASTE_DATA_ERROR, error);
          }
        }
        if (smmData) {
          this.mindMap.execCommand(
            "INSERT_MULTI_CHILD_NODE",
            [],
            Array.isArray(smmData) ? smmData : [smmData]
          );
        } else {
          text4 = htmlEscape(text4);
          const textArr = text4.split(new RegExp("\r?\n|(?<!\n)\r", "g")).filter((item) => {
            return !!item;
          });
          if (textArr.length > 1 && handleIsSplitByWrapOnPasteCreateNewNode) {
            handleIsSplitByWrapOnPasteCreateNewNode().then(() => {
              this.mindMap.execCommand(
                "INSERT_MULTI_CHILD_NODE",
                [],
                textArr.map((item) => {
                  return {
                    data: {
                      text: item
                    },
                    children: []
                  };
                })
              );
            }).catch(() => {
              this.mindMap.execCommand("INSERT_CHILD_NODE", false, [], {
                text: text4
              });
            });
          } else {
            this.mindMap.execCommand("INSERT_CHILD_NODE", false, [], {
              text: text4
            });
          }
        }
      }
      if (img) {
        try {
          let imgData = null;
          if (handleNodePasteImg && typeof handleNodePasteImg === "function") {
            imgData = await handleNodePasteImg(img);
          } else {
            imgData = await loadImage(img);
          }
          if (this.activeNodeList.length > 0) {
            this.activeNodeList.forEach((node3) => {
              this.mindMap.execCommand("SET_NODE_IMAGE", node3, {
                url: imgData.url,
                title: "",
                width: imgData.size.width,
                height: imgData.size.height
              });
            });
          }
        } catch (error) {
          errorHandler(ERROR_TYPES.LOAD_CLIPBOARD_IMAGE_ERROR, error);
        }
      }
    } else {
      if (this.beingCopyData) {
        this.mindMap.execCommand("PASTE_NODE", this.beingCopyData);
      }
    }
  }
  //  将节点移动到另一个节点的前面
  insertBefore(node3, exist) {
    this.insertTo(node3, exist, "before");
  }
  //  将节点移动到另一个节点的后面
  insertAfter(node3, exist) {
    this.insertTo(node3, exist, "after");
  }
  // 将节点移动到另一个节点的前面或后面
  insertTo(node3, exist, dir = "before") {
    let nodeList = formatDataToArray(node3);
    nodeList = nodeList.filter((item) => {
      return !item.isRoot;
    });
    if (dir === "after") {
      nodeList.reverse();
    }
    nodeList.forEach((item) => {
      this.checkNodeLayerChange(item, exist);
      let nodeParent = item.parent;
      let nodeBorthers = nodeParent.children;
      let nodeIndex = getNodeIndexInNodeList(item, nodeBorthers);
      if (nodeIndex === -1) {
        return;
      }
      nodeBorthers.splice(nodeIndex, 1);
      nodeParent.nodeData.children.splice(nodeIndex, 1);
      let existParent = exist.parent;
      let existBorthers = existParent.children;
      let existIndex = getNodeIndexInNodeList(exist, existBorthers);
      if (existIndex === -1) {
        return;
      }
      if (dir === "after") {
        existIndex++;
      }
      existBorthers.splice(existIndex, 0, item);
      existParent.nodeData.children.splice(existIndex, 0, item.nodeData);
    });
    this.mindMap.render();
  }
  // 如果是富文本模式，那么某些层级变化需要更新样式
  checkNodeLayerChange(node3, toNode3) {
    if (this.mindMap.richText) {
      let nodeLayerChanged = node3.layerIndex === 1 && toNode3.layerIndex !== 1 || node3.layerIndex !== 1 && toNode3.layerIndex === 1;
      if (nodeLayerChanged) {
        node3.setData({
          resetRichText: true
        });
      }
    }
  }
  //  移除节点
  removeNode(appointNodes = []) {
    appointNodes = formatDataToArray(appointNodes);
    if (this.activeNodeList.length <= 0 && appointNodes.length <= 0) {
      return;
    }
    let needActiveNode = null;
    let isAppointNodes = appointNodes.length > 0;
    let list2 = isAppointNodes ? appointNodes : this.activeNodeList;
    let root2 = list2.find((node3) => {
      return node3.isRoot;
    });
    if (root2) {
      this.clearActiveNodeList();
      root2.children = [];
      root2.nodeData.children = [];
    } else {
      needActiveNode = this.getNextActiveNode();
      for (let i2 = 0; i2 < list2.length; i2++) {
        let node3 = list2[i2];
        if (isAppointNodes)
          list2.splice(i2, 1);
        if (node3.isGeneralization) {
          this.deleteNodeGeneralization(node3);
          this.removeNodeFromActiveList(node3);
          i2--;
        } else {
          this.removeNodeFromActiveList(node3);
          removeFromParentNodeData(node3);
          i2--;
        }
      }
    }
    this.activeNodeList = [];
    if (needActiveNode) {
      this.addNodeToActiveList(needActiveNode);
    }
    this.emitNodeActiveEvent();
    this.mindMap.render();
  }
  // 删除概要节点，即从所属节点里删除该概要
  deleteNodeGeneralization(node3) {
    const targetNode = node3.generalizationBelongNode;
    const index3 = targetNode.getGeneralizationNodeIndex(node3);
    let generalization = targetNode.getData("generalization");
    if (Array.isArray(generalization)) {
      generalization.splice(index3, 1);
    } else {
      generalization = null;
    }
    this.mindMap.execCommand("SET_NODE_DATA", targetNode, {
      generalization
    });
    this.closeHighlightNode();
  }
  // 仅删除当前节点
  removeCurrentNode(appointNodes = []) {
    appointNodes = formatDataToArray(appointNodes);
    if (this.activeNodeList.length <= 0 && appointNodes.length <= 0) {
      return;
    }
    let needActiveNode = this.getNextActiveNode();
    let isAppointNodes = appointNodes.length > 0;
    let list2 = isAppointNodes ? appointNodes : this.activeNodeList;
    list2 = list2.filter((node3) => {
      return !node3.isRoot;
    });
    for (let i2 = 0; i2 < list2.length; i2++) {
      let node3 = list2[i2];
      if (node3.isGeneralization) {
        this.deleteNodeGeneralization(node3);
      } else {
        const parent = node3.parent;
        const index3 = getNodeDataIndex(node3);
        parent.nodeData.children.splice(
          index3,
          1,
          ...node3.nodeData.children || []
        );
      }
    }
    this.activeNodeList = [];
    if (needActiveNode) {
      this.addNodeToActiveList(needActiveNode);
    }
    this.emitNodeActiveEvent();
    this.mindMap.render();
  }
  // 计算下一个可激活的节点
  getNextActiveNode() {
    let needActiveNode = null;
    if (this.activeNodeList.length === 1 && !this.activeNodeList[0].isGeneralization && this.mindMap.opt.deleteNodeActive) {
      const node3 = this.activeNodeList[0];
      const broList = node3.parent.children;
      const nodeIndex = getNodeIndexInNodeList(node3, broList);
      if (nodeIndex < broList.length - 1) {
        needActiveNode = broList[nodeIndex + 1];
      } else {
        if (nodeIndex > 0) {
          needActiveNode = broList[nodeIndex - 1];
        } else {
          needActiveNode = node3.parent;
        }
      }
    }
    return needActiveNode;
  }
  //  复制节点
  copyNode() {
    if (this.activeNodeList.length <= 0) {
      return null;
    }
    const nodeList = getTopAncestorsFomNodeList(this.activeNodeList);
    return nodeList.map((node3) => {
      return copyNodeTree({}, node3, true);
    });
  }
  //  剪切节点
  cutNode(callback) {
    if (this.activeNodeList.length <= 0) {
      return;
    }
    const nodeList = getTopAncestorsFomNodeList(this.activeNodeList).filter(
      (node3) => {
        return !node3.isRoot;
      }
    );
    const copyData = nodeList.map((node3) => {
      return copyNodeTree({}, node3, true);
    });
    nodeList.forEach((node3) => {
      removeFromParentNodeData(node3);
    });
    this.clearActiveNodeList();
    this.mindMap.render();
    if (callback && typeof callback === "function") {
      callback(copyData);
    }
  }
  //  移动节点作为另一个节点的子节点
  moveNodeTo(node3, toNode3) {
    let nodeList = formatDataToArray(node3);
    nodeList = nodeList.filter((item) => {
      return !item.isRoot;
    });
    nodeList.forEach((item) => {
      this.checkNodeLayerChange(item, toNode3);
      this.removeNodeFromActiveList(item);
      removeFromParentNodeData(item);
      toNode3.nodeData.children.push(item.nodeData);
    });
    this.emitNodeActiveEvent();
    this.mindMap.render();
  }
  //   粘贴节点到节点
  pasteNode(data2) {
    data2 = formatDataToArray(data2);
    if (this.activeNodeList.length <= 0 || data2.length <= 0) {
      return;
    }
    this.activeNodeList.forEach((node3) => {
      node3.nodeData.children.push(
        ...data2.map((item) => {
          const newData = simpleDeepClone(item);
          createUidForAppointNodes([newData], true);
          return newData;
        })
      );
    });
    this.mindMap.render();
  }
  //  设置节点样式
  setNodeStyle(node3, prop, value) {
    let data2 = {
      [prop]: value
    };
    if (this.mindMap.richText) {
      this.mindMap.richText.setNotActiveNodeStyle(node3, {
        [prop]: value
      });
    }
    this.setNodeDataRender(node3, data2);
    if (lineStyleProps.includes(prop)) {
      ;
      (node3.parent || node3).renderLine(true);
    }
  }
  //  设置节点多个样式
  setNodeStyles(node3, style) {
    let data2 = { ...style };
    if (this.mindMap.richText) {
      this.mindMap.richText.setNotActiveNodeStyle(node3, style);
    }
    this.setNodeDataRender(node3, data2);
    let props = Object.keys(style);
    let hasLineStyleProps = false;
    props.forEach((key) => {
      if (lineStyleProps.includes(key)) {
        hasLineStyleProps = true;
      }
    });
    if (hasLineStyleProps) {
      ;
      (node3.parent || node3).renderLine(true);
    }
  }
  //  设置节点是否激活
  setNodeActive(node3, active) {
    this.mindMap.execCommand("SET_NODE_DATA", node3, {
      isActive: active
    });
    node3.updateNodeByActive(active);
  }
  //  设置节点是否展开
  setNodeExpand(node3, expand) {
    this.mindMap.execCommand("SET_NODE_DATA", node3, {
      expand
    });
    this.mindMap.render();
  }
  //  展开所有
  expandAllNode() {
    walk(
      this.renderTree,
      null,
      (node3) => {
        if (!node3.data.expand) {
          node3.data.expand = true;
        }
      },
      null,
      true,
      0,
      0
    );
    this.mindMap.render();
  }
  //  收起所有
  unexpandAllNode() {
    walk(
      this.renderTree,
      null,
      (node3, parent, isRoot) => {
        if (!isRoot && node3.children && node3.children.length > 0) {
          node3.data.expand = false;
        }
      },
      null,
      true,
      0,
      0
    );
    this.mindMap.render(() => {
      this.setRootNodeCenter();
    });
  }
  //  展开到指定层级
  expandToLevel(level) {
    walk(
      this.renderTree,
      null,
      (node3, parent, isRoot, layerIndex) => {
        const expand = layerIndex < level;
        if (expand) {
          node3.data.expand = true;
        } else if (!isRoot && node3.children && node3.children.length > 0) {
          node3.data.expand = false;
        }
      },
      null,
      true,
      0,
      0
    );
    this.mindMap.render();
  }
  //  切换激活节点的展开状态
  toggleActiveExpand() {
    this.activeNodeList.forEach((node3) => {
      if (node3.nodeData.children.length <= 0) {
        return;
      }
      this.toggleNodeExpand(node3);
    });
  }
  //  切换节点展开状态
  toggleNodeExpand(node3) {
    this.mindMap.execCommand("SET_NODE_EXPAND", node3, !node3.getData("expand"));
  }
  //  设置节点文本
  setNodeText(node3, text4, richText, resetRichText) {
    this.setNodeDataRender(node3, {
      text: text4,
      richText,
      resetRichText
    });
  }
  //  设置节点图片
  setNodeImage(node3, data2) {
    const {
      url,
      title,
      width: width2,
      height: height2,
      custom = false
    } = data2 || { url: "", title: "", width: 0, height: 0, custom: false };
    this.setNodeDataRender(node3, {
      image: url,
      imageTitle: title || "",
      imageSize: {
        width: width2,
        height: height2,
        custom
      }
    });
  }
  //  设置节点图标
  setNodeIcon(node3, icons) {
    this.setNodeDataRender(node3, {
      icon: icons
    });
  }
  //  设置节点超链接
  setNodeHyperlink(node3, link, title = "") {
    this.setNodeDataRender(node3, {
      hyperlink: link,
      hyperlinkTitle: title
    });
  }
  //  设置节点备注
  setNodeNote(node3, note2) {
    this.setNodeDataRender(node3, {
      note: note2
    });
  }
  //  设置节点标签
  setNodeTag(node3, tag) {
    this.setNodeDataRender(node3, {
      tag
    });
  }
  // 设置节点公式
  insertFormula(formula, appointNodes = []) {
    if (!this.mindMap.richText || !this.mindMap.formula)
      return;
    appointNodes = formatDataToArray(appointNodes);
    const list2 = appointNodes.length > 0 ? appointNodes : this.activeNodeList;
    list2.forEach((node3) => {
      this.mindMap.formula.insertFormulaToNode(node3, formula);
    });
  }
  //  添加节点概要
  addGeneralization(data2) {
    if (this.activeNodeList.length <= 0) {
      return;
    }
    const nodeList = this.activeNodeList.filter((node3) => {
      return !node3.isRoot && !node3.isGeneralization && !node3.checkHasSelfGeneralization();
    });
    const list2 = parseAddGeneralizationNodeList(nodeList);
    list2.forEach((item) => {
      const newData = {
        ...data2 || {
          text: this.mindMap.opt.defaultGeneralizationText
        },
        range: item.range || null
      };
      let generalization = item.node.getData("generalization");
      if (generalization) {
        if (Array.isArray(generalization)) {
          generalization.push(newData);
        } else {
          generalization = [generalization, newData];
        }
      } else {
        generalization = [newData];
      }
      this.mindMap.execCommand("SET_NODE_DATA", item.node, {
        generalization
      });
      item.node.setData({
        expand: true
      });
    });
    this.mindMap.render(() => {
      this.mindMap.render();
    });
  }
  //  删除节点概要
  removeGeneralization() {
    if (this.activeNodeList.length <= 0) {
      return;
    }
    this.activeNodeList.forEach((node3) => {
      if (!node3.checkHasGeneralization()) {
        return;
      }
      this.mindMap.execCommand("SET_NODE_DATA", node3, {
        generalization: null
      });
    });
    this.mindMap.render();
    this.closeHighlightNode();
  }
  //  设置节点自定义位置
  setNodeCustomPosition(node3, left = void 0, top = void 0) {
    let nodeList = [node3];
    nodeList.forEach((item) => {
      this.mindMap.execCommand("SET_NODE_DATA", item, {
        customLeft: left,
        customTop: top
      });
    });
  }
  //  一键整理布局，即去除自定义位置
  resetLayout() {
    walk(
      this.root,
      null,
      (node3) => {
        node3.customLeft = void 0;
        node3.customTop = void 0;
        this.mindMap.execCommand("SET_NODE_DATA", node3, {
          customLeft: void 0,
          customTop: void 0
        });
        this.mindMap.render();
      },
      null,
      true,
      0,
      0
    );
  }
  //  设置节点形状
  setNodeShape(node3, shape) {
    if (!shape || !shapeList.includes(shape)) {
      return;
    }
    let nodeList = [node3];
    nodeList.forEach((item) => {
      this.setNodeStyle(item, "shape", shape);
    });
  }
  // 定位到指定节点
  goTargetNode(node3, callback = () => {
  }) {
    let uid = typeof node3 === "string" ? node3 : node3.getData("uid");
    if (!uid)
      return;
    this.expandToNodeUid(uid, () => {
      let targetNode = this.findNodeByUid(uid);
      if (targetNode) {
        targetNode.active();
        this.moveNodeToCenter(targetNode);
        callback();
      }
    });
  }
  //  更新节点数据
  setNodeData(node3, data2) {
    Object.keys(data2).forEach((key) => {
      node3.nodeData.data[key] = data2[key];
    });
  }
  //  设置节点数据，并判断是否渲染
  setNodeDataRender(node3, data2, notRender = false) {
    this.mindMap.execCommand("SET_NODE_DATA", node3, data2);
    let changed = node3.reRender();
    if (changed) {
      if (!notRender)
        this.mindMap.render();
    } else {
      this.mindMap.emit("node_tree_render_end");
    }
  }
  //  移动节点到画布中心
  moveNodeToCenter(node3) {
    let halfWidth = this.mindMap.width / 2;
    let halfHeight = this.mindMap.height / 2;
    let { left, top, width: width2, height: height2 } = node3;
    let nodeCenterX = left + width2 / 2;
    let nodeCenterY = top + height2 / 2;
    let { state } = this.mindMap.view.getTransformData();
    let targetX = halfWidth - state.x;
    let targetY = halfHeight - state.y;
    let offsetX = targetX - nodeCenterX;
    let offsetY = targetY - nodeCenterY;
    this.mindMap.view.translateX(offsetX);
    this.mindMap.view.translateY(offsetY);
    this.mindMap.view.setScale(1);
  }
  // 回到中心主题，即设置根节点到画布中心
  setRootNodeCenter() {
    this.moveNodeToCenter(this.root);
  }
  // 展开到指定uid的节点
  expandToNodeUid(uid, callback = () => {
  }) {
    let parentsList = [];
    const cache = {};
    bfsWalk(this.renderTree, (node3, parent) => {
      if (node3.data.uid === uid) {
        parentsList = parent ? [...cache[parent.data.uid], parent] : [];
        return "stop";
      } else {
        cache[node3.data.uid] = parent ? [...cache[parent.data.uid], parent] : [];
      }
    });
    let needRender = false;
    parentsList.forEach((node3) => {
      if (!node3.data.expand) {
        needRender = true;
        node3.data.expand = true;
      }
    });
    if (needRender) {
      this.mindMap.render(callback);
    } else {
      callback();
    }
  }
  // 根据uid找到对应的节点实例
  findNodeByUid(uid) {
    let res = null;
    walk(this.root, null, (node3) => {
      if (node3.getData("uid") === uid) {
        res = node3;
        return true;
      }
    });
    return res;
  }
  // 高亮节点或子节点
  highlightNode(node3, range) {
    const { highlightNodeBoxStyle = {} } = this.mindMap.opt;
    if (!this.highlightBoxNode) {
      this.highlightBoxNode = new Polygon().stroke({
        color: highlightNodeBoxStyle.stroke || "transparent"
      }).fill({
        color: highlightNodeBoxStyle.fill || "transparent"
      });
    }
    let minx = Infinity, miny = Infinity, maxx = -Infinity, maxy = -Infinity;
    if (range) {
      const children = node3.children.slice(range[0], range[1] + 1);
      children.forEach((child) => {
        if (child.left < minx) {
          minx = child.left;
        }
        if (child.top < miny) {
          miny = child.top;
        }
        const right = child.left + child.width;
        const bottom = child.top + child.height;
        if (right > maxx) {
          maxx = right;
        }
        if (bottom > maxy) {
          maxy = bottom;
        }
      });
    } else {
      minx = node3.left;
      miny = node3.top;
      maxx = node3.left + node3.width;
      maxy = node3.top + node3.height;
    }
    this.highlightBoxNode.plot([
      [minx, miny],
      [maxx, miny],
      [maxx, maxy],
      [minx, maxy]
    ]);
    this.mindMap.otherDraw.add(this.highlightBoxNode);
  }
  // 关闭高亮
  closeHighlightNode() {
    this.highlightBoxNode.remove();
  }
};
var Render_default = Render;

// ../simple-mind-map/index.js
var import_deepmerge33 = __toESM(require_cjs());

// ../simple-mind-map/src/themes/freshGreen.js
var import_deepmerge2 = __toESM(require_cjs());
var freshGreen_default = (0, import_deepmerge2.default)(default_default, {
  // 连线的颜色
  lineColor: "#333",
  // 背景颜色
  backgroundColor: "#d1f6ec",
  // 概要连线的粗细
  generalizationLineWidth: 1,
  // 概要连线的颜色
  generalizationLineColor: "#333",
  // 根节点样式
  root: {
    fillColor: "#1fb27d"
  },
  // 二级节点样式
  second: {
    fillColor: "#fff",
    color: "#565656",
    borderColor: "transparent",
    borderWidth: 0
  },
  // 概要节点样式
  generalization: {
    fillColor: "#fff",
    borderColor: "#333",
    color: "#333"
  }
});

// ../simple-mind-map/src/themes/blueSky.js
var import_deepmerge3 = __toESM(require_cjs());
var blueSky_default = (0, import_deepmerge3.default)(default_default, {
  // 连线的颜色
  lineColor: "rgb(115, 161, 191)",
  // 背景颜色
  backgroundColor: "rgb(251, 251, 251)",
  // 概要连线的粗细
  generalizationLineWidth: 1,
  // 概要连线的颜色
  generalizationLineColor: "#333",
  // 根节点样式
  root: {
    fillColor: "rgb(115, 161, 191)"
  },
  // 二级节点样式
  second: {
    fillColor: "rgb(238, 243, 246)",
    color: "#333",
    borderColor: "rgb(115, 161, 191)",
    borderWidth: 1,
    fontSize: 14
  },
  // 三级及以下节点样式
  node: {
    fontSize: 12,
    color: "#333"
  },
  // 概要节点样式
  generalization: {
    fillColor: "#fff",
    borderColor: "#333",
    color: "#333"
  }
});

// ../simple-mind-map/src/themes/brainImpairedPink.js
var import_deepmerge4 = __toESM(require_cjs());
var brainImpairedPink_default = (0, import_deepmerge4.default)(default_default, {
  // 连线的颜色
  lineColor: "rgb(191, 115, 148)",
  // 背景颜色
  backgroundColor: "rgb(251, 251, 251)",
  // 概要连线的粗细
  generalizationLineWidth: 1,
  // 概要连线的颜色
  generalizationLineColor: "#333",
  // 根节点样式
  root: {
    fillColor: "rgb(191, 115, 148)"
  },
  // 二级节点样式
  second: {
    fillColor: "rgb(246, 238, 242)",
    color: "#333",
    borderColor: "rgb(191, 115, 148)",
    borderWidth: 1,
    fontSize: 14
  },
  // 三级及以下节点样式
  node: {
    fontSize: 12,
    color: "#333"
  },
  // 概要节点样式
  generalization: {
    fillColor: "#fff",
    borderColor: "#333",
    color: "#333"
  }
});

// ../simple-mind-map/src/themes/romanticPurple.js
var import_deepmerge5 = __toESM(require_cjs());
var romanticPurple_default = (0, import_deepmerge5.default)(default_default, {
  // 连线的颜色
  lineColor: "rgb(123, 115, 191)",
  // 背景颜色
  backgroundColor: "rgb(251, 251, 251)",
  // 概要连线的粗细
  generalizationLineWidth: 1,
  // 概要连线的颜色
  generalizationLineColor: "#333",
  // 根节点样式
  root: {
    fillColor: "rgb(123, 115, 191)"
  },
  // 二级节点样式
  second: {
    fillColor: "rgb(239, 238, 246)",
    color: "#333",
    borderColor: "rgb(123, 115, 191)",
    borderWidth: 1,
    fontSize: 14
  },
  // 三级及以下节点样式
  node: {
    fontSize: 12,
    color: "#333"
  },
  // 概要节点样式
  generalization: {
    fillColor: "#fff",
    borderColor: "#333",
    color: "#333"
  }
});

// ../simple-mind-map/src/themes/freshRed.js
var import_deepmerge6 = __toESM(require_cjs());
var freshRed_default = (0, import_deepmerge6.default)(default_default, {
  // 连线的颜色
  lineColor: "rgb(191, 115, 115)",
  // 背景颜色
  backgroundColor: "rgb(251, 251, 251)",
  // 概要连线的粗细
  generalizationLineWidth: 1,
  // 概要连线的颜色
  generalizationLineColor: "#333",
  // 根节点样式
  root: {
    fillColor: "rgb(191, 115, 115)"
  },
  // 二级节点样式
  second: {
    fillColor: "rgb(246, 238, 238)",
    color: "#333",
    borderColor: "rgb(191, 115, 115)",
    borderWidth: 1,
    fontSize: 14
  },
  // 三级及以下节点样式
  node: {
    fontSize: 12,
    color: "#333"
  },
  // 概要节点样式
  generalization: {
    fillColor: "#fff",
    borderColor: "#333",
    color: "#333"
  }
});

// ../simple-mind-map/src/themes/earthYellow.js
var import_deepmerge7 = __toESM(require_cjs());
var earthYellow_default = (0, import_deepmerge7.default)(default_default, {
  // 连线的颜色
  lineColor: "rgb(191, 147, 115)",
  // 背景颜色
  backgroundColor: "rgb(251, 251, 251)",
  // 概要连线的粗细
  generalizationLineWidth: 1,
  // 概要连线的颜色
  generalizationLineColor: "#333",
  // 根节点样式
  root: {
    fillColor: "rgb(191, 147, 115)"
  },
  // 二级节点样式
  second: {
    fillColor: "rgb(246, 242, 238)",
    color: "#333",
    borderColor: "rgb(191, 147, 115)",
    borderWidth: 1,
    fontSize: 14
  },
  // 三级及以下节点样式
  node: {
    fontSize: 12,
    color: "#333"
  },
  // 概要节点样式
  generalization: {
    fillColor: "#fff",
    borderColor: "#333",
    color: "#333"
  }
});

// ../simple-mind-map/src/themes/classic.js
var import_deepmerge8 = __toESM(require_cjs());
var classic_default = (0, import_deepmerge8.default)(default_default, {
  // 连线的颜色
  lineColor: "#fff",
  // 连线的粗细
  lineWidth: 3,
  // 概要连线的粗细
  generalizationLineWidth: 3,
  // 概要连线的颜色
  generalizationLineColor: "#fff",
  // 背景颜色
  backgroundColor: "rgb(58, 65, 68)",
  // 背景图片
  backgroundImage: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAIAAAACDbGyAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyRpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDowQzg5QTQ0NDhENzgxMUUzOENGREE4QTg0RDgzRTZDNyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDowQzg5QTQ0NThENzgxMUUzOENGREE4QTg0RDgzRTZDNyI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkMwOEQ1NDRGOEQ3NzExRTM4Q0ZEQThBODREODNFNkM3IiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkMwOEQ1NDUwOEQ3NzExRTM4Q0ZEQThBODREODNFNkM3Ii8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+e9P33AAAACVJREFUeNpisXJ0YUACTAyoAMr/+eM7EGGRZ4FQ7BycEAZAgAEAHbEGtkoQm/wAAAAASUVORK5CYII=",
  // 背景重复
  backgroundRepeat: "repeat",
  backgroundSize: "auto",
  // 根节点样式
  root: {
    fillColor: "rgb(233, 223, 152)",
    color: "#333",
    fontSize: 24,
    borderRadius: 21
  },
  // 二级节点样式
  second: {
    fillColor: "rgb(164, 197, 192)",
    borderColor: "transparent",
    color: "#333",
    fontSize: 16,
    borderRadius: 10
  },
  // 三级及以下节点样式
  node: {
    fontSize: 12,
    color: "#fff",
    fontWeight: "bold"
  },
  // 概要节点样式
  generalization: {
    fillColor: "#fff",
    borderColor: "transparent",
    color: "#333"
  }
});

// ../simple-mind-map/src/themes/classic2.js
var import_deepmerge9 = __toESM(require_cjs());
var classic2_default = (0, import_deepmerge9.default)(default_default, {
  // 连线的颜色
  lineColor: "rgb(51, 51, 51)",
  // 连线的粗细
  lineWidth: 2,
  // 概要连线的粗细
  generalizationLineWidth: 3,
  // 概要连线的颜色
  generalizationLineColor: "rgb(51, 51, 51)",
  // 背景颜色
  backgroundColor: "#fff",
  // 根节点样式
  root: {
    fillColor: "rgb(18, 187, 55)",
    color: "#fff",
    fontSize: 24,
    borderRadius: 10
  },
  // 二级节点样式
  second: {
    fillColor: "rgb(241, 242, 241)",
    borderColor: "transparent",
    color: "#1a1a1a",
    fontSize: 18,
    borderRadius: 10
  },
  // 三级及以下节点样式
  node: {
    fontSize: 14,
    color: "#1a1a1a"
  },
  // 概要节点样式
  generalization: {
    fillColor: "#fff",
    borderColor: "rgb(51, 51, 51)",
    borderWidth: 2,
    color: "#1a1a1a"
  }
});

// ../simple-mind-map/src/themes/classic3.js
var import_deepmerge10 = __toESM(require_cjs());
var classic3_default = (0, import_deepmerge10.default)(default_default, {
  // 连线的颜色
  lineColor: "rgb(94, 202, 110)",
  // 连线的粗细
  lineWidth: 2,
  // 概要连线的粗细
  generalizationLineWidth: 3,
  // 概要连线的颜色
  generalizationLineColor: "#1a1a1a",
  // 背景颜色
  backgroundColor: "rgb(241, 241, 241)",
  // 根节点样式
  root: {
    fillColor: "rgb(255, 245, 214)",
    color: "#1a1a1a",
    fontSize: 24,
    borderRadius: 10,
    borderColor: "rgb(249, 199, 84)",
    borderWidth: 1
  },
  // 二级节点样式
  second: {
    fillColor: "rgb(255, 245, 214)",
    borderColor: "rgb(249, 199, 84)",
    borderWidth: 1,
    color: "#1a1a1a",
    fontSize: 18,
    borderRadius: 10
  },
  // 三级及以下节点样式
  node: {
    fontSize: 14,
    color: "#1a1a1a"
  },
  // 概要节点样式
  generalization: {
    fillColor: "#fff",
    borderColor: "#1a1a1a",
    color: "#1a1a1a",
    borderWidth: 2
  }
});

// ../simple-mind-map/src/themes/classic4.js
var import_deepmerge11 = __toESM(require_cjs());
var classic4_default = (0, import_deepmerge11.default)(default_default, {
  // 连线的颜色
  lineColor: "rgb(30, 53, 86)",
  // 连线的粗细
  lineWidth: 2,
  // 概要连线的粗细
  generalizationLineWidth: 2,
  // 概要连线的颜色
  generalizationLineColor: "rgb(56, 123, 233)",
  // 背景颜色
  backgroundColor: "rgb(241, 241, 241)",
  // 根节点样式
  root: {
    fillColor: "rgb(30, 53, 86)",
    color: "#fff",
    fontSize: 24,
    borderRadius: 10,
    borderColor: "rgb(189, 197, 201)",
    borderWidth: 2
  },
  // 二级节点样式
  second: {
    fillColor: "rgb(169, 218, 218)",
    borderColor: "rgb(30, 53, 86)",
    borderWidth: 2,
    color: "#fff",
    fontSize: 18,
    borderRadius: 10
  },
  // 三级及以下节点样式
  node: {
    fontSize: 14,
    color: "rgb(30, 53, 86)",
    borderColor: "rgb(30, 53, 86)",
    borderWidth: 1,
    marginY: 20
  },
  // 概要节点样式
  generalization: {
    fillColor: "rgb(56, 123, 233)",
    borderColor: "rgb(56, 123, 233)",
    color: "#fff",
    borderWidth: 0
  }
});

// ../simple-mind-map/src/themes/dark.js
var import_deepmerge12 = __toESM(require_cjs());
var dark_default = (0, import_deepmerge12.default)(default_default, {
  // 连线的颜色
  lineColor: "rgb(17, 68, 23)",
  // 连线的粗细
  lineWidth: 2,
  // 概要连线的粗细
  generalizationLineWidth: 2,
  // 概要连线的颜色
  generalizationLineColor: "#fff",
  // 背景颜色
  backgroundColor: "rgb(15, 16, 17)",
  // 根节点样式
  root: {
    fillColor: "rgb(28, 178, 43)",
    color: "#fff",
    fontSize: 24,
    borderRadius: 10
  },
  // 二级节点样式
  second: {
    fillColor: "rgb(55, 56, 58)",
    color: "rgb(147,148,149)",
    fontSize: 18,
    borderRadius: 10,
    borderWidth: 0
  },
  // 三级及以下节点样式
  node: {
    fontSize: 14,
    color: "rgb(147, 148, 149)"
  },
  // 概要节点样式
  generalization: {
    fillColor: "#fff",
    borderColor: "transparent",
    color: "#333"
  }
});

// ../simple-mind-map/src/themes/classicGreen.js
var import_deepmerge13 = __toESM(require_cjs());
var classicGreen_default = (0, import_deepmerge13.default)(default_default, {
  // 连线的颜色
  lineColor: "rgb(123, 199, 120)",
  // 背景颜色
  backgroundColor: "rgb(236, 245, 231)",
  // 概要连线的粗细
  generalizationLineWidth: 2,
  // 概要连线的颜色
  generalizationLineColor: "rgb(123, 199, 120)",
  // 根节点样式
  root: {
    fillColor: "rgb(253, 244, 217)",
    color: "#222"
  },
  // 二级节点样式
  second: {
    fillColor: "rgb(253, 244, 217)",
    color: "#222",
    borderColor: "rgb(242, 200, 104)",
    borderWidth: 1,
    fontSize: 14
  },
  // 三级及以下节点样式
  node: {
    fontSize: 12,
    color: "#333"
  },
  // 概要节点样式
  generalization: {
    fillColor: "rgb(123, 199, 120)",
    borderColor: "transparent",
    borderWidth: 2,
    color: "#fff"
  }
});

// ../simple-mind-map/src/themes/classicBlue.js
var import_deepmerge14 = __toESM(require_cjs());
var classicBlue_default = (0, import_deepmerge14.default)(default_default, {
  // 连线的颜色
  lineColor: "rgb(51, 51, 51)",
  // 连线的粗细
  lineWidth: 2,
  // 概要连线的粗细
  generalizationLineWidth: 2,
  // 概要连线的颜色
  generalizationLineColor: "rgb(51, 51, 51)",
  // 背景颜色
  backgroundColor: "rgb(239, 248, 250)",
  // 根节点样式
  root: {
    fillColor: "rgb(255, 255, 255)",
    color: "#222"
  },
  // 二级节点样式
  second: {
    fillColor: "rgb(255, 255, 255)",
    color: "#222",
    borderColor: "rgb(255, 255, 255)",
    borderWidth: 1,
    fontSize: 14
  },
  // 三级及以下节点样式
  node: {
    fontSize: 12,
    color: "#333"
  },
  // 概要节点样式
  generalization: {
    fillColor: "#fff",
    borderColor: "rgb(51, 51, 51)",
    color: "#333"
  }
});

// ../simple-mind-map/src/themes/minions.js
var import_deepmerge15 = __toESM(require_cjs());
var minions_default = (0, import_deepmerge15.default)(default_default, {
  // 连线的颜色
  lineColor: "rgb(51, 51, 51)",
  lineWidth: 3,
  // 概要连线的粗细
  generalizationLineWidth: 3,
  // 概要连线的颜色
  generalizationLineColor: "#222",
  // 背景颜色
  backgroundColor: "rgb(248, 215, 49)",
  // 根节点样式
  root: {
    fillColor: "rgb(55, 165, 255)",
    borderColor: "rgb(51, 51, 51)",
    borderWidth: 3
  },
  // 二级节点样式
  second: {
    fillColor: "rgb(255, 160, 36)",
    color: "#222",
    borderColor: "rgb(51, 51, 51)",
    borderWidth: 3,
    fontSize: 14
  },
  // 三级及以下节点样式
  node: {
    fontSize: 12,
    color: "#222"
  },
  // 概要节点样式
  generalization: {
    borderColor: "#222",
    borderWidth: 3,
    color: "#222"
  }
});

// ../simple-mind-map/src/themes/pinkGrape.js
var import_deepmerge16 = __toESM(require_cjs());
var pinkGrape_default = (0, import_deepmerge16.default)(default_default, {
  // 连线的颜色
  lineColor: "rgb(166, 101, 106)",
  lineWidth: 3,
  // 概要连线的粗细
  generalizationLineWidth: 3,
  // 概要连线的颜色
  generalizationLineColor: "#fff",
  // 背景颜色
  backgroundColor: "rgb(255, 208, 211)",
  // 根节点样式
  root: {
    fillColor: "rgb(139, 109, 225)",
    borderColor: "",
    borderWidth: 0
  },
  // 二级节点样式
  second: {
    fillColor: "rgb(243, 104, 138)",
    color: "#fff",
    borderColor: "",
    borderWidth: 0,
    fontSize: 14
  },
  // 三级及以下节点样式
  node: {
    fontSize: 12,
    color: "#222"
  },
  // 概要节点样式
  generalization: {
    fillColor: "#fff",
    borderColor: "transparent",
    color: "#222"
  }
});

// ../simple-mind-map/src/themes/mint.js
var import_deepmerge17 = __toESM(require_cjs());
var mint_default = (0, import_deepmerge17.default)(default_default, {
  // 连线的颜色
  lineColor: "rgb(104, 204, 202)",
  lineWidth: 3,
  // 概要连线的粗细
  generalizationLineWidth: 3,
  // 概要连线的颜色
  generalizationLineColor: "rgb(90, 206, 241)",
  // 背景颜色
  backgroundColor: "rgb(239, 255, 255)",
  // 根节点样式
  root: {
    fillColor: "rgb(0, 192, 184)",
    borderColor: "",
    borderWidth: 0
  },
  // 二级节点样式
  second: {
    fillColor: "#fff",
    color: "#222",
    borderColor: "rgb(184, 235, 233)",
    borderWidth: 2,
    fontSize: 14
  },
  // 三级及以下节点样式
  node: {
    fontSize: 12,
    color: "#222"
  },
  // 概要节点样式
  generalization: {
    fillColor: "rgb(90, 206, 241)",
    borderColor: "transparent",
    color: "#fff"
  }
});

// ../simple-mind-map/src/themes/gold.js
var import_deepmerge18 = __toESM(require_cjs());
var gold_default = (0, import_deepmerge18.default)(default_default, {
  // 连线的颜色
  lineColor: "rgb(51, 56, 62)",
  lineWidth: 3,
  // 概要连线的粗细
  generalizationLineWidth: 3,
  // 概要连线的颜色
  generalizationLineColor: "rgb(127, 93, 64)",
  // 背景颜色
  backgroundColor: "#fff",
  // 根节点样式
  root: {
    fillColor: "rgb(51, 56, 62)",
    color: "rgb(247, 208, 160)",
    borderColor: "",
    borderWidth: 0
  },
  // 二级节点样式
  second: {
    fillColor: "rgb(239, 209, 176)",
    color: "rgb(81, 58, 42)",
    borderColor: "",
    borderWidth: 0,
    fontSize: 14
  },
  // 三级及以下节点样式
  node: {
    fontSize: 12,
    color: "#222"
  },
  // 概要节点样式
  generalization: {
    fillColor: "rgb(127, 93, 64)",
    borderColor: "transparent",
    color: "rgb(255, 214, 175)"
  }
});

// ../simple-mind-map/src/themes/vitalityOrange.js
var import_deepmerge19 = __toESM(require_cjs());
var vitalityOrange_default = (0, import_deepmerge19.default)(default_default, {
  // 连线的颜色
  lineColor: "rgb(254, 146, 0)",
  lineWidth: 3,
  // 概要连线的粗细
  generalizationLineWidth: 3,
  // 概要连线的颜色
  generalizationLineColor: "rgb(255, 222, 69)",
  // 背景颜色
  backgroundColor: "rgb(255, 246, 243)",
  // 根节点样式
  root: {
    fillColor: "rgb(255, 112, 52)",
    color: "#fff",
    borderColor: "",
    borderWidth: 0
  },
  // 二级节点样式
  second: {
    fillColor: "#fff",
    color: "rgb(51, 51, 51)",
    borderColor: "",
    borderWidth: 0,
    fontSize: 14
  },
  // 三级及以下节点样式
  node: {
    fontSize: 12,
    color: "#222"
  },
  // 概要节点样式
  generalization: {
    fillColor: "rgb(255, 222, 69)",
    borderColor: "transparent",
    color: "rgb(51, 51, 51)"
  }
});

// ../simple-mind-map/src/themes/greenLeaf.js
var import_deepmerge20 = __toESM(require_cjs());
var greenLeaf_default = (0, import_deepmerge20.default)(default_default, {
  // 连线的颜色
  lineColor: "rgb(40, 193, 84)",
  lineWidth: 3,
  // 概要连线的粗细
  generalizationLineWidth: 3,
  // 概要连线的颜色
  generalizationLineColor: "rgb(251, 158, 0)",
  // 背景颜色
  backgroundColor: "rgb(238, 255, 243)",
  // 根节点样式
  root: {
    fillColor: "rgb(25, 193, 73)",
    color: "#fff",
    borderColor: "",
    borderWidth: 0
  },
  // 二级节点样式
  second: {
    fillColor: "#fff",
    color: "rgb(69, 149, 96)",
    borderColor: "",
    borderWidth: 0,
    fontSize: 14
  },
  // 三级及以下节点样式
  node: {
    fontSize: 12,
    color: "#222"
  },
  // 概要节点样式
  generalization: {
    fillColor: "#fff",
    borderColor: "rgb(251, 158, 0)",
    borderWidth: 2,
    color: "rgb(51, 51, 51)"
  }
});

// ../simple-mind-map/src/themes/dark2.js
var import_deepmerge21 = __toESM(require_cjs());
var dark2_default = (0, import_deepmerge21.default)(default_default, {
  // 连线的颜色
  lineColor: "rgb(75, 81, 78)",
  lineWidth: 3,
  // 概要连线的粗细
  generalizationLineWidth: 3,
  // 概要连线的颜色
  generalizationLineColor: "rgb(255, 119, 34)",
  // 背景颜色
  backgroundColor: "rgb(27, 31, 34)",
  // 根节点样式
  root: {
    fillColor: "rgb(36, 179, 96)",
    color: "#fff",
    borderColor: "",
    borderWidth: 0
  },
  // 二级节点样式
  second: {
    fillColor: "rgb(254, 199, 13)",
    color: "rgb(0, 0, 0)",
    borderColor: "",
    borderWidth: 0,
    fontSize: 14
  },
  // 三级及以下节点样式
  node: {
    fontSize: 12,
    color: "rgb(204, 204, 204)"
  },
  // 概要节点样式
  generalization: {
    fillColor: "transparent",
    borderColor: "rgb(255, 119, 34)",
    borderWidth: 2,
    color: "rgb(204, 204, 204)"
  }
});

// ../simple-mind-map/src/themes/skyGreen.js
var import_deepmerge22 = __toESM(require_cjs());
var skyGreen_default = (0, import_deepmerge22.default)(default_default, {
  // 连线的颜色
  lineColor: "#fff",
  lineWidth: 3,
  // 概要连线的粗细
  generalizationLineWidth: 3,
  // 概要连线的颜色
  generalizationLineColor: "#fff",
  // 背景颜色
  backgroundColor: "rgb(80, 156, 170)",
  // 根节点样式
  root: {
    fillColor: "#fff",
    borderColor: "",
    borderWidth: 0,
    color: "rgb(65, 89, 158)"
  },
  // 二级节点样式
  second: {
    fillColor: "rgb(251, 227, 188)",
    color: "rgb(65, 89, 158)",
    borderColor: "",
    borderWidth: 0,
    fontSize: 14
  },
  // 三级及以下节点样式
  node: {
    fontSize: 12,
    color: "rgb(65, 89, 158)"
  },
  // 概要节点样式
  generalization: {
    fillColor: "#fff",
    borderColor: "transparent",
    color: "rgb(65, 89, 158)"
  }
});

// ../simple-mind-map/src/themes/simpleBlack.js
var import_deepmerge23 = __toESM(require_cjs());
var simpleBlack_default = (0, import_deepmerge23.default)(default_default, {
  // 连线的颜色
  lineColor: "rgb(34, 34, 34)",
  lineWidth: 4,
  // 概要连线的粗细
  generalizationLineWidth: 4,
  // 概要连线的颜色
  generalizationLineColor: "rgb(34, 34, 34)",
  // 根节点样式
  root: {
    fillColor: "#fff",
    color: "rgb(34, 34, 34)",
    borderColor: "rgb(34, 34, 34)",
    borderWidth: 3,
    fontSize: 24
  },
  // 二级节点样式
  second: {
    fillColor: "rgb(241, 246, 248)",
    color: "rgb(34, 34, 34)",
    borderColor: "rgb(34, 34, 34)",
    borderWidth: 3,
    fontSize: 18
  },
  // 三级及以下节点样式
  node: {
    fontSize: 14,
    color: "rgb(34, 34, 34)"
  },
  // 概要节点样式
  generalization: {
    fontSize: 14,
    fillColor: "transparent",
    borderColor: "rgb(34, 34, 34)",
    borderWidth: 2,
    color: "rgb(34, 34, 34)"
  }
});

// ../simple-mind-map/src/themes/courseGreen.js
var import_deepmerge24 = __toESM(require_cjs());
var courseGreen_default = (0, import_deepmerge24.default)(default_default, {
  // 连线的颜色
  lineColor: "rgb(113, 195, 169)",
  lineWidth: 3,
  // 概要连线的粗细
  generalizationLineWidth: 3,
  // 概要连线的颜色
  generalizationLineColor: "rgb(113, 195, 169)",
  // 根节点样式
  root: {
    fillColor: "rgb(16, 160, 121)",
    color: "#fff",
    borderColor: "",
    borderWidth: 0,
    fontSize: 24
  },
  // 二级节点样式
  second: {
    fillColor: "rgb(240, 252, 249)",
    color: "rgb(50, 113, 96)",
    borderColor: "rgb(113, 195, 169)",
    borderWidth: 2,
    fontSize: 18
  },
  // 三级及以下节点样式
  node: {
    fontSize: 14,
    color: "rgb(10, 59, 43)"
  },
  // 概要节点样式
  generalization: {
    fontSize: 14,
    fillColor: "rgb(246, 238, 211)",
    borderColor: "",
    borderWidth: 0,
    color: "rgb(173, 91, 12)"
  }
});

// ../simple-mind-map/src/themes/coffee.js
var import_deepmerge25 = __toESM(require_cjs());
var coffee_default = (0, import_deepmerge25.default)(default_default, {
  // 连线的颜色
  lineColor: "rgb(173, 123, 91)",
  lineWidth: 4,
  // 概要连线的粗细
  generalizationLineWidth: 4,
  // 概要连线的颜色
  generalizationLineColor: "rgb(173, 123, 91)",
  // 根节点样式
  root: {
    fillColor: "rgb(202, 117, 79)",
    color: "#fff",
    borderColor: "",
    borderWidth: 0,
    fontSize: 24
  },
  // 二级节点样式
  second: {
    fillColor: "rgb(245, 231, 216)",
    color: "rgb(125, 86, 42)",
    borderColor: "",
    borderWidth: 0,
    fontSize: 18
  },
  // 三级及以下节点样式
  node: {
    fontSize: 14,
    color: "rgb(96, 71, 47)"
  },
  // 概要节点样式
  generalization: {
    fontSize: 14,
    fillColor: "rgb(255, 249, 239)",
    borderColor: "rgb(173, 123, 91)",
    borderWidth: 2,
    color: "rgb(122, 83, 44)"
  }
});

// ../simple-mind-map/src/themes/redSpirit.js
var import_deepmerge26 = __toESM(require_cjs());
var redSpirit_default = (0, import_deepmerge26.default)(default_default, {
  // 背景颜色
  backgroundColor: "rgb(255, 238, 228)",
  // 连线的颜色
  lineColor: "rgb(230, 138, 131)",
  lineWidth: 3,
  // 概要连线的粗细
  generalizationLineWidth: 3,
  // 概要连线的颜色
  generalizationLineColor: "rgb(222, 101, 85)",
  // 根节点样式
  root: {
    fillColor: "rgb(207, 44, 44)",
    color: "rgb(255, 233, 157)",
    borderColor: "",
    borderWidth: 0,
    fontSize: 24
  },
  // 二级节点样式
  second: {
    fillColor: "rgb(255, 255, 255)",
    color: "rgb(211, 58, 21)",
    borderColor: "rgb(222, 101, 85)",
    borderWidth: 2,
    fontSize: 18
  },
  // 三级及以下节点样式
  node: {
    fontSize: 14,
    color: "rgb(144, 71, 43)"
  },
  // 概要节点样式
  generalization: {
    fontSize: 14,
    fillColor: "rgb(255, 247, 211)",
    borderColor: "rgb(255, 202, 162)",
    borderWidth: 2,
    color: "rgb(187, 101, 69)"
  }
});

// ../simple-mind-map/src/themes/blackHumour.js
var import_deepmerge27 = __toESM(require_cjs());
var blackHumour_default = (0, import_deepmerge27.default)(default_default, {
  // 背景颜色
  backgroundColor: "rgb(27, 31, 34)",
  // 连线的颜色
  lineColor: "rgb(75, 81, 78)",
  lineWidth: 3,
  // 概要连线的粗细
  generalizationLineWidth: 3,
  // 概要连线的颜色
  generalizationLineColor: "rgb(255, 119, 34)",
  // 根节点样式
  root: {
    fillColor: "rgb(36, 179, 96)",
    color: "#fff",
    borderColor: "",
    borderWidth: 0,
    fontSize: 24
  },
  // 二级节点样式
  second: {
    fillColor: "rgb(254, 199, 13)",
    color: "rgb(0, 0, 0)",
    borderColor: "",
    borderWidth: 0,
    fontSize: 18
  },
  // 三级及以下节点样式
  node: {
    fontSize: 14,
    color: "rgb(204, 204, 204)"
  },
  // 概要节点样式
  generalization: {
    fontSize: 14,
    fillColor: "rgb(27, 31, 34)",
    borderColor: "rgb(255, 119, 34)",
    borderWidth: 2,
    color: "rgb(204, 204, 204)"
  }
});

// ../simple-mind-map/src/themes/lateNightOffice.js
var import_deepmerge28 = __toESM(require_cjs());
var lateNightOffice_default = (0, import_deepmerge28.default)(default_default, {
  // 背景颜色
  backgroundColor: "rgb(32, 37, 49)",
  // 连线的颜色
  lineColor: "rgb(137, 167, 196)",
  lineWidth: 3,
  // 概要连线的粗细
  generalizationLineWidth: 3,
  // 概要连线的颜色
  generalizationLineColor: "rgb(255, 119, 34)",
  // 根节点样式
  root: {
    fillColor: "rgb(23, 153, 243)",
    color: "rgb(255, 255, 255)",
    borderColor: "",
    borderWidth: 0,
    fontSize: 24
  },
  // 二级节点样式
  second: {
    fillColor: "rgb(70, 78, 94)",
    color: "rgb(209, 210, 210)",
    borderColor: "",
    borderWidth: 0,
    fontSize: 18
  },
  // 三级及以下节点样式
  node: {
    fontSize: 14,
    color: "rgb(204, 204, 204)"
  },
  // 概要节点样式
  generalization: {
    fontSize: 14,
    fillColor: "rgb(255, 119, 34)",
    borderColor: "",
    borderWidth: 2,
    color: "#fff"
  }
});

// ../simple-mind-map/src/themes/blackGold.js
var import_deepmerge29 = __toESM(require_cjs());
var blackGold_default = (0, import_deepmerge29.default)(default_default, {
  // 背景颜色
  backgroundColor: "rgb(18, 20, 20)",
  // 连线的颜色
  lineColor: "rgb(205, 186, 156)",
  lineWidth: 3,
  // 概要连线的粗细
  generalizationLineWidth: 3,
  // 概要连线的颜色
  generalizationLineColor: "rgb(245, 224, 191)",
  // 根节点样式
  root: {
    fillColor: "rgb(255, 208, 124)",
    color: "rgb(111, 61, 6)",
    borderColor: "",
    borderWidth: 0,
    fontSize: 24
  },
  // 二级节点样式
  second: {
    fillColor: "rgb(66, 57, 46)",
    color: "rgb(225, 201, 158)",
    borderColor: "rgb(245, 224, 191)",
    borderWidth: 2,
    fontSize: 18
  },
  // 三级及以下节点样式
  node: {
    fontSize: 14,
    color: "rgb(231, 203, 155)"
  },
  // 概要节点样式
  generalization: {
    fontSize: 14,
    fillColor: "rgb(56, 45, 34)",
    borderColor: "rgb(104, 84, 61)",
    borderWidth: 2,
    color: "rgb(242, 216, 176)"
  }
});

// ../simple-mind-map/src/themes/avocado.js
var import_deepmerge30 = __toESM(require_cjs());
var avocado_default = (0, import_deepmerge30.default)(default_default, {
  // 背景颜色
  backgroundColor: "#e6f1de",
  // 连线的颜色
  lineColor: "#f5ffad",
  lineWidth: 4,
  // 概要连线的粗细
  generalizationLineWidth: 3,
  // 概要连线的颜色
  generalizationLineColor: "#749336",
  // 根节点样式
  root: {
    fillColor: "#94c143",
    color: "#fff",
    borderColor: "#94c143",
    borderWidth: 0,
    fontSize: 24
  },
  // 二级节点样式
  second: {
    fillColor: "#cee498",
    color: "#749336",
    borderColor: "#aec668",
    borderWidth: 2,
    fontSize: 18
  },
  // 三级及以下节点样式
  node: {
    fontSize: 14,
    color: "#749336"
  },
  // 概要节点样式
  generalization: {
    fontSize: 14,
    fillColor: "#cee498",
    borderColor: "#aec668",
    borderWidth: 2,
    color: "#749336"
  }
});

// ../simple-mind-map/src/themes/autumn.js
var import_deepmerge31 = __toESM(require_cjs());
var autumn_default = (0, import_deepmerge31.default)(default_default, {
  // 背景颜色
  backgroundColor: "#fff2df",
  // 连线的颜色
  lineColor: "#b0bc47",
  lineWidth: 3,
  // 概要连线的粗细
  generalizationLineWidth: 3,
  // 概要连线的颜色
  generalizationLineColor: "#b0bc47",
  // 根节点样式
  root: {
    fillColor: "#e68112",
    color: "#fff",
    borderColor: "#e68112",
    borderWidth: 0,
    fontSize: 24
  },
  // 二级节点样式
  second: {
    fillColor: "#ffd683",
    color: "#8c5416",
    borderColor: "#b0bc47",
    borderWidth: 2,
    fontSize: 18
  },
  // 三级及以下节点样式
  node: {
    fontSize: 14,
    color: "#8c5416"
  },
  // 概要节点样式
  generalization: {
    fontSize: 14,
    fillColor: "#ffd683",
    borderColor: "#b0bc47",
    borderWidth: 2,
    color: "#8c5416"
  }
});

// ../simple-mind-map/src/themes/orangeJuice.js
var import_deepmerge32 = __toESM(require_cjs());
var orangeJuice_default = (0, import_deepmerge32.default)(default_default, {
  // 背景颜色
  backgroundColor: "#070616",
  // 连线的颜色
  lineColor: "#fff",
  lineWidth: 3,
  // 概要连线的粗细
  generalizationLineWidth: 3,
  // 概要连线的颜色
  generalizationLineColor: "#fff",
  // 根节点样式
  root: {
    fillColor: "#ff6811",
    color: "#110501",
    borderColor: "#ff6811",
    borderWidth: 0,
    fontSize: 24
  },
  // 二级节点样式
  second: {
    fillColor: "#070616",
    color: "#a9a4a9",
    borderColor: "#ff6811",
    borderWidth: 2,
    fontSize: 18
  },
  // 三级及以下节点样式
  node: {
    fontSize: 14,
    color: "#a9a4a9"
  },
  // 概要节点样式
  generalization: {
    fontSize: 14,
    fillColor: "",
    borderColor: "#ff6811",
    borderWidth: 2,
    color: "#a9a4a9"
  }
});

// ../simple-mind-map/src/themes/index.js
var themes_default = {
  default: default_default,
  freshGreen: freshGreen_default,
  blueSky: blueSky_default,
  brainImpairedPink: brainImpairedPink_default,
  romanticPurple: romanticPurple_default,
  freshRed: freshRed_default,
  earthYellow: earthYellow_default,
  classic: classic_default,
  classic2: classic2_default,
  classic3: classic3_default,
  classic4: classic4_default,
  dark: dark_default,
  classicGreen: classicGreen_default,
  classicBlue: classicBlue_default,
  minions: minions_default,
  pinkGrape: pinkGrape_default,
  mint: mint_default,
  gold: gold_default,
  vitalityOrange: vitalityOrange_default,
  greenLeaf: greenLeaf_default,
  dark2: dark2_default,
  skyGreen: skyGreen_default,
  simpleBlack: simpleBlack_default,
  courseGreen: courseGreen_default,
  coffee: coffee_default,
  redSpirit: redSpirit_default,
  blackHumour: blackHumour_default,
  lateNightOffice: lateNightOffice_default,
  blackGold: blackGold_default,
  avocado: avocado_default,
  autumn: autumn_default,
  orangeJuice: orangeJuice_default
};

// ../simple-mind-map/src/core/command/keyMap.js
var map2 = {
  Backspace: 8,
  Tab: 9,
  Enter: 13,
  Shift: 16,
  Control: 17,
  Alt: 18,
  CapsLock: 20,
  Esc: 27,
  Spacebar: 32,
  PageUp: 33,
  PageDown: 34,
  End: 35,
  Home: 36,
  Insert: 45,
  Left: 37,
  Up: 38,
  Right: 39,
  Down: 40,
  Del: 46,
  NumLock: 144,
  Cmd: 91,
  CmdFF: 224,
  F1: 112,
  F2: 113,
  F3: 114,
  F4: 115,
  F5: 116,
  F6: 117,
  F7: 118,
  F8: 119,
  F9: 120,
  F10: 121,
  F11: 122,
  F12: 123,
  "`": 192,
  "=": 187,
  "-": 189,
  "/": 191,
  ".": 190
};
for (let i2 = 0; i2 <= 9; i2++) {
  map2[i2] = i2 + 48;
}
"abcdefghijklmnopqrstuvwxyz".split("").forEach((n2, index3) => {
  map2[n2] = index3 + 65;
});
var keyMap = map2;

// ../simple-mind-map/src/core/command/KeyCommand.js
var KeyCommand = class {
  //  构造函数
  constructor(opt) {
    this.opt = opt;
    this.mindMap = opt.mindMap;
    this.shortcutMap = {
      //Enter: [fn]
    };
    this.shortcutMapCache = {};
    this.isPause = false;
    this.isInSvg = false;
    this.bindEvent();
  }
  //  暂停快捷键响应
  pause() {
    this.isPause = true;
  }
  //  恢复快捷键响应
  recovery() {
    this.isPause = false;
  }
  //  保存当前注册的快捷键数据，然后清空快捷键数据
  save() {
    this.shortcutMapCache = this.shortcutMap;
    this.shortcutMap = {};
  }
  //  恢复保存的快捷键数据，然后清空缓存数据
  restore() {
    this.shortcutMap = this.shortcutMapCache;
    this.shortcutMapCache = {};
  }
  //  绑定事件
  bindEvent() {
    this.onKeydown = this.onKeydown.bind(this);
    this.mindMap.on("svg_mouseenter", () => {
      this.isInSvg = true;
    });
    this.mindMap.on("svg_mouseleave", () => {
      if (this.mindMap.renderer.textEdit.isShowTextEdit())
        return;
      if (this.mindMap.associativeLine && this.mindMap.associativeLine.showTextEdit) {
        return;
      }
      this.isInSvg = false;
    });
    window.addEventListener("keydown", this.onKeydown);
    this.mindMap.on("beforeDestroy", () => {
      this.unBindEvent();
    });
  }
  // 解绑事件
  unBindEvent() {
    window.removeEventListener("keydown", this.onKeydown);
  }
  // 按键事件
  onKeydown(e2) {
    if (this.isPause || this.mindMap.opt.enableShortcutOnlyWhenMouseInSvg && !this.isInSvg) {
      return;
    }
    Object.keys(this.shortcutMap).forEach((key) => {
      if (this.checkKey(e2, key)) {
        if (!this.checkKey(e2, "Control+v")) {
          e2.stopPropagation();
          e2.preventDefault();
        }
        this.shortcutMap[key].forEach((fn) => {
          fn();
        });
      }
    });
  }
  //  检查键值是否符合
  checkKey(e2, key) {
    let o2 = this.getOriginEventCodeArr(e2);
    let k = this.getKeyCodeArr(key);
    if (o2.length !== k.length) {
      return false;
    }
    for (let i2 = 0; i2 < o2.length; i2++) {
      let index3 = k.findIndex((item) => {
        return item === o2[i2];
      });
      if (index3 === -1) {
        return false;
      } else {
        k.splice(index3, 1);
      }
    }
    return true;
  }
  //  获取事件对象里的键值数组
  getOriginEventCodeArr(e2) {
    let arr = [];
    if (e2.ctrlKey || e2.metaKey) {
      arr.push(keyMap["Control"]);
    }
    if (e2.altKey) {
      arr.push(keyMap["Alt"]);
    }
    if (e2.shiftKey) {
      arr.push(keyMap["Shift"]);
    }
    if (!arr.includes(e2.keyCode)) {
      arr.push(e2.keyCode);
    }
    return arr;
  }
  // 判断是否按下了组合键
  hasCombinationKey(e2) {
    return e2.ctrlKey || e2.metaKey || e2.altKey || e2.shiftKey;
  }
  //  获取快捷键对应的键值数组
  getKeyCodeArr(key) {
    let keyArr = key.split(/\s*\+\s*/);
    let arr = [];
    keyArr.forEach((item) => {
      arr.push(keyMap[item]);
    });
    return arr;
  }
  //  添加快捷键命令
  /**
   * Enter
   * Tab | Insert
   * Shift + a
   */
  addShortcut(key, fn) {
    key.split(/\s*\|\s*/).forEach((item) => {
      if (this.shortcutMap[item]) {
        this.shortcutMap[item].push(fn);
      } else {
        this.shortcutMap[item] = [fn];
      }
    });
  }
  //  移除快捷键命令
  removeShortcut(key, fn) {
    key.split(/\s*\|\s*/).forEach((item) => {
      if (this.shortcutMap[item]) {
        if (fn) {
          let index3 = this.shortcutMap[item].findIndex((f3) => {
            return f3 === fn;
          });
          if (index3 !== -1) {
            this.shortcutMap[item].splice(index3, 1);
          }
        } else {
          this.shortcutMap[item] = [];
          delete this.shortcutMap[item];
        }
      }
    });
  }
  //  获取指定快捷键的处理函数
  getShortcutFn(key) {
    let res = [];
    key.split(/\s*\|\s*/).forEach((item) => {
      res = this.shortcutMap[item] || [];
    });
    return res;
  }
};

// ../simple-mind-map/src/core/command/Command.js
var Command = class {
  //  构造函数
  constructor(opt = {}) {
    this.opt = opt;
    this.mindMap = opt.mindMap;
    this.commands = {};
    this.history = [];
    this.activeHistoryIndex = 0;
    this.registerShortcutKeys();
    this.addHistory = throttle(
      this.addHistory,
      this.mindMap.opt.addHistoryTime,
      this
    );
  }
  //  清空历史数据
  clearHistory() {
    this.history = [];
    this.activeHistoryIndex = 0;
    this.mindMap.emit("back_forward", 0, 0);
  }
  //  注册快捷键
  registerShortcutKeys() {
    this.mindMap.keyCommand.addShortcut("Control+z", () => {
      this.mindMap.execCommand("BACK");
    });
    this.mindMap.keyCommand.addShortcut("Control+y", () => {
      this.mindMap.execCommand("FORWARD");
    });
  }
  //  执行命令
  exec(name, ...args) {
    if (this.commands[name]) {
      this.commands[name].forEach((fn) => {
        fn(...args);
      });
      if (["BACK", "FORWARD", "SET_NODE_ACTIVE", "CLEAR_ACTIVE_NODE"].includes(
        name
      )) {
        return;
      }
      this.addHistory();
    }
  }
  //  添加命令
  add(name, fn) {
    if (this.commands[name]) {
      this.commands[name].push(fn);
    } else {
      this.commands[name] = [fn];
    }
  }
  //  移除命令
  remove(name, fn) {
    if (!this.commands[name]) {
      return;
    }
    if (!fn) {
      this.commands[name] = [];
      delete this.commands[name];
    } else {
      let index3 = this.commands[name].find((item) => {
        return item === fn;
      });
      if (index3 !== -1) {
        this.commands[name].splice(index3, 1);
      }
    }
  }
  //  添加回退数据
  addHistory() {
    if (this.mindMap.opt.readonly) {
      return;
    }
    let data2 = this.getCopyData();
    if (this.history.length > 0 && JSON.stringify(this.history[this.history.length - 1]) === JSON.stringify(data2)) {
      return;
    }
    this.history = this.history.slice(0, this.activeHistoryIndex + 1);
    this.history.push(simpleDeepClone(data2));
    if (this.history.length > this.mindMap.opt.maxHistoryCount) {
      this.history.shift();
    }
    this.activeHistoryIndex = this.history.length - 1;
    this.mindMap.emit("data_change", data2);
    this.mindMap.emit(
      "back_forward",
      this.activeHistoryIndex,
      this.history.length
    );
  }
  //  回退
  back(step = 1) {
    if (this.mindMap.opt.readonly) {
      return;
    }
    if (this.activeHistoryIndex - step >= 0) {
      this.activeHistoryIndex -= step;
      this.mindMap.emit(
        "back_forward",
        this.activeHistoryIndex,
        this.history.length
      );
      let data2 = simpleDeepClone(this.history[this.activeHistoryIndex]);
      this.mindMap.emit("data_change", data2);
      return data2;
    }
  }
  //  前进
  forward(step = 1) {
    if (this.mindMap.opt.readonly) {
      return;
    }
    let len = this.history.length;
    if (this.activeHistoryIndex + step <= len - 1) {
      this.activeHistoryIndex += step;
      this.mindMap.emit(
        "back_forward",
        this.activeHistoryIndex,
        this.history.length
      );
      let data2 = simpleDeepClone(this.history[this.activeHistoryIndex]);
      this.mindMap.emit("data_change", data2);
      return data2;
    }
  }
  //  获取渲染树数据副本
  getCopyData() {
    return copyRenderTree({}, this.mindMap.renderer.renderTree, true);
  }
  // 移除节点数据中的uid
  removeDataUid(data2) {
    data2 = simpleDeepClone(data2);
    let walk2 = (root2) => {
      delete root2.data.uid;
      if (root2.children && root2.children.length > 0) {
        root2.children.forEach((item) => {
          walk2(item);
        });
      }
    };
    walk2(data2);
    return data2;
  }
};
var Command_default = Command;

// ../simple-mind-map/src/utils/BatchExecution.js
var BatchExecution = class {
  //  构造函数
  constructor() {
    this.has = {};
    this.queue = [];
    this.nextTick = nextTick(this.flush, this);
  }
  //  添加任务
  push(name, fn) {
    if (this.has[name]) {
      this.replaceTask(name, fn);
      return;
    }
    this.has[name] = true;
    this.queue.push({
      name,
      fn
    });
    this.nextTick();
  }
  // 替换任务
  replaceTask(name, fn) {
    const index3 = this.queue.findIndex((item) => {
      return item.name === name;
    });
    if (index3 !== -1) {
      this.queue[index3] = {
        name,
        fn
      };
    }
  }
  //   执行队列
  flush() {
    let fns = this.queue.slice(0);
    this.queue = [];
    fns.forEach(({ name, fn }) => {
      this.has[name] = false;
      fn();
    });
  }
};
var BatchExecution_default = BatchExecution;

// ../simple-mind-map/src/constants/defaultOptions.js
var defaultOpt = {
  // 是否只读
  readonly: false,
  // 布局
  layout: CONSTANTS.LAYOUT.LOGICAL_STRUCTURE,
  // 如果结构为鱼骨图，那么可以通过该选项控制倾斜角度
  fishboneDeg: 45,
  // 主题
  theme: "default",
  // 内置主题：default（默认主题）
  // 主题配置，会和所选择的主题进行合并
  themeConfig: {},
  // 放大缩小的增量比例
  scaleRatio: 0.2,
  // 鼠标缩放是否以鼠标当前位置为中心点，否则以画布中心点
  mouseScaleCenterUseMousePosition: true,
  // 最多显示几个标签
  maxTag: 5,
  // 展开收缩按钮尺寸
  expandBtnSize: 20,
  // 节点里图片和文字的间距
  imgTextMargin: 5,
  // 节点里各种文字信息的间距，如图标和文字的间距
  textContentMargin: 2,
  // 多选节点时鼠标移动到边缘时的画布移动偏移量
  selectTranslateStep: 3,
  // 多选节点时鼠标移动距边缘多少距离时开始偏移
  selectTranslateLimit: 20,
  // 自定义节点备注内容显示
  customNoteContentShow: null,
  /*
          {
              show(){},
              hide(){}
          }
      */
  // 是否开启节点自由拖拽
  enableFreeDrag: false,
  // 水印配置
  watermarkConfig: {
    onlyExport: false,
    // 是否仅在导出时添加水印
    text: "",
    lineSpacing: 100,
    textSpacing: 100,
    angle: 30,
    textStyle: {
      color: "#999",
      opacity: 0.5,
      fontSize: 14
    }
  },
  // 达到该宽度文本自动换行
  textAutoWrapWidth: 500,
  // 自定义鼠标滚轮事件处理
  // 可以传一个函数，回调参数为事件对象
  customHandleMousewheel: null,
  // 鼠标滚动的行为，如果customHandleMousewheel传了自定义函数，这个属性不生效
  mousewheelAction: CONSTANTS.MOUSE_WHEEL_ACTION.MOVE,
  // zoom（放大缩小）、move（上下移动）
  // 当mousewheelAction设为move时，可以通过该属性控制鼠标滚动一下视图移动的步长，单位px
  mousewheelMoveStep: 100,
  // 当mousewheelAction设为zoom时，或者按住Ctrl键时，默认向前滚动是缩小，向后滚动是放大，如果该属性设为true，那么会反过来
  mousewheelZoomActionReverse: true,
  // 默认插入的二级节点的文字
  defaultInsertSecondLevelNodeText: "\u4E8C\u7EA7\u8282\u70B9",
  // 默认插入的二级以下节点的文字
  defaultInsertBelowSecondLevelNodeText: "\u5206\u652F\u4E3B\u9898",
  // 展开收起按钮的颜色
  expandBtnStyle: {
    color: "#808080",
    fill: "#fff",
    fontSize: 13,
    strokeColor: "#333333"
  },
  // 自定义展开收起按钮的图标
  expandBtnIcon: {
    open: "",
    // svg字符串
    close: ""
  },
  // 处理收起节点数量
  expandBtnNumHandler: (num) => {
    return num;
  },
  // 是否显示带数量的收起按钮
  isShowExpandNum: true,
  // 是否只有当鼠标在画布内才响应快捷键事件
  enableShortcutOnlyWhenMouseInSvg: true,
  // 初始根节点的位置
  initRootNodePosition: null,
  // 导出png、svg、pdf时的图形内边距，注意是单侧内边距
  exportPaddingX: 10,
  exportPaddingY: 10,
  // 节点文本编辑框的z-index
  nodeTextEditZIndex: 3e3,
  // 节点备注浮层的z-index
  nodeNoteTooltipZIndex: 3e3,
  // 是否在点击了画布外的区域时结束节点文本的编辑状态
  isEndNodeTextEditOnClickOuter: true,
  // 最大历史记录数
  maxHistoryCount: 500,
  // 是否一直显示节点的展开收起按钮，默认为鼠标移上去和激活时才显示
  alwaysShowExpandBtn: false,
  // 扩展节点可插入的图标
  iconList: [
    // {
    //   name: '',// 分组名称
    //   type: '',// 分组的值
    //   list: [// 分组下的图标列表
    //     {
    //       name: '',// 图标名称
    //       icon:''// 图标，可以传svg或图片
    //     }
    //   ]
    // }
  ],
  // 节点最大缓存数量
  maxNodeCacheCount: 1e3,
  // 关联线默认文字
  defaultAssociativeLineText: "\u5173\u8054",
  // 思维导图适应画布大小时的内边距
  fitPadding: 50,
  // 是否开启按住ctrl键多选节点功能
  enableCtrlKeyNodeSelection: true,
  // 设置为左键多选节点，右键拖动画布
  useLeftKeySelectionRightKeyDrag: false,
  // 节点即将进入编辑前的回调方法，如果该方法返回true以外的值，那么将取消编辑，函数可以返回一个值，或一个Promise，回调参数为节点实例
  beforeTextEdit: null,
  // 是否开启自定义节点内容
  isUseCustomNodeContent: false,
  // 自定义返回节点内容的方法
  customCreateNodeContent: null,
  // 指定内部一些元素（节点文本编辑元素、节点备注显示元素、关联线文本编辑元素、节点图片调整按钮元素）添加到的位置，默认添加到document.body下
  customInnerElsAppendTo: null,
  // 拖拽元素时，指示元素新位置的块的最大高度
  nodeDragPlaceholderMaxSize: 20,
  // 是否在存在一个激活节点时，当按下中文、英文、数字按键时自动进入文本编辑模式
  // 开启该特性后，需要给你的输入框绑定keydown事件，并禁止冒泡
  enableAutoEnterTextEditWhenKeydown: false,
  // 设置富文本节点编辑框和节点大小一致，形成伪原地编辑的效果
  // 需要注意的是，只有当节点内只有文本、且形状是矩形才会有比较好的效果
  richTextEditFakeInPlace: false,
  // 自定义对剪贴板文本的处理。当按ctrl+v粘贴时会读取用户剪贴板中的文本和图片，默认只会判断文本是否是普通文本和simple-mind-map格式的节点数据，如果你想处理其他思维导图的数据，比如processon、zhixi等，那么可以传递一个函数，接受当前剪贴板中的文本为参数，返回处理后的数据，可以返回两种类型：
  /*
      1.返回一个纯文本，那么会直接以该文本创建一个子节点
  
      2.返回一个节点对象，格式如下：
        {
          // 代表是simple-mind-map格式的数据
          simpleMindMap: true,
          // 节点数据，同simple-mind-map节点数据格式
          data: {
            data: {
              text: ''
            },
            children: []
          }
        }
    */
  // 如果你的处理逻辑存在异步逻辑，也可以返回一个promise
  customHandleClipboardText: null,
  // 禁止鼠标滚轮缩放，你仍旧可以使用api进行缩放
  disableMouseWheelZoom: false,
  // 禁止双指缩放，你仍旧可以使用api进行缩放
  // 需要注册TouchEvent插件后生效
  disableTouchZoom: false,
  // 错误处理函数
  errorHandler: (code, error) => {
    console.error(code, error);
  },
  // 设置导出图片和svg时，针对富文本节点内容，也就是嵌入到svg中的html节点的默认样式覆盖
  // 如果不覆盖，会发生偏移问题
  resetCss: `
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
  `,
  // 是否在鼠标双击时回到根节点，也就是让根节点居中显示
  enableDblclickBackToRootNode: false,
  // 导出图片时canvas的缩放倍数，该配置会和window.devicePixelRatio值取最大值
  minExportImgCanvasScale: 2,
  // 节点鼠标hover和激活时显示的矩形边框的颜色
  hoverRectColor: "rgb(94, 200, 248)",
  // 节点鼠标hover和激活时显示的矩形边框距节点内容的距离
  hoverRectPadding: 2,
  // 双击节点进入节点文本编辑时是否默认选中文本，默认只在创建新节点时会选中
  selectTextOnEnterEditText: false,
  // 删除节点后激活相邻节点
  deleteNodeActive: true,
  // 拖拽节点时鼠标移动到画布边缘是否开启画布自动移动
  autoMoveWhenMouseInEdgeOnDrag: true,
  // 是否首次加载fit view
  fit: false,
  // 拖拽多个节点时随鼠标移动的示意矩形的样式配置
  dragMultiNodeRectConfig: {
    width: 40,
    height: 20,
    fill: ""
    // 填充颜色，如果不传默认使用连线的颜色
  },
  // 节点拖拽时新位置的示意矩形的填充颜色，如果不传默认使用连线的颜色
  dragPlaceholderRectFill: "",
  // 节点拖拽时的透明度配置
  dragOpacityConfig: {
    cloneNodeOpacity: 0.5,
    // 跟随鼠标移动的克隆节点或矩形的透明度
    beingDragNodeOpacity: 0.3
    // 被拖拽节点的透明度
  },
  // 自定义标签的颜色
  // {pass: 'green, unpass: 'red'}
  tagsColorMap: {},
  // 节点协作样式配置
  cooperateStyle: {
    avatarSize: 22,
    // 头像大小
    fontSize: 12
    // 如果是文字头像，那么文字的大小
  },
  // 关联线是否始终显示在节点上层
  // false：即创建关联线和激活关联线时处于最顶层，其他情况下处于节点下方
  associativeLineIsAlwaysAboveNode: true,
  // 插入概要的默认文本
  defaultGeneralizationText: "\u6982\u8981",
  // 粘贴文本的方式创建新节点时，控制是否按换行自动分割节点，即如果存在换行，那么会根据换行创建多个节点，否则只会创建一个节点
  // 可以传递一个函数，返回promise，resolve代表根据换行分割，reject代表忽略换行
  handleIsSplitByWrapOnPasteCreateNewNode: null,
  // 多少时间内只允许添加一次历史记录，避免添加没有必要的中间状态，单位：ms
  addHistoryTime: 100,
  // 是否禁止拖动画布
  isDisableDrag: false,
  // 鼠标移入概要高亮所属节点时的高亮框样式
  highlightNodeBoxStyle: {
    stroke: "rgb(94, 200, 248)",
    fill: "transparent"
  },
  // 创建新节点时的行为
  /*
    DEFAULT  ：默认会激活新创建的节点，并且进入编辑模式。如果同时创建了多个新节点，那么只会激活而不会进入编辑模式
    NOT_ACTIVE  : 不激活新创建的节点
    ACTIVE_ONLY  : 只激活新创建的节点，不进入编辑模式
  */
  createNewNodeBehavior: CONSTANTS.CREATE_NEW_NODE_BEHAVIOR.DEFAULT,
  // 当节点图片加载失败时显示的默认图片
  defaultNodeImage: "",
  // 是否将思维导图限制在画布内
  // 比如向右拖动时，思维导图图形的最左侧到达画布中心时将无法继续向右拖动，其他同理
  isLimitMindMapInCanvas: false,
  // 当注册了滚动条插件（Scrollbar）时，是否将思维导图限制在画布内，isLimitMindMapInCanvas不再起作用
  isLimitMindMapInCanvasWhenHasScrollbar: true,
  // 在节点上粘贴剪贴板中的图片的处理方法，默认是转换为data:url数据插入到节点中，你可以通过该方法来将图片数据上传到服务器，实现保存图片的url
  // 可以传递一个异步方法，接收Blob类型的图片数据，需要返回如下结构：
  /*
    {
      url,    // 图片url
      size: {
        width,  // 图片的宽度
        height  //图片的高度
      }
    }
  */
  handleNodePasteImg: null
};

// ../simple-mind-map/index.js
var MindMap2 = class {
  //  构造函数
  /**
   *
   * @param {defaultOpt} opt
   */
  constructor(opt = {}) {
    this.opt = this.handleOpt((0, import_deepmerge33.default)(defaultOpt, opt));
    this.el = this.opt.el;
    if (!this.el)
      throw new Error("\u7F3A\u5C11\u5BB9\u5668\u5143\u7D20el");
    this.getElRectInfo();
    this.cssEl = null;
    this.addCss();
    this.initContainer();
    this.initTheme();
    this.initCache();
    this.event = new Event_default({
      mindMap: this
    });
    this.keyCommand = new KeyCommand({
      mindMap: this
    });
    this.command = new Command_default({
      mindMap: this
    });
    this.renderer = new Render_default({
      mindMap: this
    });
    this.view = new View_default({
      mindMap: this
    });
    this.batchExecution = new BatchExecution_default();
    MindMap2.pluginList.forEach((plugin) => {
      this.initPlugin(plugin);
    });
    this.render(this.opt.fit ? () => this.view.fit() : () => {
    });
    setTimeout(() => {
      this.command.addHistory();
    }, 0);
  }
  //  配置参数处理
  handleOpt(opt) {
    opt.data = simpleDeepClone(opt.data || {});
    if (!layoutValueList.includes(opt.layout)) {
      opt.layout = CONSTANTS.LAYOUT.LOGICAL_STRUCTURE;
    }
    opt.theme = opt.theme && themes_default[opt.theme] ? opt.theme : "default";
    return opt;
  }
  // 创建容器元素
  initContainer() {
    const { associativeLineIsAlwaysAboveNode } = this.opt;
    const createAssociativeLineDraw = () => {
      this.associativeLineDraw = this.draw.group();
      this.associativeLineDraw.addClass("smm-associative-line-container");
    };
    this.svg = SVG().addTo(this.el).size(this.width, this.height);
    this.draw = this.svg.group();
    this.draw.addClass("smm-container");
    this.lineDraw = this.draw.group();
    this.lineDraw.addClass("smm-line-container");
    if (!associativeLineIsAlwaysAboveNode) {
      createAssociativeLineDraw();
    }
    this.nodeDraw = this.draw.group();
    this.nodeDraw.addClass("smm-node-container");
    if (associativeLineIsAlwaysAboveNode) {
      createAssociativeLineDraw();
    }
    this.otherDraw = this.draw.group();
    this.otherDraw.addClass("smm-other-container");
  }
  // 清空各容器
  clearDraw() {
    this.lineDraw.clear();
    this.associativeLineDraw.clear();
    this.nodeDraw.clear();
    this.otherDraw.clear();
  }
  // 添加必要的css样式到页面
  addCss() {
    this.cssEl = document.createElement("style");
    this.cssEl.type = "text/css";
    this.cssEl.innerHTML = cssContent;
    document.head.appendChild(this.cssEl);
  }
  // 移除css
  removeCss() {
    document.head.removeChild(this.cssEl);
  }
  //  渲染，部分渲染
  render(callback, source = "") {
    this.batchExecution.push("render", () => {
      this.initTheme();
      this.renderer.render(callback, source);
    });
  }
  //  重新渲染
  reRender(callback, source = "") {
    this.renderer.reRender = true;
    this.renderer.clearCache();
    this.clearDraw();
    this.render(callback, source = "");
  }
  // 获取或更新容器尺寸位置信息
  getElRectInfo() {
    this.elRect = this.el.getBoundingClientRect();
    this.width = this.elRect.width;
    this.height = this.elRect.height;
    if (this.width <= 0 || this.height <= 0)
      throw new Error("\u5BB9\u5668\u5143\u7D20el\u7684\u5BBD\u9AD8\u4E0D\u80FD\u4E3A0");
  }
  //  容器尺寸变化，调整尺寸
  resize() {
    this.getElRectInfo();
    this.svg.size(this.width, this.height);
    this.emit("resize");
  }
  //  监听事件
  on(event, fn) {
    this.event.on(event, fn);
  }
  //  触发事件
  emit(event, ...args) {
    this.event.emit(event, ...args);
  }
  //  解绑事件
  off(event, fn) {
    this.event.off(event, fn);
  }
  // 初始化缓存数据
  initCache() {
    Object.keys(commonCaches).forEach((key) => {
      let type = getType(commonCaches[key]);
      let value = "";
      switch (type) {
        case "Boolean":
          value = false;
          break;
        default:
          value = null;
          break;
      }
      commonCaches[key] = value;
    });
  }
  //  设置主题
  initTheme() {
    this.themeConfig = (0, import_deepmerge33.default)(themes_default[this.opt.theme], this.opt.themeConfig);
    Style_default.setBackgroundStyle(this.el, this.themeConfig);
  }
  //  设置主题
  setTheme(theme, notRender = false) {
    this.execCommand("CLEAR_ACTIVE_NODE");
    this.opt.theme = theme;
    if (!notRender) {
      this.render(null, CONSTANTS.CHANGE_THEME);
    }
    this.emit("view_theme_change", theme);
  }
  //  获取当前主题
  getTheme() {
    return this.opt.theme;
  }
  //  设置主题配置
  setThemeConfig(config, notRender = false) {
    const changedConfig = getObjectChangedProps(this.themeConfig, config);
    this.opt.themeConfig = config;
    if (!notRender) {
      let res = checkIsNodeSizeIndependenceConfig(changedConfig);
      this.render(null, res ? "" : CONSTANTS.CHANGE_THEME);
    }
  }
  //  获取自定义主题配置
  getCustomThemeConfig() {
    return this.opt.themeConfig;
  }
  //  获取某个主题配置值
  getThemeConfig(prop) {
    return prop === void 0 ? this.themeConfig : this.themeConfig[prop];
  }
  // 获取配置
  getConfig(prop) {
    return prop === void 0 ? this.opt : this.opt[prop];
  }
  // 更新配置
  updateConfig(opt = {}) {
    this.opt = this.handleOpt(import_deepmerge33.default.all([defaultOpt, this.opt, opt]));
  }
  //  获取当前布局结构
  getLayout() {
    return this.opt.layout;
  }
  //  设置布局结构
  setLayout(layout, notRender = false) {
    if (!layoutValueList.includes(layout)) {
      layout = CONSTANTS.LAYOUT.LOGICAL_STRUCTURE;
    }
    this.opt.layout = layout;
    this.view.reset();
    this.renderer.setLayout();
    if (!notRender) {
      this.render(null, CONSTANTS.CHANGE_LAYOUT);
    }
  }
  //  执行命令
  execCommand(...args) {
    this.command.exec(...args);
  }
  //  动态设置思维导图数据，纯节点数据
  setData(data2) {
    data2 = simpleDeepClone(data2 || {});
    this.execCommand("CLEAR_ACTIVE_NODE");
    this.command.clearHistory();
    this.command.addHistory();
    this.renderer.setData(data2);
    this.reRender(() => {
    }, CONSTANTS.SET_DATA);
    this.emit("set_data", data2);
  }
  //  动态设置思维导图数据，包括节点数据、布局、主题、视图
  setFullData(data2) {
    if (data2.root) {
      this.setData(data2.root);
    }
    if (data2.layout) {
      this.setLayout(data2.layout);
    }
    if (data2.theme) {
      if (data2.theme.template) {
        this.setTheme(data2.theme.template);
      }
      if (data2.theme.config) {
        this.setThemeConfig(data2.theme.config);
      }
    }
    if (data2.view) {
      this.view.setTransformData(data2.view);
    }
  }
  //  获取思维导图数据，节点树、主题、布局等
  getData(withConfig) {
    let nodeData = this.command.getCopyData();
    let data2 = {};
    if (withConfig) {
      data2 = {
        layout: this.getLayout(),
        root: nodeData,
        theme: {
          template: this.getTheme(),
          config: this.getCustomThemeConfig()
        },
        view: this.view.getTransformData()
      };
    } else {
      data2 = nodeData;
    }
    return simpleDeepClone(data2);
  }
  //  导出
  async export(...args) {
    try {
      let result = await this.doExport.export(...args);
      return result;
    } catch (error) {
      this.opt.errorHandler(ERROR_TYPES.EXPORT_ERROR, error);
    }
  }
  //  转换位置
  toPos(x2, y3) {
    return {
      x: x2 - this.elRect.left,
      y: y3 - this.elRect.top
    };
  }
  //  设置只读模式、编辑模式
  setMode(mode) {
    if (![CONSTANTS.MODE.READONLY, CONSTANTS.MODE.EDIT].includes(mode)) {
      return;
    }
    this.opt.readonly = mode === CONSTANTS.MODE.READONLY;
    if (this.opt.readonly) {
      this.execCommand("CLEAR_ACTIVE_NODE");
    }
    this.emit("mode_change", mode);
  }
  // 获取svg数据
  getSvgData({ paddingX = 0, paddingY = 0, ignoreWatermark = false } = {}) {
    const svg2 = this.svg;
    const draw = this.draw;
    const origWidth = svg2.width();
    const origHeight = svg2.height();
    const origTransform = draw.transform();
    const elRect = this.elRect;
    draw.scale(1 / origTransform.scaleX, 1 / origTransform.scaleY);
    const rect = draw.rbox();
    rect.width += paddingX * 2;
    rect.height += paddingY * 2;
    draw.translate(paddingX, paddingY);
    svg2.size(rect.width, rect.height);
    draw.translate(-rect.x + elRect.left, -rect.y + elRect.top);
    let clone = svg2.clone();
    const hasWatermark = this.watermark && this.watermark.hasWatermark();
    if (!ignoreWatermark && hasWatermark) {
      this.watermark.isInExport = true;
      const { onlyExport } = this.opt.watermarkConfig;
      const needReDrawWatermark = rect.width > origWidth || rect.height > origHeight;
      if (needReDrawWatermark) {
        this.width = rect.width;
        this.height = rect.height;
        this.watermark.onResize();
        clone = svg2.clone();
        this.width = origWidth;
        this.height = origHeight;
        this.watermark.onResize();
      } else if (onlyExport) {
        this.watermark.onResize();
        clone = svg2.clone();
      }
      if (onlyExport) {
        this.watermark.clear();
      }
      this.watermark.isInExport = false;
    }
    clone.add(SVG(`<style>${cssContent}</style>`));
    const markerList = svg2.find("marker");
    if (markerList && markerList.length > 0) {
      const id = markerList[0].attr("id");
      clone.find("marker").forEach((item) => {
        item.attr("id", id);
      });
    }
    svg2.size(origWidth, origHeight);
    draw.transform(origTransform);
    return {
      svg: clone,
      // 思维导图图形的整体svg元素，包括：svg（画布容器）、g（实际的思维导图组）
      svgHTML: clone.svg(),
      // svg字符串
      rect: {
        ...rect,
        // 思维导图图形未缩放时的位置尺寸等信息
        ratio: rect.width / rect.height
        // 思维导图图形的宽高比
      },
      origWidth,
      // 画布宽度
      origHeight,
      // 画布高度
      scaleX: origTransform.scaleX,
      // 思维导图图形的水平缩放值
      scaleY: origTransform.scaleY
      // 思维导图图形的垂直缩放值
    };
  }
  // 添加插件
  addPlugin(plugin, opt) {
    let index3 = MindMap2.hasPlugin(plugin);
    if (index3 === -1) {
      MindMap2.usePlugin(plugin, opt);
      this.initPlugin(plugin);
    }
  }
  // 移除插件
  removePlugin(plugin) {
    let index3 = MindMap2.hasPlugin(plugin);
    if (index3 !== -1) {
      MindMap2.pluginList.splice(index3, 1);
      if (this[plugin.instanceName]) {
        if (this[plugin.instanceName].beforePluginRemove) {
          this[plugin.instanceName].beforePluginRemove();
        }
        delete this[plugin.instanceName];
      }
    }
  }
  // 实例化插件
  initPlugin(plugin) {
    this[plugin.instanceName] = new plugin({
      mindMap: this,
      pluginOpt: plugin.pluginOpt
    });
  }
  // 销毁
  destroy() {
    this.emit("beforeDestroy");
    this.renderer.textEdit.hideEditTextBox();
    if (this.associativeLine) {
      this.associativeLine.hideEditTextBox();
    }
    ;
    [...MindMap2.pluginList].forEach((plugin) => {
      if (this[plugin.instanceName] && this[plugin.instanceName].beforePluginDestroy) {
        this[plugin.instanceName].beforePluginDestroy();
      }
      this[plugin.instanceName] = null;
    });
    this.event.unbind();
    this.svg.remove();
    Style_default.removeBackgroundStyle(this.el);
    this.el.innerHTML = "";
    this.el = null;
    this.removeCss();
  }
};
MindMap2.pluginList = [];
MindMap2.usePlugin = (plugin, opt = {}) => {
  if (MindMap2.hasPlugin(plugin) !== -1)
    return MindMap2;
  plugin.pluginOpt = opt;
  MindMap2.pluginList.push(plugin);
  return MindMap2;
};
MindMap2.hasPlugin = (plugin) => {
  return MindMap2.pluginList.findIndex((item) => {
    return item === plugin;
  });
};
MindMap2.defineTheme = (name, config = {}) => {
  if (themes_default[name]) {
    return new Error("\u8BE5\u4E3B\u9898\u540D\u79F0\u5DF2\u5B58\u5728");
  }
  themes_default[name] = (0, import_deepmerge33.default)(default_default, config);
};
var simple_mind_map_default = MindMap2;

// ../simple-mind-map/src/plugins/MiniMap.js
var MiniMap = class {
  //  构造函数
  constructor(opt) {
    this.mindMap = opt.mindMap;
    this.isMousedown = false;
    this.mousedownPos = {
      x: 0,
      y: 0
    };
    this.startViewPos = {
      x: 0,
      y: 0
    };
  }
  //  计算小地图的渲染数据
  /**
   * boxWidth：小地图容器的宽度
   * boxHeight：小地图容器的高度
   */
  calculationMiniMap(boxWidth, boxHeight) {
    let { svg: svg2, rect, origWidth, origHeight, scaleX, scaleY } = this.mindMap.getSvgData({
      ignoreWatermark: true
    });
    const elRect = this.mindMap.elRect;
    rect.x -= elRect.left;
    rect.x2 -= elRect.left;
    rect.y -= elRect.top;
    rect.y2 -= elRect.top;
    let boxRatio = boxWidth / boxHeight;
    let actWidth = 0;
    let actHeight = 0;
    if (boxRatio > rect.ratio) {
      actHeight = boxHeight;
      actWidth = rect.ratio * actHeight;
    } else {
      actWidth = boxWidth;
      actHeight = actWidth / rect.ratio;
    }
    let miniMapBoxScale = actWidth / rect.width;
    let miniMapBoxLeft = (boxWidth - actWidth) / 2;
    let miniMapBoxTop = (boxHeight - actHeight) / 2;
    let _rectX = rect.x - (rect.width * scaleX - rect.width) / 2;
    let _rectX2 = rect.x2 + (rect.width * scaleX - rect.width) / 2;
    let _rectY = rect.y - (rect.height * scaleY - rect.height) / 2;
    let _rectY2 = rect.y2 + (rect.height * scaleY - rect.height) / 2;
    let _rectWidth = rect.width * scaleX;
    let _rectHeight = rect.height * scaleY;
    let viewBoxStyle = {
      left: 0,
      top: 0,
      right: 0,
      bottom: 0
    };
    viewBoxStyle.left = Math.max(0, -_rectX / _rectWidth * actWidth) + miniMapBoxLeft;
    viewBoxStyle.right = Math.max(0, (_rectX2 - origWidth) / _rectWidth * actWidth) + miniMapBoxLeft;
    viewBoxStyle.top = Math.max(0, -_rectY / _rectHeight * actHeight) + miniMapBoxTop;
    viewBoxStyle.bottom = Math.max(0, (_rectY2 - origHeight) / _rectHeight * actHeight) + miniMapBoxTop;
    if (viewBoxStyle.top > miniMapBoxTop + actHeight) {
      viewBoxStyle.top = miniMapBoxTop + actHeight;
    }
    if (viewBoxStyle.left > miniMapBoxLeft + actWidth) {
      viewBoxStyle.left = miniMapBoxLeft + actWidth;
    }
    Object.keys(viewBoxStyle).forEach((key) => {
      viewBoxStyle[key] = viewBoxStyle[key] + "px";
    });
    this.removeNodeContent(svg2);
    const svgStr = svg2.svg();
    return {
      getImgUrl: async (callback) => {
        const blob = new Blob([svgStr], {
          type: "image/svg+xml"
        });
        const res = await readBlob(blob);
        callback(res);
      },
      svgHTML: svgStr,
      // 小地图html
      viewBoxStyle,
      // 视图框的位置信息
      miniMapBoxScale,
      // 视图框的缩放值
      miniMapBoxLeft,
      // 视图框的left值
      miniMapBoxTop
      // 视图框的top值
    };
  }
  // 移除节点的内容
  removeNodeContent(svg2) {
    if (svg2.hasClass("smm-node")) {
      let shape = svg2.findOne(".smm-node-shape");
      let fill = shape.attr("fill");
      if (isWhite(fill) || isTransparent(fill)) {
        shape.attr("fill", getVisibleColorFromTheme(this.mindMap.themeConfig));
      }
      svg2.clear();
      svg2.add(shape);
      return;
    }
    let children = svg2.children();
    if (children && children.length > 0) {
      children.forEach((node3) => {
        this.removeNodeContent(node3);
      });
    }
  }
  //  小地图鼠标按下事件
  onMousedown(e2) {
    this.isMousedown = true;
    this.mousedownPos = {
      x: e2.clientX,
      y: e2.clientY
    };
    let transformData = this.mindMap.view.getTransformData();
    this.startViewPos = {
      x: transformData.state.x,
      y: transformData.state.y
    };
  }
  //  小地图鼠标移动事件
  onMousemove(e2, sensitivityNum = 5) {
    if (!this.isMousedown) {
      return;
    }
    let ox = e2.clientX - this.mousedownPos.x;
    let oy = e2.clientY - this.mousedownPos.y;
    this.mindMap.view.translateXTo(ox * sensitivityNum + this.startViewPos.x);
    this.mindMap.view.translateYTo(oy * sensitivityNum + this.startViewPos.y);
  }
  //  小地图鼠标松开事件
  onMouseup() {
    this.isMousedown = false;
  }
};
MiniMap.instanceName = "miniMap";
var MiniMap_default = MiniMap;

// ../simple-mind-map/src/plugins/Watermark.js
var import_deepmerge34 = __toESM(require_cjs());
var Watermark = class {
  constructor(opt = {}) {
    this.mindMap = opt.mindMap;
    this.lineSpacing = 0;
    this.textSpacing = 0;
    this.angle = 0;
    this.text = "";
    this.textStyle = {};
    this.watermarkDraw = null;
    this.isInExport = false;
    this.maxLong = this.getMaxLong();
    this.updateWatermark(this.mindMap.opt.watermarkConfig || {});
    this.bindEvent();
  }
  getMaxLong() {
    return Math.sqrt(
      Math.pow(this.mindMap.width, 2) + Math.pow(this.mindMap.height, 2)
    );
  }
  bindEvent() {
    this.onResize = this.onResize.bind(this);
    this.mindMap.on("resize", this.onResize);
  }
  unBindEvent() {
    this.mindMap.off("resize", this.onResize);
  }
  onResize() {
    this.maxLong = this.getMaxLong();
    this.draw();
  }
  // 创建水印容器
  createContainer() {
    if (this.watermarkDraw)
      return;
    this.watermarkDraw = this.mindMap.svg.group().css({ "pointer-events": "none", "user-select": "none" }).addClass("smm-water-mark-container");
  }
  // 删除水印容器
  removeContainer() {
    if (!this.watermarkDraw) {
      return;
    }
    this.watermarkDraw.remove();
    this.watermarkDraw = null;
  }
  // 获取是否存在水印
  hasWatermark() {
    return !!this.text.trim();
  }
  // 处理水印配置
  handleConfig({ text: text4, lineSpacing, textSpacing, angle, textStyle }) {
    this.text = text4 === void 0 ? "" : String(text4).trim();
    this.lineSpacing = typeof lineSpacing === "number" && lineSpacing > 0 ? lineSpacing : 100;
    this.textSpacing = typeof textSpacing === "number" && textSpacing > 0 ? textSpacing : 100;
    this.angle = typeof angle === "number" && angle >= 0 && angle <= 90 ? angle : 30;
    this.textStyle = Object.assign(this.textStyle, textStyle || {});
  }
  // 清除水印
  clear() {
    if (this.watermarkDraw)
      this.watermarkDraw.clear();
  }
  // 绘制水印
  // 非精确绘制，会绘制一些超出可视区域的水印
  draw() {
    this.clear();
    const { onlyExport } = this.mindMap.opt.watermarkConfig;
    if (onlyExport && !this.isInExport)
      return;
    if (!this.hasWatermark()) {
      this.removeContainer();
      return;
    }
    this.createContainer();
    let x2 = 0;
    while (x2 < this.mindMap.width) {
      this.drawText(x2);
      x2 += this.lineSpacing / Math.sin(degToRad(this.angle));
    }
    let yOffset = this.lineSpacing / Math.cos(degToRad(this.angle)) || this.lineSpacing;
    let y3 = yOffset;
    while (y3 < this.mindMap.height) {
      this.drawText(0, y3);
      y3 += yOffset;
    }
  }
  // 绘制文字
  drawText(x2, y3) {
    let long = Math.min(
      this.maxLong,
      (this.mindMap.width - x2) / Math.cos(degToRad(this.angle))
    );
    let g = new G();
    let bbox2 = null;
    let bboxWidth = 0;
    let textHeight = -1;
    while (bboxWidth < long) {
      let text4 = new Text2().text(this.text);
      g.add(text4);
      text4.transform({
        translateX: bboxWidth
      });
      this.setTextStyle(text4);
      bbox2 = g.bbox();
      if (textHeight === -1) {
        textHeight = bbox2.height;
      }
      bboxWidth = bbox2.width + this.textSpacing;
    }
    let params = {
      rotate: this.angle,
      origin: "top left",
      translateX: x2,
      translateY: textHeight
    };
    if (y3 !== void 0) {
      params.translateY = y3 + textHeight;
    }
    g.transform(params);
    this.watermarkDraw.add(g);
  }
  // 给文字设置样式
  setTextStyle(text4) {
    Object.keys(this.textStyle).forEach((item) => {
      let value = this.textStyle[item];
      if (item === "color") {
        text4.fill(value);
      } else {
        text4.css(camelCaseToHyphen(item), value);
      }
    });
  }
  // 更新水印
  updateWatermark(config) {
    this.mindMap.opt.watermarkConfig = (0, import_deepmerge34.default)(
      this.mindMap.opt.watermarkConfig,
      config
    );
    this.handleConfig(config);
    this.draw();
  }
  // 插件被移除前做的事情
  beforePluginRemove() {
    this.unBindEvent();
  }
  // 插件被卸载前做的事情
  beforePluginDestroy() {
    this.unBindEvent();
  }
};
Watermark.instanceName = "watermark";
var Watermark_default = Watermark;

// ../simple-mind-map/src/plugins/KeyboardNavigation.js
var KeyboardNavigation = class {
  //  构造函数
  constructor(opt) {
    this.opt = opt;
    this.mindMap = opt.mindMap;
    this.addShortcut();
  }
  addShortcut() {
    this.onLeftKeyUp = this.onLeftKeyUp.bind(this);
    this.onUpKeyUp = this.onUpKeyUp.bind(this);
    this.onRightKeyUp = this.onRightKeyUp.bind(this);
    this.onDownKeyUp = this.onDownKeyUp.bind(this);
    this.mindMap.keyCommand.addShortcut(
      CONSTANTS.KEY_DIR.LEFT,
      this.onLeftKeyUp
    );
    this.mindMap.keyCommand.addShortcut(CONSTANTS.KEY_DIR.UP, this.onUpKeyUp);
    this.mindMap.keyCommand.addShortcut(
      CONSTANTS.KEY_DIR.RIGHT,
      this.onRightKeyUp
    );
    this.mindMap.keyCommand.addShortcut(
      CONSTANTS.KEY_DIR.DOWN,
      this.onDownKeyUp
    );
  }
  removeShortcut() {
    this.mindMap.keyCommand.removeShortcut(
      CONSTANTS.KEY_DIR.LEFT,
      this.onLeftKeyUp
    );
    this.mindMap.keyCommand.removeShortcut(CONSTANTS.KEY_DIR.UP, this.onUpKeyUp);
    this.mindMap.keyCommand.removeShortcut(
      CONSTANTS.KEY_DIR.RIGHT,
      this.onRightKeyUp
    );
    this.mindMap.keyCommand.removeShortcut(
      CONSTANTS.KEY_DIR.DOWN,
      this.onDownKeyUp
    );
  }
  onLeftKeyUp() {
    this.onKeyup(CONSTANTS.KEY_DIR.LEFT);
  }
  onUpKeyUp() {
    this.onKeyup(CONSTANTS.KEY_DIR.UP);
  }
  onRightKeyUp() {
    this.onKeyup(CONSTANTS.KEY_DIR.RIGHT);
  }
  onDownKeyUp() {
    this.onKeyup(CONSTANTS.KEY_DIR.DOWN);
  }
  //  处理按键事件
  onKeyup(dir) {
    if (this.mindMap.renderer.activeNodeList.length > 0) {
      this.focus(dir);
    } else {
      let root2 = this.mindMap.renderer.root;
      this.mindMap.execCommand("GO_TARGET_NODE", root2);
    }
  }
  //  聚焦到下一个节点
  focus(dir) {
    let currentActiveNode = this.mindMap.renderer.activeNodeList[0];
    let currentActiveNodeRect = this.getNodeRect(currentActiveNode);
    let targetNode = null;
    let targetDis = Infinity;
    let checkNodeDis = (rect, node3) => {
      let dis = this.getDistance(currentActiveNodeRect, rect);
      if (dis < targetDis) {
        targetNode = node3;
        targetDis = dis;
      }
    };
    this.getFocusNodeByShadowAlgorithm({
      currentActiveNode,
      currentActiveNodeRect,
      dir,
      checkNodeDis
    });
    if (!targetNode) {
      this.getFocusNodeByAreaAlgorithm({
        currentActiveNode,
        currentActiveNodeRect,
        dir,
        checkNodeDis
      });
    }
    if (!targetNode) {
      this.getFocusNodeBySimpleAlgorithm({
        currentActiveNode,
        currentActiveNodeRect,
        dir,
        checkNodeDis
      });
    }
    if (targetNode) {
      this.mindMap.execCommand("GO_TARGET_NODE", targetNode);
    }
  }
  //  1.简单算法
  getFocusNodeBySimpleAlgorithm({
    currentActiveNode,
    currentActiveNodeRect,
    dir,
    checkNodeDis
  }) {
    bfsWalk(this.mindMap.renderer.root, (node3) => {
      if (node3.uid === currentActiveNode.uid)
        return;
      let rect = this.getNodeRect(node3);
      let { left, top, right, bottom } = rect;
      let match = false;
      if (dir === CONSTANTS.KEY_DIR.LEFT) {
        match = right <= currentActiveNodeRect.left;
      } else if (dir === CONSTANTS.KEY_DIR.RIGHT) {
        match = left >= currentActiveNodeRect.right;
      } else if (dir === CONSTANTS.KEY_DIR.UP) {
        match = bottom <= currentActiveNodeRect.top;
      } else if (dir === CONSTANTS.KEY_DIR.DOWN) {
        match = top >= currentActiveNodeRect.bottom;
      }
      if (match) {
        checkNodeDis(rect, node3);
      }
    });
  }
  //  2.阴影算法
  getFocusNodeByShadowAlgorithm({
    currentActiveNode,
    currentActiveNodeRect,
    dir,
    checkNodeDis
  }) {
    bfsWalk(this.mindMap.renderer.root, (node3) => {
      if (node3.uid === currentActiveNode.uid)
        return;
      let rect = this.getNodeRect(node3);
      let { left, top, right, bottom } = rect;
      let match = false;
      if (dir === CONSTANTS.KEY_DIR.LEFT) {
        match = left < currentActiveNodeRect.left && top < currentActiveNodeRect.bottom && bottom > currentActiveNodeRect.top;
      } else if (dir === CONSTANTS.KEY_DIR.RIGHT) {
        match = right > currentActiveNodeRect.right && top < currentActiveNodeRect.bottom && bottom > currentActiveNodeRect.top;
      } else if (dir === CONSTANTS.KEY_DIR.UP) {
        match = top < currentActiveNodeRect.top && left < currentActiveNodeRect.right && right > currentActiveNodeRect.left;
      } else if (dir === CONSTANTS.KEY_DIR.DOWN) {
        match = bottom > currentActiveNodeRect.bottom && left < currentActiveNodeRect.right && right > currentActiveNodeRect.left;
      }
      if (match) {
        checkNodeDis(rect, node3);
      }
    });
  }
  //  3.区域算法
  getFocusNodeByAreaAlgorithm({
    currentActiveNode,
    currentActiveNodeRect,
    dir,
    checkNodeDis
  }) {
    let cX = (currentActiveNodeRect.right + currentActiveNodeRect.left) / 2;
    let cY = (currentActiveNodeRect.bottom + currentActiveNodeRect.top) / 2;
    bfsWalk(this.mindMap.renderer.root, (node3) => {
      if (node3.uid === currentActiveNode.uid)
        return;
      let rect = this.getNodeRect(node3);
      let { left, top, right, bottom } = rect;
      let ccX = (right + left) / 2;
      let ccY = (bottom + top) / 2;
      let offsetX = ccX - cX;
      let offsetY = ccY - cY;
      if (offsetX === 0 && offsetY === 0)
        return;
      let match = false;
      if (dir === CONSTANTS.KEY_DIR.LEFT) {
        match = offsetX <= 0 && offsetX <= offsetY && offsetX <= -offsetY;
      } else if (dir === CONSTANTS.KEY_DIR.RIGHT) {
        match = offsetX > 0 && offsetX >= -offsetY && offsetX >= offsetY;
      } else if (dir === CONSTANTS.KEY_DIR.UP) {
        match = offsetY <= 0 && offsetY < offsetX && offsetY < -offsetX;
      } else if (dir === CONSTANTS.KEY_DIR.DOWN) {
        match = offsetY > 0 && -offsetY < offsetX && offsetY > offsetX;
      }
      if (match) {
        checkNodeDis(rect, node3);
      }
    });
  }
  //  获取节点的位置信息
  getNodeRect(node3) {
    let { scaleX, scaleY, translateX, translateY } = this.mindMap.draw.transform();
    let { left, top, width: width2, height: height2 } = node3;
    return {
      right: (left + width2) * scaleX + translateX,
      bottom: (top + height2) * scaleY + translateY,
      left: left * scaleX + translateX,
      top: top * scaleY + translateY
    };
  }
  //  获取两个节点的距离
  getDistance(node1Rect, node2Rect) {
    let center1 = this.getCenter(node1Rect);
    let center2 = this.getCenter(node2Rect);
    return Math.sqrt(
      Math.pow(center1.x - center2.x, 2) + Math.pow(center1.y - center2.y, 2)
    );
  }
  //  获取节点的中心点
  getCenter({ left, right, top, bottom }) {
    return {
      x: (left + right) / 2,
      y: (top + bottom) / 2
    };
  }
  // 插件被移除前做的事情
  beforePluginRemove() {
    this.removeShortcut();
  }
  // 插件被卸载前做的事情
  beforePluginDestroy() {
    this.removeShortcut();
  }
};
KeyboardNavigation.instanceName = "keyboardNavigation";
var KeyboardNavigation_default = KeyboardNavigation;

// ../simple-mind-map/src/parse/xmind.js
var import_jszip = __toESM(require_jszip_min());
var import_xml_js = __toESM(require_lib());

// ../simple-mind-map/src/utils/xmind.js
var getSummaryText = (node3, topicId) => {
  if (node3.children.summary && node3.children.summary.length > 0) {
    for (let i2 = 0; i2 < node3.children.summary.length; i2++) {
      const cur = node3.children.summary[i2];
      if (cur.id === topicId) {
        return cur.title;
      }
    }
  }
};
var getSummaryText2 = (item, topicId) => {
  const summaryElements = getElementsByType(item.elements, "summary");
  if (summaryElements && summaryElements && summaryElements.length > 0) {
    for (let i2 = 0; i2 < summaryElements.length; i2++) {
      const cur = summaryElements[i2];
      if (cur.attributes.id === topicId) {
        return cur.elements && cur.elements[0] && cur.elements[0].elements && cur.elements[0].elements[0] ? cur.elements[0].elements[0].text : "";
      }
    }
  }
  return "";
};
var getRoot = (list2) => {
  let root2 = null;
  const walk2 = (arr) => {
    if (!arr)
      return;
    for (let i2 = 0; i2 < arr.length; i2++) {
      if (!root2 && arr[i2].name === "topic") {
        root2 = arr[i2];
        return;
      }
    }
    arr.forEach((item) => {
      walk2(item.elements);
    });
  };
  walk2(list2);
  return root2;
};
var getItemByName = (arr, name) => {
  return arr.find((item) => {
    return item.name === name;
  });
};
var getElementsByType = (arr, type) => {
  return arr.find((el2) => {
    return el2.attributes.type === type;
  }).elements;
};
var addSummaryData = (selfList, childrenList, getText3, range) => {
  const summaryData = {
    expand: true,
    isActive: false,
    text: getText3(),
    range: null
  };
  const match = range.match(/\((\d+),(\d+)\)/);
  if (match) {
    const startIndex = Number(match[1]);
    const endIndex = Number(match[2]);
    if (startIndex === endIndex) {
      childrenList[startIndex] = summaryData;
    } else {
      summaryData.range = [startIndex, endIndex];
      selfList.push(summaryData);
    }
  } else {
    selfList.push(summaryData);
  }
};
var handleNodeImageFromXmind = async (node3, newNode, promiseList, files) => {
  if (node3.image && /\.(jpg|jpeg|png|gif|webp)$/.test(node3.image.src)) {
    let resolve = null;
    const promise = new Promise((_resolve) => {
      resolve = _resolve;
    });
    promiseList.push(promise);
    try {
      const imageType = /\.([^.]+)$/.exec(node3.image.src)[1];
      const imageBase64 = `data:image/${imageType};base64,` + await files["resources/" + node3.image.src.split("/")[1]].async(
        "base64"
      );
      newNode.data.image = imageBase64;
      if (!node3.image.width && !node3.image.height) {
        const imageSize = await getImageSize(imageBase64);
        newNode.data.imageSize = {
          width: imageSize.width,
          height: imageSize.height
        };
      } else {
        newNode.data.imageSize = {
          width: node3.image.width,
          height: node3.image.height
        };
      }
      resolve();
    } catch (error) {
      console.log(error);
      resolve();
    }
  }
};
var handleNodeImageToXmind = async (node3, newData, promiseList, imageList) => {
  if (node3.data.image) {
    let resolve = null;
    let promise = new Promise((_resolve) => {
      resolve = _resolve;
    });
    promiseList.push(promise);
    try {
      let imgName = "";
      let imgData = node3.data.image;
      if (!/^data:/.test(node3.data.image)) {
        imgData = await imgToDataUrl(node3.data.image);
      }
      let dataUrlRes = parseDataUrl(imgData);
      imgName = "image_" + imageList.length + "." + dataUrlRes.type;
      imageList.push({
        name: imgName,
        data: dataUrlRes.base64
      });
      newData.image = {
        src: "xap:resources/" + imgName,
        width: node3.data.imageSize.width,
        height: node3.data.imageSize.height
      };
      resolve();
    } catch (error) {
      console.log(error);
      resolve();
    }
  }
};
var getXmindContentXmlData = () => {
  return `<?xml version="1.0" encoding="UTF-8" standalone="no"?><xmap-content xmlns="urn:xmind:xmap:xmlns:content:2.0" xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:svg="http://www.w3.org/2000/svg" xmlns:xhtml="http://www.w3.org/1999/xhtml" xmlns:xlink="http://www.w3.org/1999/xlink" modified-by="bruce" timestamp="1503058545540" version="2.0">    <sheet id="7abtd0ssc7n4pi1nu6i7b6lsdh" modified-by="bruce" theme="0kdeemiijde6nuk97e4t0vpp54" timestamp="1503058545540">        <topic id="1vr0lcte2og4t2sopiogvdmifc" modified-by="bruce" structure-class="org.xmind.ui.logic.right" timestamp="1503058545417">            <title>Warning                \u8B66\u544A                Attention                Warnung                \uACBD\uACE0</title>            <children>                <topics type="attached">                    <topic id="71h1aip2t1o8vvm0a41nausaar" modified-by="bruce" timestamp="1503058545423">                        <title svg:width="500">This file can not be opened normally, please do not modify and save, otherwise the contents will be permanently lost\uFF01</title>                        <children>                            <topics type="attached">                                <topic id="428akmkh9a0tog6c91qj995qdl" modified-by="bruce" timestamp="1503058545427">                                    <title>You can try using XMind 8 Update 3 or later version to open</title>                                </topic>                            </topics>                        </children>                    </topic>                    <topic id="2kb87f8m38b3hnfhp450c7q35e" modified-by="bruce" timestamp="1503058545434">                        <title svg:width="500">\u8BE5\u6587\u4EF6\u65E0\u6CD5\u6B63\u5E38\u6253\u5F00\uFF0C\u8BF7\u52FF\u4FEE\u6539\u5E76\u4FDD\u5B58\uFF0C\u5426\u5219\u6587\u4EF6\u5185\u5BB9\u5C06\u4F1A\u6C38\u4E45\u6027\u4E22\u5931\uFF01</title>                        <children>                            <topics type="attached">                                <topic id="3m9hoo4a09n53ofl6fohdun99f" modified-by="bruce" timestamp="1503058545438">                                    <title>\u4F60\u53EF\u4EE5\u5C1D\u8BD5\u4F7F\u7528 XMind 8 Update 3 \u6216\u66F4\u65B0\u7248\u672C\u6253\u5F00</title>                                </topic>                            </topics>                        </children>                    </topic>                    <topic id="7r3r4617hvh931ot9obi595r8f" modified-by="bruce" timestamp="1503058545444">                        <title svg:width="500">\u8A72\u6587\u4EF6\u7121\u6CD5\u6B63\u5E38\u6253\u958B\uFF0C\u8ACB\u52FF\u4FEE\u6539\u4E26\u4FDD\u5B58\uFF0C\u5426\u5247\u6587\u4EF6\u5167\u5BB9\u5C07\u6703\u6C38\u4E45\u6027\u4E1F\u5931\uFF01</title>                        <children>                            <topics type="attached">                                <topic id="691pgka6gmgpgkacaa0h3f1hjb" modified-by="bruce" timestamp="1503058545448">                                    <title>\u4F60\u53EF\u4EE5\u5617\u8A66\u4F7F\u7528 XMind 8 Update 3 \u6216\u66F4\u65B0\u7248\u672C\u6253\u958B</title>                                </topic>                            </topics>                        </children>                    </topic>                    <topic id="0f2e3rpkfahg4spg4nda946r0b" modified-by="bruce" timestamp="1503058545453">                        <title svg:width="500">\u3053\u306E\u6587\u66F8\u306F\u6B63\u5E38\u306B\u958B\u304B\u306A\u3044\u306E\u3067\u3001\u4FEE\u6B63\u3057\u3066\u4FDD\u5B58\u3057\u306A\u3044\u3088\u3046\u306B\u3057\u3066\u304F\u3060\u3055\u3044\u3002\u305D\u3046\u3067\u306A\u3044\u3068\u3001\u66F8\u985E\u306E\u5185\u5BB9\u304C\u6C38\u4E45\u306B\u5931\u308F\u308C\u307E\u3059\u3002\uFF01</title>                        <children>                            <topics type="attached">                                <topic id="4vuubta53ksc1falk46mevge0t" modified-by="bruce" timestamp="1503058545457">                                    <title>XMind 8 Update 3 \u3084\u66F4\u65B0\u7248\u3092\u4F7F\u3063\u3066\u958B\u304F\u3053\u3068\u3082\u3067\u304D\u307E\u3059</title>                                </topic>                            </topics>                        </children>                    </topic>                    <topic id="70n9i4u3lb89sq9l1m1bs255j5" modified-by="bruce" timestamp="1503058545463">                        <title svg:width="500">Datei kann nicht richtig ge\xF6ffnet werden. Bitte \xE4ndern Sie diese Datei nicht und speichern Sie sie, sonst wird die Datei endg\xFCltig gel\xF6scht werden.</title>                        <children>                            <topics type="attached">                                <topic id="1qpc5ee298p2sqeqbinpca46b7" modified-by="bruce" timestamp="1503058545466">                                    <title svg:width="500">Bitte versuchen Sie, diese Datei mit XMind 8 Update 3 oder sp\xE4ter zu \xF6ffnen.</title>                                </topic>                            </topics>                        </children>                    </topic>                    <topic id="4dmes10uc19pq7enu8sc4bmvif" modified-by="bruce" timestamp="1503058545473">                        <title svg:width="500">Ce fichier ne peut pas ouvert normalement, veuillez le r\xE9diger et sauvegarder, sinon le fichier sera perdu en permanence. </title>                        <children>                            <topics type="attached">                                <topic id="5f0rivgubii2launodiln7sdkt" modified-by="bruce" timestamp="1503058545476">                                    <title svg:width="500">Vous pouvez essayer d'ouvrir avec XMind 8 Update 3 ou avec une version plus r\xE9cente.</title>                                </topic>                            </topics>                        </children>                    </topic>                    <topic id="10pn1os1sgfsnqa8akabom5pej" modified-by="bruce" timestamp="1503058545481">                        <title svg:width="500">\uD30C\uC77C\uC744 \uC815\uC0C1\uC801\uC73C\uB85C \uC5F4 \uC218 \uC5C6\uC73C\uBA70, \uC218\uC815 \uBC0F \uC800\uC7A5\uD558\uC9C0 \uB9C8\uC2ED\uC2DC\uC624. \uADF8\uB807\uC9C0 \uC54A\uC73C\uBA74 \uD30C\uC77C\uC758 \uB0B4\uC6A9\uC774 \uC601\uAD6C\uC801\uC73C\uB85C \uC190\uC2E4\uB429\uB2C8\uB2E4!</title>                        <children>                            <topics type="attached">                                <topic id="0l2nr0fq3em22rctapkj46ue58" modified-by="bruce" timestamp="1503058545484">                                    <title svg:width="500">XMind 8 Update 3 \uB610\uB294 \uC774\uD6C4 \uBC84\uC804\uC744 \uC0AC\uC6A9\uD558\uC5EC</title>                                </topic>                            </topics>                        </children>                    </topic>                </topics>            </children>            <extensions>                <extension provider="org.xmind.ui.map.unbalanced">                    <content>                        <right-number>-1</right-number>                    </content>                </extension>            </extensions>        </topic>        <title>Sheet 1</title>    </sheet></xmap-content>`;
};
var formatGetGeneralization2 = (data2) => {
  const generalization = data2.generalization;
  return Array.isArray(generalization) ? generalization : generalization ? [generalization] : [];
};
var getSelfGeneralization = (data2) => {
  const list2 = formatGetGeneralization2(data2);
  return list2.filter((item) => {
    return !item.range || item.range.length <= 0;
  });
};
var getRangeGeneralization = (data2) => {
  const list2 = formatGetGeneralization2(data2);
  return list2.filter((item) => {
    return item.range && item.range.length > 0;
  });
};
var parseNodeGeneralizationToXmind = (node3) => {
  const summary = [];
  const summaries = [];
  const collectSummary = (item, startIndex, endIndex) => {
    const summaryTopicId = createUid();
    const summaryTitle = getTextFromHtml(item.text);
    summary.push({
      id: summaryTopicId,
      title: summaryTitle,
      attributedTitle: [
        {
          text: summaryTitle
        }
      ]
    });
    summaries.push({
      id: createUid(),
      range: "(" + startIndex + "," + endIndex + ")",
      topicId: summaryTopicId
    });
  };
  const generalizationList = getRangeGeneralization(node3.data);
  generalizationList.forEach((item) => {
    collectSummary(item, item.range[0], item.range[1]);
  });
  (node3.children || []).forEach((child, childIndex) => {
    const list2 = getSelfGeneralization(child.data);
    list2.forEach((item) => {
      collectSummary(item, childIndex, childIndex);
    });
  });
  return {
    summary,
    summaries
  };
};

// ../simple-mind-map/src/parse/xmind.js
var parseXmindFile = (file) => {
  return new Promise((resolve, reject) => {
    import_jszip.default.loadAsync(file).then(
      async (zip) => {
        try {
          let content3 = "";
          let jsonFile = zip.files["content.json"];
          let xmlFile = zip.files["content.xml"] || zip.files["/content.xml"];
          if (jsonFile) {
            let json = await jsonFile.async("string");
            content3 = await transformXmind(json, zip.files);
          } else if (xmlFile) {
            let xml = await xmlFile.async("string");
            let json = import_xml_js.default.xml2json(xml);
            content3 = transformOldXmind(json);
          }
          if (content3) {
            resolve(content3);
          } else {
            reject(new Error("\u89E3\u6790\u5931\u8D25"));
          }
        } catch (error) {
          reject(error);
        }
      },
      (e2) => {
        reject(e2);
      }
    );
  });
};
var transformXmind = async (content3, files) => {
  const data2 = JSON.parse(content3)[0];
  const nodeTree = data2.rootTopic;
  const newTree = {};
  const waitLoadImageList = [];
  const walk2 = async (node3, newNode) => {
    newNode.data = {
      // 节点内容
      text: isUndef(node3.title) ? "" : node3.title
    };
    if (node3.notes) {
      const notesData = node3.notes.realHTML || node3.notes.plain;
      newNode.data.note = notesData ? notesData.content || "" : "";
    }
    if (node3.href && /^https?:\/\//.test(node3.href)) {
      newNode.data.hyperlink = node3.href;
    }
    if (node3.labels && node3.labels.length > 0) {
      newNode.data.tag = node3.labels;
    }
    handleNodeImageFromXmind(node3, newNode, waitLoadImageList, files);
    const selfSummary = [];
    const childrenSummary = [];
    if (newNode._summary) {
      selfSummary.push(newNode._summary);
    }
    if (Array.isArray(node3.summaries) && node3.summaries.length > 0) {
      node3.summaries.forEach((item) => {
        addSummaryData(
          selfSummary,
          childrenSummary,
          () => {
            return getSummaryText(node3, item.topicId);
          },
          item.range
        );
      });
    }
    newNode.data.generalization = selfSummary;
    newNode.children = [];
    if (node3.children && node3.children.attached && node3.children.attached.length > 0) {
      node3.children.attached.forEach((item, index3) => {
        const newChild = {};
        newNode.children.push(newChild);
        if (childrenSummary[index3]) {
          newChild._summary = childrenSummary[index3];
        }
        walk2(item, newChild);
      });
    }
  };
  walk2(nodeTree, newTree);
  await Promise.all(waitLoadImageList);
  return newTree;
};
var transformOldXmind = (content3) => {
  const data2 = JSON.parse(content3);
  const elements3 = data2.elements;
  const root2 = getRoot(elements3);
  const newTree = {};
  const walk2 = (node3, newNode) => {
    const nodeElements = node3.elements;
    let nodeTitle = getItemByName(nodeElements, "title");
    nodeTitle = nodeTitle && nodeTitle.elements && nodeTitle.elements[0].text;
    newNode.data = {
      text: isUndef(nodeTitle) ? "" : nodeTitle
    };
    try {
      const notesElement = getItemByName(nodeElements, "notes");
      if (notesElement) {
        newNode.data.note = notesElement.elements[0].elements[0].elements[0].text;
      }
    } catch (error) {
      console.log(error);
    }
    try {
      if (node3.attributes && node3.attributes["xlink:href"] && /^https?:\/\//.test(node3.attributes["xlink:href"])) {
        newNode.data.hyperlink = node3.attributes["xlink:href"];
      }
    } catch (error) {
      console.log(error);
    }
    try {
      const labelsElement = getItemByName(nodeElements, "labels");
      if (labelsElement) {
        newNode.data.tag = labelsElement.elements.map((item) => {
          return item.elements[0].text;
        });
      }
    } catch (error) {
      console.log(error);
    }
    const childrenItem = getItemByName(nodeElements, "children");
    const selfSummary = [];
    const childrenSummary = [];
    try {
      if (newNode._summary) {
        selfSummary.push(newNode._summary);
      }
      const summariesItem = getItemByName(nodeElements, "summaries");
      if (summariesItem && Array.isArray(summariesItem.elements) && summariesItem.elements.length > 0) {
        summariesItem.elements.forEach((item) => {
          addSummaryData(
            selfSummary,
            childrenSummary,
            () => {
              return getSummaryText2(childrenItem, item.attributes["topic-id"]);
            },
            item.attributes.range
          );
        });
      }
    } catch (error) {
      console.log(error);
    }
    newNode.data.generalization = selfSummary;
    newNode.children = [];
    if (childrenItem && childrenItem.elements && childrenItem.elements.length > 0) {
      const children = getElementsByType(childrenItem.elements, "attached");
      children.forEach((item, index3) => {
        const newChild = {};
        newNode.children.push(newChild);
        if (childrenSummary[index3]) {
          newChild._summary = childrenSummary[index3];
        }
        walk2(item, newChild);
      });
    }
  };
  walk2(root2, newTree);
  return newTree;
};
var transformToXmind = async (data2, name) => {
  const id = "simpleMindMap_" + Date.now();
  const imageList = [];
  let newTree = {};
  let waitLoadImageList = [];
  let walk2 = async (node3, newNode, isRoot) => {
    let newData = {
      id: node3.data.uid,
      structureClass: "org.xmind.ui.logic.right",
      title: getTextFromHtml(node3.data.text),
      // 节点文本
      children: {
        attached: []
      }
    };
    if (node3.data.note !== void 0) {
      newData.notes = {
        realHTML: {
          content: node3.data.note
        },
        plain: {
          content: node3.data.note
        }
      };
    }
    if (node3.data.hyperlink !== void 0) {
      newData.href = node3.data.hyperlink;
    }
    if (node3.data.tag !== void 0) {
      newData.labels = node3.data.tag || [];
    }
    handleNodeImageToXmind(node3, newNode, waitLoadImageList, imageList);
    if (isRoot) {
      newData.class = "topic";
      newNode.id = id;
      newNode.class = "sheet";
      newNode.title = name;
      newNode.extensions = [];
      newNode.topicPositioning = "fixed";
      newNode.topicOverlapping = "overlap";
      newNode.coreVersion = "2.100.0";
      newNode.rootTopic = newData;
    } else {
      Object.keys(newData).forEach((key) => {
        newNode[key] = newData[key];
      });
    }
    const { summary, summaries } = parseNodeGeneralizationToXmind(node3);
    if (isRoot) {
      if (summaries.length > 0) {
        newNode.rootTopic.children.summary = summary;
        newNode.rootTopic.summaries = summaries;
      }
    } else {
      if (summaries.length > 0) {
        newNode.children.summary = summary;
        newNode.summaries = summaries;
      }
    }
    if (node3.children && node3.children.length > 0) {
      node3.children.forEach((child) => {
        let newChild = {};
        walk2(child, newChild);
        newData.children.attached.push(newChild);
      });
    }
  };
  walk2(data2, newTree, true);
  await Promise.all(waitLoadImageList);
  const contentData = [newTree];
  const zip = new import_jszip.default();
  zip.file("content.json", JSON.stringify(contentData));
  zip.file(
    "metadata.json",
    `{"modifier":"","dataStructureVersion":"2","creator":{"name":"mind-map"},"layoutEngineVersion":"3","activeSheetId":"${id}"}`
  );
  zip.file("content.xml", getXmindContentXmlData());
  const manifestData = {
    "file-entries": {
      "content.json": {},
      "metadata.json": {},
      "Thumbnails/thumbnail.png": {}
    }
  };
  if (imageList.length > 0) {
    imageList.forEach((item) => {
      manifestData["file-entries"]["resources/" + item.name] = {};
      const img = zip.folder("resources");
      img.file(item.name, item.data, { base64: true });
    });
  }
  zip.file("manifest.json", JSON.stringify(manifestData));
  const zipData = await zip.generateAsync({ type: "blob" });
  return zipData;
};
var xmind_default = {
  parseXmindFile,
  transformXmind,
  transformOldXmind,
  transformToXmind
};

// ../simple-mind-map/src/plugins/ExportXMind.js
var ExportXMind = class {
  //  构造函数
  constructor(opt) {
    this.mindMap = opt.mindMap;
  }
  // 导出xmind
  async xmind(data2, name) {
    const zipData = await xmind_default.transformToXmind(data2, name);
    return zipData;
  }
  // 获取解析器
  getXmind() {
    return xmind_default;
  }
};
ExportXMind.instanceName = "doExportXMind";
var ExportXMind_default = ExportXMind;

// ../simple-mind-map/src/utils/jspdf.js
init_typeof();

// ../simple-mind-map/node_modules/fflate/esm/browser.js
var u8 = Uint8Array;
var u16 = Uint16Array;
var u32 = Uint32Array;
var fleb = new u8([
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  2,
  2,
  2,
  2,
  3,
  3,
  3,
  3,
  4,
  4,
  4,
  4,
  5,
  5,
  5,
  5,
  0,
  /* unused */
  0,
  0,
  /* impossible */
  0
]);
var fdeb = new u8([
  0,
  0,
  0,
  0,
  1,
  1,
  2,
  2,
  3,
  3,
  4,
  4,
  5,
  5,
  6,
  6,
  7,
  7,
  8,
  8,
  9,
  9,
  10,
  10,
  11,
  11,
  12,
  12,
  13,
  13,
  /* unused */
  0,
  0
]);
var clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
var freb = function(eb, start) {
  var b = new u16(31);
  for (var i2 = 0; i2 < 31; ++i2) {
    b[i2] = start += 1 << eb[i2 - 1];
  }
  var r2 = new u32(b[30]);
  for (var i2 = 1; i2 < 30; ++i2) {
    for (var j = b[i2]; j < b[i2 + 1]; ++j) {
      r2[j] = j - b[i2] << 5 | i2;
    }
  }
  return [b, r2];
};
var _a = freb(fleb, 2);
var fl = _a[0];
var revfl = _a[1];
fl[28] = 258, revfl[258] = 28;
var _b = freb(fdeb, 0);
var fd = _b[0];
var revfd = _b[1];
var rev = new u16(32768);
for (i2 = 0; i2 < 32768; ++i2) {
  x2 = (i2 & 43690) >>> 1 | (i2 & 21845) << 1;
  x2 = (x2 & 52428) >>> 2 | (x2 & 13107) << 2;
  x2 = (x2 & 61680) >>> 4 | (x2 & 3855) << 4;
  rev[i2] = ((x2 & 65280) >>> 8 | (x2 & 255) << 8) >>> 1;
}
var x2;
var i2;
var hMap = function(cd, mb, r2) {
  var s2 = cd.length;
  var i2 = 0;
  var l2 = new u16(mb);
  for (; i2 < s2; ++i2)
    ++l2[cd[i2] - 1];
  var le = new u16(mb);
  for (i2 = 0; i2 < mb; ++i2) {
    le[i2] = le[i2 - 1] + l2[i2 - 1] << 1;
  }
  var co;
  if (r2) {
    co = new u16(1 << mb);
    var rvb = 15 - mb;
    for (i2 = 0; i2 < s2; ++i2) {
      if (cd[i2]) {
        var sv = i2 << 4 | cd[i2];
        var r_1 = mb - cd[i2];
        var v2 = le[cd[i2] - 1]++ << r_1;
        for (var m3 = v2 | (1 << r_1) - 1; v2 <= m3; ++v2) {
          co[rev[v2] >>> rvb] = sv;
        }
      }
    }
  } else {
    co = new u16(s2);
    for (i2 = 0; i2 < s2; ++i2)
      co[i2] = rev[le[cd[i2] - 1]++] >>> 15 - cd[i2];
  }
  return co;
};
var flt = new u8(288);
for (i2 = 0; i2 < 144; ++i2)
  flt[i2] = 8;
var i2;
for (i2 = 144; i2 < 256; ++i2)
  flt[i2] = 9;
var i2;
for (i2 = 256; i2 < 280; ++i2)
  flt[i2] = 7;
var i2;
for (i2 = 280; i2 < 288; ++i2)
  flt[i2] = 8;
var i2;
var fdt = new u8(32);
for (i2 = 0; i2 < 32; ++i2)
  fdt[i2] = 5;
var i2;
var flm = /* @__PURE__ */ hMap(flt, 9, 0);
var flrm = /* @__PURE__ */ hMap(flt, 9, 1);
var fdm = /* @__PURE__ */ hMap(fdt, 5, 0);
var fdrm = /* @__PURE__ */ hMap(fdt, 5, 1);
var max = function(a2) {
  var m3 = a2[0];
  for (var i2 = 1; i2 < a2.length; ++i2) {
    if (a2[i2] > m3)
      m3 = a2[i2];
  }
  return m3;
};
var bits = function(d, p2, m3) {
  var o2 = p2 / 8 >> 0;
  return (d[o2] | d[o2 + 1] << 8) >>> (p2 & 7) & m3;
};
var bits16 = function(d, p2) {
  var o2 = p2 / 8 >> 0;
  return (d[o2] | d[o2 + 1] << 8 | d[o2 + 2] << 16) >>> (p2 & 7);
};
var shft = function(p2) {
  return (p2 / 8 >> 0) + (p2 & 7 && 1);
};
var slc = function(v2, s2, e2) {
  if (s2 == null || s2 < 0)
    s2 = 0;
  if (e2 == null || e2 > v2.length)
    e2 = v2.length;
  var n2 = new (v2 instanceof u16 ? u16 : v2 instanceof u32 ? u32 : u8)(e2 - s2);
  n2.set(v2.subarray(s2, e2));
  return n2;
};
var inflt = function(dat, buf, st) {
  var sl = dat.length;
  var noBuf = !buf || st;
  var noSt = !st || st.i;
  if (!st)
    st = {};
  if (!buf)
    buf = new u8(sl * 3);
  var cbuf = function(l3) {
    var bl = buf.length;
    if (l3 > bl) {
      var nbuf = new u8(Math.max(bl * 2, l3));
      nbuf.set(buf);
      buf = nbuf;
    }
  };
  var final = st.f || 0, pos = st.p || 0, bt = st.b || 0, lm = st.l, dm = st.d, lbt = st.m, dbt = st.n;
  var tbts = sl * 8;
  do {
    if (!lm) {
      st.f = final = bits(dat, pos, 1);
      var type = bits(dat, pos + 1, 3);
      pos += 3;
      if (!type) {
        var s2 = shft(pos) + 4, l2 = dat[s2 - 4] | dat[s2 - 3] << 8, t2 = s2 + l2;
        if (t2 > sl) {
          if (noSt)
            throw "unexpected EOF";
          break;
        }
        if (noBuf)
          cbuf(bt + l2);
        buf.set(dat.subarray(s2, t2), bt);
        st.b = bt += l2, st.p = pos = t2 * 8;
        continue;
      } else if (type == 1)
        lm = flrm, dm = fdrm, lbt = 9, dbt = 5;
      else if (type == 2) {
        var hLit = bits(dat, pos, 31) + 257, hcLen = bits(dat, pos + 10, 15) + 4;
        var tl = hLit + bits(dat, pos + 5, 31) + 1;
        pos += 14;
        var ldt = new u8(tl);
        var clt = new u8(19);
        for (var i2 = 0; i2 < hcLen; ++i2) {
          clt[clim[i2]] = bits(dat, pos + i2 * 3, 7);
        }
        pos += hcLen * 3;
        var clb = max(clt), clbmsk = (1 << clb) - 1;
        if (!noSt && pos + tl * (clb + 7) > tbts)
          break;
        var clm = hMap(clt, clb, 1);
        for (var i2 = 0; i2 < tl; ) {
          var r2 = clm[bits(dat, pos, clbmsk)];
          pos += r2 & 15;
          var s2 = r2 >>> 4;
          if (s2 < 16) {
            ldt[i2++] = s2;
          } else {
            var c3 = 0, n2 = 0;
            if (s2 == 16)
              n2 = 3 + bits(dat, pos, 3), pos += 2, c3 = ldt[i2 - 1];
            else if (s2 == 17)
              n2 = 3 + bits(dat, pos, 7), pos += 3;
            else if (s2 == 18)
              n2 = 11 + bits(dat, pos, 127), pos += 7;
            while (n2--)
              ldt[i2++] = c3;
          }
        }
        var lt = ldt.subarray(0, hLit), dt = ldt.subarray(hLit);
        lbt = max(lt);
        dbt = max(dt);
        lm = hMap(lt, lbt, 1);
        dm = hMap(dt, dbt, 1);
      } else
        throw "invalid block type";
      if (pos > tbts)
        throw "unexpected EOF";
    }
    if (noBuf)
      cbuf(bt + 131072);
    var lms = (1 << lbt) - 1, dms = (1 << dbt) - 1;
    var mxa = lbt + dbt + 18;
    while (noSt || pos + mxa < tbts) {
      var c3 = lm[bits16(dat, pos) & lms], sym = c3 >>> 4;
      pos += c3 & 15;
      if (pos > tbts)
        throw "unexpected EOF";
      if (!c3)
        throw "invalid length/literal";
      if (sym < 256)
        buf[bt++] = sym;
      else if (sym == 256) {
        lm = null;
        break;
      } else {
        var add = sym - 254;
        if (sym > 264) {
          var i2 = sym - 257, b = fleb[i2];
          add = bits(dat, pos, (1 << b) - 1) + fl[i2];
          pos += b;
        }
        var d = dm[bits16(dat, pos) & dms], dsym = d >>> 4;
        if (!d)
          throw "invalid distance";
        pos += d & 15;
        var dt = fd[dsym];
        if (dsym > 3) {
          var b = fdeb[dsym];
          dt += bits16(dat, pos) & (1 << b) - 1, pos += b;
        }
        if (pos > tbts)
          throw "unexpected EOF";
        if (noBuf)
          cbuf(bt + 131072);
        var end = bt + add;
        for (; bt < end; bt += 4) {
          buf[bt] = buf[bt - dt];
          buf[bt + 1] = buf[bt + 1 - dt];
          buf[bt + 2] = buf[bt + 2 - dt];
          buf[bt + 3] = buf[bt + 3 - dt];
        }
        bt = end;
      }
    }
    st.l = lm, st.p = pos, st.b = bt;
    if (lm)
      final = 1, st.m = lbt, st.d = dm, st.n = dbt;
  } while (!final);
  return bt == buf.length ? buf : slc(buf, 0, bt);
};
var wbits = function(d, p2, v2) {
  v2 <<= p2 & 7;
  var o2 = p2 / 8 >> 0;
  d[o2] |= v2;
  d[o2 + 1] |= v2 >>> 8;
};
var wbits16 = function(d, p2, v2) {
  v2 <<= p2 & 7;
  var o2 = p2 / 8 >> 0;
  d[o2] |= v2;
  d[o2 + 1] |= v2 >>> 8;
  d[o2 + 2] |= v2 >>> 16;
};
var hTree = function(d, mb) {
  var t2 = [];
  for (var i2 = 0; i2 < d.length; ++i2) {
    if (d[i2])
      t2.push({ s: i2, f: d[i2] });
  }
  var s2 = t2.length;
  var t22 = t2.slice();
  if (!s2)
    return [new u8(0), 0];
  if (s2 == 1) {
    var v2 = new u8(t2[0].s + 1);
    v2[t2[0].s] = 1;
    return [v2, 1];
  }
  t2.sort(function(a2, b) {
    return a2.f - b.f;
  });
  t2.push({ s: -1, f: 25001 });
  var l2 = t2[0], r2 = t2[1], i0 = 0, i1 = 1, i22 = 2;
  t2[0] = { s: -1, f: l2.f + r2.f, l: l2, r: r2 };
  while (i1 != s2 - 1) {
    l2 = t2[t2[i0].f < t2[i22].f ? i0++ : i22++];
    r2 = t2[i0 != i1 && t2[i0].f < t2[i22].f ? i0++ : i22++];
    t2[i1++] = { s: -1, f: l2.f + r2.f, l: l2, r: r2 };
  }
  var maxSym = t22[0].s;
  for (var i2 = 1; i2 < s2; ++i2) {
    if (t22[i2].s > maxSym)
      maxSym = t22[i2].s;
  }
  var tr = new u16(maxSym + 1);
  var mbt = ln(t2[i1 - 1], tr, 0);
  if (mbt > mb) {
    var i2 = 0, dt = 0;
    var lft = mbt - mb, cst = 1 << lft;
    t22.sort(function(a2, b) {
      return tr[b.s] - tr[a2.s] || a2.f - b.f;
    });
    for (; i2 < s2; ++i2) {
      var i2_1 = t22[i2].s;
      if (tr[i2_1] > mb) {
        dt += cst - (1 << mbt - tr[i2_1]);
        tr[i2_1] = mb;
      } else
        break;
    }
    dt >>>= lft;
    while (dt > 0) {
      var i2_2 = t22[i2].s;
      if (tr[i2_2] < mb)
        dt -= 1 << mb - tr[i2_2]++ - 1;
      else
        ++i2;
    }
    for (; i2 >= 0 && dt; --i2) {
      var i2_3 = t22[i2].s;
      if (tr[i2_3] == mb) {
        --tr[i2_3];
        ++dt;
      }
    }
    mbt = mb;
  }
  return [new u8(tr), mbt];
};
var ln = function(n2, l2, d) {
  return n2.s == -1 ? Math.max(ln(n2.l, l2, d + 1), ln(n2.r, l2, d + 1)) : l2[n2.s] = d;
};
var lc = function(c3) {
  var s2 = c3.length;
  while (s2 && !c3[--s2])
    ;
  var cl = new u16(++s2);
  var cli = 0, cln = c3[0], cls = 1;
  var w = function(v2) {
    cl[cli++] = v2;
  };
  for (var i2 = 1; i2 <= s2; ++i2) {
    if (c3[i2] == cln && i2 != s2)
      ++cls;
    else {
      if (!cln && cls > 2) {
        for (; cls > 138; cls -= 138)
          w(32754);
        if (cls > 2) {
          w(cls > 10 ? cls - 11 << 5 | 28690 : cls - 3 << 5 | 12305);
          cls = 0;
        }
      } else if (cls > 3) {
        w(cln), --cls;
        for (; cls > 6; cls -= 6)
          w(8304);
        if (cls > 2)
          w(cls - 3 << 5 | 8208), cls = 0;
      }
      while (cls--)
        w(cln);
      cls = 1;
      cln = c3[i2];
    }
  }
  return [cl.subarray(0, cli), s2];
};
var clen = function(cf, cl) {
  var l2 = 0;
  for (var i2 = 0; i2 < cl.length; ++i2)
    l2 += cf[i2] * cl[i2];
  return l2;
};
var wfblk = function(out, pos, dat) {
  var s2 = dat.length;
  var o2 = shft(pos + 2);
  out[o2] = s2 & 255;
  out[o2 + 1] = s2 >>> 8;
  out[o2 + 2] = out[o2] ^ 255;
  out[o2 + 3] = out[o2 + 1] ^ 255;
  for (var i2 = 0; i2 < s2; ++i2)
    out[o2 + i2 + 4] = dat[i2];
  return (o2 + 4 + s2) * 8;
};
var wblk = function(dat, out, final, syms, lf, df, eb, li, bs, bl, p2) {
  wbits(out, p2++, final);
  ++lf[256];
  var _a2 = hTree(lf, 15), dlt = _a2[0], mlb = _a2[1];
  var _b2 = hTree(df, 15), ddt = _b2[0], mdb = _b2[1];
  var _c = lc(dlt), lclt = _c[0], nlc = _c[1];
  var _d = lc(ddt), lcdt = _d[0], ndc = _d[1];
  var lcfreq = new u16(19);
  for (var i2 = 0; i2 < lclt.length; ++i2)
    lcfreq[lclt[i2] & 31]++;
  for (var i2 = 0; i2 < lcdt.length; ++i2)
    lcfreq[lcdt[i2] & 31]++;
  var _e = hTree(lcfreq, 7), lct = _e[0], mlcb = _e[1];
  var nlcc = 19;
  for (; nlcc > 4 && !lct[clim[nlcc - 1]]; --nlcc)
    ;
  var flen = bl + 5 << 3;
  var ftlen = clen(lf, flt) + clen(df, fdt) + eb;
  var dtlen = clen(lf, dlt) + clen(df, ddt) + eb + 14 + 3 * nlcc + clen(lcfreq, lct) + (2 * lcfreq[16] + 3 * lcfreq[17] + 7 * lcfreq[18]);
  if (flen <= ftlen && flen <= dtlen)
    return wfblk(out, p2, dat.subarray(bs, bs + bl));
  var lm, ll, dm, dl;
  wbits(out, p2, 1 + (dtlen < ftlen)), p2 += 2;
  if (dtlen < ftlen) {
    lm = hMap(dlt, mlb, 0), ll = dlt, dm = hMap(ddt, mdb, 0), dl = ddt;
    var llm = hMap(lct, mlcb, 0);
    wbits(out, p2, nlc - 257);
    wbits(out, p2 + 5, ndc - 1);
    wbits(out, p2 + 10, nlcc - 4);
    p2 += 14;
    for (var i2 = 0; i2 < nlcc; ++i2)
      wbits(out, p2 + 3 * i2, lct[clim[i2]]);
    p2 += 3 * nlcc;
    var lcts = [lclt, lcdt];
    for (var it = 0; it < 2; ++it) {
      var clct = lcts[it];
      for (var i2 = 0; i2 < clct.length; ++i2) {
        var len = clct[i2] & 31;
        wbits(out, p2, llm[len]), p2 += lct[len];
        if (len > 15)
          wbits(out, p2, clct[i2] >>> 5 & 127), p2 += clct[i2] >>> 12;
      }
    }
  } else {
    lm = flm, ll = flt, dm = fdm, dl = fdt;
  }
  for (var i2 = 0; i2 < li; ++i2) {
    if (syms[i2] > 255) {
      var len = syms[i2] >>> 18 & 31;
      wbits16(out, p2, lm[len + 257]), p2 += ll[len + 257];
      if (len > 7)
        wbits(out, p2, syms[i2] >>> 23 & 31), p2 += fleb[len];
      var dst = syms[i2] & 31;
      wbits16(out, p2, dm[dst]), p2 += dl[dst];
      if (dst > 3)
        wbits16(out, p2, syms[i2] >>> 5 & 8191), p2 += fdeb[dst];
    } else {
      wbits16(out, p2, lm[syms[i2]]), p2 += ll[syms[i2]];
    }
  }
  wbits16(out, p2, lm[256]);
  return p2 + ll[256];
};
var deo = /* @__PURE__ */ new u32([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]);
var et = /* @__PURE__ */ new u8(0);
var dflt = function(dat, lvl, plvl, pre, post, lst) {
  var s2 = dat.length;
  var o2 = new u8(pre + s2 + 5 * (1 + Math.floor(s2 / 7e3)) + post);
  var w = o2.subarray(pre, o2.length - post);
  var pos = 0;
  if (!lvl || s2 < 8) {
    for (var i2 = 0; i2 <= s2; i2 += 65535) {
      var e2 = i2 + 65535;
      if (e2 < s2) {
        pos = wfblk(w, pos, dat.subarray(i2, e2));
      } else {
        w[i2] = lst;
        pos = wfblk(w, pos, dat.subarray(i2, s2));
      }
    }
  } else {
    var opt = deo[lvl - 1];
    var n2 = opt >>> 13, c3 = opt & 8191;
    var msk_1 = (1 << plvl) - 1;
    var prev2 = new u16(32768), head = new u16(msk_1 + 1);
    var bs1_1 = Math.ceil(plvl / 3), bs2_1 = 2 * bs1_1;
    var hsh = function(i3) {
      return (dat[i3] ^ dat[i3 + 1] << bs1_1 ^ dat[i3 + 2] << bs2_1) & msk_1;
    };
    var syms = new u32(25e3);
    var lf = new u16(288), df = new u16(32);
    var lc_1 = 0, eb = 0, i2 = 0, li = 0, wi = 0, bs = 0;
    for (; i2 < s2; ++i2) {
      var hv = hsh(i2);
      var imod = i2 & 32767;
      var pimod = head[hv];
      prev2[imod] = pimod;
      head[hv] = imod;
      if (wi <= i2) {
        var rem = s2 - i2;
        if ((lc_1 > 7e3 || li > 24576) && rem > 423) {
          pos = wblk(dat, w, 0, syms, lf, df, eb, li, bs, i2 - bs, pos);
          li = lc_1 = eb = 0, bs = i2;
          for (var j = 0; j < 286; ++j)
            lf[j] = 0;
          for (var j = 0; j < 30; ++j)
            df[j] = 0;
        }
        var l2 = 2, d = 0, ch_1 = c3, dif = imod - pimod & 32767;
        if (rem > 2 && hv == hsh(i2 - dif)) {
          var maxn = Math.min(n2, rem) - 1;
          var maxd = Math.min(32767, i2);
          var ml = Math.min(258, rem);
          while (dif <= maxd && --ch_1 && imod != pimod) {
            if (dat[i2 + l2] == dat[i2 + l2 - dif]) {
              var nl = 0;
              for (; nl < ml && dat[i2 + nl] == dat[i2 + nl - dif]; ++nl)
                ;
              if (nl > l2) {
                l2 = nl, d = dif;
                if (nl > maxn)
                  break;
                var mmd = Math.min(dif, nl - 2);
                var md = 0;
                for (var j = 0; j < mmd; ++j) {
                  var ti = i2 - dif + j + 32768 & 32767;
                  var pti = prev2[ti];
                  var cd = ti - pti + 32768 & 32767;
                  if (cd > md)
                    md = cd, pimod = ti;
                }
              }
            }
            imod = pimod, pimod = prev2[imod];
            dif += imod - pimod + 32768 & 32767;
          }
        }
        if (d) {
          syms[li++] = 268435456 | revfl[l2] << 18 | revfd[d];
          var lin = revfl[l2] & 31, din = revfd[d] & 31;
          eb += fleb[lin] + fdeb[din];
          ++lf[257 + lin];
          ++df[din];
          wi = i2 + l2;
          ++lc_1;
        } else {
          syms[li++] = dat[i2];
          ++lf[dat[i2]];
        }
      }
    }
    pos = wblk(dat, w, lst, syms, lf, df, eb, li, bs, i2 - bs, pos);
    if (!lst)
      pos = wfblk(w, pos, et);
  }
  return slc(o2, 0, pre + shft(pos) + post);
};
var adler = function() {
  var a2 = 1, b = 0;
  return {
    p: function(d) {
      var n2 = a2, m3 = b;
      var l2 = d.length;
      for (var i2 = 0; i2 != l2; ) {
        var e2 = Math.min(i2 + 5552, l2);
        for (; i2 < e2; ++i2)
          n2 += d[i2], m3 += n2;
        n2 %= 65521, m3 %= 65521;
      }
      a2 = n2, b = m3;
    },
    d: function() {
      return (a2 >>> 8 << 16 | (b & 255) << 8 | b >>> 8) + ((a2 & 255) << 23) * 2;
    }
  };
};
var dopt = function(dat, opt, pre, post, st) {
  return dflt(dat, opt.level == null ? 6 : opt.level, opt.mem == null ? Math.ceil(Math.max(8, Math.min(13, Math.log(dat.length))) * 1.5) : 12 + opt.mem, pre, post, !st);
};
var wbytes = function(d, b, v2) {
  for (; v2; ++b)
    d[b] = v2, v2 >>>= 8;
};
var zlh = function(c3, o2) {
  var lv = o2.level, fl2 = lv == 0 ? 0 : lv < 6 ? 1 : lv == 9 ? 3 : 2;
  c3[0] = 120, c3[1] = fl2 << 6 | (fl2 ? 32 - 2 * fl2 : 1);
};
var zlv = function(d) {
  if ((d[0] & 15) != 8 || d[0] >>> 4 > 7 || (d[0] << 8 | d[1]) % 31)
    throw "invalid zlib data";
  if (d[1] & 32)
    throw "invalid zlib data: preset dictionaries not supported";
};
function zlibSync(data2, opts) {
  if (opts === void 0) {
    opts = {};
  }
  var a2 = adler();
  a2.p(data2);
  var d = dopt(data2, opts, 2, 4);
  return zlh(d, opts), wbytes(d, d.length - 4, a2.d()), d;
}
function unzlibSync(data2, out) {
  return inflt((zlv(data2), data2.subarray(2, -4)), out);
}

// ../simple-mind-map/src/utils/jspdf.js
var globalObject = function() {
  return "undefined" !== typeof window ? window : "undefined" !== typeof global ? global : "undefined" !== typeof self ? self : this;
}();
function consoleLog() {
  if (globalObject.console && typeof globalObject.console.log === "function") {
    globalObject.console.log.apply(globalObject.console, arguments);
  }
}
function consoleWarn(str) {
  if (globalObject.console) {
    if (typeof globalObject.console.warn === "function") {
      globalObject.console.warn.apply(globalObject.console, arguments);
    } else {
      consoleLog.call(null, arguments);
    }
  }
}
function consoleError(str) {
  if (globalObject.console) {
    if (typeof globalObject.console.error === "function") {
      globalObject.console.error.apply(globalObject.console, arguments);
    } else {
      consoleLog(str);
    }
  }
}
var console2 = {
  log: consoleLog,
  warn: consoleWarn,
  error: consoleError
};
function bom(blob, opts) {
  if (typeof opts === "undefined")
    opts = {
      autoBom: false
    };
  else if (_typeof(opts) !== "object") {
    console2.warn("Deprecated: Expected third argument to be a object");
    opts = {
      autoBom: !opts
    };
  }
  if (opts.autoBom && /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(blob.type)) {
    return new Blob([String.fromCharCode(65279), blob], {
      type: blob.type
    });
  }
  return blob;
}
function download(url, name, opts) {
  var xhr = new XMLHttpRequest();
  xhr.open("GET", url);
  xhr.responseType = "blob";
  xhr.onload = function() {
    saveAs(xhr.response, name, opts);
  };
  xhr.onerror = function() {
    console2.error("could not download file");
  };
  xhr.send();
}
function corsEnabled(url) {
  var xhr = new XMLHttpRequest();
  xhr.open("HEAD", url, false);
  try {
    xhr.send();
  } catch (e2) {
  }
  return xhr.status >= 200 && xhr.status <= 299;
}
function click(node3) {
  try {
    node3.dispatchEvent(new MouseEvent("click"));
  } catch (e2) {
    var evt = document.createEvent("MouseEvents");
    evt.initMouseEvent("click", true, true, window, 0, 0, 0, 80, 20, false, false, false, false, 0, null);
    node3.dispatchEvent(evt);
  }
}
var saveAs = globalObject.saveAs || // probably in some web worker
((typeof window === "undefined" ? "undefined" : _typeof(window)) !== "object" || window !== globalObject ? function saveAs2() {
} : (
  // Use download attribute first if possible (#193 Lumia mobile) unless this is a native app
  typeof HTMLAnchorElement !== "undefined" && "download" in HTMLAnchorElement.prototype ? function saveAs3(blob, name, opts) {
    var URL2 = globalObject.URL || globalObject.webkitURL;
    var a2 = document.createElement("a");
    name = name || blob.name || "download";
    a2.download = name;
    a2.rel = "noopener";
    if (typeof blob === "string") {
      a2.href = blob;
      if (a2.origin !== location.origin) {
        corsEnabled(a2.href) ? download(blob, name, opts) : click(a2, a2.target = "_blank");
      } else {
        click(a2);
      }
    } else {
      a2.href = URL2.createObjectURL(blob);
      setTimeout(function() {
        URL2.revokeObjectURL(a2.href);
      }, 4e4);
      setTimeout(function() {
        click(a2);
      }, 0);
    }
  } : (
    // Use msSaveOrOpenBlob as a second approach
    "msSaveOrOpenBlob" in navigator ? function saveAs4(blob, name, opts) {
      name = name || blob.name || "download";
      if (typeof blob === "string") {
        if (corsEnabled(blob)) {
          download(blob, name, opts);
        } else {
          var a2 = document.createElement("a");
          a2.href = blob;
          a2.target = "_blank";
          setTimeout(function() {
            click(a2);
          });
        }
      } else {
        navigator.msSaveOrOpenBlob(bom(blob, opts), name);
      }
    } : (
      // Fallback to using FileReader and a popup
      function saveAs5(blob, name, opts, popup) {
        popup = popup || open("", "_blank");
        if (popup) {
          popup.document.title = popup.document.body.innerText = "downloading...";
        }
        if (typeof blob === "string")
          return download(blob, name, opts);
        var force = blob.type === "application/octet-stream";
        var isSafari = /constructor/i.test(globalObject.HTMLElement) || globalObject.safari;
        var isChromeIOS = /CriOS\/[\d]+/.test(navigator.userAgent);
        if ((isChromeIOS || force && isSafari) && (typeof FileReader === "undefined" ? "undefined" : _typeof(FileReader)) === "object") {
          var reader = new FileReader();
          reader.onloadend = function() {
            var url2 = reader.result;
            url2 = isChromeIOS ? url2 : url2.replace(/^data:[^;]*;/, "data:attachment/file;");
            if (popup)
              popup.location.href = url2;
            else
              location = url2;
            popup = null;
          };
          reader.readAsDataURL(blob);
        } else {
          var URL2 = globalObject.URL || globalObject.webkitURL;
          var url = URL2.createObjectURL(blob);
          if (popup)
            popup.location = url;
          else
            location.href = url;
          popup = null;
          setTimeout(function() {
            URL2.revokeObjectURL(url);
          }, 4e4);
        }
      }
    )
  )
));
function RGBColor3(color_string) {
  color_string = color_string || "";
  this.ok = false;
  if (color_string.charAt(0) == "#") {
    color_string = color_string.substr(1, 6);
  }
  color_string = color_string.replace(/ /g, "");
  color_string = color_string.toLowerCase();
  var channels;
  var simple_colors = {
    aliceblue: "f0f8ff",
    antiquewhite: "faebd7",
    aqua: "00ffff",
    aquamarine: "7fffd4",
    azure: "f0ffff",
    beige: "f5f5dc",
    bisque: "ffe4c4",
    black: "000000",
    blanchedalmond: "ffebcd",
    blue: "0000ff",
    blueviolet: "8a2be2",
    brown: "a52a2a",
    burlywood: "deb887",
    cadetblue: "5f9ea0",
    chartreuse: "7fff00",
    chocolate: "d2691e",
    coral: "ff7f50",
    cornflowerblue: "6495ed",
    cornsilk: "fff8dc",
    crimson: "dc143c",
    cyan: "00ffff",
    darkblue: "00008b",
    darkcyan: "008b8b",
    darkgoldenrod: "b8860b",
    darkgray: "a9a9a9",
    darkgreen: "006400",
    darkkhaki: "bdb76b",
    darkmagenta: "8b008b",
    darkolivegreen: "556b2f",
    darkorange: "ff8c00",
    darkorchid: "9932cc",
    darkred: "8b0000",
    darksalmon: "e9967a",
    darkseagreen: "8fbc8f",
    darkslateblue: "483d8b",
    darkslategray: "2f4f4f",
    darkturquoise: "00ced1",
    darkviolet: "9400d3",
    deeppink: "ff1493",
    deepskyblue: "00bfff",
    dimgray: "696969",
    dodgerblue: "1e90ff",
    feldspar: "d19275",
    firebrick: "b22222",
    floralwhite: "fffaf0",
    forestgreen: "228b22",
    fuchsia: "ff00ff",
    gainsboro: "dcdcdc",
    ghostwhite: "f8f8ff",
    gold: "ffd700",
    goldenrod: "daa520",
    gray: "808080",
    green: "008000",
    greenyellow: "adff2f",
    honeydew: "f0fff0",
    hotpink: "ff69b4",
    indianred: "cd5c5c",
    indigo: "4b0082",
    ivory: "fffff0",
    khaki: "f0e68c",
    lavender: "e6e6fa",
    lavenderblush: "fff0f5",
    lawngreen: "7cfc00",
    lemonchiffon: "fffacd",
    lightblue: "add8e6",
    lightcoral: "f08080",
    lightcyan: "e0ffff",
    lightgoldenrodyellow: "fafad2",
    lightgrey: "d3d3d3",
    lightgreen: "90ee90",
    lightpink: "ffb6c1",
    lightsalmon: "ffa07a",
    lightseagreen: "20b2aa",
    lightskyblue: "87cefa",
    lightslateblue: "8470ff",
    lightslategray: "778899",
    lightsteelblue: "b0c4de",
    lightyellow: "ffffe0",
    lime: "00ff00",
    limegreen: "32cd32",
    linen: "faf0e6",
    magenta: "ff00ff",
    maroon: "800000",
    mediumaquamarine: "66cdaa",
    mediumblue: "0000cd",
    mediumorchid: "ba55d3",
    mediumpurple: "9370d8",
    mediumseagreen: "3cb371",
    mediumslateblue: "7b68ee",
    mediumspringgreen: "00fa9a",
    mediumturquoise: "48d1cc",
    mediumvioletred: "c71585",
    midnightblue: "191970",
    mintcream: "f5fffa",
    mistyrose: "ffe4e1",
    moccasin: "ffe4b5",
    navajowhite: "ffdead",
    navy: "000080",
    oldlace: "fdf5e6",
    olive: "808000",
    olivedrab: "6b8e23",
    orange: "ffa500",
    orangered: "ff4500",
    orchid: "da70d6",
    palegoldenrod: "eee8aa",
    palegreen: "98fb98",
    paleturquoise: "afeeee",
    palevioletred: "d87093",
    papayawhip: "ffefd5",
    peachpuff: "ffdab9",
    peru: "cd853f",
    pink: "ffc0cb",
    plum: "dda0dd",
    powderblue: "b0e0e6",
    purple: "800080",
    red: "ff0000",
    rosybrown: "bc8f8f",
    royalblue: "4169e1",
    saddlebrown: "8b4513",
    salmon: "fa8072",
    sandybrown: "f4a460",
    seagreen: "2e8b57",
    seashell: "fff5ee",
    sienna: "a0522d",
    silver: "c0c0c0",
    skyblue: "87ceeb",
    slateblue: "6a5acd",
    slategray: "708090",
    snow: "fffafa",
    springgreen: "00ff7f",
    steelblue: "4682b4",
    tan: "d2b48c",
    teal: "008080",
    thistle: "d8bfd8",
    tomato: "ff6347",
    turquoise: "40e0d0",
    violet: "ee82ee",
    violetred: "d02090",
    wheat: "f5deb3",
    white: "ffffff",
    whitesmoke: "f5f5f5",
    yellow: "ffff00",
    yellowgreen: "9acd32"
  };
  color_string = simple_colors[color_string] || color_string;
  var color_defs = [{
    re: /^rgb\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)$/,
    example: ["rgb(123, 234, 45)", "rgb(255,234,245)"],
    process: function process2(bits3) {
      return [parseInt(bits3[1]), parseInt(bits3[2]), parseInt(bits3[3])];
    }
  }, {
    re: /^(\w{2})(\w{2})(\w{2})$/,
    example: ["#00ff00", "336699"],
    process: function process2(bits3) {
      return [parseInt(bits3[1], 16), parseInt(bits3[2], 16), parseInt(bits3[3], 16)];
    }
  }, {
    re: /^(\w{1})(\w{1})(\w{1})$/,
    example: ["#fb0", "f0f"],
    process: function process2(bits3) {
      return [parseInt(bits3[1] + bits3[1], 16), parseInt(bits3[2] + bits3[2], 16), parseInt(bits3[3] + bits3[3], 16)];
    }
  }];
  for (var i2 = 0; i2 < color_defs.length; i2++) {
    var re = color_defs[i2].re;
    var processor = color_defs[i2].process;
    var bits2 = re.exec(color_string);
    if (bits2) {
      channels = processor(bits2);
      this.r = channels[0];
      this.g = channels[1];
      this.b = channels[2];
      this.ok = true;
    }
  }
  this.r = this.r < 0 || isNaN(this.r) ? 0 : this.r > 255 ? 255 : this.r;
  this.g = this.g < 0 || isNaN(this.g) ? 0 : this.g > 255 ? 255 : this.g;
  this.b = this.b < 0 || isNaN(this.b) ? 0 : this.b > 255 ? 255 : this.b;
  this.toRGB = function() {
    return "rgb(" + this.r + ", " + this.g + ", " + this.b + ")";
  };
  this.toHex = function() {
    var r2 = this.r.toString(16);
    var g = this.g.toString(16);
    var b = this.b.toString(16);
    if (r2.length == 1)
      r2 = "0" + r2;
    if (g.length == 1)
      g = "0" + g;
    if (b.length == 1)
      b = "0" + b;
    return "#" + r2 + g + b;
  };
}
var atob2;
var btoa;
(function() {
  atob2 = globalObject.atob.bind(globalObject);
  btoa = globalObject.btoa.bind(globalObject);
  return;
})();
function md5cycle(x2, k) {
  var a2 = x2[0], b = x2[1], c3 = x2[2], d = x2[3];
  a2 = ff(a2, b, c3, d, k[0], 7, -680876936);
  d = ff(d, a2, b, c3, k[1], 12, -389564586);
  c3 = ff(c3, d, a2, b, k[2], 17, 606105819);
  b = ff(b, c3, d, a2, k[3], 22, -1044525330);
  a2 = ff(a2, b, c3, d, k[4], 7, -176418897);
  d = ff(d, a2, b, c3, k[5], 12, 1200080426);
  c3 = ff(c3, d, a2, b, k[6], 17, -1473231341);
  b = ff(b, c3, d, a2, k[7], 22, -45705983);
  a2 = ff(a2, b, c3, d, k[8], 7, 1770035416);
  d = ff(d, a2, b, c3, k[9], 12, -1958414417);
  c3 = ff(c3, d, a2, b, k[10], 17, -42063);
  b = ff(b, c3, d, a2, k[11], 22, -1990404162);
  a2 = ff(a2, b, c3, d, k[12], 7, 1804603682);
  d = ff(d, a2, b, c3, k[13], 12, -40341101);
  c3 = ff(c3, d, a2, b, k[14], 17, -1502002290);
  b = ff(b, c3, d, a2, k[15], 22, 1236535329);
  a2 = gg(a2, b, c3, d, k[1], 5, -165796510);
  d = gg(d, a2, b, c3, k[6], 9, -1069501632);
  c3 = gg(c3, d, a2, b, k[11], 14, 643717713);
  b = gg(b, c3, d, a2, k[0], 20, -373897302);
  a2 = gg(a2, b, c3, d, k[5], 5, -701558691);
  d = gg(d, a2, b, c3, k[10], 9, 38016083);
  c3 = gg(c3, d, a2, b, k[15], 14, -660478335);
  b = gg(b, c3, d, a2, k[4], 20, -405537848);
  a2 = gg(a2, b, c3, d, k[9], 5, 568446438);
  d = gg(d, a2, b, c3, k[14], 9, -1019803690);
  c3 = gg(c3, d, a2, b, k[3], 14, -187363961);
  b = gg(b, c3, d, a2, k[8], 20, 1163531501);
  a2 = gg(a2, b, c3, d, k[13], 5, -1444681467);
  d = gg(d, a2, b, c3, k[2], 9, -51403784);
  c3 = gg(c3, d, a2, b, k[7], 14, 1735328473);
  b = gg(b, c3, d, a2, k[12], 20, -1926607734);
  a2 = hh(a2, b, c3, d, k[5], 4, -378558);
  d = hh(d, a2, b, c3, k[8], 11, -2022574463);
  c3 = hh(c3, d, a2, b, k[11], 16, 1839030562);
  b = hh(b, c3, d, a2, k[14], 23, -35309556);
  a2 = hh(a2, b, c3, d, k[1], 4, -1530992060);
  d = hh(d, a2, b, c3, k[4], 11, 1272893353);
  c3 = hh(c3, d, a2, b, k[7], 16, -155497632);
  b = hh(b, c3, d, a2, k[10], 23, -1094730640);
  a2 = hh(a2, b, c3, d, k[13], 4, 681279174);
  d = hh(d, a2, b, c3, k[0], 11, -358537222);
  c3 = hh(c3, d, a2, b, k[3], 16, -722521979);
  b = hh(b, c3, d, a2, k[6], 23, 76029189);
  a2 = hh(a2, b, c3, d, k[9], 4, -640364487);
  d = hh(d, a2, b, c3, k[12], 11, -421815835);
  c3 = hh(c3, d, a2, b, k[15], 16, 530742520);
  b = hh(b, c3, d, a2, k[2], 23, -995338651);
  a2 = ii(a2, b, c3, d, k[0], 6, -198630844);
  d = ii(d, a2, b, c3, k[7], 10, 1126891415);
  c3 = ii(c3, d, a2, b, k[14], 15, -1416354905);
  b = ii(b, c3, d, a2, k[5], 21, -57434055);
  a2 = ii(a2, b, c3, d, k[12], 6, 1700485571);
  d = ii(d, a2, b, c3, k[3], 10, -1894986606);
  c3 = ii(c3, d, a2, b, k[10], 15, -1051523);
  b = ii(b, c3, d, a2, k[1], 21, -2054922799);
  a2 = ii(a2, b, c3, d, k[8], 6, 1873313359);
  d = ii(d, a2, b, c3, k[15], 10, -30611744);
  c3 = ii(c3, d, a2, b, k[6], 15, -1560198380);
  b = ii(b, c3, d, a2, k[13], 21, 1309151649);
  a2 = ii(a2, b, c3, d, k[4], 6, -145523070);
  d = ii(d, a2, b, c3, k[11], 10, -1120210379);
  c3 = ii(c3, d, a2, b, k[2], 15, 718787259);
  b = ii(b, c3, d, a2, k[9], 21, -343485551);
  x2[0] = add32(a2, x2[0]);
  x2[1] = add32(b, x2[1]);
  x2[2] = add32(c3, x2[2]);
  x2[3] = add32(d, x2[3]);
}
function cmn(q, a2, b, x2, s2, t2) {
  a2 = add32(add32(a2, q), add32(x2, t2));
  return add32(a2 << s2 | a2 >>> 32 - s2, b);
}
function ff(a2, b, c3, d, x2, s2, t2) {
  return cmn(b & c3 | ~b & d, a2, b, x2, s2, t2);
}
function gg(a2, b, c3, d, x2, s2, t2) {
  return cmn(b & d | c3 & ~d, a2, b, x2, s2, t2);
}
function hh(a2, b, c3, d, x2, s2, t2) {
  return cmn(b ^ c3 ^ d, a2, b, x2, s2, t2);
}
function ii(a2, b, c3, d, x2, s2, t2) {
  return cmn(c3 ^ (b | ~d), a2, b, x2, s2, t2);
}
function md51(s2) {
  var n2 = s2.length, state = [1732584193, -271733879, -1732584194, 271733878], i2;
  for (i2 = 64; i2 <= s2.length; i2 += 64) {
    md5cycle(state, md5blk(s2.substring(i2 - 64, i2)));
  }
  s2 = s2.substring(i2 - 64);
  var tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
  for (i2 = 0; i2 < s2.length; i2++) {
    tail[i2 >> 2] |= s2.charCodeAt(i2) << (i2 % 4 << 3);
  }
  tail[i2 >> 2] |= 128 << (i2 % 4 << 3);
  if (i2 > 55) {
    md5cycle(state, tail);
    for (i2 = 0; i2 < 16; i2++) {
      tail[i2] = 0;
    }
  }
  tail[14] = n2 * 8;
  md5cycle(state, tail);
  return state;
}
function md5blk(s2) {
  var md5blks = [], i2;
  for (i2 = 0; i2 < 64; i2 += 4) {
    md5blks[i2 >> 2] = s2.charCodeAt(i2) + (s2.charCodeAt(i2 + 1) << 8) + (s2.charCodeAt(i2 + 2) << 16) + (s2.charCodeAt(i2 + 3) << 24);
  }
  return md5blks;
}
var hex_chr = "0123456789abcdef".split("");
function rhex(n2) {
  var s2 = "", j = 0;
  for (; j < 4; j++) {
    s2 += hex_chr[n2 >> j * 8 + 4 & 15] + hex_chr[n2 >> j * 8 & 15];
  }
  return s2;
}
function hex2(x2) {
  for (var i2 = 0; i2 < x2.length; i2++) {
    x2[i2] = rhex(x2[i2]);
  }
  return x2.join("");
}
function singleToByteString(n2) {
  return String.fromCharCode((n2 & 255) >> 0, (n2 & 65280) >> 8, (n2 & 16711680) >> 16, (n2 & 4278190080) >> 24);
}
function toByteString(x2) {
  return x2.map(singleToByteString).join("");
}
function md5Bin(s2) {
  return toByteString(md51(s2));
}
function md5(s2) {
  return hex2(md51(s2));
}
var md5Check = md5("hello") != "5d41402abc4b2a76b9719d911017c592";
function add32(a2, b) {
  if (md5Check) {
    var lsw = (a2 & 65535) + (b & 65535), msw = (a2 >> 16) + (b >> 16) + (lsw >> 16);
    return msw << 16 | lsw & 65535;
  } else {
    return a2 + b & 4294967295;
  }
}
function repeat(str, num) {
  return new Array(num + 1).join(str);
}
function rc4(key, data2) {
  var lastKey, lastState;
  if (key !== lastKey) {
    var k = repeat(key, (256 / key.length >> 0) + 1);
    var state = [];
    for (var i2 = 0; i2 < 256; i2++) {
      state[i2] = i2;
    }
    var j = 0;
    for (var i2 = 0; i2 < 256; i2++) {
      var t2 = state[i2];
      j = (j + t2 + k.charCodeAt(i2)) % 256;
      state[i2] = state[j];
      state[j] = t2;
    }
    lastKey = key;
    lastState = state;
  } else {
    state = lastState;
  }
  var length2 = data2.length;
  var a2 = 0;
  var b = 0;
  var out = "";
  for (var i2 = 0; i2 < length2; i2++) {
    a2 = (a2 + 1) % 256;
    t2 = state[a2];
    b = (b + t2) % 256;
    state[a2] = state[b];
    state[b] = t2;
    k = state[(state[a2] + state[b]) % 256];
    out += String.fromCharCode(data2.charCodeAt(i2) ^ k);
  }
  return out;
}
var permissionOptions = {
  print: 4,
  modify: 8,
  copy: 16,
  "annot-forms": 32
};
function PDFSecurity(permissions, userPassword, ownerPassword, fileId) {
  this.v = 1;
  this.r = 2;
  var protection = 192;
  permissions.forEach(function(perm) {
    if (typeof permissionOptions.perm !== "undefined") {
      throw new Error("Invalid permission: " + perm);
    }
    protection += permissionOptions[perm];
  });
  this.padding = "(\xBFN^Nu\x8AAd\0NV\xFF\xFA\b..\0\xB6\xD0h>\x80/\f\xA9\xFEdSiz";
  var paddedUserPassword = (userPassword + this.padding).substr(0, 32);
  var paddedOwnerPassword = (ownerPassword + this.padding).substr(0, 32);
  this.O = this.processOwnerPassword(paddedUserPassword, paddedOwnerPassword);
  this.P = -((protection ^ 255) + 1);
  this.encryptionKey = md5Bin(paddedUserPassword + this.O + this.lsbFirstWord(this.P) + this.hexToBytes(fileId)).substr(0, 5);
  this.U = rc4(this.encryptionKey, this.padding);
}
PDFSecurity.prototype.lsbFirstWord = function(data2) {
  return String.fromCharCode(data2 >> 0 & 255, data2 >> 8 & 255, data2 >> 16 & 255, data2 >> 24 & 255);
};
PDFSecurity.prototype.toHexString = function(byteString) {
  return byteString.split("").map(function(byte) {
    return ("0" + (byte.charCodeAt(0) & 255).toString(16)).slice(-2);
  }).join("");
};
PDFSecurity.prototype.hexToBytes = function(hex3) {
  for (var bytes = [], c3 = 0; c3 < hex3.length; c3 += 2) {
    bytes.push(String.fromCharCode(parseInt(hex3.substr(c3, 2), 16)));
  }
  return bytes.join("");
};
PDFSecurity.prototype.processOwnerPassword = function(paddedUserPassword, paddedOwnerPassword) {
  var key = md5Bin(paddedOwnerPassword).substr(0, 5);
  return rc4(key, paddedUserPassword);
};
PDFSecurity.prototype.encryptor = function(objectId, generation) {
  var key = md5Bin(this.encryptionKey + String.fromCharCode(objectId & 255, objectId >> 8 & 255, objectId >> 16 & 255, generation & 255, generation >> 8 & 255)).substr(0, 10);
  return function(data2) {
    return rc4(key, data2);
  };
};
function toPDFName(str) {
  if (/[^\u0000-\u00ff]/.test(str)) {
    throw new Error("Invalid PDF Name Object: " + str + ", Only accept ASCII characters.");
  }
  var result = "", strLength = str.length;
  for (var i2 = 0; i2 < strLength; i2++) {
    var charCode = str.charCodeAt(i2);
    if (charCode < 33 || charCode === 35 || charCode === 37 || charCode === 40 || charCode === 41 || charCode === 47 || charCode === 60 || charCode === 62 || charCode === 91 || charCode === 93 || charCode === 123 || charCode === 125 || charCode > 126) {
      var hexStr = charCode.toString(16), paddingHexStr = ("0" + hexStr).slice(-2);
      result += "#" + paddingHexStr;
    } else {
      result += str[i2];
    }
  }
  return result;
}
function PubSub(context) {
  if (_typeof(context) !== "object") {
    throw new Error("Invalid Context passed to initialize PubSub (jsPDF-module)");
  }
  var topics = {};
  this.subscribe = function(topic, callback, once) {
    once = once || false;
    if (typeof topic !== "string" || typeof callback !== "function" || typeof once !== "boolean") {
      throw new Error("Invalid arguments passed to PubSub.subscribe (jsPDF-module)");
    }
    if (!topics.hasOwnProperty(topic)) {
      topics[topic] = {};
    }
    var token = Math.random().toString(35);
    topics[topic][token] = [callback, !!once];
    return token;
  };
  this.unsubscribe = function(token) {
    for (var topic in topics) {
      if (topics[topic][token]) {
        delete topics[topic][token];
        if (Object.keys(topics[topic]).length === 0) {
          delete topics[topic];
        }
        return true;
      }
    }
    return false;
  };
  this.publish = function(topic) {
    if (topics.hasOwnProperty(topic)) {
      var args = Array.prototype.slice.call(arguments, 1), tokens = [];
      for (var token in topics[topic]) {
        var sub2 = topics[topic][token];
        try {
          sub2[0].apply(context, args);
        } catch (ex) {
          if (globalObject.console) {
            console2.error("jsPDF PubSub Error", ex.message, ex);
          }
        }
        if (sub2[1])
          tokens.push(token);
      }
      if (tokens.length)
        tokens.forEach(this.unsubscribe);
    }
  };
  this.getTopics = function() {
    return topics;
  };
}
function GState(parameters) {
  if (!(this instanceof GState)) {
    return new GState(parameters);
  }
  var supported = "opacity,stroke-opacity".split(",");
  for (var p2 in parameters) {
    if (parameters.hasOwnProperty(p2) && supported.indexOf(p2) >= 0) {
      this[p2] = parameters[p2];
    }
  }
  this.id = "";
  this.objectNumber = -1;
}
GState.prototype.equals = function equals(other) {
  var ignore = "id,objectNumber,equals";
  var p2;
  if (!other || _typeof(other) !== _typeof(this))
    return false;
  var count = 0;
  for (p2 in this) {
    if (ignore.indexOf(p2) >= 0)
      continue;
    if (this.hasOwnProperty(p2) && !other.hasOwnProperty(p2))
      return false;
    if (this[p2] !== other[p2])
      return false;
    count++;
  }
  for (p2 in other) {
    if (other.hasOwnProperty(p2) && ignore.indexOf(p2) < 0)
      count--;
  }
  return count === 0;
};
function Pattern2(gState, matrix) {
  this.gState = gState;
  this.matrix = matrix;
  this.id = "";
  this.objectNumber = -1;
}
function ShadingPattern(type, coords, colors, gState, matrix) {
  if (!(this instanceof ShadingPattern)) {
    return new ShadingPattern(type, coords, colors, gState, matrix);
  }
  this.type = type === "axial" ? 2 : 3;
  this.coords = coords;
  this.colors = colors;
  Pattern2.call(this, gState, matrix);
}
function TilingPattern(boundingBox, xStep, yStep, gState, matrix) {
  if (!(this instanceof TilingPattern)) {
    return new TilingPattern(boundingBox, xStep, yStep, gState, matrix);
  }
  this.boundingBox = boundingBox;
  this.xStep = xStep;
  this.yStep = yStep;
  this.stream = "";
  this.cloneIndex = 0;
  Pattern2.call(this, gState, matrix);
}
function jsPDF(options) {
  var orientation = typeof arguments[0] === "string" ? arguments[0] : "p";
  var unit = arguments[1];
  var format = arguments[2];
  var compressPdf = arguments[3];
  var filters = [];
  var userUnit = 1;
  var precision;
  var floatPrecision = 16;
  var defaultPathOperation = "S";
  var encryptionOptions = null;
  options = options || {};
  if (_typeof(options) === "object") {
    orientation = options.orientation;
    unit = options.unit || unit;
    format = options.format || format;
    compressPdf = options.compress || options.compressPdf || compressPdf;
    encryptionOptions = options.encryption || null;
    if (encryptionOptions !== null) {
      encryptionOptions.userPassword = encryptionOptions.userPassword || "";
      encryptionOptions.ownerPassword = encryptionOptions.ownerPassword || "";
      encryptionOptions.userPermissions = encryptionOptions.userPermissions || [];
    }
    userUnit = typeof options.userUnit === "number" ? Math.abs(options.userUnit) : 1;
    if (typeof options.precision !== "undefined") {
      precision = options.precision;
    }
    if (typeof options.floatPrecision !== "undefined") {
      floatPrecision = options.floatPrecision;
    }
    defaultPathOperation = options.defaultPathOperation || "S";
  }
  filters = options.filters || (compressPdf === true ? ["FlateEncode"] : filters);
  unit = unit || "mm";
  orientation = ("" + (orientation || "P")).toLowerCase();
  var putOnlyUsedFonts = options.putOnlyUsedFonts || false;
  var usedFonts = {};
  var API = {
    internal: {},
    __private__: {}
  };
  API.__private__.PubSub = PubSub;
  var pdfVersion = "1.3";
  var getPdfVersion = API.__private__.getPdfVersion = function() {
    return pdfVersion;
  };
  API.__private__.setPdfVersion = function(value) {
    pdfVersion = value;
  };
  var pageFormats = {
    a0: [2383.94, 3370.39],
    a1: [1683.78, 2383.94],
    a2: [1190.55, 1683.78],
    a3: [841.89, 1190.55],
    a4: [595.28, 841.89],
    a5: [419.53, 595.28],
    a6: [297.64, 419.53],
    a7: [209.76, 297.64],
    a8: [147.4, 209.76],
    a9: [104.88, 147.4],
    a10: [73.7, 104.88],
    b0: [2834.65, 4008.19],
    b1: [2004.09, 2834.65],
    b2: [1417.32, 2004.09],
    b3: [1000.63, 1417.32],
    b4: [708.66, 1000.63],
    b5: [498.9, 708.66],
    b6: [354.33, 498.9],
    b7: [249.45, 354.33],
    b8: [175.75, 249.45],
    b9: [124.72, 175.75],
    b10: [87.87, 124.72],
    c0: [2599.37, 3676.54],
    c1: [1836.85, 2599.37],
    c2: [1298.27, 1836.85],
    c3: [918.43, 1298.27],
    c4: [649.13, 918.43],
    c5: [459.21, 649.13],
    c6: [323.15, 459.21],
    c7: [229.61, 323.15],
    c8: [161.57, 229.61],
    c9: [113.39, 161.57],
    c10: [79.37, 113.39],
    dl: [311.81, 623.62],
    letter: [612, 792],
    "government-letter": [576, 756],
    legal: [612, 1008],
    "junior-legal": [576, 360],
    ledger: [1224, 792],
    tabloid: [792, 1224],
    "credit-card": [153, 243]
  };
  API.__private__.getPageFormats = function() {
    return pageFormats;
  };
  var getPageFormat = API.__private__.getPageFormat = function(value) {
    return pageFormats[value];
  };
  format = format || "a4";
  var ApiMode = {
    COMPAT: "compat",
    ADVANCED: "advanced"
  };
  var apiMode = ApiMode.COMPAT;
  function advancedAPI() {
    this.saveGraphicsState();
    out(new Matrix3(scaleFactor2, 0, 0, -scaleFactor2, 0, getPageHeight() * scaleFactor2).toString() + " cm");
    this.setFontSize(this.getFontSize() / scaleFactor2);
    defaultPathOperation = "n";
    apiMode = ApiMode.ADVANCED;
  }
  function compatAPI() {
    this.restoreGraphicsState();
    defaultPathOperation = "S";
    apiMode = ApiMode.COMPAT;
  }
  var combineFontStyleAndFontWeight = API.__private__.combineFontStyleAndFontWeight = function(fontStyle, fontWeight) {
    if (fontStyle == "bold" && fontWeight == "normal" || fontStyle == "bold" && fontWeight == 400 || fontStyle == "normal" && fontWeight == "italic" || fontStyle == "bold" && fontWeight == "italic") {
      throw new Error("Invalid Combination of fontweight and fontstyle");
    }
    if (fontWeight) {
      fontStyle = fontWeight == 400 || fontWeight === "normal" ? fontStyle === "italic" ? "italic" : "normal" : (fontWeight == 700 || fontWeight === "bold") && fontStyle === "normal" ? "bold" : (fontWeight == 700 ? "bold" : fontWeight) + "" + fontStyle;
    }
    return fontStyle;
  };
  API.advancedAPI = function(body) {
    var doSwitch = apiMode === ApiMode.COMPAT;
    if (doSwitch) {
      advancedAPI.call(this);
    }
    if (typeof body !== "function") {
      return this;
    }
    body(this);
    if (doSwitch) {
      compatAPI.call(this);
    }
    return this;
  };
  API.compatAPI = function(body) {
    var doSwitch = apiMode === ApiMode.ADVANCED;
    if (doSwitch) {
      compatAPI.call(this);
    }
    if (typeof body !== "function") {
      return this;
    }
    body(this);
    if (doSwitch) {
      advancedAPI.call(this);
    }
    return this;
  };
  API.isAdvancedAPI = function() {
    return apiMode === ApiMode.ADVANCED;
  };
  var advancedApiModeTrap = function advancedApiModeTrap2(methodName) {
    if (apiMode !== ApiMode.ADVANCED) {
      throw new Error(methodName + " is only available in 'advanced' API mode. You need to call advancedAPI() first.");
    }
  };
  var roundToPrecision = API.roundToPrecision = API.__private__.roundToPrecision = function(number, parmPrecision) {
    var tmpPrecision = precision || parmPrecision;
    if (isNaN(number) || isNaN(tmpPrecision)) {
      throw new Error("Invalid argument passed to jsPDF.roundToPrecision");
    }
    return number.toFixed(tmpPrecision).replace(/0+$/, "");
  };
  var hpf;
  if (typeof floatPrecision === "number") {
    hpf = API.hpf = API.__private__.hpf = function(number) {
      if (isNaN(number)) {
        throw new Error("Invalid argument passed to jsPDF.hpf");
      }
      return roundToPrecision(number, floatPrecision);
    };
  } else if (floatPrecision === "smart") {
    hpf = API.hpf = API.__private__.hpf = function(number) {
      if (isNaN(number)) {
        throw new Error("Invalid argument passed to jsPDF.hpf");
      }
      if (number > -1 && number < 1) {
        return roundToPrecision(number, 16);
      } else {
        return roundToPrecision(number, 5);
      }
    };
  } else {
    hpf = API.hpf = API.__private__.hpf = function(number) {
      if (isNaN(number)) {
        throw new Error("Invalid argument passed to jsPDF.hpf");
      }
      return roundToPrecision(number, 16);
    };
  }
  var f23 = API.f2 = API.__private__.f2 = function(number) {
    if (isNaN(number)) {
      throw new Error("Invalid argument passed to jsPDF.f2");
    }
    return roundToPrecision(number, 2);
  };
  var f3 = API.__private__.f3 = function(number) {
    if (isNaN(number)) {
      throw new Error("Invalid argument passed to jsPDF.f3");
    }
    return roundToPrecision(number, 3);
  };
  var scale3 = API.scale = API.__private__.scale = function(number) {
    if (isNaN(number)) {
      throw new Error("Invalid argument passed to jsPDF.scale");
    }
    if (apiMode === ApiMode.COMPAT) {
      return number * scaleFactor2;
    } else if (apiMode === ApiMode.ADVANCED) {
      return number;
    }
  };
  var transformY = function transformY2(y3) {
    if (apiMode === ApiMode.COMPAT) {
      return getPageHeight() - y3;
    } else if (apiMode === ApiMode.ADVANCED) {
      return y3;
    }
  };
  var transformScaleY = function transformScaleY2(y3) {
    return scale3(transformY(y3));
  };
  API.__private__.setPrecision = API.setPrecision = function(value) {
    if (typeof parseInt(value, 10) === "number") {
      precision = parseInt(value, 10);
    }
  };
  var fileId = "00000000000000000000000000000000";
  var getFileId = API.__private__.getFileId = function() {
    return fileId;
  };
  var setFileId = API.__private__.setFileId = function(value) {
    if (typeof value !== "undefined" && /^[a-fA-F0-9]{32}$/.test(value)) {
      fileId = value.toUpperCase();
    } else {
      fileId = fileId.split("").map(function() {
        return "ABCDEF0123456789".charAt(Math.floor(Math.random() * 16));
      }).join("");
    }
    if (encryptionOptions !== null) {
      encryption = new PDFSecurity(encryptionOptions.userPermissions, encryptionOptions.userPassword, encryptionOptions.ownerPassword, fileId);
    }
    return fileId;
  };
  API.setFileId = function(value) {
    setFileId(value);
    return this;
  };
  API.getFileId = function() {
    return getFileId();
  };
  var creationDate;
  var convertDateToPDFDate = API.__private__.convertDateToPDFDate = function(parmDate) {
    var result = "";
    var tzoffset = parmDate.getTimezoneOffset(), tzsign = tzoffset < 0 ? "+" : "-", tzhour = Math.floor(Math.abs(tzoffset / 60)), tzmin = Math.abs(tzoffset % 60), timeZoneString = [tzsign, padd2(tzhour), "'", padd2(tzmin), "'"].join("");
    result = ["D:", parmDate.getFullYear(), padd2(parmDate.getMonth() + 1), padd2(parmDate.getDate()), padd2(parmDate.getHours()), padd2(parmDate.getMinutes()), padd2(parmDate.getSeconds()), timeZoneString].join("");
    return result;
  };
  var convertPDFDateToDate = API.__private__.convertPDFDateToDate = function(parmPDFDate) {
    var year = parseInt(parmPDFDate.substr(2, 4), 10);
    var month = parseInt(parmPDFDate.substr(6, 2), 10) - 1;
    var date = parseInt(parmPDFDate.substr(8, 2), 10);
    var hour = parseInt(parmPDFDate.substr(10, 2), 10);
    var minutes = parseInt(parmPDFDate.substr(12, 2), 10);
    var seconds = parseInt(parmPDFDate.substr(14, 2), 10);
    var resultingDate = new Date(year, month, date, hour, minutes, seconds, 0);
    return resultingDate;
  };
  var setCreationDate = API.__private__.setCreationDate = function(date) {
    var tmpCreationDateString;
    var regexPDFCreationDate = /^D:(20[0-2][0-9]|203[0-7]|19[7-9][0-9])(0[0-9]|1[0-2])([0-2][0-9]|3[0-1])(0[0-9]|1[0-9]|2[0-3])(0[0-9]|[1-5][0-9])(0[0-9]|[1-5][0-9])(\+0[0-9]|\+1[0-4]|-0[0-9]|-1[0-1])'(0[0-9]|[1-5][0-9])'?$/;
    if (typeof date === "undefined") {
      date = /* @__PURE__ */ new Date();
    }
    if (date instanceof Date) {
      tmpCreationDateString = convertDateToPDFDate(date);
    } else if (regexPDFCreationDate.test(date)) {
      tmpCreationDateString = date;
    } else {
      throw new Error("Invalid argument passed to jsPDF.setCreationDate");
    }
    creationDate = tmpCreationDateString;
    return creationDate;
  };
  var getCreationDate = API.__private__.getCreationDate = function(type) {
    var result = creationDate;
    if (type === "jsDate") {
      result = convertPDFDateToDate(creationDate);
    }
    return result;
  };
  API.setCreationDate = function(date) {
    setCreationDate(date);
    return this;
  };
  API.getCreationDate = function(type) {
    return getCreationDate(type);
  };
  var padd2 = API.__private__.padd2 = function(number) {
    return ("0" + parseInt(number)).slice(-2);
  };
  var padd2Hex = API.__private__.padd2Hex = function(hexString) {
    hexString = hexString.toString();
    return ("00" + hexString).substr(hexString.length);
  };
  var objectNumber = 0;
  var offsets = [];
  var content3 = [];
  var contentLength = 0;
  var additionalObjects = [];
  var pages = [];
  var currentPage;
  var hasCustomDestination = false;
  var outputDestination = content3;
  var resetDocument = function resetDocument2() {
    objectNumber = 0;
    contentLength = 0;
    content3 = [];
    offsets = [];
    additionalObjects = [];
    rootDictionaryObjId = newObjectDeferred();
    resourceDictionaryObjId = newObjectDeferred();
  };
  API.__private__.setCustomOutputDestination = function(destination) {
    hasCustomDestination = true;
    outputDestination = destination;
  };
  var setOutputDestination = function setOutputDestination2(destination) {
    if (!hasCustomDestination) {
      outputDestination = destination;
    }
  };
  API.__private__.resetCustomOutputDestination = function() {
    hasCustomDestination = false;
    outputDestination = content3;
  };
  var out = API.__private__.out = function(string3) {
    string3 = string3.toString();
    contentLength += string3.length + 1;
    outputDestination.push(string3);
    return outputDestination;
  };
  var write = API.__private__.write = function(value) {
    return out(arguments.length === 1 ? value.toString() : Array.prototype.join.call(arguments, " "));
  };
  var getArrayBuffer = API.__private__.getArrayBuffer = function(data2) {
    if (data2 instanceof ArrayBuffer) {
      return data2;
    }
    var len = data2.length, ab = new ArrayBuffer(len), u82 = new Uint8Array(ab);
    while (len--) {
      u82[len] = data2.charCodeAt(len);
    }
    return ab;
  };
  var standardFonts = [["Helvetica", "helvetica", "normal", "WinAnsiEncoding"], ["Helvetica-Bold", "helvetica", "bold", "WinAnsiEncoding"], ["Helvetica-Oblique", "helvetica", "italic", "WinAnsiEncoding"], ["Helvetica-BoldOblique", "helvetica", "bolditalic", "WinAnsiEncoding"], ["Courier", "courier", "normal", "WinAnsiEncoding"], ["Courier-Bold", "courier", "bold", "WinAnsiEncoding"], ["Courier-Oblique", "courier", "italic", "WinAnsiEncoding"], ["Courier-BoldOblique", "courier", "bolditalic", "WinAnsiEncoding"], ["Times-Roman", "times", "normal", "WinAnsiEncoding"], ["Times-Bold", "times", "bold", "WinAnsiEncoding"], ["Times-Italic", "times", "italic", "WinAnsiEncoding"], ["Times-BoldItalic", "times", "bolditalic", "WinAnsiEncoding"], ["ZapfDingbats", "zapfdingbats", "normal", null], ["Symbol", "symbol", "normal", null]];
  API.__private__.getStandardFonts = function() {
    return standardFonts;
  };
  var activeFontSize = options.fontSize || 16;
  API.__private__.setFontSize = API.setFontSize = function(size2) {
    if (apiMode === ApiMode.ADVANCED) {
      activeFontSize = size2 / scaleFactor2;
    } else {
      activeFontSize = size2;
    }
    return this;
  };
  var getFontSize = API.__private__.getFontSize = API.getFontSize = function() {
    if (apiMode === ApiMode.COMPAT) {
      return activeFontSize;
    } else {
      return activeFontSize * scaleFactor2;
    }
  };
  var R2L = options.R2L || false;
  API.__private__.setR2L = API.setR2L = function(value) {
    R2L = value;
    return this;
  };
  API.__private__.getR2L = API.getR2L = function() {
    return R2L;
  };
  var zoomMode;
  var setZoomMode = API.__private__.setZoomMode = function(zoom) {
    var validZoomModes = [void 0, null, "fullwidth", "fullheight", "fullpage", "original"];
    if (/^(?:\d+\.\d*|\d*\.\d+|\d+)%$/.test(zoom)) {
      zoomMode = zoom;
    } else if (!isNaN(zoom)) {
      zoomMode = parseInt(zoom, 10);
    } else if (validZoomModes.indexOf(zoom) !== -1) {
      zoomMode = zoom;
    } else {
      throw new Error('zoom must be Integer (e.g. 2), a percentage Value (e.g. 300%) or fullwidth, fullheight, fullpage, original. "' + zoom + '" is not recognized.');
    }
  };
  API.__private__.getZoomMode = function() {
    return zoomMode;
  };
  var pageMode;
  var setPageMode = API.__private__.setPageMode = function(pmode) {
    var validPageModes = [void 0, null, "UseNone", "UseOutlines", "UseThumbs", "FullScreen"];
    if (validPageModes.indexOf(pmode) == -1) {
      throw new Error('Page mode must be one of UseNone, UseOutlines, UseThumbs, or FullScreen. "' + pmode + '" is not recognized.');
    }
    pageMode = pmode;
  };
  API.__private__.getPageMode = function() {
    return pageMode;
  };
  var layoutMode;
  var setLayoutMode = API.__private__.setLayoutMode = function(layout) {
    var validLayoutModes = [void 0, null, "continuous", "single", "twoleft", "tworight", "two"];
    if (validLayoutModes.indexOf(layout) == -1) {
      throw new Error('Layout mode must be one of continuous, single, twoleft, tworight. "' + layout + '" is not recognized.');
    }
    layoutMode = layout;
  };
  API.__private__.getLayoutMode = function() {
    return layoutMode;
  };
  API.__private__.setDisplayMode = API.setDisplayMode = function(zoom, layout, pmode) {
    setZoomMode(zoom);
    setLayoutMode(layout);
    setPageMode(pmode);
    return this;
  };
  var documentProperties = {
    title: "",
    subject: "",
    author: "",
    keywords: "",
    creator: ""
  };
  API.__private__.getDocumentProperty = function(key) {
    if (Object.keys(documentProperties).indexOf(key) === -1) {
      throw new Error("Invalid argument passed to jsPDF.getDocumentProperty");
    }
    return documentProperties[key];
  };
  API.__private__.getDocumentProperties = function() {
    return documentProperties;
  };
  API.__private__.setDocumentProperties = API.setProperties = API.setDocumentProperties = function(properties) {
    for (var property in documentProperties) {
      if (documentProperties.hasOwnProperty(property) && properties[property]) {
        documentProperties[property] = properties[property];
      }
    }
    return this;
  };
  API.__private__.setDocumentProperty = function(key, value) {
    if (Object.keys(documentProperties).indexOf(key) === -1) {
      throw new Error("Invalid arguments passed to jsPDF.setDocumentProperty");
    }
    return documentProperties[key] = value;
  };
  var fonts = {};
  var fontmap = {};
  var activeFontKey;
  var fontStateStack = [];
  var patterns = {};
  var patternMap = {};
  var gStates = {};
  var gStatesMap = {};
  var activeGState = null;
  var scaleFactor2;
  var page = 0;
  var pagesContext = [];
  var events = new PubSub(API);
  var hotfixes = options.hotfixes || [];
  var renderTargets = {};
  var renderTargetMap = {};
  var renderTargetStack = [];
  var pageX;
  var pageY;
  var pageMatrix;
  var Matrix3 = function Matrix4(sx, shy, shx, sy, tx, ty) {
    if (!(this instanceof Matrix4)) {
      return new Matrix4(sx, shy, shx, sy, tx, ty);
    }
    if (isNaN(sx))
      sx = 1;
    if (isNaN(shy))
      shy = 0;
    if (isNaN(shx))
      shx = 0;
    if (isNaN(sy))
      sy = 1;
    if (isNaN(tx))
      tx = 0;
    if (isNaN(ty))
      ty = 0;
    this._matrix = [sx, shy, shx, sy, tx, ty];
  };
  Object.defineProperty(Matrix3.prototype, "sx", {
    get: function get() {
      return this._matrix[0];
    },
    set: function set(value) {
      this._matrix[0] = value;
    }
  });
  Object.defineProperty(Matrix3.prototype, "shy", {
    get: function get() {
      return this._matrix[1];
    },
    set: function set(value) {
      this._matrix[1] = value;
    }
  });
  Object.defineProperty(Matrix3.prototype, "shx", {
    get: function get() {
      return this._matrix[2];
    },
    set: function set(value) {
      this._matrix[2] = value;
    }
  });
  Object.defineProperty(Matrix3.prototype, "sy", {
    get: function get() {
      return this._matrix[3];
    },
    set: function set(value) {
      this._matrix[3] = value;
    }
  });
  Object.defineProperty(Matrix3.prototype, "tx", {
    get: function get() {
      return this._matrix[4];
    },
    set: function set(value) {
      this._matrix[4] = value;
    }
  });
  Object.defineProperty(Matrix3.prototype, "ty", {
    get: function get() {
      return this._matrix[5];
    },
    set: function set(value) {
      this._matrix[5] = value;
    }
  });
  Object.defineProperty(Matrix3.prototype, "a", {
    get: function get() {
      return this._matrix[0];
    },
    set: function set(value) {
      this._matrix[0] = value;
    }
  });
  Object.defineProperty(Matrix3.prototype, "b", {
    get: function get() {
      return this._matrix[1];
    },
    set: function set(value) {
      this._matrix[1] = value;
    }
  });
  Object.defineProperty(Matrix3.prototype, "c", {
    get: function get() {
      return this._matrix[2];
    },
    set: function set(value) {
      this._matrix[2] = value;
    }
  });
  Object.defineProperty(Matrix3.prototype, "d", {
    get: function get() {
      return this._matrix[3];
    },
    set: function set(value) {
      this._matrix[3] = value;
    }
  });
  Object.defineProperty(Matrix3.prototype, "e", {
    get: function get() {
      return this._matrix[4];
    },
    set: function set(value) {
      this._matrix[4] = value;
    }
  });
  Object.defineProperty(Matrix3.prototype, "f", {
    get: function get() {
      return this._matrix[5];
    },
    set: function set(value) {
      this._matrix[5] = value;
    }
  });
  Object.defineProperty(Matrix3.prototype, "rotation", {
    get: function get() {
      return Math.atan2(this.shx, this.sx);
    }
  });
  Object.defineProperty(Matrix3.prototype, "scaleX", {
    get: function get() {
      return this.decompose().scale.sx;
    }
  });
  Object.defineProperty(Matrix3.prototype, "scaleY", {
    get: function get() {
      return this.decompose().scale.sy;
    }
  });
  Object.defineProperty(Matrix3.prototype, "isIdentity", {
    get: function get() {
      if (this.sx !== 1) {
        return false;
      }
      if (this.shy !== 0) {
        return false;
      }
      if (this.shx !== 0) {
        return false;
      }
      if (this.sy !== 1) {
        return false;
      }
      if (this.tx !== 0) {
        return false;
      }
      if (this.ty !== 0) {
        return false;
      }
      return true;
    }
  });
  Matrix3.prototype.join = function(separator) {
    return [this.sx, this.shy, this.shx, this.sy, this.tx, this.ty].map(hpf).join(separator);
  };
  Matrix3.prototype.multiply = function(matrix) {
    var sx = matrix.sx * this.sx + matrix.shy * this.shx;
    var shy = matrix.sx * this.shy + matrix.shy * this.sy;
    var shx = matrix.shx * this.sx + matrix.sy * this.shx;
    var sy = matrix.shx * this.shy + matrix.sy * this.sy;
    var tx = matrix.tx * this.sx + matrix.ty * this.shx + this.tx;
    var ty = matrix.tx * this.shy + matrix.ty * this.sy + this.ty;
    return new Matrix3(sx, shy, shx, sy, tx, ty);
  };
  Matrix3.prototype.decompose = function() {
    var a2 = this.sx;
    var b = this.shy;
    var c3 = this.shx;
    var d = this.sy;
    var e2 = this.tx;
    var f4 = this.ty;
    var scaleX = Math.sqrt(a2 * a2 + b * b);
    a2 /= scaleX;
    b /= scaleX;
    var shear = a2 * c3 + b * d;
    c3 -= a2 * shear;
    d -= b * shear;
    var scaleY = Math.sqrt(c3 * c3 + d * d);
    c3 /= scaleY;
    d /= scaleY;
    shear /= scaleY;
    if (a2 * d < b * c3) {
      a2 = -a2;
      b = -b;
      shear = -shear;
      scaleX = -scaleX;
    }
    return {
      scale: new Matrix3(scaleX, 0, 0, scaleY, 0, 0),
      translate: new Matrix3(1, 0, 0, 1, e2, f4),
      rotate: new Matrix3(a2, b, -b, a2, 0, 0),
      skew: new Matrix3(1, 0, shear, 1, 0, 0)
    };
  };
  Matrix3.prototype.toString = function(parmPrecision) {
    return this.join(" ");
  };
  Matrix3.prototype.inversed = function() {
    var a2 = this.sx, b = this.shy, c3 = this.shx, d = this.sy, e2 = this.tx, f4 = this.ty;
    var quot = 1 / (a2 * d - b * c3);
    var aInv = d * quot;
    var bInv = -b * quot;
    var cInv = -c3 * quot;
    var dInv = a2 * quot;
    var eInv = -aInv * e2 - cInv * f4;
    var fInv = -bInv * e2 - dInv * f4;
    return new Matrix3(aInv, bInv, cInv, dInv, eInv, fInv);
  };
  Matrix3.prototype.applyToPoint = function(pt) {
    var x2 = pt.x * this.sx + pt.y * this.shx + this.tx;
    var y3 = pt.x * this.shy + pt.y * this.sy + this.ty;
    return new Point3(x2, y3);
  };
  Matrix3.prototype.applyToRectangle = function(rect) {
    var pt1 = this.applyToPoint(rect);
    var pt2 = this.applyToPoint(new Point3(rect.x + rect.w, rect.y + rect.h));
    return new Rectangle(pt1.x, pt1.y, pt2.x - pt1.x, pt2.y - pt1.y);
  };
  Matrix3.prototype.clone = function() {
    var sx = this.sx;
    var shy = this.shy;
    var shx = this.shx;
    var sy = this.sy;
    var tx = this.tx;
    var ty = this.ty;
    return new Matrix3(sx, shy, shx, sy, tx, ty);
  };
  API.Matrix = Matrix3;
  var matrixMult = API.matrixMult = function(m1, m22) {
    return m22.multiply(m1);
  };
  var identityMatrix = new Matrix3(1, 0, 0, 1, 0, 0);
  API.unitMatrix = API.identityMatrix = identityMatrix;
  var addPattern = function addPattern2(key, pattern) {
    if (patternMap[key])
      return;
    var prefix = pattern instanceof ShadingPattern ? "Sh" : "P";
    var patternKey = prefix + (Object.keys(patterns).length + 1).toString(10);
    pattern.id = patternKey;
    patternMap[key] = patternKey;
    patterns[patternKey] = pattern;
    events.publish("addPattern", pattern);
  };
  API.ShadingPattern = ShadingPattern;
  API.TilingPattern = TilingPattern;
  API.addShadingPattern = function(key, pattern) {
    advancedApiModeTrap("addShadingPattern()");
    addPattern(key, pattern);
    return this;
  };
  API.beginTilingPattern = function(pattern) {
    advancedApiModeTrap("beginTilingPattern()");
    beginNewRenderTarget(pattern.boundingBox[0], pattern.boundingBox[1], pattern.boundingBox[2] - pattern.boundingBox[0], pattern.boundingBox[3] - pattern.boundingBox[1], pattern.matrix);
  };
  API.endTilingPattern = function(key, pattern) {
    advancedApiModeTrap("endTilingPattern()");
    pattern.stream = pages[currentPage].join("\n");
    addPattern(key, pattern);
    events.publish("endTilingPattern", pattern);
    renderTargetStack.pop().restore();
  };
  var newObject = API.__private__.newObject = function() {
    var oid = newObjectDeferred();
    newObjectDeferredBegin(oid, true);
    return oid;
  };
  var newObjectDeferred = API.__private__.newObjectDeferred = function() {
    objectNumber++;
    offsets[objectNumber] = function() {
      return contentLength;
    };
    return objectNumber;
  };
  var newObjectDeferredBegin = function newObjectDeferredBegin2(oid, doOutput) {
    doOutput = typeof doOutput === "boolean" ? doOutput : false;
    offsets[oid] = contentLength;
    if (doOutput) {
      out(oid + " 0 obj");
    }
    return oid;
  };
  var newAdditionalObject = API.__private__.newAdditionalObject = function() {
    var objId = newObjectDeferred();
    var obj = {
      objId,
      content: ""
    };
    additionalObjects.push(obj);
    return obj;
  };
  var rootDictionaryObjId = newObjectDeferred();
  var resourceDictionaryObjId = newObjectDeferred();
  var decodeColorString = API.__private__.decodeColorString = function(color) {
    var colorEncoded = color.split(" ");
    if (colorEncoded.length === 2 && (colorEncoded[1] === "g" || colorEncoded[1] === "G")) {
      var floatVal = parseFloat(colorEncoded[0]);
      colorEncoded = [floatVal, floatVal, floatVal, "r"];
    } else if (colorEncoded.length === 5 && (colorEncoded[4] === "k" || colorEncoded[4] === "K")) {
      var red = (1 - colorEncoded[0]) * (1 - colorEncoded[3]);
      var green = (1 - colorEncoded[1]) * (1 - colorEncoded[3]);
      var blue = (1 - colorEncoded[2]) * (1 - colorEncoded[3]);
      colorEncoded = [red, green, blue, "r"];
    }
    var colorAsRGB = "#";
    for (var i2 = 0; i2 < 3; i2++) {
      colorAsRGB += ("0" + Math.floor(parseFloat(colorEncoded[i2]) * 255).toString(16)).slice(-2);
    }
    return colorAsRGB;
  };
  var encodeColorString = API.__private__.encodeColorString = function(options2) {
    var color;
    if (typeof options2 === "string") {
      options2 = {
        ch1: options2
      };
    }
    var ch1 = options2.ch1;
    var ch2 = options2.ch2;
    var ch3 = options2.ch3;
    var ch4 = options2.ch4;
    var letterArray = options2.pdfColorType === "draw" ? ["G", "RG", "K"] : ["g", "rg", "k"];
    if (typeof ch1 === "string" && ch1.charAt(0) !== "#") {
      var rgbColor = new RGBColor3(ch1);
      if (rgbColor.ok) {
        ch1 = rgbColor.toHex();
      } else if (!/^\d*\.?\d*$/.test(ch1)) {
        throw new Error('Invalid color "' + ch1 + '" passed to jsPDF.encodeColorString.');
      }
    }
    if (typeof ch1 === "string" && /^#[0-9A-Fa-f]{3}$/.test(ch1)) {
      ch1 = "#" + ch1[1] + ch1[1] + ch1[2] + ch1[2] + ch1[3] + ch1[3];
    }
    if (typeof ch1 === "string" && /^#[0-9A-Fa-f]{6}$/.test(ch1)) {
      var hex3 = parseInt(ch1.substr(1), 16);
      ch1 = hex3 >> 16 & 255;
      ch2 = hex3 >> 8 & 255;
      ch3 = hex3 & 255;
    }
    if (typeof ch2 === "undefined" || typeof ch4 === "undefined" && ch1 === ch2 && ch2 === ch3) {
      if (typeof ch1 === "string") {
        color = ch1 + " " + letterArray[0];
      } else {
        switch (options2.precision) {
          case 2:
            color = f23(ch1 / 255) + " " + letterArray[0];
            break;
          case 3:
          default:
            color = f3(ch1 / 255) + " " + letterArray[0];
        }
      }
    } else if (typeof ch4 === "undefined" || _typeof(ch4) === "object") {
      if (ch4 && !isNaN(ch4.a)) {
        if (ch4.a === 0) {
          color = ["1.", "1.", "1.", letterArray[1]].join(" ");
          return color;
        }
      }
      if (typeof ch1 === "string") {
        color = [ch1, ch2, ch3, letterArray[1]].join(" ");
      } else {
        switch (options2.precision) {
          case 2:
            color = [f23(ch1 / 255), f23(ch2 / 255), f23(ch3 / 255), letterArray[1]].join(" ");
            break;
          default:
          case 3:
            color = [f3(ch1 / 255), f3(ch2 / 255), f3(ch3 / 255), letterArray[1]].join(" ");
        }
      }
    } else {
      if (typeof ch1 === "string") {
        color = [ch1, ch2, ch3, ch4, letterArray[2]].join(" ");
      } else {
        switch (options2.precision) {
          case 2:
            color = [f23(ch1), f23(ch2), f23(ch3), f23(ch4), letterArray[2]].join(" ");
            break;
          case 3:
          default:
            color = [f3(ch1), f3(ch2), f3(ch3), f3(ch4), letterArray[2]].join(" ");
        }
      }
    }
    return color;
  };
  var getFilters = API.__private__.getFilters = function() {
    return filters;
  };
  var putStream = API.__private__.putStream = function(options2) {
    options2 = options2 || {};
    var data2 = options2.data || "";
    var filters2 = options2.filters || getFilters();
    var alreadyAppliedFilters = options2.alreadyAppliedFilters || [];
    var addLength1 = options2.addLength1 || false;
    var valueOfLength1 = data2.length;
    var objectId = options2.objectId;
    var encryptor = function encryptor2(data3) {
      return data3;
    };
    if (encryptionOptions !== null && typeof objectId == "undefined") {
      throw new Error("ObjectId must be passed to putStream for file encryption");
    }
    if (encryptionOptions !== null) {
      encryptor = encryption.encryptor(objectId, 0);
    }
    var processedData = {};
    if (filters2 === true) {
      filters2 = ["FlateEncode"];
    }
    var keyValues = options2.additionalKeyValues || [];
    if (typeof jsPDF.API.processDataByFilters !== "undefined") {
      processedData = jsPDF.API.processDataByFilters(data2, filters2);
    } else {
      processedData = {
        data: data2,
        reverseChain: []
      };
    }
    var filterAsString = processedData.reverseChain + (Array.isArray(alreadyAppliedFilters) ? alreadyAppliedFilters.join(" ") : alreadyAppliedFilters.toString());
    if (processedData.data.length !== 0) {
      keyValues.push({
        key: "Length",
        value: processedData.data.length
      });
      if (addLength1 === true) {
        keyValues.push({
          key: "Length1",
          value: valueOfLength1
        });
      }
    }
    if (filterAsString.length != 0) {
      if (filterAsString.split("/").length - 1 === 1) {
        keyValues.push({
          key: "Filter",
          value: filterAsString
        });
      } else {
        keyValues.push({
          key: "Filter",
          value: "[" + filterAsString + "]"
        });
        for (var j = 0; j < keyValues.length; j += 1) {
          if (keyValues[j].key === "DecodeParms") {
            var decodeParmsArray = [];
            for (var i2 = 0; i2 < processedData.reverseChain.split("/").length - 1; i2 += 1) {
              decodeParmsArray.push("null");
            }
            decodeParmsArray.push(keyValues[j].value);
            keyValues[j].value = "[" + decodeParmsArray.join(" ") + "]";
          }
        }
      }
    }
    out("<<");
    for (var k = 0; k < keyValues.length; k++) {
      out("/" + keyValues[k].key + " " + keyValues[k].value);
    }
    out(">>");
    if (processedData.data.length !== 0) {
      out("stream");
      out(encryptor(processedData.data));
      out("endstream");
    }
  };
  var putPage = API.__private__.putPage = function(page2) {
    var pageNumber = page2.number;
    var data2 = page2.data;
    var pageObjectNumber = page2.objId;
    var pageContentsObjId = page2.contentsObjId;
    newObjectDeferredBegin(pageObjectNumber, true);
    out("<</Type /Page");
    out("/Parent " + page2.rootDictionaryObjId + " 0 R");
    out("/Resources " + page2.resourceDictionaryObjId + " 0 R");
    out("/MediaBox [" + parseFloat(hpf(page2.mediaBox.bottomLeftX)) + " " + parseFloat(hpf(page2.mediaBox.bottomLeftY)) + " " + hpf(page2.mediaBox.topRightX) + " " + hpf(page2.mediaBox.topRightY) + "]");
    if (page2.cropBox !== null) {
      out("/CropBox [" + hpf(page2.cropBox.bottomLeftX) + " " + hpf(page2.cropBox.bottomLeftY) + " " + hpf(page2.cropBox.topRightX) + " " + hpf(page2.cropBox.topRightY) + "]");
    }
    if (page2.bleedBox !== null) {
      out("/BleedBox [" + hpf(page2.bleedBox.bottomLeftX) + " " + hpf(page2.bleedBox.bottomLeftY) + " " + hpf(page2.bleedBox.topRightX) + " " + hpf(page2.bleedBox.topRightY) + "]");
    }
    if (page2.trimBox !== null) {
      out("/TrimBox [" + hpf(page2.trimBox.bottomLeftX) + " " + hpf(page2.trimBox.bottomLeftY) + " " + hpf(page2.trimBox.topRightX) + " " + hpf(page2.trimBox.topRightY) + "]");
    }
    if (page2.artBox !== null) {
      out("/ArtBox [" + hpf(page2.artBox.bottomLeftX) + " " + hpf(page2.artBox.bottomLeftY) + " " + hpf(page2.artBox.topRightX) + " " + hpf(page2.artBox.topRightY) + "]");
    }
    if (typeof page2.userUnit === "number" && page2.userUnit !== 1) {
      out("/UserUnit " + page2.userUnit);
    }
    events.publish("putPage", {
      objId: pageObjectNumber,
      pageContext: pagesContext[pageNumber],
      pageNumber,
      page: data2
    });
    out("/Contents " + pageContentsObjId + " 0 R");
    out(">>");
    out("endobj");
    var pageContent = data2.join("\n");
    if (apiMode === ApiMode.ADVANCED) {
      pageContent += "\nQ";
    }
    newObjectDeferredBegin(pageContentsObjId, true);
    putStream({
      data: pageContent,
      filters: getFilters(),
      objectId: pageContentsObjId
    });
    out("endobj");
    return pageObjectNumber;
  };
  var putPages = API.__private__.putPages = function() {
    var n2, i2, pageObjectNumbers = [];
    for (n2 = 1; n2 <= page; n2++) {
      pagesContext[n2].objId = newObjectDeferred();
      pagesContext[n2].contentsObjId = newObjectDeferred();
    }
    for (n2 = 1; n2 <= page; n2++) {
      pageObjectNumbers.push(putPage({
        number: n2,
        data: pages[n2],
        objId: pagesContext[n2].objId,
        contentsObjId: pagesContext[n2].contentsObjId,
        mediaBox: pagesContext[n2].mediaBox,
        cropBox: pagesContext[n2].cropBox,
        bleedBox: pagesContext[n2].bleedBox,
        trimBox: pagesContext[n2].trimBox,
        artBox: pagesContext[n2].artBox,
        userUnit: pagesContext[n2].userUnit,
        rootDictionaryObjId,
        resourceDictionaryObjId
      }));
    }
    newObjectDeferredBegin(rootDictionaryObjId, true);
    out("<</Type /Pages");
    var kids = "/Kids [";
    for (i2 = 0; i2 < page; i2++) {
      kids += pageObjectNumbers[i2] + " 0 R ";
    }
    out(kids + "]");
    out("/Count " + page);
    out(">>");
    out("endobj");
    events.publish("postPutPages");
  };
  var putFont = function putFont2(font) {
    events.publish("putFont", {
      font,
      out,
      newObject,
      putStream
    });
    if (font.isAlreadyPutted !== true) {
      font.objectNumber = newObject();
      out("<<");
      out("/Type /Font");
      out("/BaseFont /" + toPDFName(font.postScriptName));
      out("/Subtype /Type1");
      if (typeof font.encoding === "string") {
        out("/Encoding /" + font.encoding);
      }
      out("/FirstChar 32");
      out("/LastChar 255");
      out(">>");
      out("endobj");
    }
  };
  var putFonts = function putFonts2() {
    for (var fontKey in fonts) {
      if (fonts.hasOwnProperty(fontKey)) {
        if (putOnlyUsedFonts === false || putOnlyUsedFonts === true && usedFonts.hasOwnProperty(fontKey)) {
          putFont(fonts[fontKey]);
        }
      }
    }
  };
  var putXObject = function putXObject2(xObject) {
    xObject.objectNumber = newObject();
    var options2 = [];
    options2.push({
      key: "Type",
      value: "/XObject"
    });
    options2.push({
      key: "Subtype",
      value: "/Form"
    });
    options2.push({
      key: "BBox",
      value: "[" + [hpf(xObject.x), hpf(xObject.y), hpf(xObject.x + xObject.width), hpf(xObject.y + xObject.height)].join(" ") + "]"
    });
    options2.push({
      key: "Matrix",
      value: "[" + xObject.matrix.toString() + "]"
    });
    var stream = xObject.pages[1].join("\n");
    putStream({
      data: stream,
      additionalKeyValues: options2,
      objectId: xObject.objectNumber
    });
    out("endobj");
  };
  var putXObjects = function putXObjects2() {
    for (var xObjectKey in renderTargets) {
      if (renderTargets.hasOwnProperty(xObjectKey)) {
        putXObject(renderTargets[xObjectKey]);
      }
    }
  };
  var interpolateAndEncodeRGBStream = function interpolateAndEncodeRGBStream2(colors, numberSamples) {
    var tValues = [];
    var t2;
    var dT = 1 / (numberSamples - 1);
    for (t2 = 0; t2 < 1; t2 += dT) {
      tValues.push(t2);
    }
    tValues.push(1);
    if (colors[0].offset != 0) {
      var c0 = {
        offset: 0,
        color: colors[0].color
      };
      colors.unshift(c0);
    }
    if (colors[colors.length - 1].offset != 1) {
      var c1 = {
        offset: 1,
        color: colors[colors.length - 1].color
      };
      colors.push(c1);
    }
    var out2 = "";
    var index3 = 0;
    for (var i2 = 0; i2 < tValues.length; i2++) {
      t2 = tValues[i2];
      while (t2 > colors[index3 + 1].offset) {
        index3++;
      }
      var a2 = colors[index3].offset;
      var b = colors[index3 + 1].offset;
      var d = (t2 - a2) / (b - a2);
      var aColor = colors[index3].color;
      var bColor = colors[index3 + 1].color;
      out2 += padd2Hex(Math.round((1 - d) * aColor[0] + d * bColor[0]).toString(16)) + padd2Hex(Math.round((1 - d) * aColor[1] + d * bColor[1]).toString(16)) + padd2Hex(Math.round((1 - d) * aColor[2] + d * bColor[2]).toString(16));
    }
    return out2.trim();
  };
  var putShadingPattern = function putShadingPattern2(pattern, numberSamples) {
    numberSamples || (numberSamples = 21);
    var funcObjectNumber = newObject();
    var stream = interpolateAndEncodeRGBStream(pattern.colors, numberSamples);
    var options2 = [];
    options2.push({
      key: "FunctionType",
      value: "0"
    });
    options2.push({
      key: "Domain",
      value: "[0.0 1.0]"
    });
    options2.push({
      key: "Size",
      value: "[" + numberSamples + "]"
    });
    options2.push({
      key: "BitsPerSample",
      value: "8"
    });
    options2.push({
      key: "Range",
      value: "[0.0 1.0 0.0 1.0 0.0 1.0]"
    });
    options2.push({
      key: "Decode",
      value: "[0.0 1.0 0.0 1.0 0.0 1.0]"
    });
    putStream({
      data: stream,
      additionalKeyValues: options2,
      alreadyAppliedFilters: ["/ASCIIHexDecode"],
      objectId: funcObjectNumber
    });
    out("endobj");
    pattern.objectNumber = newObject();
    out("<< /ShadingType " + pattern.type);
    out("/ColorSpace /DeviceRGB");
    var coords = "/Coords [" + hpf(parseFloat(pattern.coords[0])) + " " + // x1
    hpf(parseFloat(pattern.coords[1])) + " ";
    if (pattern.type === 2) {
      coords += hpf(parseFloat(pattern.coords[2])) + " " + // x2
      hpf(parseFloat(pattern.coords[3]));
    } else {
      coords += hpf(parseFloat(pattern.coords[2])) + " " + // r1
      hpf(parseFloat(pattern.coords[3])) + " " + // x2
      hpf(parseFloat(pattern.coords[4])) + " " + // y2
      hpf(parseFloat(pattern.coords[5]));
    }
    coords += "]";
    out(coords);
    if (pattern.matrix) {
      out("/Matrix [" + pattern.matrix.toString() + "]");
    }
    out("/Function " + funcObjectNumber + " 0 R");
    out("/Extend [true true]");
    out(">>");
    out("endobj");
  };
  var putTilingPattern = function putTilingPattern2(pattern, deferredResourceDictionaryIds) {
    var resourcesObjectId = newObjectDeferred();
    var patternObjectId = newObject();
    deferredResourceDictionaryIds.push({
      resourcesOid: resourcesObjectId,
      objectOid: patternObjectId
    });
    pattern.objectNumber = patternObjectId;
    var options2 = [];
    options2.push({
      key: "Type",
      value: "/Pattern"
    });
    options2.push({
      key: "PatternType",
      value: "1"
    });
    options2.push({
      key: "PaintType",
      value: "1"
    });
    options2.push({
      key: "TilingType",
      value: "1"
    });
    options2.push({
      key: "BBox",
      value: "[" + pattern.boundingBox.map(hpf).join(" ") + "]"
    });
    options2.push({
      key: "XStep",
      value: hpf(pattern.xStep)
    });
    options2.push({
      key: "YStep",
      value: hpf(pattern.yStep)
    });
    options2.push({
      key: "Resources",
      value: resourcesObjectId + " 0 R"
    });
    if (pattern.matrix) {
      options2.push({
        key: "Matrix",
        value: "[" + pattern.matrix.toString() + "]"
      });
    }
    putStream({
      data: pattern.stream,
      additionalKeyValues: options2,
      objectId: pattern.objectNumber
    });
    out("endobj");
  };
  var putPatterns = function putPatterns2(deferredResourceDictionaryIds) {
    var patternKey;
    for (patternKey in patterns) {
      if (patterns.hasOwnProperty(patternKey)) {
        if (patterns[patternKey] instanceof ShadingPattern) {
          putShadingPattern(patterns[patternKey]);
        } else if (patterns[patternKey] instanceof TilingPattern) {
          putTilingPattern(patterns[patternKey], deferredResourceDictionaryIds);
        }
      }
    }
  };
  var putGState = function putGState2(gState) {
    gState.objectNumber = newObject();
    out("<<");
    for (var p2 in gState) {
      switch (p2) {
        case "opacity":
          out("/ca " + f23(gState[p2]));
          break;
        case "stroke-opacity":
          out("/CA " + f23(gState[p2]));
          break;
      }
    }
    out(">>");
    out("endobj");
  };
  var putGStates = function putGStates2() {
    var gStateKey;
    for (gStateKey in gStates) {
      if (gStates.hasOwnProperty(gStateKey)) {
        putGState(gStates[gStateKey]);
      }
    }
  };
  var putXobjectDict = function putXobjectDict2() {
    out("/XObject <<");
    for (var xObjectKey in renderTargets) {
      if (renderTargets.hasOwnProperty(xObjectKey) && renderTargets[xObjectKey].objectNumber >= 0) {
        out("/" + xObjectKey + " " + renderTargets[xObjectKey].objectNumber + " 0 R");
      }
    }
    events.publish("putXobjectDict");
    out(">>");
  };
  var putEncryptionDict = function putEncryptionDict2() {
    encryption.oid = newObject();
    out("<<");
    out("/Filter /Standard");
    out("/V " + encryption.v);
    out("/R " + encryption.r);
    out("/U <" + encryption.toHexString(encryption.U) + ">");
    out("/O <" + encryption.toHexString(encryption.O) + ">");
    out("/P " + encryption.P);
    out(">>");
    out("endobj");
  };
  var putFontDict = function putFontDict2() {
    out("/Font <<");
    for (var fontKey in fonts) {
      if (fonts.hasOwnProperty(fontKey)) {
        if (putOnlyUsedFonts === false || putOnlyUsedFonts === true && usedFonts.hasOwnProperty(fontKey)) {
          out("/" + fontKey + " " + fonts[fontKey].objectNumber + " 0 R");
        }
      }
    }
    out(">>");
  };
  var putShadingPatternDict = function putShadingPatternDict2() {
    if (Object.keys(patterns).length > 0) {
      out("/Shading <<");
      for (var patternKey in patterns) {
        if (patterns.hasOwnProperty(patternKey) && patterns[patternKey] instanceof ShadingPattern && patterns[patternKey].objectNumber >= 0) {
          out("/" + patternKey + " " + patterns[patternKey].objectNumber + " 0 R");
        }
      }
      events.publish("putShadingPatternDict");
      out(">>");
    }
  };
  var putTilingPatternDict = function putTilingPatternDict2(objectOid) {
    if (Object.keys(patterns).length > 0) {
      out("/Pattern <<");
      for (var patternKey in patterns) {
        if (patterns.hasOwnProperty(patternKey) && patterns[patternKey] instanceof API.TilingPattern && patterns[patternKey].objectNumber >= 0 && patterns[patternKey].objectNumber < objectOid) {
          out("/" + patternKey + " " + patterns[patternKey].objectNumber + " 0 R");
        }
      }
      events.publish("putTilingPatternDict");
      out(">>");
    }
  };
  var putGStatesDict = function putGStatesDict2() {
    if (Object.keys(gStates).length > 0) {
      var gStateKey;
      out("/ExtGState <<");
      for (gStateKey in gStates) {
        if (gStates.hasOwnProperty(gStateKey) && gStates[gStateKey].objectNumber >= 0) {
          out("/" + gStateKey + " " + gStates[gStateKey].objectNumber + " 0 R");
        }
      }
      events.publish("putGStateDict");
      out(">>");
    }
  };
  var putResourceDictionary = function putResourceDictionary2(objectIds) {
    newObjectDeferredBegin(objectIds.resourcesOid, true);
    out("<<");
    out("/ProcSet [/PDF /Text /ImageB /ImageC /ImageI]");
    putFontDict();
    putShadingPatternDict();
    putTilingPatternDict(objectIds.objectOid);
    putGStatesDict();
    putXobjectDict();
    out(">>");
    out("endobj");
  };
  var putResources = function putResources2() {
    var deferredResourceDictionaryIds = [];
    putFonts();
    putGStates();
    putXObjects();
    putPatterns(deferredResourceDictionaryIds);
    events.publish("putResources");
    deferredResourceDictionaryIds.forEach(putResourceDictionary);
    putResourceDictionary({
      resourcesOid: resourceDictionaryObjId,
      objectOid: Number.MAX_SAFE_INTEGER
      // output all objects
    });
    events.publish("postPutResources");
  };
  var putAdditionalObjects = function putAdditionalObjects2() {
    events.publish("putAdditionalObjects");
    for (var i2 = 0; i2 < additionalObjects.length; i2++) {
      var obj = additionalObjects[i2];
      newObjectDeferredBegin(obj.objId, true);
      out(obj.content);
      out("endobj");
    }
    events.publish("postPutAdditionalObjects");
  };
  var addFontToFontDictionary = function addFontToFontDictionary2(font) {
    fontmap[font.fontName] = fontmap[font.fontName] || {};
    fontmap[font.fontName][font.fontStyle] = font.id;
  };
  var addFont = function addFont2(postScriptName, fontName, fontStyle, encoding, isStandardFont) {
    var font = {
      id: "F" + (Object.keys(fonts).length + 1).toString(10),
      postScriptName,
      fontName,
      fontStyle,
      encoding,
      isStandardFont: isStandardFont || false,
      metadata: {}
    };
    events.publish("addFont", {
      font,
      instance: this
    });
    fonts[font.id] = font;
    addFontToFontDictionary(font);
    return font.id;
  };
  var addFonts = function addFonts2(arrayOfFonts) {
    for (var i2 = 0, l2 = standardFonts.length; i2 < l2; i2++) {
      var fontKey = addFont.call(this, arrayOfFonts[i2][0], arrayOfFonts[i2][1], arrayOfFonts[i2][2], standardFonts[i2][3], true);
      if (putOnlyUsedFonts === false) {
        usedFonts[fontKey] = true;
      }
      var parts = arrayOfFonts[i2][0].split("-");
      addFontToFontDictionary({
        id: fontKey,
        fontName: parts[0],
        fontStyle: parts[1] || ""
      });
    }
    events.publish("addFonts", {
      fonts,
      dictionary: fontmap
    });
  };
  var SAFE = function __safeCall(fn) {
    fn.foo = function __safeCallWrapper() {
      try {
        return fn.apply(this, arguments);
      } catch (e2) {
        var stack = e2.stack || "";
        if (~stack.indexOf(" at "))
          stack = stack.split(" at ")[1];
        var m3 = "Error in function " + stack.split("\n")[0].split("<")[0] + ": " + e2.message;
        if (globalObject.console) {
          globalObject.console.error(m3, e2);
          if (globalObject.alert)
            alert(m3);
        } else {
          throw new Error(m3);
        }
      }
    };
    fn.foo.bar = fn;
    return fn.foo;
  };
  var to8bitStream = function to8bitStream2(text4, flags) {
    var i2, l2, sourceEncoding, encodingBlock, outputEncoding, newtext, isUnicode, ch, bch;
    flags = flags || {};
    sourceEncoding = flags.sourceEncoding || "Unicode";
    outputEncoding = flags.outputEncoding;
    if ((flags.autoencode || outputEncoding) && fonts[activeFontKey].metadata && fonts[activeFontKey].metadata[sourceEncoding] && fonts[activeFontKey].metadata[sourceEncoding].encoding) {
      encodingBlock = fonts[activeFontKey].metadata[sourceEncoding].encoding;
      if (!outputEncoding && fonts[activeFontKey].encoding) {
        outputEncoding = fonts[activeFontKey].encoding;
      }
      if (!outputEncoding && encodingBlock.codePages) {
        outputEncoding = encodingBlock.codePages[0];
      }
      if (typeof outputEncoding === "string") {
        outputEncoding = encodingBlock[outputEncoding];
      }
      if (outputEncoding) {
        isUnicode = false;
        newtext = [];
        for (i2 = 0, l2 = text4.length; i2 < l2; i2++) {
          ch = outputEncoding[text4.charCodeAt(i2)];
          if (ch) {
            newtext.push(String.fromCharCode(ch));
          } else {
            newtext.push(text4[i2]);
          }
          if (newtext[i2].charCodeAt(0) >> 8) {
            isUnicode = true;
          }
        }
        text4 = newtext.join("");
      }
    }
    i2 = text4.length;
    while (isUnicode === void 0 && i2 !== 0) {
      if (text4.charCodeAt(i2 - 1) >> 8) {
        isUnicode = true;
      }
      i2--;
    }
    if (!isUnicode) {
      return text4;
    }
    newtext = flags.noBOM ? [] : [254, 255];
    for (i2 = 0, l2 = text4.length; i2 < l2; i2++) {
      ch = text4.charCodeAt(i2);
      bch = ch >> 8;
      if (bch >> 8) {
        throw new Error("Character at position " + i2 + " of string '" + text4 + "' exceeds 16bits. Cannot be encoded into UCS-2 BE");
      }
      newtext.push(bch);
      newtext.push(ch - (bch << 8));
    }
    return String.fromCharCode.apply(void 0, newtext);
  };
  var pdfEscape3 = API.__private__.pdfEscape = API.pdfEscape = function(text4, flags) {
    return to8bitStream(text4, flags).replace(/\\/g, "\\\\").replace(/\(/g, "\\(").replace(/\)/g, "\\)");
  };
  var beginPage = API.__private__.beginPage = function(format2) {
    pages[++page] = [];
    pagesContext[page] = {
      objId: 0,
      contentsObjId: 0,
      userUnit: Number(userUnit),
      artBox: null,
      bleedBox: null,
      cropBox: null,
      trimBox: null,
      mediaBox: {
        bottomLeftX: 0,
        bottomLeftY: 0,
        topRightX: Number(format2[0]),
        topRightY: Number(format2[1])
      }
    };
    _setPage(page);
    setOutputDestination(pages[currentPage]);
  };
  var _addPage = function _addPage2(parmFormat, parmOrientation) {
    var dimensions, width2, height2;
    orientation = parmOrientation || orientation;
    if (typeof parmFormat === "string") {
      dimensions = getPageFormat(parmFormat.toLowerCase());
      if (Array.isArray(dimensions)) {
        width2 = dimensions[0];
        height2 = dimensions[1];
      }
    }
    if (Array.isArray(parmFormat)) {
      width2 = parmFormat[0] * scaleFactor2;
      height2 = parmFormat[1] * scaleFactor2;
    }
    if (isNaN(width2)) {
      width2 = format[0];
      height2 = format[1];
    }
    if (width2 > 14400 || height2 > 14400) {
      console2.warn("A page in a PDF can not be wider or taller than 14400 userUnit. jsPDF limits the width/height to 14400");
      width2 = Math.min(14400, width2);
      height2 = Math.min(14400, height2);
    }
    format = [width2, height2];
    switch (orientation.substr(0, 1)) {
      case "l":
        if (height2 > width2) {
          format = [height2, width2];
        }
        break;
      case "p":
        if (width2 > height2) {
          format = [height2, width2];
        }
        break;
    }
    beginPage(format);
    setLineWidth(lineWidth);
    out(strokeColor);
    if (lineCapID !== 0) {
      out(lineCapID + " J");
    }
    if (lineJoinID !== 0) {
      out(lineJoinID + " j");
    }
    events.publish("addPage", {
      pageNumber: page
    });
  };
  var _deletePage = function _deletePage2(n2) {
    if (n2 > 0 && n2 <= page) {
      pages.splice(n2, 1);
      pagesContext.splice(n2, 1);
      page--;
      if (currentPage > page) {
        currentPage = page;
      }
      this.setPage(currentPage);
    }
  };
  var _setPage = function _setPage2(n2) {
    if (n2 > 0 && n2 <= page) {
      currentPage = n2;
    }
  };
  var getNumberOfPages = API.__private__.getNumberOfPages = API.getNumberOfPages = function() {
    return pages.length - 1;
  };
  var getFont = function getFont2(fontName, fontStyle, options2) {
    var key = void 0, fontNameLowerCase;
    options2 = options2 || {};
    fontName = fontName !== void 0 ? fontName : fonts[activeFontKey].fontName;
    fontStyle = fontStyle !== void 0 ? fontStyle : fonts[activeFontKey].fontStyle;
    fontNameLowerCase = fontName.toLowerCase();
    if (fontmap[fontNameLowerCase] !== void 0 && fontmap[fontNameLowerCase][fontStyle] !== void 0) {
      key = fontmap[fontNameLowerCase][fontStyle];
    } else if (fontmap[fontName] !== void 0 && fontmap[fontName][fontStyle] !== void 0) {
      key = fontmap[fontName][fontStyle];
    } else {
      if (options2.disableWarning === false) {
        console2.warn("Unable to look up font label for font '" + fontName + "', '" + fontStyle + "'. Refer to getFontList() for available fonts.");
      }
    }
    if (!key && !options2.noFallback) {
      key = fontmap["times"][fontStyle];
      if (key == null) {
        key = fontmap["times"]["normal"];
      }
    }
    return key;
  };
  var putInfo = API.__private__.putInfo = function() {
    var objectId = newObject();
    var encryptor = function encryptor2(data2) {
      return data2;
    };
    if (encryptionOptions !== null) {
      encryptor = encryption.encryptor(objectId, 0);
    }
    out("<<");
    out("/Producer (" + pdfEscape3(encryptor("jsPDF " + jsPDF.version)) + ")");
    for (var key in documentProperties) {
      if (documentProperties.hasOwnProperty(key) && documentProperties[key]) {
        out("/" + key.substr(0, 1).toUpperCase() + key.substr(1) + " (" + pdfEscape3(encryptor(documentProperties[key])) + ")");
      }
    }
    out("/CreationDate (" + pdfEscape3(encryptor(creationDate)) + ")");
    out(">>");
    out("endobj");
  };
  var putCatalog = API.__private__.putCatalog = function(options2) {
    options2 = options2 || {};
    var tmpRootDictionaryObjId = options2.rootDictionaryObjId || rootDictionaryObjId;
    newObject();
    out("<<");
    out("/Type /Catalog");
    out("/Pages " + tmpRootDictionaryObjId + " 0 R");
    if (!zoomMode)
      zoomMode = "fullwidth";
    switch (zoomMode) {
      case "fullwidth":
        out("/OpenAction [3 0 R /FitH null]");
        break;
      case "fullheight":
        out("/OpenAction [3 0 R /FitV null]");
        break;
      case "fullpage":
        out("/OpenAction [3 0 R /Fit]");
        break;
      case "original":
        out("/OpenAction [3 0 R /XYZ null null 1]");
        break;
      default:
        var pcn = "" + zoomMode;
        if (pcn.substr(pcn.length - 1) === "%")
          zoomMode = parseInt(zoomMode) / 100;
        if (typeof zoomMode === "number") {
          out("/OpenAction [3 0 R /XYZ null null " + f23(zoomMode) + "]");
        }
    }
    if (!layoutMode)
      layoutMode = "continuous";
    switch (layoutMode) {
      case "continuous":
        out("/PageLayout /OneColumn");
        break;
      case "single":
        out("/PageLayout /SinglePage");
        break;
      case "two":
      case "twoleft":
        out("/PageLayout /TwoColumnLeft");
        break;
      case "tworight":
        out("/PageLayout /TwoColumnRight");
        break;
    }
    if (pageMode) {
      out("/PageMode /" + pageMode);
    }
    events.publish("putCatalog");
    out(">>");
    out("endobj");
  };
  var putTrailer = API.__private__.putTrailer = function() {
    out("trailer");
    out("<<");
    out("/Size " + (objectNumber + 1));
    out("/Root " + objectNumber + " 0 R");
    out("/Info " + (objectNumber - 1) + " 0 R");
    if (encryptionOptions !== null) {
      out("/Encrypt " + encryption.oid + " 0 R");
    }
    out("/ID [ <" + fileId + "> <" + fileId + "> ]");
    out(">>");
  };
  var putHeader = API.__private__.putHeader = function() {
    out("%PDF-" + pdfVersion);
    out("%\xBA\xDF\xAC\xE0");
  };
  var putXRef = API.__private__.putXRef = function() {
    var p2 = "0000000000";
    out("xref");
    out("0 " + (objectNumber + 1));
    out("0000000000 65535 f ");
    for (var i2 = 1; i2 <= objectNumber; i2++) {
      var offset = offsets[i2];
      if (typeof offset === "function") {
        out((p2 + offsets[i2]()).slice(-10) + " 00000 n ");
      } else {
        if (typeof offsets[i2] !== "undefined") {
          out((p2 + offsets[i2]).slice(-10) + " 00000 n ");
        } else {
          out("0000000000 00000 n ");
        }
      }
    }
  };
  var buildDocument = API.__private__.buildDocument = function(returnType = "string") {
    resetDocument();
    setOutputDestination(content3);
    events.publish("buildDocument");
    putHeader();
    putPages();
    putAdditionalObjects();
    putResources();
    if (encryptionOptions !== null)
      putEncryptionDict();
    putInfo();
    putCatalog();
    var offsetOfXRef = contentLength;
    putXRef();
    putTrailer();
    out("startxref");
    out("" + offsetOfXRef);
    out("%%EOF");
    setOutputDestination(pages[currentPage]);
    if (returnType === "arrayBuffer") {
      return getContentArrayBuffer();
    } else {
      return content3.join("\n");
    }
  };
  var getContentArrayBuffer = API.__private__.getContentArrayBuffer = function() {
    let length2 = 0;
    for (let contentItem of content3) {
      length2 += contentItem.length;
      ++length2;
    }
    let arrayBuffer = new ArrayBuffer(length2);
    let uint8Array = new Uint8Array(arrayBuffer);
    let index3 = 0;
    for (let contentItem of content3) {
      for (let i2 = 0; i2 < contentItem.length; i2++) {
        uint8Array[index3++] = contentItem.charCodeAt(i2);
      }
      uint8Array[index3++] = 10;
    }
    return arrayBuffer;
  };
  var getBlob = API.__private__.getBlob = function(data2) {
    return new Blob([getArrayBuffer(data2)], {
      type: "application/pdf"
    });
  };
  var output = API.output = API.__private__.output = SAFE(function output2(type, options2) {
    options2 = options2 || {};
    if (typeof options2 === "string") {
      options2 = {
        filename: options2
      };
    } else {
      options2.filename = options2.filename || "generated.pdf";
    }
    switch (type) {
      case void 0:
        return buildDocument();
      case "save":
        API.save(options2.filename);
        break;
      case "arraybuffer":
        return getArrayBuffer(buildDocument("arrayBuffer"));
      case "blob":
        return getBlob(buildDocument("arrayBuffer"));
      case "bloburi":
      case "bloburl":
        if (typeof globalObject.URL !== "undefined" && typeof globalObject.URL.createObjectURL === "function") {
          return globalObject.URL && globalObject.URL.createObjectURL(getBlob(buildDocument("arrayBuffer"))) || void 0;
        } else {
          console2.warn("bloburl is not supported by your system, because URL.createObjectURL is not supported by your browser.");
        }
        break;
      case "datauristring":
      case "dataurlstring":
        var dataURI = "";
        var pdfDocument = buildDocument();
        try {
          dataURI = btoa(pdfDocument);
        } catch (e2) {
          dataURI = btoa(unescape(encodeURIComponent(pdfDocument)));
        }
        return "data:application/pdf;filename=" + options2.filename + ";base64," + dataURI;
      case "pdfobjectnewwindow":
        if (Object.prototype.toString.call(globalObject) === "[object Window]") {
          var pdfObjectUrl = "https://cdnjs.cloudflare.com/ajax/libs/pdfobject/2.1.1/pdfobject.min.js";
          var integrity = ' integrity="sha512-4ze/a9/4jqu+tX9dfOqJYSvyYd5M6qum/3HpCLr+/Jqf0whc37VUbkpNGHR7/8pSnCFw47T1fmIpwBV7UySh3g==" crossorigin="anonymous"';
          if (options2.pdfObjectUrl) {
            pdfObjectUrl = options2.pdfObjectUrl;
            integrity = "";
          }
          var htmlForNewWindow = '<html><style>html, body { padding: 0; margin: 0; } iframe { width: 100%; height: 100%; border: 0;}  </style><body><script src="' + pdfObjectUrl + '"' + integrity + '><\/script><script >PDFObject.embed("' + this.output("dataurlstring") + '", ' + JSON.stringify(options2) + ");<\/script></body></html>";
          var nW = globalObject.open();
          if (nW !== null) {
            nW.document.write(htmlForNewWindow);
          }
          return nW;
        } else {
          throw new Error("The option pdfobjectnewwindow just works in a browser-environment.");
        }
      case "pdfjsnewwindow":
        if (Object.prototype.toString.call(globalObject) === "[object Window]") {
          var pdfJsUrl = options2.pdfJsUrl || "examples/PDF.js/web/viewer.html";
          var htmlForPDFjsNewWindow = '<html><style>html, body { padding: 0; margin: 0; } iframe { width: 100%; height: 100%; border: 0;}  </style><body><iframe id="pdfViewer" src="' + pdfJsUrl + "?file=&downloadName=" + options2.filename + '" width="500px" height="400px" /></body></html>';
          var PDFjsNewWindow = globalObject.open();
          if (PDFjsNewWindow !== null) {
            PDFjsNewWindow.document.write(htmlForPDFjsNewWindow);
            var scope = this;
            PDFjsNewWindow.document.documentElement.querySelector("#pdfViewer").onload = function() {
              PDFjsNewWindow.document.title = options2.filename;
              PDFjsNewWindow.document.documentElement.querySelector("#pdfViewer").contentWindow.PDFViewerApplication.open(scope.output("bloburl"));
            };
          }
          return PDFjsNewWindow;
        } else {
          throw new Error("The option pdfjsnewwindow just works in a browser-environment.");
        }
      case "dataurlnewwindow":
        if (Object.prototype.toString.call(globalObject) === "[object Window]") {
          var htmlForDataURLNewWindow = '<html><style>html, body { padding: 0; margin: 0; } iframe { width: 100%; height: 100%; border: 0;}  </style><body><iframe src="' + this.output("datauristring", options2) + '"></iframe></body></html>';
          var dataURLNewWindow = globalObject.open();
          if (dataURLNewWindow !== null) {
            dataURLNewWindow.document.write(htmlForDataURLNewWindow);
            dataURLNewWindow.document.title = options2.filename;
          }
          if (dataURLNewWindow || typeof safari === "undefined")
            return dataURLNewWindow;
        } else {
          throw new Error("The option dataurlnewwindow just works in a browser-environment.");
        }
        break;
      case "datauri":
      case "dataurl":
        return globalObject.document.location.href = this.output("datauristring", options2);
      default:
        return null;
    }
  });
  var hasHotfix = function hasHotfix2(hotfixName) {
    return Array.isArray(hotfixes) === true && hotfixes.indexOf(hotfixName) > -1;
  };
  switch (unit) {
    case "pt":
      scaleFactor2 = 1;
      break;
    case "mm":
      scaleFactor2 = 72 / 25.4;
      break;
    case "cm":
      scaleFactor2 = 72 / 2.54;
      break;
    case "in":
      scaleFactor2 = 72;
      break;
    case "px":
      if (hasHotfix("px_scaling") == true) {
        scaleFactor2 = 72 / 96;
      } else {
        scaleFactor2 = 96 / 72;
      }
      break;
    case "pc":
      scaleFactor2 = 12;
      break;
    case "em":
      scaleFactor2 = 12;
      break;
    case "ex":
      scaleFactor2 = 6;
      break;
    default:
      if (typeof unit === "number") {
        scaleFactor2 = unit;
      } else {
        throw new Error("Invalid unit: " + unit);
      }
  }
  var encryption = null;
  setCreationDate();
  setFileId();
  var getEncryptor = function getEncryptor2(objectId) {
    if (encryptionOptions !== null) {
      return encryption.encryptor(objectId, 0);
    }
    return function(data2) {
      return data2;
    };
  };
  var getPageInfo = API.__private__.getPageInfo = API.getPageInfo = function(pageNumberOneBased) {
    if (isNaN(pageNumberOneBased) || pageNumberOneBased % 1 !== 0) {
      throw new Error("Invalid argument passed to jsPDF.getPageInfo");
    }
    var objId = pagesContext[pageNumberOneBased].objId;
    return {
      objId,
      pageNumber: pageNumberOneBased,
      pageContext: pagesContext[pageNumberOneBased]
    };
  };
  var getPageInfoByObjId = API.__private__.getPageInfoByObjId = function(objId) {
    if (isNaN(objId) || objId % 1 !== 0) {
      throw new Error("Invalid argument passed to jsPDF.getPageInfoByObjId");
    }
    for (var pageNumber in pagesContext) {
      if (pagesContext[pageNumber].objId === objId) {
        break;
      }
    }
    return getPageInfo(pageNumber);
  };
  var getCurrentPageInfo = API.__private__.getCurrentPageInfo = API.getCurrentPageInfo = function() {
    return {
      objId: pagesContext[currentPage].objId,
      pageNumber: currentPage,
      pageContext: pagesContext[currentPage]
    };
  };
  API.addPage = function() {
    _addPage.apply(this, arguments);
    return this;
  };
  API.setPage = function() {
    _setPage.apply(this, arguments);
    setOutputDestination.call(this, pages[currentPage]);
    return this;
  };
  API.insertPage = function(beforePage) {
    this.addPage();
    this.movePage(currentPage, beforePage);
    return this;
  };
  API.movePage = function(targetPage, beforePage) {
    var tmpPages, tmpPagesContext;
    if (targetPage > beforePage) {
      tmpPages = pages[targetPage];
      tmpPagesContext = pagesContext[targetPage];
      for (var i2 = targetPage; i2 > beforePage; i2--) {
        pages[i2] = pages[i2 - 1];
        pagesContext[i2] = pagesContext[i2 - 1];
      }
      pages[beforePage] = tmpPages;
      pagesContext[beforePage] = tmpPagesContext;
      this.setPage(beforePage);
    } else if (targetPage < beforePage) {
      tmpPages = pages[targetPage];
      tmpPagesContext = pagesContext[targetPage];
      for (var j = targetPage; j < beforePage; j++) {
        pages[j] = pages[j + 1];
        pagesContext[j] = pagesContext[j + 1];
      }
      pages[beforePage] = tmpPages;
      pagesContext[beforePage] = tmpPagesContext;
      this.setPage(beforePage);
    }
    return this;
  };
  API.deletePage = function() {
    _deletePage.apply(this, arguments);
    return this;
  };
  API.__private__.text = API.text = function(text4, x2, y3, options2, transform2) {
    options2 = options2 || {};
    var scope = options2.scope || this;
    var payload, da, angle, align, charSpace, maxWidth, flags, horizontalScale;
    if (typeof text4 === "number" && typeof x2 === "number" && (typeof y3 === "string" || Array.isArray(y3))) {
      var tmp = y3;
      y3 = x2;
      x2 = text4;
      text4 = tmp;
    }
    var transformationMatrix;
    if (arguments[3] instanceof Matrix3 === false) {
      flags = arguments[3];
      angle = arguments[4];
      align = arguments[5];
      if (_typeof(flags) !== "object" || flags === null) {
        if (typeof angle === "string") {
          align = angle;
          angle = null;
        }
        if (typeof flags === "string") {
          align = flags;
          flags = null;
        }
        if (typeof flags === "number") {
          angle = flags;
          flags = null;
        }
        options2 = {
          flags,
          angle,
          align
        };
      }
    } else {
      advancedApiModeTrap("The transform parameter of text() with a Matrix value");
      transformationMatrix = transform2;
    }
    if (isNaN(x2) || isNaN(y3) || typeof text4 === "undefined" || text4 === null) {
      throw new Error("Invalid arguments passed to jsPDF.text");
    }
    if (text4.length === 0) {
      return scope;
    }
    var xtra = "";
    var isHex2 = false;
    var lineHeight = typeof options2.lineHeightFactor === "number" ? options2.lineHeightFactor : lineHeightFactor;
    var scaleFactor3 = scope.internal.scaleFactor;
    function ESC(s3) {
      s3 = s3.split("	").join(Array(options2.TabLen || 9).join(" "));
      return pdfEscape3(s3, flags);
    }
    function transformTextToSpecialArray(text5) {
      var sa2 = text5.concat();
      var da2 = [];
      var len2 = sa2.length;
      var curDa2;
      while (len2--) {
        curDa2 = sa2.shift();
        if (typeof curDa2 === "string") {
          da2.push(curDa2);
        } else {
          if (Array.isArray(text5) && (curDa2.length === 1 || curDa2[1] === void 0 && curDa2[2] === void 0)) {
            da2.push(curDa2[0]);
          } else {
            da2.push([curDa2[0], curDa2[1], curDa2[2]]);
          }
        }
      }
      return da2;
    }
    function processTextByFunction(text5, processingFunction) {
      var result2;
      if (typeof text5 === "string") {
        result2 = processingFunction(text5)[0];
      } else if (Array.isArray(text5)) {
        var sa2 = text5.concat();
        var da2 = [];
        var len2 = sa2.length;
        var curDa2;
        var tmpResult;
        while (len2--) {
          curDa2 = sa2.shift();
          if (typeof curDa2 === "string") {
            da2.push(processingFunction(curDa2)[0]);
          } else if (Array.isArray(curDa2) && typeof curDa2[0] === "string") {
            tmpResult = processingFunction(curDa2[0], curDa2[1], curDa2[2]);
            da2.push([tmpResult[0], tmpResult[1], tmpResult[2]]);
          }
        }
        result2 = da2;
      }
      return result2;
    }
    var textIsOfTypeString = false;
    var tmpTextIsOfTypeString = true;
    if (typeof text4 === "string") {
      textIsOfTypeString = true;
    } else if (Array.isArray(text4)) {
      var sa = text4.concat();
      da = [];
      var len = sa.length;
      var curDa;
      while (len--) {
        curDa = sa.shift();
        if (typeof curDa !== "string" || Array.isArray(curDa) && typeof curDa[0] !== "string") {
          tmpTextIsOfTypeString = false;
        }
      }
      textIsOfTypeString = tmpTextIsOfTypeString;
    }
    if (textIsOfTypeString === false) {
      throw new Error('Type of text must be string or Array. "' + text4 + '" is not recognized.');
    }
    if (typeof text4 === "string") {
      if (text4.match(/[\r?\n]/)) {
        text4 = text4.split(/\r\n|\r|\n/g);
      } else {
        text4 = [text4];
      }
    }
    var height2 = activeFontSize / scope.internal.scaleFactor;
    var descent = height2 * (lineHeight - 1);
    switch (options2.baseline) {
      case "bottom":
        y3 -= descent;
        break;
      case "top":
        y3 += height2 - descent;
        break;
      case "hanging":
        y3 += height2 - 2 * descent;
        break;
      case "middle":
        y3 += height2 / 2 - descent;
        break;
    }
    maxWidth = options2.maxWidth || 0;
    if (maxWidth > 0) {
      if (typeof text4 === "string") {
        text4 = scope.splitTextToSize(text4, maxWidth);
      } else if (Object.prototype.toString.call(text4) === "[object Array]") {
        text4 = text4.reduce(function(acc, textLine) {
          return acc.concat(scope.splitTextToSize(textLine, maxWidth));
        }, []);
      }
    }
    payload = {
      text: text4,
      x: x2,
      y: y3,
      options: options2,
      mutex: {
        pdfEscape: pdfEscape3,
        activeFontKey,
        fonts,
        activeFontSize
      }
    };
    events.publish("preProcessText", payload);
    text4 = payload.text;
    options2 = payload.options;
    angle = options2.angle;
    if (transformationMatrix instanceof Matrix3 === false && angle && typeof angle === "number") {
      angle *= Math.PI / 180;
      if (options2.rotationDirection === 0) {
        angle = -angle;
      }
      if (apiMode === ApiMode.ADVANCED) {
        angle = -angle;
      }
      var c3 = Math.cos(angle);
      var s2 = Math.sin(angle);
      transformationMatrix = new Matrix3(c3, s2, -s2, c3, 0, 0);
    } else if (angle && angle instanceof Matrix3) {
      transformationMatrix = angle;
    }
    if (apiMode === ApiMode.ADVANCED && !transformationMatrix) {
      transformationMatrix = identityMatrix;
    }
    charSpace = options2.charSpace || activeCharSpace;
    if (typeof charSpace !== "undefined") {
      xtra += hpf(scale3(charSpace)) + " Tc\n";
      this.setCharSpace(this.getCharSpace() || 0);
    }
    horizontalScale = options2.horizontalScale;
    if (typeof horizontalScale !== "undefined") {
      xtra += hpf(horizontalScale * 100) + " Tz\n";
    }
    var lang = options2.lang;
    var renderingMode = -1;
    var parmRenderingMode = typeof options2.renderingMode !== "undefined" ? options2.renderingMode : options2.stroke;
    var pageContext = scope.internal.getCurrentPageInfo().pageContext;
    switch (parmRenderingMode) {
      case 0:
      case false:
      case "fill":
        renderingMode = 0;
        break;
      case 1:
      case true:
      case "stroke":
        renderingMode = 1;
        break;
      case 2:
      case "fillThenStroke":
        renderingMode = 2;
        break;
      case 3:
      case "invisible":
        renderingMode = 3;
        break;
      case 4:
      case "fillAndAddForClipping":
        renderingMode = 4;
        break;
      case 5:
      case "strokeAndAddPathForClipping":
        renderingMode = 5;
        break;
      case 6:
      case "fillThenStrokeAndAddToPathForClipping":
        renderingMode = 6;
        break;
      case 7:
      case "addToPathForClipping":
        renderingMode = 7;
        break;
    }
    var usedRenderingMode = typeof pageContext.usedRenderingMode !== "undefined" ? pageContext.usedRenderingMode : -1;
    if (renderingMode !== -1) {
      xtra += renderingMode + " Tr\n";
    } else if (usedRenderingMode !== -1) {
      xtra += "0 Tr\n";
    }
    if (renderingMode !== -1) {
      pageContext.usedRenderingMode = renderingMode;
    }
    align = options2.align || "left";
    var leading = activeFontSize * lineHeight;
    var pageWidth = scope.internal.pageSize.getWidth();
    var activeFont = fonts[activeFontKey];
    charSpace = options2.charSpace || activeCharSpace;
    maxWidth = options2.maxWidth || 0;
    var lineWidths;
    flags = Object.assign({
      autoencode: true,
      noBOM: true
    }, options2.flags);
    var wordSpacingPerLine = [];
    if (Object.prototype.toString.call(text4) === "[object Array]") {
      da = transformTextToSpecialArray(text4);
      var newY;
      if (align !== "left") {
        lineWidths = da.map(function(v2) {
          return scope.getStringUnitWidth(v2, {
            font: activeFont,
            charSpace,
            fontSize: activeFontSize,
            doKerning: false
          }) * activeFontSize / scaleFactor3;
        });
      }
      var prevWidth = 0;
      var newX;
      if (align === "right") {
        x2 -= lineWidths[0];
        text4 = [];
        len = da.length;
        for (var i2 = 0; i2 < len; i2++) {
          if (i2 === 0) {
            newX = getHorizontalCoordinate(x2);
            newY = getVerticalCoordinate(y3);
          } else {
            newX = scale3(prevWidth - lineWidths[i2]);
            newY = -leading;
          }
          text4.push([da[i2], newX, newY]);
          prevWidth = lineWidths[i2];
        }
      } else if (align === "center") {
        x2 -= lineWidths[0] / 2;
        text4 = [];
        len = da.length;
        for (var j = 0; j < len; j++) {
          if (j === 0) {
            newX = getHorizontalCoordinate(x2);
            newY = getVerticalCoordinate(y3);
          } else {
            newX = scale3((prevWidth - lineWidths[j]) / 2);
            newY = -leading;
          }
          text4.push([da[j], newX, newY]);
          prevWidth = lineWidths[j];
        }
      } else if (align === "left") {
        text4 = [];
        len = da.length;
        for (var h2 = 0; h2 < len; h2++) {
          text4.push(da[h2]);
        }
      } else if (align === "justify") {
        text4 = [];
        len = da.length;
        maxWidth = maxWidth !== 0 ? maxWidth : pageWidth;
        for (var l2 = 0; l2 < len; l2++) {
          newY = l2 === 0 ? getVerticalCoordinate(y3) : -leading;
          newX = l2 === 0 ? getHorizontalCoordinate(x2) : 0;
          if (l2 < len - 1) {
            wordSpacingPerLine.push(hpf(scale3((maxWidth - lineWidths[l2]) / (da[l2].split(" ").length - 1))));
          } else {
            wordSpacingPerLine.push(0);
          }
          text4.push([da[l2], newX, newY]);
        }
      } else {
        throw new Error('Unrecognized alignment option, use "left", "center", "right" or "justify".');
      }
    }
    var doReversing = typeof options2.R2L === "boolean" ? options2.R2L : R2L;
    if (doReversing === true) {
      text4 = processTextByFunction(text4, function(text5, posX2, posY2) {
        return [text5.split("").reverse().join(""), posX2, posY2];
      });
    }
    payload = {
      text: text4,
      x: x2,
      y: y3,
      options: options2,
      mutex: {
        pdfEscape: pdfEscape3,
        activeFontKey,
        fonts,
        activeFontSize
      }
    };
    events.publish("postProcessText", payload);
    text4 = payload.text;
    isHex2 = payload.mutex.isHex || false;
    var activeFontEncoding = fonts[activeFontKey].encoding;
    if (activeFontEncoding === "WinAnsiEncoding" || activeFontEncoding === "StandardEncoding") {
      text4 = processTextByFunction(text4, function(text5, posX2, posY2) {
        return [ESC(text5), posX2, posY2];
      });
    }
    da = transformTextToSpecialArray(text4);
    text4 = [];
    var STRING = 0;
    var ARRAY = 1;
    var variant = Array.isArray(da[0]) ? ARRAY : STRING;
    var posX;
    var posY;
    var content4;
    var wordSpacing = "";
    var generatePosition = function generatePosition2(parmPosX, parmPosY, parmTransformationMatrix) {
      var position3 = "";
      if (parmTransformationMatrix instanceof Matrix3) {
        if (typeof options2.angle === "number") {
          parmTransformationMatrix = matrixMult(parmTransformationMatrix, new Matrix3(1, 0, 0, 1, parmPosX, parmPosY));
        } else {
          parmTransformationMatrix = matrixMult(new Matrix3(1, 0, 0, 1, parmPosX, parmPosY), parmTransformationMatrix);
        }
        if (apiMode === ApiMode.ADVANCED) {
          parmTransformationMatrix = matrixMult(new Matrix3(1, 0, 0, -1, 0, 0), parmTransformationMatrix);
        }
        position3 = parmTransformationMatrix.join(" ") + " Tm\n";
      } else {
        position3 = hpf(parmPosX) + " " + hpf(parmPosY) + " Td\n";
      }
      return position3;
    };
    for (var lineIndex = 0; lineIndex < da.length; lineIndex++) {
      wordSpacing = "";
      switch (variant) {
        case ARRAY:
          content4 = (isHex2 ? "<" : "(") + da[lineIndex][0] + (isHex2 ? ">" : ")");
          posX = parseFloat(da[lineIndex][1]);
          posY = parseFloat(da[lineIndex][2]);
          break;
        case STRING:
          content4 = (isHex2 ? "<" : "(") + da[lineIndex] + (isHex2 ? ">" : ")");
          posX = getHorizontalCoordinate(x2);
          posY = getVerticalCoordinate(y3);
          break;
      }
      if (typeof wordSpacingPerLine !== "undefined" && typeof wordSpacingPerLine[lineIndex] !== "undefined") {
        wordSpacing = wordSpacingPerLine[lineIndex] + " Tw\n";
      }
      if (lineIndex === 0) {
        text4.push(wordSpacing + generatePosition(posX, posY, transformationMatrix) + content4);
      } else if (variant === STRING) {
        text4.push(wordSpacing + content4);
      } else if (variant === ARRAY) {
        text4.push(wordSpacing + generatePosition(posX, posY, transformationMatrix) + content4);
      }
    }
    text4 = variant === STRING ? text4.join(" Tj\nT* ") : text4.join(" Tj\n");
    text4 += " Tj\n";
    var result = "BT\n/";
    result += activeFontKey + " " + activeFontSize + " Tf\n";
    result += hpf(activeFontSize * lineHeight) + " TL\n";
    result += textColor + "\n";
    result += xtra;
    result += text4;
    result += "ET";
    out(result);
    usedFonts[activeFontKey] = true;
    return scope;
  };
  var clip = API.__private__.clip = API.clip = function(rule) {
    if ("evenodd" === rule) {
      out("W*");
    } else {
      out("W");
    }
    return this;
  };
  API.clipEvenOdd = function() {
    return clip("evenodd");
  };
  API.__private__.discardPath = API.discardPath = function() {
    out("n");
    return this;
  };
  var isValidStyle = API.__private__.isValidStyle = function(style) {
    var validStyleVariants = [void 0, null, "S", "D", "F", "DF", "FD", "f", "f*", "B", "B*", "n"];
    var result = false;
    if (validStyleVariants.indexOf(style) !== -1) {
      result = true;
    }
    return result;
  };
  API.__private__.setDefaultPathOperation = API.setDefaultPathOperation = function(operator) {
    if (isValidStyle(operator)) {
      defaultPathOperation = operator;
    }
    return this;
  };
  var getStyle = API.__private__.getStyle = API.getStyle = function(style) {
    var op2 = defaultPathOperation;
    switch (style) {
      case "D":
      case "S":
        op2 = "S";
        break;
      case "F":
        op2 = "f";
        break;
      case "FD":
      case "DF":
        op2 = "B";
        break;
      case "f":
      case "f*":
      case "B":
      case "B*":
        op2 = style;
        break;
    }
    return op2;
  };
  var close3 = API.close = function() {
    out("h");
    return this;
  };
  API.stroke = function() {
    out("S");
    return this;
  };
  API.fill = function(pattern) {
    fillWithOptionalPattern("f", pattern);
    return this;
  };
  API.fillEvenOdd = function(pattern) {
    fillWithOptionalPattern("f*", pattern);
    return this;
  };
  API.fillStroke = function(pattern) {
    fillWithOptionalPattern("B", pattern);
    return this;
  };
  API.fillStrokeEvenOdd = function(pattern) {
    fillWithOptionalPattern("B*", pattern);
    return this;
  };
  var fillWithOptionalPattern = function fillWithOptionalPattern2(style, pattern) {
    if (_typeof(pattern) === "object") {
      fillWithPattern(pattern, style);
    } else {
      out(style);
    }
  };
  var putStyle = function putStyle2(style) {
    if (style === null || apiMode === ApiMode.ADVANCED && style === void 0) {
      return;
    }
    style = getStyle(style);
    out(style);
  };
  function cloneTilingPattern(patternKey, boundingBox, xStep, yStep, matrix) {
    var clone = new TilingPattern(boundingBox || this.boundingBox, xStep || this.xStep, yStep || this.yStep, this.gState, matrix || this.matrix);
    clone.stream = this.stream;
    var key = patternKey + "$$" + this.cloneIndex++ + "$$";
    addPattern(key, clone);
    return clone;
  }
  var fillWithPattern = function fillWithPattern2(patternData, style) {
    var patternId = patternMap[patternData.key];
    var pattern = patterns[patternId];
    if (pattern instanceof ShadingPattern) {
      out("q");
      out(clipRuleFromStyle(style));
      if (pattern.gState) {
        API.setGState(pattern.gState);
      }
      out(patternData.matrix.toString() + " cm");
      out("/" + patternId + " sh");
      out("Q");
    } else if (pattern instanceof TilingPattern) {
      var matrix = new Matrix3(1, 0, 0, -1, 0, getPageHeight());
      if (patternData.matrix) {
        matrix = matrix.multiply(patternData.matrix || identityMatrix);
        patternId = cloneTilingPattern.call(pattern, patternData.key, patternData.boundingBox, patternData.xStep, patternData.yStep, matrix).id;
      }
      out("q");
      out("/Pattern cs");
      out("/" + patternId + " scn");
      if (pattern.gState) {
        API.setGState(pattern.gState);
      }
      out(style);
      out("Q");
    }
  };
  var clipRuleFromStyle = function clipRuleFromStyle2(style) {
    switch (style) {
      case "f":
      case "F":
        return "W n";
      case "f*":
        return "W* n";
      case "B":
        return "W S";
      case "B*":
        return "W* S";
      case "S":
        return "W S";
      case "n":
        return "W n";
    }
  };
  var moveTo = API.moveTo = function(x2, y3) {
    out(hpf(scale3(x2)) + " " + hpf(transformScaleY(y3)) + " m");
    return this;
  };
  var lineTo = API.lineTo = function(x2, y3) {
    out(hpf(scale3(x2)) + " " + hpf(transformScaleY(y3)) + " l");
    return this;
  };
  var curveTo = API.curveTo = function(x1, y1, x2, y22, x3, y3) {
    out([hpf(scale3(x1)), hpf(transformScaleY(y1)), hpf(scale3(x2)), hpf(transformScaleY(y22)), hpf(scale3(x3)), hpf(transformScaleY(y3)), "c"].join(" "));
    return this;
  };
  API.__private__.line = API.line = function(x1, y1, x2, y22, style) {
    if (isNaN(x1) || isNaN(y1) || isNaN(x2) || isNaN(y22) || !isValidStyle(style)) {
      throw new Error("Invalid arguments passed to jsPDF.line");
    }
    if (apiMode === ApiMode.COMPAT) {
      return this.lines([[x2 - x1, y22 - y1]], x1, y1, [1, 1], style || "S");
    } else {
      return this.lines([[x2 - x1, y22 - y1]], x1, y1, [1, 1]).stroke();
    }
  };
  API.__private__.lines = API.lines = function(lines, x2, y3, scale4, style, closed) {
    var scalex, scaley, i2, l2, leg, x22, y22, x3, y32, x4, y4, tmp;
    if (typeof lines === "number") {
      tmp = y3;
      y3 = x2;
      x2 = lines;
      lines = tmp;
    }
    scale4 = scale4 || [1, 1];
    closed = closed || false;
    if (isNaN(x2) || isNaN(y3) || !Array.isArray(lines) || !Array.isArray(scale4) || !isValidStyle(style) || typeof closed !== "boolean") {
      throw new Error("Invalid arguments passed to jsPDF.lines");
    }
    moveTo(x2, y3);
    scalex = scale4[0];
    scaley = scale4[1];
    l2 = lines.length;
    x4 = x2;
    y4 = y3;
    for (i2 = 0; i2 < l2; i2++) {
      leg = lines[i2];
      if (leg.length === 2) {
        x4 = leg[0] * scalex + x4;
        y4 = leg[1] * scaley + y4;
        lineTo(x4, y4);
      } else {
        x22 = leg[0] * scalex + x4;
        y22 = leg[1] * scaley + y4;
        x3 = leg[2] * scalex + x4;
        y32 = leg[3] * scaley + y4;
        x4 = leg[4] * scalex + x4;
        y4 = leg[5] * scaley + y4;
        curveTo(x22, y22, x3, y32, x4, y4);
      }
    }
    if (closed) {
      close3();
    }
    putStyle(style);
    return this;
  };
  API.path = function(lines) {
    for (var i2 = 0; i2 < lines.length; i2++) {
      var leg = lines[i2];
      var coords = leg.c;
      switch (leg.op) {
        case "m":
          moveTo(coords[0], coords[1]);
          break;
        case "l":
          lineTo(coords[0], coords[1]);
          break;
        case "c":
          curveTo.apply(this, coords);
          break;
        case "h":
          close3();
          break;
      }
    }
    return this;
  };
  API.__private__.rect = API.rect = function(x2, y3, w, h2, style) {
    if (isNaN(x2) || isNaN(y3) || isNaN(w) || isNaN(h2) || !isValidStyle(style)) {
      throw new Error("Invalid arguments passed to jsPDF.rect");
    }
    if (apiMode === ApiMode.COMPAT) {
      h2 = -h2;
    }
    out([hpf(scale3(x2)), hpf(transformScaleY(y3)), hpf(scale3(w)), hpf(scale3(h2)), "re"].join(" "));
    putStyle(style);
    return this;
  };
  API.__private__.triangle = API.triangle = function(x1, y1, x2, y22, x3, y3, style) {
    if (isNaN(x1) || isNaN(y1) || isNaN(x2) || isNaN(y22) || isNaN(x3) || isNaN(y3) || !isValidStyle(style)) {
      throw new Error("Invalid arguments passed to jsPDF.triangle");
    }
    this.lines(
      [
        [x2 - x1, y22 - y1],
        // vector to point 2
        [x3 - x2, y3 - y22],
        // vector to point 3
        [x1 - x3, y1 - y3]
        // closing vector back to point 1
      ],
      x1,
      y1,
      // start of path
      [1, 1],
      style,
      true
    );
    return this;
  };
  API.__private__.roundedRect = API.roundedRect = function(x2, y3, w, h2, rx2, ry2, style) {
    if (isNaN(x2) || isNaN(y3) || isNaN(w) || isNaN(h2) || isNaN(rx2) || isNaN(ry2) || !isValidStyle(style)) {
      throw new Error("Invalid arguments passed to jsPDF.roundedRect");
    }
    var MyArc = 4 / 3 * (Math.SQRT2 - 1);
    rx2 = Math.min(rx2, w * 0.5);
    ry2 = Math.min(ry2, h2 * 0.5);
    this.lines(
      [[w - 2 * rx2, 0], [rx2 * MyArc, 0, rx2, ry2 - ry2 * MyArc, rx2, ry2], [0, h2 - 2 * ry2], [0, ry2 * MyArc, -(rx2 * MyArc), ry2, -rx2, ry2], [-w + 2 * rx2, 0], [-(rx2 * MyArc), 0, -rx2, -(ry2 * MyArc), -rx2, -ry2], [0, -h2 + 2 * ry2], [0, -(ry2 * MyArc), rx2 * MyArc, -ry2, rx2, -ry2]],
      x2 + rx2,
      y3,
      // start of path
      [1, 1],
      style,
      true
    );
    return this;
  };
  API.__private__.ellipse = API.ellipse = function(x2, y3, rx2, ry2, style) {
    if (isNaN(x2) || isNaN(y3) || isNaN(rx2) || isNaN(ry2) || !isValidStyle(style)) {
      throw new Error("Invalid arguments passed to jsPDF.ellipse");
    }
    var lx = 4 / 3 * (Math.SQRT2 - 1) * rx2, ly = 4 / 3 * (Math.SQRT2 - 1) * ry2;
    moveTo(x2 + rx2, y3);
    curveTo(x2 + rx2, y3 - ly, x2 + lx, y3 - ry2, x2, y3 - ry2);
    curveTo(x2 - lx, y3 - ry2, x2 - rx2, y3 - ly, x2 - rx2, y3);
    curveTo(x2 - rx2, y3 + ly, x2 - lx, y3 + ry2, x2, y3 + ry2);
    curveTo(x2 + lx, y3 + ry2, x2 + rx2, y3 + ly, x2 + rx2, y3);
    putStyle(style);
    return this;
  };
  API.__private__.circle = API.circle = function(x2, y3, r2, style) {
    if (isNaN(x2) || isNaN(y3) || isNaN(r2) || !isValidStyle(style)) {
      throw new Error("Invalid arguments passed to jsPDF.circle");
    }
    return this.ellipse(x2, y3, r2, r2, style);
  };
  API.setFont = function(fontName, fontStyle, fontWeight) {
    if (fontWeight) {
      fontStyle = combineFontStyleAndFontWeight(fontStyle, fontWeight);
    }
    activeFontKey = getFont(fontName, fontStyle, {
      disableWarning: false
    });
    return this;
  };
  var getFontEntry = API.__private__.getFont = API.getFont = function() {
    return fonts[getFont.apply(API, arguments)];
  };
  API.__private__.getFontList = API.getFontList = function() {
    var list2 = {}, fontName, fontStyle;
    for (fontName in fontmap) {
      if (fontmap.hasOwnProperty(fontName)) {
        list2[fontName] = [];
        for (fontStyle in fontmap[fontName]) {
          if (fontmap[fontName].hasOwnProperty(fontStyle)) {
            list2[fontName].push(fontStyle);
          }
        }
      }
    }
    return list2;
  };
  API.addFont = function(postScriptName, fontName, fontStyle, fontWeight, encoding) {
    var encodingOptions = ["StandardEncoding", "MacRomanEncoding", "Identity-H", "WinAnsiEncoding"];
    if (arguments[3] && encodingOptions.indexOf(arguments[3]) !== -1) {
      encoding = arguments[3];
    } else if (arguments[3] && encodingOptions.indexOf(arguments[3]) == -1) {
      fontStyle = combineFontStyleAndFontWeight(fontStyle, fontWeight);
    }
    encoding = encoding || "Identity-H";
    return addFont.call(this, postScriptName, fontName, fontStyle, encoding);
  };
  var lineWidth = options.lineWidth || 0.200025;
  var getLineWidth = API.__private__.getLineWidth = API.getLineWidth = function() {
    return lineWidth;
  };
  var setLineWidth = API.__private__.setLineWidth = API.setLineWidth = function(width2) {
    lineWidth = width2;
    out(hpf(scale3(width2)) + " w");
    return this;
  };
  API.__private__.setLineDash = jsPDF.API.setLineDash = jsPDF.API.setLineDashPattern = function(dashArray, dashPhase) {
    dashArray = dashArray || [];
    dashPhase = dashPhase || 0;
    if (isNaN(dashPhase) || !Array.isArray(dashArray)) {
      throw new Error("Invalid arguments passed to jsPDF.setLineDash");
    }
    dashArray = dashArray.map(function(x2) {
      return hpf(scale3(x2));
    }).join(" ");
    dashPhase = hpf(scale3(dashPhase));
    out("[" + dashArray + "] " + dashPhase + " d");
    return this;
  };
  var lineHeightFactor;
  var getLineHeight = API.__private__.getLineHeight = API.getLineHeight = function() {
    return activeFontSize * lineHeightFactor;
  };
  API.__private__.getLineHeight = API.getLineHeight = function() {
    return activeFontSize * lineHeightFactor;
  };
  var setLineHeightFactor = API.__private__.setLineHeightFactor = API.setLineHeightFactor = function(value) {
    value = value || 1.15;
    if (typeof value === "number") {
      lineHeightFactor = value;
    }
    return this;
  };
  var getLineHeightFactor = API.__private__.getLineHeightFactor = API.getLineHeightFactor = function() {
    return lineHeightFactor;
  };
  setLineHeightFactor(options.lineHeight);
  var getHorizontalCoordinate = API.__private__.getHorizontalCoordinate = function(value) {
    return scale3(value);
  };
  var getVerticalCoordinate = API.__private__.getVerticalCoordinate = function(value) {
    if (apiMode === ApiMode.ADVANCED) {
      return value;
    } else {
      var pageHeight = pagesContext[currentPage].mediaBox.topRightY - pagesContext[currentPage].mediaBox.bottomLeftY;
      return pageHeight - scale3(value);
    }
  };
  var getHorizontalCoordinateString = API.__private__.getHorizontalCoordinateString = API.getHorizontalCoordinateString = function(value) {
    return hpf(getHorizontalCoordinate(value));
  };
  var getVerticalCoordinateString = API.__private__.getVerticalCoordinateString = API.getVerticalCoordinateString = function(value) {
    return hpf(getVerticalCoordinate(value));
  };
  var strokeColor = options.strokeColor || "0 G";
  API.__private__.getStrokeColor = API.getDrawColor = function() {
    return decodeColorString(strokeColor);
  };
  API.__private__.setStrokeColor = API.setDrawColor = function(ch1, ch2, ch3, ch4) {
    var options2 = {
      ch1,
      ch2,
      ch3,
      ch4,
      pdfColorType: "draw",
      precision: 2
    };
    strokeColor = encodeColorString(options2);
    out(strokeColor);
    return this;
  };
  var fillColor = options.fillColor || "0 g";
  API.__private__.getFillColor = API.getFillColor = function() {
    return decodeColorString(fillColor);
  };
  API.__private__.setFillColor = API.setFillColor = function(ch1, ch2, ch3, ch4) {
    var options2 = {
      ch1,
      ch2,
      ch3,
      ch4,
      pdfColorType: "fill",
      precision: 2
    };
    fillColor = encodeColorString(options2);
    out(fillColor);
    return this;
  };
  var textColor = options.textColor || "0 g";
  var getTextColor = API.__private__.getTextColor = API.getTextColor = function() {
    return decodeColorString(textColor);
  };
  API.__private__.setTextColor = API.setTextColor = function(ch1, ch2, ch3, ch4) {
    var options2 = {
      ch1,
      ch2,
      ch3,
      ch4,
      pdfColorType: "text",
      precision: 3
    };
    textColor = encodeColorString(options2);
    return this;
  };
  var activeCharSpace = options.charSpace;
  var getCharSpace = API.__private__.getCharSpace = API.getCharSpace = function() {
    return parseFloat(activeCharSpace || 0);
  };
  API.__private__.setCharSpace = API.setCharSpace = function(charSpace) {
    if (isNaN(charSpace)) {
      throw new Error("Invalid argument passed to jsPDF.setCharSpace");
    }
    activeCharSpace = charSpace;
    return this;
  };
  var lineCapID = 0;
  API.CapJoinStyles = {
    0: 0,
    butt: 0,
    but: 0,
    miter: 0,
    1: 1,
    round: 1,
    rounded: 1,
    circle: 1,
    2: 2,
    projecting: 2,
    project: 2,
    square: 2,
    bevel: 2
  };
  API.__private__.setLineCap = API.setLineCap = function(style) {
    var id = API.CapJoinStyles[style];
    if (id === void 0) {
      throw new Error("Line cap style of '" + style + "' is not recognized. See or extend .CapJoinStyles property for valid styles");
    }
    lineCapID = id;
    out(id + " J");
    return this;
  };
  var lineJoinID = 0;
  API.__private__.setLineJoin = API.setLineJoin = function(style) {
    var id = API.CapJoinStyles[style];
    if (id === void 0) {
      throw new Error("Line join style of '" + style + "' is not recognized. See or extend .CapJoinStyles property for valid styles");
    }
    lineJoinID = id;
    out(id + " j");
    return this;
  };
  API.__private__.setLineMiterLimit = API.__private__.setMiterLimit = API.setLineMiterLimit = API.setMiterLimit = function(length2) {
    length2 = length2 || 0;
    if (isNaN(length2)) {
      throw new Error("Invalid argument passed to jsPDF.setLineMiterLimit");
    }
    out(hpf(scale3(length2)) + " M");
    return this;
  };
  API.GState = GState;
  API.setGState = function(gState) {
    if (typeof gState === "string") {
      gState = gStates[gStatesMap[gState]];
    } else {
      gState = addGState(null, gState);
    }
    if (!gState.equals(activeGState)) {
      out("/" + gState.id + " gs");
      activeGState = gState;
    }
  };
  var addGState = function addGState2(key, gState) {
    if (key && gStatesMap[key])
      return;
    var duplicate = false;
    for (var s2 in gStates) {
      if (gStates.hasOwnProperty(s2)) {
        if (gStates[s2].equals(gState)) {
          duplicate = true;
          break;
        }
      }
    }
    if (duplicate) {
      gState = gStates[s2];
    } else {
      var gStateKey = "GS" + (Object.keys(gStates).length + 1).toString(10);
      gStates[gStateKey] = gState;
      gState.id = gStateKey;
    }
    key && (gStatesMap[key] = gState.id);
    events.publish("addGState", gState);
    return gState;
  };
  API.addGState = function(key, gState) {
    addGState(key, gState);
    return this;
  };
  API.saveGraphicsState = function() {
    out("q");
    fontStateStack.push({
      key: activeFontKey,
      size: activeFontSize,
      color: textColor
    });
    return this;
  };
  API.restoreGraphicsState = function() {
    out("Q");
    var fontState = fontStateStack.pop();
    activeFontKey = fontState.key;
    activeFontSize = fontState.size;
    textColor = fontState.color;
    activeGState = null;
    return this;
  };
  API.setCurrentTransformationMatrix = function(matrix) {
    out(matrix.toString() + " cm");
    return this;
  };
  API.comment = function(text4) {
    out("#" + text4);
    return this;
  };
  var Point3 = function Point4(x2, y3) {
    var _x = x2 || 0;
    Object.defineProperty(this, "x", {
      enumerable: true,
      get: function get() {
        return _x;
      },
      set: function set(value) {
        if (!isNaN(value)) {
          _x = parseFloat(value);
        }
      }
    });
    var _y = y3 || 0;
    Object.defineProperty(this, "y", {
      enumerable: true,
      get: function get() {
        return _y;
      },
      set: function set(value) {
        if (!isNaN(value)) {
          _y = parseFloat(value);
        }
      }
    });
    var _type = "pt";
    Object.defineProperty(this, "type", {
      enumerable: true,
      get: function get() {
        return _type;
      },
      set: function set(value) {
        _type = value.toString();
      }
    });
    return this;
  };
  var Rectangle = function Rectangle2(x2, y3, w, h2) {
    Point3.call(this, x2, y3);
    this.type = "rect";
    var _w = w || 0;
    Object.defineProperty(this, "w", {
      enumerable: true,
      get: function get() {
        return _w;
      },
      set: function set(value) {
        if (!isNaN(value)) {
          _w = parseFloat(value);
        }
      }
    });
    var _h = h2 || 0;
    Object.defineProperty(this, "h", {
      enumerable: true,
      get: function get() {
        return _h;
      },
      set: function set(value) {
        if (!isNaN(value)) {
          _h = parseFloat(value);
        }
      }
    });
    return this;
  };
  var RenderTarget = function RenderTarget2() {
    this.page = page;
    this.currentPage = currentPage;
    this.pages = pages.slice(0);
    this.pagesContext = pagesContext.slice(0);
    this.x = pageX;
    this.y = pageY;
    this.matrix = pageMatrix;
    this.width = getPageWidth(currentPage);
    this.height = getPageHeight(currentPage);
    this.outputDestination = outputDestination;
    this.id = "";
    this.objectNumber = -1;
  };
  RenderTarget.prototype.restore = function() {
    page = this.page;
    currentPage = this.currentPage;
    pagesContext = this.pagesContext;
    pages = this.pages;
    pageX = this.x;
    pageY = this.y;
    pageMatrix = this.matrix;
    setPageWidth(currentPage, this.width);
    setPageHeight(currentPage, this.height);
    outputDestination = this.outputDestination;
  };
  var beginNewRenderTarget = function beginNewRenderTarget2(x2, y3, width2, height2, matrix) {
    renderTargetStack.push(new RenderTarget());
    page = currentPage = 0;
    pages = [];
    pageX = x2;
    pageY = y3;
    pageMatrix = matrix;
    beginPage([width2, height2]);
  };
  var endFormObject = function endFormObject2(key) {
    if (renderTargetMap[key]) {
      renderTargetStack.pop().restore();
      return;
    }
    var newXObject = new RenderTarget();
    var xObjectId = "Xo" + (Object.keys(renderTargets).length + 1).toString(10);
    newXObject.id = xObjectId;
    renderTargetMap[key] = xObjectId;
    renderTargets[xObjectId] = newXObject;
    events.publish("addFormObject", newXObject);
    renderTargetStack.pop().restore();
  };
  API.beginFormObject = function(x2, y3, width2, height2, matrix) {
    beginNewRenderTarget(x2, y3, width2, height2, matrix);
    return this;
  };
  API.endFormObject = function(key) {
    endFormObject(key);
    return this;
  };
  API.doFormObject = function(key, matrix) {
    var xObject = renderTargets[renderTargetMap[key]];
    out("q");
    out(matrix.toString() + " cm");
    out("/" + xObject.id + " Do");
    out("Q");
    return this;
  };
  API.getFormObject = function(key) {
    var xObject = renderTargets[renderTargetMap[key]];
    return {
      x: xObject.x,
      y: xObject.y,
      width: xObject.width,
      height: xObject.height,
      matrix: xObject.matrix
    };
  };
  API.save = function(filename, options2) {
    filename = filename || "generated.pdf";
    options2 = options2 || {};
    options2.returnPromise = options2.returnPromise || false;
    if (options2.returnPromise === false) {
      saveAs(getBlob(buildDocument("arrayBuffer")), filename);
      if (typeof saveAs.unload === "function") {
        if (globalObject.setTimeout) {
          setTimeout(saveAs.unload, 911);
        }
      }
      return this;
    } else {
      return new Promise(function(resolve, reject) {
        try {
          var result = saveAs(getBlob(buildDocument("arrayBuffer")), filename);
          if (typeof saveAs.unload === "function") {
            if (globalObject.setTimeout) {
              setTimeout(saveAs.unload, 911);
            }
          }
          resolve(result);
        } catch (e2) {
          reject(e2.message);
        }
      });
    }
  };
  for (var plugin in jsPDF.API) {
    if (jsPDF.API.hasOwnProperty(plugin)) {
      if (plugin === "events" && jsPDF.API.events.length) {
        (function(events2, newEvents) {
          var eventname, handler_and_args, i2;
          for (i2 = newEvents.length - 1; i2 !== -1; i2--) {
            eventname = newEvents[i2][0];
            handler_and_args = newEvents[i2][1];
            events2.subscribe.apply(events2, [eventname].concat(typeof handler_and_args === "function" ? [handler_and_args] : handler_and_args));
          }
        })(events, jsPDF.API.events);
      } else {
        API[plugin] = jsPDF.API[plugin];
      }
    }
  }
  var getPageWidth = API.getPageWidth = function(pageNumber) {
    pageNumber = pageNumber || currentPage;
    return (pagesContext[pageNumber].mediaBox.topRightX - pagesContext[pageNumber].mediaBox.bottomLeftX) / scaleFactor2;
  };
  var setPageWidth = API.setPageWidth = function(pageNumber, value) {
    pagesContext[pageNumber].mediaBox.topRightX = value * scaleFactor2 + pagesContext[pageNumber].mediaBox.bottomLeftX;
  };
  var getPageHeight = API.getPageHeight = function(pageNumber) {
    pageNumber = pageNumber || currentPage;
    return (pagesContext[pageNumber].mediaBox.topRightY - pagesContext[pageNumber].mediaBox.bottomLeftY) / scaleFactor2;
  };
  var setPageHeight = API.setPageHeight = function(pageNumber, value) {
    pagesContext[pageNumber].mediaBox.topRightY = value * scaleFactor2 + pagesContext[pageNumber].mediaBox.bottomLeftY;
  };
  API.internal = {
    pdfEscape: pdfEscape3,
    getStyle,
    getFont: getFontEntry,
    getFontSize,
    getCharSpace,
    getTextColor,
    getLineHeight,
    getLineHeightFactor,
    getLineWidth,
    write,
    getHorizontalCoordinate,
    getVerticalCoordinate,
    getCoordinateString: getHorizontalCoordinateString,
    getVerticalCoordinateString,
    collections: {},
    newObject,
    newAdditionalObject,
    newObjectDeferred,
    newObjectDeferredBegin,
    getFilters,
    putStream,
    events,
    scaleFactor: scaleFactor2,
    pageSize: {
      getWidth: function getWidth() {
        return getPageWidth(currentPage);
      },
      setWidth: function setWidth(value) {
        setPageWidth(currentPage, value);
      },
      getHeight: function getHeight() {
        return getPageHeight(currentPage);
      },
      setHeight: function setHeight(value) {
        setPageHeight(currentPage, value);
      }
    },
    encryptionOptions,
    encryption,
    getEncryptor,
    output,
    getNumberOfPages,
    pages,
    out,
    f2: f23,
    f3,
    getPageInfo,
    getPageInfoByObjId,
    getCurrentPageInfo,
    getPDFVersion: getPdfVersion,
    Point: Point3,
    Rectangle,
    Matrix: Matrix3,
    hasHotfix
    //Expose the hasHotfix check so plugins can also check them.
  };
  Object.defineProperty(API.internal.pageSize, "width", {
    get: function get() {
      return getPageWidth(currentPage);
    },
    set: function set(value) {
      setPageWidth(currentPage, value);
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(API.internal.pageSize, "height", {
    get: function get() {
      return getPageHeight(currentPage);
    },
    set: function set(value) {
      setPageHeight(currentPage, value);
    },
    enumerable: true,
    configurable: true
  });
  addFonts.call(API, standardFonts);
  activeFontKey = "F1";
  _addPage(format, orientation);
  events.publish("initialized");
  return API;
}
jsPDF.API = {
  events: []
};
jsPDF.version = "2.5.1";
var jsPDFAPI = jsPDF.API;
var scaleFactor = 1;
var pdfEscape = function pdfEscape2(value) {
  return value.replace(/\\/g, "\\\\").replace(/\(/g, "\\(").replace(/\)/g, "\\)");
};
var pdfUnescape = function pdfUnescape2(value) {
  return value.replace(/\\\\/g, "\\").replace(/\\\(/g, "(").replace(/\\\)/g, ")");
};
var f2 = function f22(number) {
  return number.toFixed(2);
};
var f5 = function f52(number) {
  return number.toFixed(5);
};
jsPDFAPI.__acroform__ = {};
var inherit = function inherit2(child, parent) {
  child.prototype = Object.create(parent.prototype);
  child.prototype.constructor = child;
};
var scale = function scale2(x2) {
  return x2 * scaleFactor;
};
var createFormXObject = function createFormXObject2(formObject) {
  var xobj = new AcroFormXObject();
  var height2 = AcroFormAppearance.internal.getHeight(formObject) || 0;
  var width2 = AcroFormAppearance.internal.getWidth(formObject) || 0;
  xobj.BBox = [0, 0, Number(f2(width2)), Number(f2(height2))];
  return xobj;
};
var setBit = jsPDFAPI.__acroform__.setBit = function(number, bitPosition) {
  number = number || 0;
  bitPosition = bitPosition || 0;
  if (isNaN(number) || isNaN(bitPosition)) {
    throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.setBit");
  }
  var bitMask = 1 << bitPosition;
  number |= bitMask;
  return number;
};
var clearBit = jsPDFAPI.__acroform__.clearBit = function(number, bitPosition) {
  number = number || 0;
  bitPosition = bitPosition || 0;
  if (isNaN(number) || isNaN(bitPosition)) {
    throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.clearBit");
  }
  var bitMask = 1 << bitPosition;
  number &= ~bitMask;
  return number;
};
var getBit = jsPDFAPI.__acroform__.getBit = function(number, bitPosition) {
  if (isNaN(number) || isNaN(bitPosition)) {
    throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.getBit");
  }
  return (number & 1 << bitPosition) === 0 ? 0 : 1;
};
var getBitForPdf = jsPDFAPI.__acroform__.getBitForPdf = function(number, bitPosition) {
  if (isNaN(number) || isNaN(bitPosition)) {
    throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.getBitForPdf");
  }
  return getBit(number, bitPosition - 1);
};
var setBitForPdf = jsPDFAPI.__acroform__.setBitForPdf = function(number, bitPosition) {
  if (isNaN(number) || isNaN(bitPosition)) {
    throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.setBitForPdf");
  }
  return setBit(number, bitPosition - 1);
};
var clearBitForPdf = jsPDFAPI.__acroform__.clearBitForPdf = function(number, bitPosition) {
  if (isNaN(number) || isNaN(bitPosition)) {
    throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.clearBitForPdf");
  }
  return clearBit(number, bitPosition - 1);
};
var calculateCoordinates = jsPDFAPI.__acroform__.calculateCoordinates = function(args, scope) {
  var getHorizontalCoordinate = scope.internal.getHorizontalCoordinate;
  var getVerticalCoordinate = scope.internal.getVerticalCoordinate;
  var x2 = args[0];
  var y3 = args[1];
  var w = args[2];
  var h2 = args[3];
  var coordinates = {};
  coordinates.lowerLeft_X = getHorizontalCoordinate(x2) || 0;
  coordinates.lowerLeft_Y = getVerticalCoordinate(y3 + h2) || 0;
  coordinates.upperRight_X = getHorizontalCoordinate(x2 + w) || 0;
  coordinates.upperRight_Y = getVerticalCoordinate(y3) || 0;
  return [Number(f2(coordinates.lowerLeft_X)), Number(f2(coordinates.lowerLeft_Y)), Number(f2(coordinates.upperRight_X)), Number(f2(coordinates.upperRight_Y))];
};
var calculateAppearanceStream = function calculateAppearanceStream2(formObject) {
  if (formObject.appearanceStreamContent) {
    return formObject.appearanceStreamContent;
  }
  if (!formObject.V && !formObject.DV) {
    return;
  }
  var stream = [];
  var text4 = formObject._V || formObject.DV;
  var calcRes = calculateX(formObject, text4);
  var fontKey = formObject.scope.internal.getFont(formObject.fontName, formObject.fontStyle).id;
  stream.push("/Tx BMC");
  stream.push("q");
  stream.push("BT");
  stream.push(formObject.scope.__private__.encodeColorString(formObject.color));
  stream.push("/" + fontKey + " " + f2(calcRes.fontSize) + " Tf");
  stream.push("1 0 0 1 0 0 Tm");
  stream.push(calcRes.text);
  stream.push("ET");
  stream.push("Q");
  stream.push("EMC");
  var appearanceStreamContent = createFormXObject(formObject);
  appearanceStreamContent.scope = formObject.scope;
  appearanceStreamContent.stream = stream.join("\n");
  return appearanceStreamContent;
};
var calculateX = function calculateX2(formObject, text4) {
  var maxFontSize = formObject.fontSize === 0 ? formObject.maxFontSize : formObject.fontSize;
  var returnValue = {
    text: "",
    fontSize: ""
  };
  text4 = text4.substr(0, 1) == "(" ? text4.substr(1) : text4;
  text4 = text4.substr(text4.length - 1) == ")" ? text4.substr(0, text4.length - 1) : text4;
  var textSplit = text4.split(" ");
  if (formObject.multiline) {
    textSplit = textSplit.map(function(word) {
      return word.split("\n");
    });
  } else {
    textSplit = textSplit.map(function(word) {
      return [word];
    });
  }
  var fontSize = maxFontSize;
  var lineSpacing = 2;
  var borderPadding = 2;
  var height2 = AcroFormAppearance.internal.getHeight(formObject) || 0;
  height2 = height2 < 0 ? -height2 : height2;
  var width2 = AcroFormAppearance.internal.getWidth(formObject) || 0;
  width2 = width2 < 0 ? -width2 : width2;
  var isSmallerThanWidth = function isSmallerThanWidth2(i3, lastLine2, fontSize2) {
    if (i3 + 1 < textSplit.length) {
      var tmp = lastLine2 + " " + textSplit[i3 + 1][0];
      var TextWidth = calculateFontSpace(tmp, formObject, fontSize2).width;
      var FieldWidth = width2 - 2 * borderPadding;
      return TextWidth <= FieldWidth;
    } else {
      return false;
    }
  };
  fontSize++;
  FontSize:
    while (fontSize > 0) {
      text4 = "";
      fontSize--;
      var textHeight = calculateFontSpace("3", formObject, fontSize).height;
      var startY = formObject.multiline ? height2 - fontSize : (height2 - textHeight) / 2;
      startY += lineSpacing;
      var startX;
      var lastY = startY;
      var firstWordInLine = 0, lastWordInLine = 0;
      var lastLength;
      var currWord = 0;
      if (fontSize <= 0) {
        fontSize = 12;
        text4 = "(...) Tj\n";
        text4 += "% Width of Text: " + calculateFontSpace(text4, formObject, fontSize).width + ", FieldWidth:" + width2 + "\n";
        break;
      }
      var lastLine = "";
      var lineCount = 0;
      Line:
        for (var i2 = 0; i2 < textSplit.length; i2++) {
          if (textSplit.hasOwnProperty(i2)) {
            var isWithNewLine = false;
            if (textSplit[i2].length !== 1 && currWord !== textSplit[i2].length - 1) {
              if ((textHeight + lineSpacing) * (lineCount + 2) + lineSpacing > height2) {
                continue FontSize;
              }
              lastLine += textSplit[i2][currWord];
              isWithNewLine = true;
              lastWordInLine = i2;
              i2--;
            } else {
              lastLine += textSplit[i2][currWord] + " ";
              lastLine = lastLine.substr(lastLine.length - 1) == " " ? lastLine.substr(0, lastLine.length - 1) : lastLine;
              var key = parseInt(i2);
              var nextLineIsSmaller = isSmallerThanWidth(key, lastLine, fontSize);
              var isLastWord = i2 >= textSplit.length - 1;
              if (nextLineIsSmaller && !isLastWord) {
                lastLine += " ";
                currWord = 0;
                continue;
              } else if (!nextLineIsSmaller && !isLastWord) {
                if (!formObject.multiline) {
                  continue FontSize;
                } else {
                  if ((textHeight + lineSpacing) * (lineCount + 2) + lineSpacing > height2) {
                    continue FontSize;
                  }
                  lastWordInLine = key;
                }
              } else if (isLastWord) {
                lastWordInLine = key;
              } else {
                if (formObject.multiline && (textHeight + lineSpacing) * (lineCount + 2) + lineSpacing > height2) {
                  continue FontSize;
                }
              }
            }
            var line = "";
            for (var x2 = firstWordInLine; x2 <= lastWordInLine; x2++) {
              var currLine = textSplit[x2];
              if (formObject.multiline) {
                if (x2 === lastWordInLine) {
                  line += currLine[currWord] + " ";
                  currWord = (currWord + 1) % currLine.length;
                  continue;
                }
                if (x2 === firstWordInLine) {
                  line += currLine[currLine.length - 1] + " ";
                  continue;
                }
              }
              line += currLine[0] + " ";
            }
            line = line.substr(line.length - 1) == " " ? line.substr(0, line.length - 1) : line;
            lastLength = calculateFontSpace(line, formObject, fontSize).width;
            switch (formObject.textAlign) {
              case "right":
                startX = width2 - lastLength - borderPadding;
                break;
              case "center":
                startX = (width2 - lastLength) / 2;
                break;
              case "left":
              default:
                startX = borderPadding;
                break;
            }
            text4 += f2(startX) + " " + f2(lastY) + " Td\n";
            text4 += "(" + pdfEscape(line) + ") Tj\n";
            text4 += -f2(startX) + " 0 Td\n";
            lastY = -(fontSize + lineSpacing);
            lastLength = 0;
            firstWordInLine = isWithNewLine ? lastWordInLine : lastWordInLine + 1;
            lineCount++;
            lastLine = "";
            continue Line;
          }
        }
      break;
    }
  returnValue.text = text4;
  returnValue.fontSize = fontSize;
  return returnValue;
};
var calculateFontSpace = function calculateFontSpace2(text4, formObject, fontSize) {
  var font = formObject.scope.internal.getFont(formObject.fontName, formObject.fontStyle);
  var width2 = formObject.scope.getStringUnitWidth(text4, {
    font,
    fontSize: parseFloat(fontSize),
    charSpace: 0
  }) * parseFloat(fontSize);
  var height2 = formObject.scope.getStringUnitWidth("3", {
    font,
    fontSize: parseFloat(fontSize),
    charSpace: 0
  }) * parseFloat(fontSize) * 1.5;
  return {
    height: height2,
    width: width2
  };
};
var acroformPluginTemplate = {
  fields: [],
  xForms: [],
  /**
   * acroFormDictionaryRoot contains information about the AcroForm
   * Dictionary 0: The Event-Token, the AcroFormDictionaryCallback has
   * 1: The Object ID of the Root
   */
  acroFormDictionaryRoot: null,
  /**
   * After the PDF gets evaluated, the reference to the root has to be
   * reset, this indicates, whether the root has already been printed
   * out
   */
  printedOut: false,
  internal: null,
  isInitialized: false
};
var annotReferenceCallback = function annotReferenceCallback2(scope) {
  scope.internal.acroformPlugin.acroFormDictionaryRoot.objId = void 0;
  var fields = scope.internal.acroformPlugin.acroFormDictionaryRoot.Fields;
  for (var i2 in fields) {
    if (fields.hasOwnProperty(i2)) {
      var formObject = fields[i2];
      formObject.objId = void 0;
      if (formObject.hasAnnotation) {
        createAnnotationReference(formObject, scope);
      }
    }
  }
};
var putForm = function putForm2(formObject) {
  if (formObject.scope.internal.acroformPlugin.printedOut) {
    formObject.scope.internal.acroformPlugin.printedOut = false;
    formObject.scope.internal.acroformPlugin.acroFormDictionaryRoot = null;
  }
  formObject.scope.internal.acroformPlugin.acroFormDictionaryRoot.Fields.push(formObject);
};
var createAnnotationReference = function createAnnotationReference2(object, scope) {
  var options = {
    type: "reference",
    object
  };
  var findEntry = function findEntry2(entry) {
    return entry.type === options.type && entry.object === options.object;
  };
  if (scope.internal.getPageInfo(object.page).pageContext.annotations.find(findEntry) === void 0) {
    scope.internal.getPageInfo(object.page).pageContext.annotations.push(options);
  }
};
var putCatalogCallback = function putCatalogCallback2(scope) {
  if (typeof scope.internal.acroformPlugin.acroFormDictionaryRoot !== "undefined") {
    scope.internal.write("/AcroForm " + scope.internal.acroformPlugin.acroFormDictionaryRoot.objId + " 0 R");
  } else {
    throw new Error("putCatalogCallback: Root missing.");
  }
};
var AcroFormDictionaryCallback = function AcroFormDictionaryCallback2(scope) {
  scope.internal.events.unsubscribe(scope.internal.acroformPlugin.acroFormDictionaryRoot._eventID);
  delete scope.internal.acroformPlugin.acroFormDictionaryRoot._eventID;
  scope.internal.acroformPlugin.printedOut = true;
};
var createFieldCallback = function createFieldCallback2(fieldArray, scope) {
  var standardFields = !fieldArray;
  if (!fieldArray) {
    scope.internal.newObjectDeferredBegin(scope.internal.acroformPlugin.acroFormDictionaryRoot.objId, true);
    scope.internal.acroformPlugin.acroFormDictionaryRoot.putStream();
  }
  fieldArray = fieldArray || scope.internal.acroformPlugin.acroFormDictionaryRoot.Kids;
  for (var i2 in fieldArray) {
    if (fieldArray.hasOwnProperty(i2)) {
      var fieldObject = fieldArray[i2];
      var keyValueList = [];
      var oldRect = fieldObject.Rect;
      if (fieldObject.Rect) {
        fieldObject.Rect = calculateCoordinates(fieldObject.Rect, scope);
      }
      scope.internal.newObjectDeferredBegin(fieldObject.objId, true);
      fieldObject.DA = AcroFormAppearance.createDefaultAppearanceStream(fieldObject);
      if (_typeof(fieldObject) === "object" && typeof fieldObject.getKeyValueListForStream === "function") {
        keyValueList = fieldObject.getKeyValueListForStream();
      }
      fieldObject.Rect = oldRect;
      if (fieldObject.hasAppearanceStream && !fieldObject.appearanceStreamContent) {
        var appearance = calculateAppearanceStream(fieldObject);
        keyValueList.push({
          key: "AP",
          value: "<</N " + appearance + ">>"
        });
        scope.internal.acroformPlugin.xForms.push(appearance);
      }
      if (fieldObject.appearanceStreamContent) {
        var appearanceStreamString = "";
        for (var k in fieldObject.appearanceStreamContent) {
          if (fieldObject.appearanceStreamContent.hasOwnProperty(k)) {
            var value = fieldObject.appearanceStreamContent[k];
            appearanceStreamString += "/" + k + " ";
            appearanceStreamString += "<<";
            if (Object.keys(value).length >= 1 || Array.isArray(value)) {
              for (var i2 in value) {
                if (value.hasOwnProperty(i2)) {
                  var obj = value[i2];
                  if (typeof obj === "function") {
                    obj = obj.call(scope, fieldObject);
                  }
                  appearanceStreamString += "/" + i2 + " " + obj + " ";
                  if (!(scope.internal.acroformPlugin.xForms.indexOf(obj) >= 0))
                    scope.internal.acroformPlugin.xForms.push(obj);
                }
              }
            } else {
              obj = value;
              if (typeof obj === "function") {
                obj = obj.call(scope, fieldObject);
              }
              appearanceStreamString += "/" + i2 + " " + obj;
              if (!(scope.internal.acroformPlugin.xForms.indexOf(obj) >= 0))
                scope.internal.acroformPlugin.xForms.push(obj);
            }
            appearanceStreamString += ">>";
          }
        }
        keyValueList.push({
          key: "AP",
          value: "<<\n" + appearanceStreamString + ">>"
        });
      }
      scope.internal.putStream({
        additionalKeyValues: keyValueList,
        objectId: fieldObject.objId
      });
      scope.internal.out("endobj");
    }
  }
  if (standardFields) {
    createXFormObjectCallback(scope.internal.acroformPlugin.xForms, scope);
  }
};
var createXFormObjectCallback = function createXFormObjectCallback2(fieldArray, scope) {
  for (var i2 in fieldArray) {
    if (fieldArray.hasOwnProperty(i2)) {
      var key = i2;
      var fieldObject = fieldArray[i2];
      scope.internal.newObjectDeferredBegin(fieldObject.objId, true);
      if (_typeof(fieldObject) === "object" && typeof fieldObject.putStream === "function") {
        fieldObject.putStream();
      }
      delete fieldArray[key];
    }
  }
};
var initializeAcroForm = function initializeAcroForm2(scope, formObject) {
  formObject.scope = scope;
  if (scope.internal !== void 0 && (scope.internal.acroformPlugin === void 0 || scope.internal.acroformPlugin.isInitialized === false)) {
    AcroFormField.FieldNum = 0;
    scope.internal.acroformPlugin = JSON.parse(JSON.stringify(acroformPluginTemplate));
    if (scope.internal.acroformPlugin.acroFormDictionaryRoot) {
      throw new Error("Exception while creating AcroformDictionary");
    }
    scaleFactor = scope.internal.scaleFactor;
    scope.internal.acroformPlugin.acroFormDictionaryRoot = new AcroFormDictionary();
    scope.internal.acroformPlugin.acroFormDictionaryRoot.scope = scope;
    scope.internal.acroformPlugin.acroFormDictionaryRoot._eventID = scope.internal.events.subscribe("postPutResources", function() {
      AcroFormDictionaryCallback(scope);
    });
    scope.internal.events.subscribe("buildDocument", function() {
      annotReferenceCallback(scope);
    });
    scope.internal.events.subscribe("putCatalog", function() {
      putCatalogCallback(scope);
    });
    scope.internal.events.subscribe("postPutPages", function(fieldArray) {
      createFieldCallback(fieldArray, scope);
    });
    scope.internal.acroformPlugin.isInitialized = true;
  }
};
var arrayToPdfArray = jsPDFAPI.__acroform__.arrayToPdfArray = function(array2, objId, scope) {
  var encryptor = function encryptor2(data2) {
    return data2;
  };
  if (Array.isArray(array2)) {
    var content3 = "[";
    for (var i2 = 0; i2 < array2.length; i2++) {
      if (i2 !== 0) {
        content3 += " ";
      }
      switch (_typeof(array2[i2])) {
        case "boolean":
        case "number":
        case "object":
          content3 += array2[i2].toString();
          break;
        case "string":
          if (array2[i2].substr(0, 1) !== "/") {
            if (typeof objId !== "undefined" && scope)
              encryptor = scope.internal.getEncryptor(objId);
            content3 += "(" + pdfEscape(encryptor(array2[i2].toString())) + ")";
          } else {
            content3 += array2[i2].toString();
          }
          break;
      }
    }
    content3 += "]";
    return content3;
  }
  throw new Error("Invalid argument passed to jsPDF.__acroform__.arrayToPdfArray");
};
function getMatches(string3, regex, index3) {
  index3 || (index3 = 1);
  var matches = [];
  var match;
  while (match = regex.exec(string3)) {
    matches.push(match[index3]);
  }
  return matches;
}
var pdfArrayToStringArray = function pdfArrayToStringArray2(array2) {
  var result = [];
  if (typeof array2 === "string") {
    result = getMatches(array2, /\((.*?)\)/g);
  }
  return result;
};
var toPdfString = function toPdfString2(string3, objId, scope) {
  var encryptor = function encryptor2(data2) {
    return data2;
  };
  if (typeof objId !== "undefined" && scope)
    encryptor = scope.internal.getEncryptor(objId);
  string3 = string3 || "";
  string3.toString();
  string3 = "(" + pdfEscape(encryptor(string3)) + ")";
  return string3;
};
var AcroFormPDFObject = function AcroFormPDFObject2() {
  this._objId = void 0;
  this._scope = void 0;
  Object.defineProperty(this, "objId", {
    get: function get() {
      if (typeof this._objId === "undefined") {
        if (typeof this.scope === "undefined") {
          return void 0;
        }
        this._objId = this.scope.internal.newObjectDeferred();
      }
      return this._objId;
    },
    set: function set(value) {
      this._objId = value;
    }
  });
  Object.defineProperty(this, "scope", {
    value: this._scope,
    writable: true
  });
};
AcroFormPDFObject.prototype.toString = function() {
  return this.objId + " 0 R";
};
AcroFormPDFObject.prototype.putStream = function() {
  var keyValueList = this.getKeyValueListForStream();
  this.scope.internal.putStream({
    data: this.stream,
    additionalKeyValues: keyValueList,
    objectId: this.objId
  });
  this.scope.internal.out("endobj");
};
AcroFormPDFObject.prototype.getKeyValueListForStream = function() {
  var keyValueList = [];
  var keys = Object.getOwnPropertyNames(this).filter(function(key2) {
    return key2 != "content" && key2 != "appearanceStreamContent" && key2 != "scope" && key2 != "objId" && key2.substring(0, 1) != "_";
  });
  for (var i2 in keys) {
    if (Object.getOwnPropertyDescriptor(this, keys[i2]).configurable === false) {
      var key = keys[i2];
      var value = this[key];
      if (value) {
        if (Array.isArray(value)) {
          keyValueList.push({
            key,
            value: arrayToPdfArray(value, this.objId, this.scope)
          });
        } else if (value instanceof AcroFormPDFObject) {
          value.scope = this.scope;
          keyValueList.push({
            key,
            value: value.objId + " 0 R"
          });
        } else if (typeof value !== "function") {
          keyValueList.push({
            key,
            value
          });
        }
      }
    }
  }
  return keyValueList;
};
var AcroFormXObject = function AcroFormXObject2() {
  AcroFormPDFObject.call(this);
  Object.defineProperty(this, "Type", {
    value: "/XObject",
    configurable: false,
    writable: true
  });
  Object.defineProperty(this, "Subtype", {
    value: "/Form",
    configurable: false,
    writable: true
  });
  Object.defineProperty(this, "FormType", {
    value: 1,
    configurable: false,
    writable: true
  });
  var _BBox = [];
  Object.defineProperty(this, "BBox", {
    configurable: false,
    get: function get() {
      return _BBox;
    },
    set: function set(value) {
      _BBox = value;
    }
  });
  Object.defineProperty(this, "Resources", {
    value: "2 0 R",
    configurable: false,
    writable: true
  });
  var _stream;
  Object.defineProperty(this, "stream", {
    enumerable: false,
    configurable: true,
    set: function set(value) {
      _stream = value.trim();
    },
    get: function get() {
      if (_stream) {
        return _stream;
      } else {
        return null;
      }
    }
  });
};
inherit(AcroFormXObject, AcroFormPDFObject);
var AcroFormDictionary = function AcroFormDictionary2() {
  AcroFormPDFObject.call(this);
  var _Kids = [];
  Object.defineProperty(this, "Kids", {
    enumerable: false,
    configurable: true,
    get: function get() {
      if (_Kids.length > 0) {
        return _Kids;
      } else {
        return void 0;
      }
    }
  });
  Object.defineProperty(this, "Fields", {
    enumerable: false,
    configurable: false,
    get: function get() {
      return _Kids;
    }
  });
  var _DA;
  Object.defineProperty(this, "DA", {
    enumerable: false,
    configurable: false,
    get: function get() {
      if (!_DA) {
        return void 0;
      }
      var encryptor = function encryptor2(data2) {
        return data2;
      };
      if (this.scope)
        encryptor = this.scope.internal.getEncryptor(this.objId);
      return "(" + pdfEscape(encryptor(_DA)) + ")";
    },
    set: function set(value) {
      _DA = value;
    }
  });
};
inherit(AcroFormDictionary, AcroFormPDFObject);
var AcroFormField = function AcroFormField2() {
  AcroFormPDFObject.call(this);
  var _F = 4;
  Object.defineProperty(this, "F", {
    enumerable: false,
    configurable: false,
    get: function get() {
      return _F;
    },
    set: function set(value) {
      if (!isNaN(value)) {
        _F = value;
      } else {
        throw new Error('Invalid value "' + value + '" for attribute F supplied.');
      }
    }
  });
  Object.defineProperty(this, "showWhenPrinted", {
    enumerable: true,
    configurable: true,
    get: function get() {
      return Boolean(getBitForPdf(_F, 3));
    },
    set: function set(value) {
      if (Boolean(value) === true) {
        this.F = setBitForPdf(_F, 3);
      } else {
        this.F = clearBitForPdf(_F, 3);
      }
    }
  });
  var _Ff = 0;
  Object.defineProperty(this, "Ff", {
    enumerable: false,
    configurable: false,
    get: function get() {
      return _Ff;
    },
    set: function set(value) {
      if (!isNaN(value)) {
        _Ff = value;
      } else {
        throw new Error('Invalid value "' + value + '" for attribute Ff supplied.');
      }
    }
  });
  var _Rect = [];
  Object.defineProperty(this, "Rect", {
    enumerable: false,
    configurable: false,
    get: function get() {
      if (_Rect.length === 0) {
        return void 0;
      }
      return _Rect;
    },
    set: function set(value) {
      if (typeof value !== "undefined") {
        _Rect = value;
      } else {
        _Rect = [];
      }
    }
  });
  Object.defineProperty(this, "x", {
    enumerable: true,
    configurable: true,
    get: function get() {
      if (!_Rect || isNaN(_Rect[0])) {
        return 0;
      }
      return _Rect[0];
    },
    set: function set(value) {
      _Rect[0] = value;
    }
  });
  Object.defineProperty(this, "y", {
    enumerable: true,
    configurable: true,
    get: function get() {
      if (!_Rect || isNaN(_Rect[1])) {
        return 0;
      }
      return _Rect[1];
    },
    set: function set(value) {
      _Rect[1] = value;
    }
  });
  Object.defineProperty(this, "width", {
    enumerable: true,
    configurable: true,
    get: function get() {
      if (!_Rect || isNaN(_Rect[2])) {
        return 0;
      }
      return _Rect[2];
    },
    set: function set(value) {
      _Rect[2] = value;
    }
  });
  Object.defineProperty(this, "height", {
    enumerable: true,
    configurable: true,
    get: function get() {
      if (!_Rect || isNaN(_Rect[3])) {
        return 0;
      }
      return _Rect[3];
    },
    set: function set(value) {
      _Rect[3] = value;
    }
  });
  var _FT = "";
  Object.defineProperty(this, "FT", {
    enumerable: true,
    configurable: false,
    get: function get() {
      return _FT;
    },
    set: function set(value) {
      switch (value) {
        case "/Btn":
        case "/Tx":
        case "/Ch":
        case "/Sig":
          _FT = value;
          break;
        default:
          throw new Error('Invalid value "' + value + '" for attribute FT supplied.');
      }
    }
  });
  var _T = null;
  Object.defineProperty(this, "T", {
    enumerable: true,
    configurable: false,
    get: function get() {
      if (!_T || _T.length < 1) {
        if (this instanceof AcroFormChildClass) {
          return void 0;
        }
        _T = "FieldObject" + AcroFormField2.FieldNum++;
      }
      var encryptor = function encryptor2(data2) {
        return data2;
      };
      if (this.scope)
        encryptor = this.scope.internal.getEncryptor(this.objId);
      return "(" + pdfEscape(encryptor(_T)) + ")";
    },
    set: function set(value) {
      _T = value.toString();
    }
  });
  Object.defineProperty(this, "fieldName", {
    configurable: true,
    enumerable: true,
    get: function get() {
      return _T;
    },
    set: function set(value) {
      _T = value;
    }
  });
  var _fontName = "helvetica";
  Object.defineProperty(this, "fontName", {
    enumerable: true,
    configurable: true,
    get: function get() {
      return _fontName;
    },
    set: function set(value) {
      _fontName = value;
    }
  });
  var _fontStyle = "normal";
  Object.defineProperty(this, "fontStyle", {
    enumerable: true,
    configurable: true,
    get: function get() {
      return _fontStyle;
    },
    set: function set(value) {
      _fontStyle = value;
    }
  });
  var _fontSize = 0;
  Object.defineProperty(this, "fontSize", {
    enumerable: true,
    configurable: true,
    get: function get() {
      return _fontSize;
    },
    set: function set(value) {
      _fontSize = value;
    }
  });
  var _maxFontSize = void 0;
  Object.defineProperty(this, "maxFontSize", {
    enumerable: true,
    configurable: true,
    get: function get() {
      if (_maxFontSize === void 0) {
        return 50 / scaleFactor;
      } else {
        return _maxFontSize;
      }
    },
    set: function set(value) {
      _maxFontSize = value;
    }
  });
  var _color = "black";
  Object.defineProperty(this, "color", {
    enumerable: true,
    configurable: true,
    get: function get() {
      return _color;
    },
    set: function set(value) {
      _color = value;
    }
  });
  var _DA = "/F1 0 Tf 0 g";
  Object.defineProperty(this, "DA", {
    enumerable: true,
    configurable: false,
    get: function get() {
      if (!_DA || this instanceof AcroFormChildClass || this instanceof AcroFormTextField) {
        return void 0;
      }
      return toPdfString(_DA, this.objId, this.scope);
    },
    set: function set(value) {
      value = value.toString();
      _DA = value;
    }
  });
  var _DV = null;
  Object.defineProperty(this, "DV", {
    enumerable: false,
    configurable: false,
    get: function get() {
      if (!_DV) {
        return void 0;
      }
      if (this instanceof AcroFormButton === false) {
        return toPdfString(_DV, this.objId, this.scope);
      }
      return _DV;
    },
    set: function set(value) {
      value = value.toString();
      if (this instanceof AcroFormButton === false) {
        if (value.substr(0, 1) === "(") {
          _DV = pdfUnescape(value.substr(1, value.length - 2));
        } else {
          _DV = pdfUnescape(value);
        }
      } else {
        _DV = value;
      }
    }
  });
  Object.defineProperty(this, "defaultValue", {
    enumerable: true,
    configurable: true,
    get: function get() {
      if (this instanceof AcroFormButton === true) {
        return pdfUnescape(_DV.substr(1, _DV.length - 1));
      } else {
        return _DV;
      }
    },
    set: function set(value) {
      value = value.toString();
      if (this instanceof AcroFormButton === true) {
        _DV = "/" + value;
      } else {
        _DV = value;
      }
    }
  });
  var _V = null;
  Object.defineProperty(this, "_V", {
    enumerable: false,
    configurable: false,
    get: function get() {
      if (!_V) {
        return void 0;
      }
      return _V;
    },
    set: function set(value) {
      this.V = value;
    }
  });
  Object.defineProperty(this, "V", {
    enumerable: false,
    configurable: false,
    get: function get() {
      if (!_V) {
        return void 0;
      }
      if (this instanceof AcroFormButton === false) {
        return toPdfString(_V, this.objId, this.scope);
      }
      return _V;
    },
    set: function set(value) {
      value = value.toString();
      if (this instanceof AcroFormButton === false) {
        if (value.substr(0, 1) === "(") {
          _V = pdfUnescape(value.substr(1, value.length - 2));
        } else {
          _V = pdfUnescape(value);
        }
      } else {
        _V = value;
      }
    }
  });
  Object.defineProperty(this, "value", {
    enumerable: true,
    configurable: true,
    get: function get() {
      if (this instanceof AcroFormButton === true) {
        return pdfUnescape(_V.substr(1, _V.length - 1));
      } else {
        return _V;
      }
    },
    set: function set(value) {
      value = value.toString();
      if (this instanceof AcroFormButton === true) {
        _V = "/" + value;
      } else {
        _V = value;
      }
    }
  });
  Object.defineProperty(this, "hasAnnotation", {
    enumerable: true,
    configurable: true,
    get: function get() {
      return this.Rect;
    }
  });
  Object.defineProperty(this, "Type", {
    enumerable: true,
    configurable: false,
    get: function get() {
      return this.hasAnnotation ? "/Annot" : null;
    }
  });
  Object.defineProperty(this, "Subtype", {
    enumerable: true,
    configurable: false,
    get: function get() {
      return this.hasAnnotation ? "/Widget" : null;
    }
  });
  var _hasAppearanceStream = false;
  Object.defineProperty(this, "hasAppearanceStream", {
    enumerable: true,
    configurable: true,
    get: function get() {
      return _hasAppearanceStream;
    },
    set: function set(value) {
      value = Boolean(value);
      _hasAppearanceStream = value;
    }
  });
  var _page;
  Object.defineProperty(this, "page", {
    enumerable: true,
    configurable: true,
    get: function get() {
      if (!_page) {
        return void 0;
      }
      return _page;
    },
    set: function set(value) {
      _page = value;
    }
  });
  Object.defineProperty(this, "readOnly", {
    enumerable: true,
    configurable: true,
    get: function get() {
      return Boolean(getBitForPdf(this.Ff, 1));
    },
    set: function set(value) {
      if (Boolean(value) === true) {
        this.Ff = setBitForPdf(this.Ff, 1);
      } else {
        this.Ff = clearBitForPdf(this.Ff, 1);
      }
    }
  });
  Object.defineProperty(this, "required", {
    enumerable: true,
    configurable: true,
    get: function get() {
      return Boolean(getBitForPdf(this.Ff, 2));
    },
    set: function set(value) {
      if (Boolean(value) === true) {
        this.Ff = setBitForPdf(this.Ff, 2);
      } else {
        this.Ff = clearBitForPdf(this.Ff, 2);
      }
    }
  });
  Object.defineProperty(this, "noExport", {
    enumerable: true,
    configurable: true,
    get: function get() {
      return Boolean(getBitForPdf(this.Ff, 3));
    },
    set: function set(value) {
      if (Boolean(value) === true) {
        this.Ff = setBitForPdf(this.Ff, 3);
      } else {
        this.Ff = clearBitForPdf(this.Ff, 3);
      }
    }
  });
  var _Q = null;
  Object.defineProperty(this, "Q", {
    enumerable: true,
    configurable: false,
    get: function get() {
      if (_Q === null) {
        return void 0;
      }
      return _Q;
    },
    set: function set(value) {
      if ([0, 1, 2].indexOf(value) !== -1) {
        _Q = value;
      } else {
        throw new Error('Invalid value "' + value + '" for attribute Q supplied.');
      }
    }
  });
  Object.defineProperty(this, "textAlign", {
    get: function get() {
      var result;
      switch (_Q) {
        case 0:
        default:
          result = "left";
          break;
        case 1:
          result = "center";
          break;
        case 2:
          result = "right";
          break;
      }
      return result;
    },
    configurable: true,
    enumerable: true,
    set: function set(value) {
      switch (value) {
        case "right":
        case 2:
          _Q = 2;
          break;
        case "center":
        case 1:
          _Q = 1;
          break;
        case "left":
        case 0:
        default:
          _Q = 0;
      }
    }
  });
};
inherit(AcroFormField, AcroFormPDFObject);
var AcroFormChoiceField = function AcroFormChoiceField2() {
  AcroFormField.call(this);
  this.FT = "/Ch";
  this.V = "()";
  this.fontName = "zapfdingbats";
  var _TI = 0;
  Object.defineProperty(this, "TI", {
    enumerable: true,
    configurable: false,
    get: function get() {
      return _TI;
    },
    set: function set(value) {
      _TI = value;
    }
  });
  Object.defineProperty(this, "topIndex", {
    enumerable: true,
    configurable: true,
    get: function get() {
      return _TI;
    },
    set: function set(value) {
      _TI = value;
    }
  });
  var _Opt = [];
  Object.defineProperty(this, "Opt", {
    enumerable: true,
    configurable: false,
    get: function get() {
      return arrayToPdfArray(_Opt, this.objId, this.scope);
    },
    set: function set(value) {
      _Opt = pdfArrayToStringArray(value);
    }
  });
  this.getOptions = function() {
    return _Opt;
  };
  this.setOptions = function(value) {
    _Opt = value;
    if (this.sort) {
      _Opt.sort();
    }
  };
  this.addOption = function(value) {
    value = value || "";
    value = value.toString();
    _Opt.push(value);
    if (this.sort) {
      _Opt.sort();
    }
  };
  this.removeOption = function(value, allEntries) {
    allEntries = allEntries || false;
    value = value || "";
    value = value.toString();
    while (_Opt.indexOf(value) !== -1) {
      _Opt.splice(_Opt.indexOf(value), 1);
      if (allEntries === false) {
        break;
      }
    }
  };
  Object.defineProperty(this, "combo", {
    enumerable: true,
    configurable: true,
    get: function get() {
      return Boolean(getBitForPdf(this.Ff, 18));
    },
    set: function set(value) {
      if (Boolean(value) === true) {
        this.Ff = setBitForPdf(this.Ff, 18);
      } else {
        this.Ff = clearBitForPdf(this.Ff, 18);
      }
    }
  });
  Object.defineProperty(this, "edit", {
    enumerable: true,
    configurable: true,
    get: function get() {
      return Boolean(getBitForPdf(this.Ff, 19));
    },
    set: function set(value) {
      if (this.combo === true) {
        if (Boolean(value) === true) {
          this.Ff = setBitForPdf(this.Ff, 19);
        } else {
          this.Ff = clearBitForPdf(this.Ff, 19);
        }
      }
    }
  });
  Object.defineProperty(this, "sort", {
    enumerable: true,
    configurable: true,
    get: function get() {
      return Boolean(getBitForPdf(this.Ff, 20));
    },
    set: function set(value) {
      if (Boolean(value) === true) {
        this.Ff = setBitForPdf(this.Ff, 20);
        _Opt.sort();
      } else {
        this.Ff = clearBitForPdf(this.Ff, 20);
      }
    }
  });
  Object.defineProperty(this, "multiSelect", {
    enumerable: true,
    configurable: true,
    get: function get() {
      return Boolean(getBitForPdf(this.Ff, 22));
    },
    set: function set(value) {
      if (Boolean(value) === true) {
        this.Ff = setBitForPdf(this.Ff, 22);
      } else {
        this.Ff = clearBitForPdf(this.Ff, 22);
      }
    }
  });
  Object.defineProperty(this, "doNotSpellCheck", {
    enumerable: true,
    configurable: true,
    get: function get() {
      return Boolean(getBitForPdf(this.Ff, 23));
    },
    set: function set(value) {
      if (Boolean(value) === true) {
        this.Ff = setBitForPdf(this.Ff, 23);
      } else {
        this.Ff = clearBitForPdf(this.Ff, 23);
      }
    }
  });
  Object.defineProperty(this, "commitOnSelChange", {
    enumerable: true,
    configurable: true,
    get: function get() {
      return Boolean(getBitForPdf(this.Ff, 27));
    },
    set: function set(value) {
      if (Boolean(value) === true) {
        this.Ff = setBitForPdf(this.Ff, 27);
      } else {
        this.Ff = clearBitForPdf(this.Ff, 27);
      }
    }
  });
  this.hasAppearanceStream = false;
};
inherit(AcroFormChoiceField, AcroFormField);
var AcroFormListBox = function AcroFormListBox2() {
  AcroFormChoiceField.call(this);
  this.fontName = "helvetica";
  this.combo = false;
};
inherit(AcroFormListBox, AcroFormChoiceField);
var AcroFormComboBox = function AcroFormComboBox2() {
  AcroFormListBox.call(this);
  this.combo = true;
};
inherit(AcroFormComboBox, AcroFormListBox);
var AcroFormEditBox = function AcroFormEditBox2() {
  AcroFormComboBox.call(this);
  this.edit = true;
};
inherit(AcroFormEditBox, AcroFormComboBox);
var AcroFormButton = function AcroFormButton2() {
  AcroFormField.call(this);
  this.FT = "/Btn";
  Object.defineProperty(this, "noToggleToOff", {
    enumerable: true,
    configurable: true,
    get: function get() {
      return Boolean(getBitForPdf(this.Ff, 15));
    },
    set: function set(value) {
      if (Boolean(value) === true) {
        this.Ff = setBitForPdf(this.Ff, 15);
      } else {
        this.Ff = clearBitForPdf(this.Ff, 15);
      }
    }
  });
  Object.defineProperty(this, "radio", {
    enumerable: true,
    configurable: true,
    get: function get() {
      return Boolean(getBitForPdf(this.Ff, 16));
    },
    set: function set(value) {
      if (Boolean(value) === true) {
        this.Ff = setBitForPdf(this.Ff, 16);
      } else {
        this.Ff = clearBitForPdf(this.Ff, 16);
      }
    }
  });
  Object.defineProperty(this, "pushButton", {
    enumerable: true,
    configurable: true,
    get: function get() {
      return Boolean(getBitForPdf(this.Ff, 17));
    },
    set: function set(value) {
      if (Boolean(value) === true) {
        this.Ff = setBitForPdf(this.Ff, 17);
      } else {
        this.Ff = clearBitForPdf(this.Ff, 17);
      }
    }
  });
  Object.defineProperty(this, "radioIsUnison", {
    enumerable: true,
    configurable: true,
    get: function get() {
      return Boolean(getBitForPdf(this.Ff, 26));
    },
    set: function set(value) {
      if (Boolean(value) === true) {
        this.Ff = setBitForPdf(this.Ff, 26);
      } else {
        this.Ff = clearBitForPdf(this.Ff, 26);
      }
    }
  });
  var _MK = {};
  Object.defineProperty(this, "MK", {
    enumerable: false,
    configurable: false,
    get: function get() {
      var encryptor = function encryptor2(data2) {
        return data2;
      };
      if (this.scope)
        encryptor = this.scope.internal.getEncryptor(this.objId);
      if (Object.keys(_MK).length !== 0) {
        var result = [];
        result.push("<<");
        var key;
        for (key in _MK) {
          result.push("/" + key + " (" + pdfEscape(encryptor(_MK[key])) + ")");
        }
        result.push(">>");
        return result.join("\n");
      }
      return void 0;
    },
    set: function set(value) {
      if (_typeof(value) === "object") {
        _MK = value;
      }
    }
  });
  Object.defineProperty(this, "caption", {
    enumerable: true,
    configurable: true,
    get: function get() {
      return _MK.CA || "";
    },
    set: function set(value) {
      if (typeof value === "string") {
        _MK.CA = value;
      }
    }
  });
  var _AS;
  Object.defineProperty(this, "AS", {
    enumerable: false,
    configurable: false,
    get: function get() {
      return _AS;
    },
    set: function set(value) {
      _AS = value;
    }
  });
  Object.defineProperty(this, "appearanceState", {
    enumerable: true,
    configurable: true,
    get: function get() {
      return _AS.substr(1, _AS.length - 1);
    },
    set: function set(value) {
      _AS = "/" + value;
    }
  });
};
inherit(AcroFormButton, AcroFormField);
var AcroFormPushButton = function AcroFormPushButton2() {
  AcroFormButton.call(this);
  this.pushButton = true;
};
inherit(AcroFormPushButton, AcroFormButton);
var AcroFormRadioButton = function AcroFormRadioButton2() {
  AcroFormButton.call(this);
  this.radio = true;
  this.pushButton = false;
  var _Kids = [];
  Object.defineProperty(this, "Kids", {
    enumerable: true,
    configurable: false,
    get: function get() {
      return _Kids;
    },
    set: function set(value) {
      if (typeof value !== "undefined") {
        _Kids = value;
      } else {
        _Kids = [];
      }
    }
  });
};
inherit(AcroFormRadioButton, AcroFormButton);
var AcroFormChildClass = function AcroFormChildClass2() {
  AcroFormField.call(this);
  var _parent;
  Object.defineProperty(this, "Parent", {
    enumerable: false,
    configurable: false,
    get: function get() {
      return _parent;
    },
    set: function set(value) {
      _parent = value;
    }
  });
  var _optionName;
  Object.defineProperty(this, "optionName", {
    enumerable: false,
    configurable: true,
    get: function get() {
      return _optionName;
    },
    set: function set(value) {
      _optionName = value;
    }
  });
  var _MK = {};
  Object.defineProperty(this, "MK", {
    enumerable: false,
    configurable: false,
    get: function get() {
      var encryptor = function encryptor2(data2) {
        return data2;
      };
      if (this.scope)
        encryptor = this.scope.internal.getEncryptor(this.objId);
      var result = [];
      result.push("<<");
      var key;
      for (key in _MK) {
        result.push("/" + key + " (" + pdfEscape(encryptor(_MK[key])) + ")");
      }
      result.push(">>");
      return result.join("\n");
    },
    set: function set(value) {
      if (_typeof(value) === "object") {
        _MK = value;
      }
    }
  });
  Object.defineProperty(this, "caption", {
    enumerable: true,
    configurable: true,
    get: function get() {
      return _MK.CA || "";
    },
    set: function set(value) {
      if (typeof value === "string") {
        _MK.CA = value;
      }
    }
  });
  var _AS;
  Object.defineProperty(this, "AS", {
    enumerable: false,
    configurable: false,
    get: function get() {
      return _AS;
    },
    set: function set(value) {
      _AS = value;
    }
  });
  Object.defineProperty(this, "appearanceState", {
    enumerable: true,
    configurable: true,
    get: function get() {
      return _AS.substr(1, _AS.length - 1);
    },
    set: function set(value) {
      _AS = "/" + value;
    }
  });
  this.caption = "l";
  this.appearanceState = "Off";
  this._AppearanceType = AcroFormAppearance.RadioButton.Circle;
  this.appearanceStreamContent = this._AppearanceType.createAppearanceStream(this.optionName);
};
inherit(AcroFormChildClass, AcroFormField);
AcroFormRadioButton.prototype.setAppearance = function(appearance) {
  if (!("createAppearanceStream" in appearance && "getCA" in appearance)) {
    throw new Error("Couldn't assign Appearance to RadioButton. Appearance was Invalid!");
  }
  for (var objId in this.Kids) {
    if (this.Kids.hasOwnProperty(objId)) {
      var child = this.Kids[objId];
      child.appearanceStreamContent = appearance.createAppearanceStream(child.optionName);
      child.caption = appearance.getCA();
    }
  }
};
AcroFormRadioButton.prototype.createOption = function(name) {
  var child = new AcroFormChildClass();
  child.Parent = this;
  child.optionName = name;
  this.Kids.push(child);
  addField.call(this.scope, child);
  return child;
};
var AcroFormCheckBox = function AcroFormCheckBox2() {
  AcroFormButton.call(this);
  this.fontName = "zapfdingbats";
  this.caption = "3";
  this.appearanceState = "On";
  this.value = "On";
  this.textAlign = "center";
  this.appearanceStreamContent = AcroFormAppearance.CheckBox.createAppearanceStream();
};
inherit(AcroFormCheckBox, AcroFormButton);
var AcroFormTextField = function AcroFormTextField2() {
  AcroFormField.call(this);
  this.FT = "/Tx";
  Object.defineProperty(this, "multiline", {
    enumerable: true,
    configurable: true,
    get: function get() {
      return Boolean(getBitForPdf(this.Ff, 13));
    },
    set: function set(value) {
      if (Boolean(value) === true) {
        this.Ff = setBitForPdf(this.Ff, 13);
      } else {
        this.Ff = clearBitForPdf(this.Ff, 13);
      }
    }
  });
  Object.defineProperty(this, "fileSelect", {
    enumerable: true,
    configurable: true,
    get: function get() {
      return Boolean(getBitForPdf(this.Ff, 21));
    },
    set: function set(value) {
      if (Boolean(value) === true) {
        this.Ff = setBitForPdf(this.Ff, 21);
      } else {
        this.Ff = clearBitForPdf(this.Ff, 21);
      }
    }
  });
  Object.defineProperty(this, "doNotSpellCheck", {
    enumerable: true,
    configurable: true,
    get: function get() {
      return Boolean(getBitForPdf(this.Ff, 23));
    },
    set: function set(value) {
      if (Boolean(value) === true) {
        this.Ff = setBitForPdf(this.Ff, 23);
      } else {
        this.Ff = clearBitForPdf(this.Ff, 23);
      }
    }
  });
  Object.defineProperty(this, "doNotScroll", {
    enumerable: true,
    configurable: true,
    get: function get() {
      return Boolean(getBitForPdf(this.Ff, 24));
    },
    set: function set(value) {
      if (Boolean(value) === true) {
        this.Ff = setBitForPdf(this.Ff, 24);
      } else {
        this.Ff = clearBitForPdf(this.Ff, 24);
      }
    }
  });
  Object.defineProperty(this, "comb", {
    enumerable: true,
    configurable: true,
    get: function get() {
      return Boolean(getBitForPdf(this.Ff, 25));
    },
    set: function set(value) {
      if (Boolean(value) === true) {
        this.Ff = setBitForPdf(this.Ff, 25);
      } else {
        this.Ff = clearBitForPdf(this.Ff, 25);
      }
    }
  });
  Object.defineProperty(this, "richText", {
    enumerable: true,
    configurable: true,
    get: function get() {
      return Boolean(getBitForPdf(this.Ff, 26));
    },
    set: function set(value) {
      if (Boolean(value) === true) {
        this.Ff = setBitForPdf(this.Ff, 26);
      } else {
        this.Ff = clearBitForPdf(this.Ff, 26);
      }
    }
  });
  var _MaxLen = null;
  Object.defineProperty(this, "MaxLen", {
    enumerable: true,
    configurable: false,
    get: function get() {
      return _MaxLen;
    },
    set: function set(value) {
      _MaxLen = value;
    }
  });
  Object.defineProperty(this, "maxLength", {
    enumerable: true,
    configurable: true,
    get: function get() {
      return _MaxLen;
    },
    set: function set(value) {
      if (Number.isInteger(value)) {
        _MaxLen = value;
      }
    }
  });
  Object.defineProperty(this, "hasAppearanceStream", {
    enumerable: true,
    configurable: true,
    get: function get() {
      return this.V || this.DV;
    }
  });
};
inherit(AcroFormTextField, AcroFormField);
var AcroFormPasswordField = function AcroFormPasswordField2() {
  AcroFormTextField.call(this);
  Object.defineProperty(this, "password", {
    enumerable: true,
    configurable: true,
    get: function get() {
      return Boolean(getBitForPdf(this.Ff, 14));
    },
    set: function set(value) {
      if (Boolean(value) === true) {
        this.Ff = setBitForPdf(this.Ff, 14);
      } else {
        this.Ff = clearBitForPdf(this.Ff, 14);
      }
    }
  });
  this.password = true;
};
inherit(AcroFormPasswordField, AcroFormTextField);
var AcroFormAppearance = {
  CheckBox: {
    createAppearanceStream: function createAppearanceStream() {
      var appearance = {
        N: {
          On: AcroFormAppearance.CheckBox.YesNormal
        },
        D: {
          On: AcroFormAppearance.CheckBox.YesPushDown,
          Off: AcroFormAppearance.CheckBox.OffPushDown
        }
      };
      return appearance;
    },
    /**
     * Returns the standard On Appearance for a CheckBox
     *
     * @returns {AcroFormXObject}
     */
    YesPushDown: function YesPushDown(formObject) {
      var xobj = createFormXObject(formObject);
      xobj.scope = formObject.scope;
      var stream = [];
      var fontKey = formObject.scope.internal.getFont(formObject.fontName, formObject.fontStyle).id;
      var encodedColor = formObject.scope.__private__.encodeColorString(formObject.color);
      var calcRes = calculateX(formObject, formObject.caption);
      stream.push("0.749023 g");
      stream.push("0 0 " + f2(AcroFormAppearance.internal.getWidth(formObject)) + " " + f2(AcroFormAppearance.internal.getHeight(formObject)) + " re");
      stream.push("f");
      stream.push("BMC");
      stream.push("q");
      stream.push("0 0 1 rg");
      stream.push("/" + fontKey + " " + f2(calcRes.fontSize) + " Tf " + encodedColor);
      stream.push("BT");
      stream.push(calcRes.text);
      stream.push("ET");
      stream.push("Q");
      stream.push("EMC");
      xobj.stream = stream.join("\n");
      return xobj;
    },
    YesNormal: function YesNormal(formObject) {
      var xobj = createFormXObject(formObject);
      xobj.scope = formObject.scope;
      var fontKey = formObject.scope.internal.getFont(formObject.fontName, formObject.fontStyle).id;
      var encodedColor = formObject.scope.__private__.encodeColorString(formObject.color);
      var stream = [];
      var height2 = AcroFormAppearance.internal.getHeight(formObject);
      var width2 = AcroFormAppearance.internal.getWidth(formObject);
      var calcRes = calculateX(formObject, formObject.caption);
      stream.push("1 g");
      stream.push("0 0 " + f2(width2) + " " + f2(height2) + " re");
      stream.push("f");
      stream.push("q");
      stream.push("0 0 1 rg");
      stream.push("0 0 " + f2(width2 - 1) + " " + f2(height2 - 1) + " re");
      stream.push("W");
      stream.push("n");
      stream.push("0 g");
      stream.push("BT");
      stream.push("/" + fontKey + " " + f2(calcRes.fontSize) + " Tf " + encodedColor);
      stream.push(calcRes.text);
      stream.push("ET");
      stream.push("Q");
      xobj.stream = stream.join("\n");
      return xobj;
    },
    /**
     * Returns the standard Off Appearance for a CheckBox
     *
     * @returns {AcroFormXObject}
     */
    OffPushDown: function OffPushDown(formObject) {
      var xobj = createFormXObject(formObject);
      xobj.scope = formObject.scope;
      var stream = [];
      stream.push("0.749023 g");
      stream.push("0 0 " + f2(AcroFormAppearance.internal.getWidth(formObject)) + " " + f2(AcroFormAppearance.internal.getHeight(formObject)) + " re");
      stream.push("f");
      xobj.stream = stream.join("\n");
      return xobj;
    }
  },
  RadioButton: {
    Circle: {
      createAppearanceStream: function createAppearanceStream2(name) {
        var appearanceStreamContent = {
          D: {
            Off: AcroFormAppearance.RadioButton.Circle.OffPushDown
          },
          N: {}
        };
        appearanceStreamContent.N[name] = AcroFormAppearance.RadioButton.Circle.YesNormal;
        appearanceStreamContent.D[name] = AcroFormAppearance.RadioButton.Circle.YesPushDown;
        return appearanceStreamContent;
      },
      getCA: function getCA() {
        return "l";
      },
      YesNormal: function YesNormal2(formObject) {
        var xobj = createFormXObject(formObject);
        xobj.scope = formObject.scope;
        var stream = [];
        var DotRadius = AcroFormAppearance.internal.getWidth(formObject) <= AcroFormAppearance.internal.getHeight(formObject) ? AcroFormAppearance.internal.getWidth(formObject) / 4 : AcroFormAppearance.internal.getHeight(formObject) / 4;
        DotRadius = Number((DotRadius * 0.9).toFixed(5));
        var c3 = AcroFormAppearance.internal.Bezier_C;
        var DotRadiusBezier = Number((DotRadius * c3).toFixed(5));
        stream.push("q");
        stream.push("1 0 0 1 " + f5(AcroFormAppearance.internal.getWidth(formObject) / 2) + " " + f5(AcroFormAppearance.internal.getHeight(formObject) / 2) + " cm");
        stream.push(DotRadius + " 0 m");
        stream.push(DotRadius + " " + DotRadiusBezier + " " + DotRadiusBezier + " " + DotRadius + " 0 " + DotRadius + " c");
        stream.push("-" + DotRadiusBezier + " " + DotRadius + " -" + DotRadius + " " + DotRadiusBezier + " -" + DotRadius + " 0 c");
        stream.push("-" + DotRadius + " -" + DotRadiusBezier + " -" + DotRadiusBezier + " -" + DotRadius + " 0 -" + DotRadius + " c");
        stream.push(DotRadiusBezier + " -" + DotRadius + " " + DotRadius + " -" + DotRadiusBezier + " " + DotRadius + " 0 c");
        stream.push("f");
        stream.push("Q");
        xobj.stream = stream.join("\n");
        return xobj;
      },
      YesPushDown: function YesPushDown2(formObject) {
        var xobj = createFormXObject(formObject);
        xobj.scope = formObject.scope;
        var stream = [];
        var DotRadius = AcroFormAppearance.internal.getWidth(formObject) <= AcroFormAppearance.internal.getHeight(formObject) ? AcroFormAppearance.internal.getWidth(formObject) / 4 : AcroFormAppearance.internal.getHeight(formObject) / 4;
        DotRadius = Number((DotRadius * 0.9).toFixed(5));
        var k = Number((DotRadius * 2).toFixed(5));
        var kc = Number((k * AcroFormAppearance.internal.Bezier_C).toFixed(5));
        var dc = Number((DotRadius * AcroFormAppearance.internal.Bezier_C).toFixed(5));
        stream.push("0.749023 g");
        stream.push("q");
        stream.push("1 0 0 1 " + f5(AcroFormAppearance.internal.getWidth(formObject) / 2) + " " + f5(AcroFormAppearance.internal.getHeight(formObject) / 2) + " cm");
        stream.push(k + " 0 m");
        stream.push(k + " " + kc + " " + kc + " " + k + " 0 " + k + " c");
        stream.push("-" + kc + " " + k + " -" + k + " " + kc + " -" + k + " 0 c");
        stream.push("-" + k + " -" + kc + " -" + kc + " -" + k + " 0 -" + k + " c");
        stream.push(kc + " -" + k + " " + k + " -" + kc + " " + k + " 0 c");
        stream.push("f");
        stream.push("Q");
        stream.push("0 g");
        stream.push("q");
        stream.push("1 0 0 1 " + f5(AcroFormAppearance.internal.getWidth(formObject) / 2) + " " + f5(AcroFormAppearance.internal.getHeight(formObject) / 2) + " cm");
        stream.push(DotRadius + " 0 m");
        stream.push("" + DotRadius + " " + dc + " " + dc + " " + DotRadius + " 0 " + DotRadius + " c");
        stream.push("-" + dc + " " + DotRadius + " -" + DotRadius + " " + dc + " -" + DotRadius + " 0 c");
        stream.push("-" + DotRadius + " -" + dc + " -" + dc + " -" + DotRadius + " 0 -" + DotRadius + " c");
        stream.push(dc + " -" + DotRadius + " " + DotRadius + " -" + dc + " " + DotRadius + " 0 c");
        stream.push("f");
        stream.push("Q");
        xobj.stream = stream.join("\n");
        return xobj;
      },
      OffPushDown: function OffPushDown2(formObject) {
        var xobj = createFormXObject(formObject);
        xobj.scope = formObject.scope;
        var stream = [];
        var DotRadius = AcroFormAppearance.internal.getWidth(formObject) <= AcroFormAppearance.internal.getHeight(formObject) ? AcroFormAppearance.internal.getWidth(formObject) / 4 : AcroFormAppearance.internal.getHeight(formObject) / 4;
        DotRadius = Number((DotRadius * 0.9).toFixed(5));
        var k = Number((DotRadius * 2).toFixed(5));
        var kc = Number((k * AcroFormAppearance.internal.Bezier_C).toFixed(5));
        stream.push("0.749023 g");
        stream.push("q");
        stream.push("1 0 0 1 " + f5(AcroFormAppearance.internal.getWidth(formObject) / 2) + " " + f5(AcroFormAppearance.internal.getHeight(formObject) / 2) + " cm");
        stream.push(k + " 0 m");
        stream.push(k + " " + kc + " " + kc + " " + k + " 0 " + k + " c");
        stream.push("-" + kc + " " + k + " -" + k + " " + kc + " -" + k + " 0 c");
        stream.push("-" + k + " -" + kc + " -" + kc + " -" + k + " 0 -" + k + " c");
        stream.push(kc + " -" + k + " " + k + " -" + kc + " " + k + " 0 c");
        stream.push("f");
        stream.push("Q");
        xobj.stream = stream.join("\n");
        return xobj;
      }
    },
    Cross: {
      /**
       * Creates the Actual AppearanceDictionary-References
       *
       * @param {string} name
       * @returns {Object}
       * @ignore
       */
      createAppearanceStream: function createAppearanceStream3(name) {
        var appearanceStreamContent = {
          D: {
            Off: AcroFormAppearance.RadioButton.Cross.OffPushDown
          },
          N: {}
        };
        appearanceStreamContent.N[name] = AcroFormAppearance.RadioButton.Cross.YesNormal;
        appearanceStreamContent.D[name] = AcroFormAppearance.RadioButton.Cross.YesPushDown;
        return appearanceStreamContent;
      },
      getCA: function getCA2() {
        return "8";
      },
      YesNormal: function YesNormal3(formObject) {
        var xobj = createFormXObject(formObject);
        xobj.scope = formObject.scope;
        var stream = [];
        var cross = AcroFormAppearance.internal.calculateCross(formObject);
        stream.push("q");
        stream.push("1 1 " + f2(AcroFormAppearance.internal.getWidth(formObject) - 2) + " " + f2(AcroFormAppearance.internal.getHeight(formObject) - 2) + " re");
        stream.push("W");
        stream.push("n");
        stream.push(f2(cross.x1.x) + " " + f2(cross.x1.y) + " m");
        stream.push(f2(cross.x2.x) + " " + f2(cross.x2.y) + " l");
        stream.push(f2(cross.x4.x) + " " + f2(cross.x4.y) + " m");
        stream.push(f2(cross.x3.x) + " " + f2(cross.x3.y) + " l");
        stream.push("s");
        stream.push("Q");
        xobj.stream = stream.join("\n");
        return xobj;
      },
      YesPushDown: function YesPushDown3(formObject) {
        var xobj = createFormXObject(formObject);
        xobj.scope = formObject.scope;
        var cross = AcroFormAppearance.internal.calculateCross(formObject);
        var stream = [];
        stream.push("0.749023 g");
        stream.push("0 0 " + f2(AcroFormAppearance.internal.getWidth(formObject)) + " " + f2(AcroFormAppearance.internal.getHeight(formObject)) + " re");
        stream.push("f");
        stream.push("q");
        stream.push("1 1 " + f2(AcroFormAppearance.internal.getWidth(formObject) - 2) + " " + f2(AcroFormAppearance.internal.getHeight(formObject) - 2) + " re");
        stream.push("W");
        stream.push("n");
        stream.push(f2(cross.x1.x) + " " + f2(cross.x1.y) + " m");
        stream.push(f2(cross.x2.x) + " " + f2(cross.x2.y) + " l");
        stream.push(f2(cross.x4.x) + " " + f2(cross.x4.y) + " m");
        stream.push(f2(cross.x3.x) + " " + f2(cross.x3.y) + " l");
        stream.push("s");
        stream.push("Q");
        xobj.stream = stream.join("\n");
        return xobj;
      },
      OffPushDown: function OffPushDown3(formObject) {
        var xobj = createFormXObject(formObject);
        xobj.scope = formObject.scope;
        var stream = [];
        stream.push("0.749023 g");
        stream.push("0 0 " + f2(AcroFormAppearance.internal.getWidth(formObject)) + " " + f2(AcroFormAppearance.internal.getHeight(formObject)) + " re");
        stream.push("f");
        xobj.stream = stream.join("\n");
        return xobj;
      }
    }
  },
  /**
   * Returns the standard Appearance
   *
   * @returns {AcroFormXObject}
   */
  createDefaultAppearanceStream: function createDefaultAppearanceStream(formObject) {
    var fontKey = formObject.scope.internal.getFont(formObject.fontName, formObject.fontStyle).id;
    var encodedColor = formObject.scope.__private__.encodeColorString(formObject.color);
    var fontSize = formObject.fontSize;
    var result = "/" + fontKey + " " + fontSize + " Tf " + encodedColor;
    return result;
  }
};
AcroFormAppearance.internal = {
  Bezier_C: 0.551915024494,
  calculateCross: function calculateCross(formObject) {
    var width2 = AcroFormAppearance.internal.getWidth(formObject);
    var height2 = AcroFormAppearance.internal.getHeight(formObject);
    var a2 = Math.min(width2, height2);
    var cross = {
      x1: {
        // upperLeft
        x: (width2 - a2) / 2,
        y: (height2 - a2) / 2 + a2
        // height - borderPadding
      },
      x2: {
        // lowerRight
        x: (width2 - a2) / 2 + a2,
        y: (height2 - a2) / 2
        // borderPadding
      },
      x3: {
        // lowerLeft
        x: (width2 - a2) / 2,
        y: (height2 - a2) / 2
        // borderPadding
      },
      x4: {
        // upperRight
        x: (width2 - a2) / 2 + a2,
        y: (height2 - a2) / 2 + a2
        // height - borderPadding
      }
    };
    return cross;
  }
};
AcroFormAppearance.internal.getWidth = function(formObject) {
  var result = 0;
  if (_typeof(formObject) === "object") {
    result = scale(formObject.Rect[2]);
  }
  return result;
};
AcroFormAppearance.internal.getHeight = function(formObject) {
  var result = 0;
  if (_typeof(formObject) === "object") {
    result = scale(formObject.Rect[3]);
  }
  return result;
};
var addField = jsPDFAPI.addField = function(fieldObject) {
  initializeAcroForm(this, fieldObject);
  if (fieldObject instanceof AcroFormField) {
    putForm(fieldObject);
  } else {
    throw new Error("Invalid argument passed to jsPDF.addField.");
  }
  fieldObject.page = fieldObject.scope.internal.getCurrentPageInfo().pageNumber;
  return this;
};
jsPDFAPI.AcroFormChoiceField = AcroFormChoiceField;
jsPDFAPI.AcroFormListBox = AcroFormListBox;
jsPDFAPI.AcroFormComboBox = AcroFormComboBox;
jsPDFAPI.AcroFormEditBox = AcroFormEditBox;
jsPDFAPI.AcroFormButton = AcroFormButton;
jsPDFAPI.AcroFormPushButton = AcroFormPushButton;
jsPDFAPI.AcroFormRadioButton = AcroFormRadioButton;
jsPDFAPI.AcroFormCheckBox = AcroFormCheckBox;
jsPDFAPI.AcroFormTextField = AcroFormTextField;
jsPDFAPI.AcroFormPasswordField = AcroFormPasswordField;
jsPDFAPI.AcroFormAppearance = AcroFormAppearance;
jsPDFAPI.AcroForm = {
  ChoiceField: AcroFormChoiceField,
  ListBox: AcroFormListBox,
  ComboBox: AcroFormComboBox,
  EditBox: AcroFormEditBox,
  Button: AcroFormButton,
  PushButton: AcroFormPushButton,
  RadioButton: AcroFormRadioButton,
  CheckBox: AcroFormCheckBox,
  TextField: AcroFormTextField,
  PasswordField: AcroFormPasswordField,
  Appearance: AcroFormAppearance
};
jsPDF.AcroForm = {
  ChoiceField: AcroFormChoiceField,
  ListBox: AcroFormListBox,
  ComboBox: AcroFormComboBox,
  EditBox: AcroFormEditBox,
  Button: AcroFormButton,
  PushButton: AcroFormPushButton,
  RadioButton: AcroFormRadioButton,
  CheckBox: AcroFormCheckBox,
  TextField: AcroFormTextField,
  PasswordField: AcroFormPasswordField,
  Appearance: AcroFormAppearance
};
var AcroForm = jsPDF.AcroForm;
(function(jsPDFAPI2) {
  var namespace = "addImage_";
  jsPDFAPI2.__addimage__ = {};
  var UNKNOWN = "UNKNOWN";
  var ARRAY_APPLY_BATCH = 8192;
  var imageFileTypeHeaders = {
    PNG: [[137, 80, 78, 71]],
    TIFF: [
      [77, 77, 0, 42],
      //Motorola
      [73, 73, 42, 0]
      //Intel
    ],
    JPEG: [
      [255, 216, 255, 224, void 0, void 0, 74, 70, 73, 70, 0],
      //JFIF
      [255, 216, 255, 225, void 0, void 0, 69, 120, 105, 102, 0, 0],
      //Exif
      [255, 216, 255, 219],
      //JPEG RAW
      [255, 216, 255, 238]
      //EXIF RAW
    ],
    JPEG2000: [[0, 0, 0, 12, 106, 80, 32, 32]],
    GIF87a: [[71, 73, 70, 56, 55, 97]],
    GIF89a: [[71, 73, 70, 56, 57, 97]],
    WEBP: [[82, 73, 70, 70, void 0, void 0, void 0, void 0, 87, 69, 66, 80]],
    BMP: [
      [66, 77],
      //BM - Windows 3.1x, 95, NT, ... etc.
      [66, 65],
      //BA - OS/2 struct bitmap array
      [67, 73],
      //CI - OS/2 struct color icon
      [67, 80],
      //CP - OS/2 const color pointer
      [73, 67],
      //IC - OS/2 struct icon
      [80, 84]
      //PT - OS/2 pointer
    ]
  };
  var getImageFileTypeByImageData = jsPDFAPI2.__addimage__.getImageFileTypeByImageData = function(imageData, fallbackFormat) {
    fallbackFormat = fallbackFormat || UNKNOWN;
    var i2;
    var j;
    var result = UNKNOWN;
    var headerSchemata;
    var compareResult;
    var fileType;
    if (fallbackFormat === "RGBA" || imageData.data !== void 0 && imageData.data instanceof Uint8ClampedArray && "height" in imageData && "width" in imageData) {
      return "RGBA";
    }
    if (isArrayBufferView(imageData)) {
      for (fileType in imageFileTypeHeaders) {
        headerSchemata = imageFileTypeHeaders[fileType];
        for (i2 = 0; i2 < headerSchemata.length; i2 += 1) {
          compareResult = true;
          for (j = 0; j < headerSchemata[i2].length; j += 1) {
            if (headerSchemata[i2][j] === void 0) {
              continue;
            }
            if (headerSchemata[i2][j] !== imageData[j]) {
              compareResult = false;
              break;
            }
          }
          if (compareResult === true) {
            result = fileType;
            break;
          }
        }
      }
    } else {
      for (fileType in imageFileTypeHeaders) {
        headerSchemata = imageFileTypeHeaders[fileType];
        for (i2 = 0; i2 < headerSchemata.length; i2 += 1) {
          compareResult = true;
          for (j = 0; j < headerSchemata[i2].length; j += 1) {
            if (headerSchemata[i2][j] === void 0) {
              continue;
            }
            if (headerSchemata[i2][j] !== imageData.charCodeAt(j)) {
              compareResult = false;
              break;
            }
          }
          if (compareResult === true) {
            result = fileType;
            break;
          }
        }
      }
    }
    if (result === UNKNOWN && fallbackFormat !== UNKNOWN) {
      result = fallbackFormat;
    }
    return result;
  };
  var putImage = function putImage2(image) {
    var out = this.internal.write;
    var putStream = this.internal.putStream;
    var getFilters = this.internal.getFilters;
    var filter2 = getFilters();
    while (filter2.indexOf("FlateEncode") !== -1) {
      filter2.splice(filter2.indexOf("FlateEncode"), 1);
    }
    image.objectId = this.internal.newObject();
    var additionalKeyValues = [];
    additionalKeyValues.push({
      key: "Type",
      value: "/XObject"
    });
    additionalKeyValues.push({
      key: "Subtype",
      value: "/Image"
    });
    additionalKeyValues.push({
      key: "Width",
      value: image.width
    });
    additionalKeyValues.push({
      key: "Height",
      value: image.height
    });
    if (image.colorSpace === color_spaces.INDEXED) {
      additionalKeyValues.push({
        key: "ColorSpace",
        value: "[/Indexed /DeviceRGB " + // if an indexed png defines more than one colour with transparency, we've created a sMask
        (image.palette.length / 3 - 1) + " " + ("sMask" in image && typeof image.sMask !== "undefined" ? image.objectId + 2 : image.objectId + 1) + " 0 R]"
      });
    } else {
      additionalKeyValues.push({
        key: "ColorSpace",
        value: "/" + image.colorSpace
      });
      if (image.colorSpace === color_spaces.DEVICE_CMYK) {
        additionalKeyValues.push({
          key: "Decode",
          value: "[1 0 1 0 1 0 1 0]"
        });
      }
    }
    additionalKeyValues.push({
      key: "BitsPerComponent",
      value: image.bitsPerComponent
    });
    if ("decodeParameters" in image && typeof image.decodeParameters !== "undefined") {
      additionalKeyValues.push({
        key: "DecodeParms",
        value: "<<" + image.decodeParameters + ">>"
      });
    }
    if ("transparency" in image && Array.isArray(image.transparency)) {
      var transparency = "", i2 = 0, len = image.transparency.length;
      for (; i2 < len; i2++) {
        transparency += image.transparency[i2] + " " + image.transparency[i2] + " ";
      }
      additionalKeyValues.push({
        key: "Mask",
        value: "[" + transparency + "]"
      });
    }
    if (typeof image.sMask !== "undefined") {
      additionalKeyValues.push({
        key: "SMask",
        value: image.objectId + 1 + " 0 R"
      });
    }
    var alreadyAppliedFilters = typeof image.filter !== "undefined" ? ["/" + image.filter] : void 0;
    putStream({
      data: image.data,
      additionalKeyValues,
      alreadyAppliedFilters,
      objectId: image.objectId
    });
    out("endobj");
    if ("sMask" in image && typeof image.sMask !== "undefined") {
      var decodeParameters = "/Predictor " + image.predictor + " /Colors 1 /BitsPerComponent " + image.bitsPerComponent + " /Columns " + image.width;
      var sMask = {
        width: image.width,
        height: image.height,
        colorSpace: "DeviceGray",
        bitsPerComponent: image.bitsPerComponent,
        decodeParameters,
        data: image.sMask
      };
      if ("filter" in image) {
        sMask.filter = image.filter;
      }
      putImage2.call(this, sMask);
    }
    if (image.colorSpace === color_spaces.INDEXED) {
      var objId = this.internal.newObject();
      putStream({
        data: arrayBufferToBinaryString(new Uint8Array(image.palette)),
        objectId: objId
      });
      out("endobj");
    }
  };
  var putResourcesCallback = function putResourcesCallback2() {
    var images = this.internal.collections[namespace + "images"];
    for (var i2 in images) {
      putImage.call(this, images[i2]);
    }
  };
  var putXObjectsDictCallback = function putXObjectsDictCallback2() {
    var images = this.internal.collections[namespace + "images"], out = this.internal.write, image;
    for (var i2 in images) {
      image = images[i2];
      out("/I" + image.index, image.objectId, "0", "R");
    }
  };
  var checkCompressValue = function checkCompressValue2(value) {
    if (value && typeof value === "string")
      value = value.toUpperCase();
    return value in jsPDFAPI2.image_compression ? value : image_compression.NONE;
  };
  var initialize = function initialize2() {
    if (!this.internal.collections[namespace + "images"]) {
      this.internal.collections[namespace + "images"] = {};
      this.internal.events.subscribe("putResources", putResourcesCallback);
      this.internal.events.subscribe("putXobjectDict", putXObjectsDictCallback);
    }
  };
  var getImages = function getImages2() {
    var images = this.internal.collections[namespace + "images"];
    initialize.call(this);
    return images;
  };
  var getImageIndex = function getImageIndex2() {
    return Object.keys(this.internal.collections[namespace + "images"]).length;
  };
  var notDefined = function notDefined2(value) {
    return typeof value === "undefined" || value === null || value.length === 0;
  };
  var generateAliasFromImageData = function generateAliasFromImageData2(imageData) {
    if (typeof imageData === "string" || isArrayBufferView(imageData)) {
      return sHashCode(imageData);
    } else if (isArrayBufferView(imageData.data)) {
      return sHashCode(imageData.data);
    }
    return null;
  };
  var isImageTypeSupported = function isImageTypeSupported2(type) {
    return typeof jsPDFAPI2["process" + type.toUpperCase()] === "function";
  };
  var isDOMElement = function isDOMElement2(object) {
    return _typeof(object) === "object" && object.nodeType === 1;
  };
  var getImageDataFromElement = function getImageDataFromElement2(element2, format) {
    if (element2.nodeName === "IMG" && element2.hasAttribute("src")) {
      var src = "" + element2.getAttribute("src");
      if (src.indexOf("data:image/") === 0) {
        return atob2(unescape(src).split("base64,").pop());
      }
      var tmpImageData = jsPDFAPI2.loadFile(src, true);
      if (tmpImageData !== void 0) {
        return tmpImageData;
      }
    }
    if (element2.nodeName === "CANVAS") {
      if (element2.width === 0 || element2.height === 0) {
        throw new Error("Given canvas must have data. Canvas width: " + element2.width + ", height: " + element2.height);
      }
      var mimeType;
      switch (format) {
        case "PNG":
          mimeType = "image/png";
          break;
        case "WEBP":
          mimeType = "image/webp";
          break;
        case "JPEG":
        case "JPG":
        default:
          mimeType = "image/jpeg";
          break;
      }
      return atob2(element2.toDataURL(mimeType, 1).split("base64,").pop());
    }
  };
  var checkImagesForAlias = function checkImagesForAlias2(alias) {
    var images = this.internal.collections[namespace + "images"];
    if (images) {
      for (var e2 in images) {
        if (alias === images[e2].alias) {
          return images[e2];
        }
      }
    }
  };
  var determineWidthAndHeight = function determineWidthAndHeight2(width2, height2, image) {
    if (!width2 && !height2) {
      width2 = -96;
      height2 = -96;
    }
    if (width2 < 0) {
      width2 = -1 * image.width * 72 / width2 / this.internal.scaleFactor;
    }
    if (height2 < 0) {
      height2 = -1 * image.height * 72 / height2 / this.internal.scaleFactor;
    }
    if (width2 === 0) {
      width2 = height2 * image.width / image.height;
    }
    if (height2 === 0) {
      height2 = width2 * image.height / image.width;
    }
    return [width2, height2];
  };
  var writeImageToPDF = function writeImageToPDF2(x2, y3, width2, height2, image, rotation) {
    var dims = determineWidthAndHeight.call(this, width2, height2, image), coord = this.internal.getCoordinateString, vcoord = this.internal.getVerticalCoordinateString;
    var images = getImages.call(this);
    width2 = dims[0];
    height2 = dims[1];
    images[image.index] = image;
    if (rotation) {
      rotation *= Math.PI / 180;
      var c3 = Math.cos(rotation);
      var s2 = Math.sin(rotation);
      var f4 = function f42(number) {
        return number.toFixed(4);
      };
      var rotationTransformationMatrix = [f4(c3), f4(s2), f4(s2 * -1), f4(c3), 0, 0, "cm"];
    }
    this.internal.write("q");
    if (rotation) {
      this.internal.write([1, "0", "0", 1, coord(x2), vcoord(y3 + height2), "cm"].join(" "));
      this.internal.write(rotationTransformationMatrix.join(" "));
      this.internal.write([coord(width2), "0", "0", coord(height2), "0", "0", "cm"].join(" "));
    } else {
      this.internal.write([coord(width2), "0", "0", coord(height2), coord(x2), vcoord(y3 + height2), "cm"].join(" "));
    }
    if (this.isAdvancedAPI()) {
      this.internal.write([1, 0, 0, -1, 0, 0, "cm"].join(" "));
    }
    this.internal.write("/I" + image.index + " Do");
    this.internal.write("Q");
  };
  var color_spaces = jsPDFAPI2.color_spaces = {
    DEVICE_RGB: "DeviceRGB",
    DEVICE_GRAY: "DeviceGray",
    DEVICE_CMYK: "DeviceCMYK",
    CAL_GREY: "CalGray",
    CAL_RGB: "CalRGB",
    LAB: "Lab",
    ICC_BASED: "ICCBased",
    INDEXED: "Indexed",
    PATTERN: "Pattern",
    SEPARATION: "Separation",
    DEVICE_N: "DeviceN"
  };
  jsPDFAPI2.decode = {
    DCT_DECODE: "DCTDecode",
    FLATE_DECODE: "FlateDecode",
    LZW_DECODE: "LZWDecode",
    JPX_DECODE: "JPXDecode",
    JBIG2_DECODE: "JBIG2Decode",
    ASCII85_DECODE: "ASCII85Decode",
    ASCII_HEX_DECODE: "ASCIIHexDecode",
    RUN_LENGTH_DECODE: "RunLengthDecode",
    CCITT_FAX_DECODE: "CCITTFaxDecode"
  };
  var image_compression = jsPDFAPI2.image_compression = {
    NONE: "NONE",
    FAST: "FAST",
    MEDIUM: "MEDIUM",
    SLOW: "SLOW"
  };
  var sHashCode = jsPDFAPI2.__addimage__.sHashCode = function(data2) {
    var hash = 0, i2, len;
    if (typeof data2 === "string") {
      len = data2.length;
      for (i2 = 0; i2 < len; i2++) {
        hash = (hash << 5) - hash + data2.charCodeAt(i2);
        hash |= 0;
      }
    } else if (isArrayBufferView(data2)) {
      len = data2.byteLength / 2;
      for (i2 = 0; i2 < len; i2++) {
        hash = (hash << 5) - hash + data2[i2];
        hash |= 0;
      }
    }
    return hash;
  };
  var validateStringAsBase64 = jsPDFAPI2.__addimage__.validateStringAsBase64 = function(possibleBase64String) {
    possibleBase64String = possibleBase64String || "";
    possibleBase64String.toString().trim();
    var result = true;
    if (possibleBase64String.length === 0) {
      result = false;
    }
    if (possibleBase64String.length % 4 !== 0) {
      result = false;
    }
    if (/^[A-Za-z0-9+/]+$/.test(possibleBase64String.substr(0, possibleBase64String.length - 2)) === false) {
      result = false;
    }
    if (/^[A-Za-z0-9/][A-Za-z0-9+/]|[A-Za-z0-9+/]=|==$/.test(possibleBase64String.substr(-2)) === false) {
      result = false;
    }
    return result;
  };
  var extractImageFromDataUrl = jsPDFAPI2.__addimage__.extractImageFromDataUrl = function(dataUrl) {
    dataUrl = dataUrl || "";
    var dataUrlParts = dataUrl.split("base64,");
    var result = null;
    if (dataUrlParts.length === 2) {
      var extractedInfo = /^data:(\w*\/\w*);*(charset=(?!charset=)[\w=-]*)*;*$/.exec(dataUrlParts[0]);
      if (Array.isArray(extractedInfo)) {
        result = {
          mimeType: extractedInfo[1],
          charset: extractedInfo[2],
          data: dataUrlParts[1]
        };
      }
    }
    return result;
  };
  var supportsArrayBuffer = jsPDFAPI2.__addimage__.supportsArrayBuffer = function() {
    return typeof ArrayBuffer !== "undefined" && typeof Uint8Array !== "undefined";
  };
  jsPDFAPI2.__addimage__.isArrayBuffer = function(object) {
    return supportsArrayBuffer() && object instanceof ArrayBuffer;
  };
  var isArrayBufferView = jsPDFAPI2.__addimage__.isArrayBufferView = function(object) {
    return supportsArrayBuffer() && typeof Uint32Array !== "undefined" && (object instanceof Int8Array || object instanceof Uint8Array || typeof Uint8ClampedArray !== "undefined" && object instanceof Uint8ClampedArray || object instanceof Int16Array || object instanceof Uint16Array || object instanceof Int32Array || object instanceof Uint32Array || object instanceof Float32Array || object instanceof Float64Array);
  };
  var binaryStringToUint8Array = jsPDFAPI2.__addimage__.binaryStringToUint8Array = function(binary_string) {
    var len = binary_string.length;
    var bytes = new Uint8Array(len);
    for (var i2 = 0; i2 < len; i2++) {
      bytes[i2] = binary_string.charCodeAt(i2);
    }
    return bytes;
  };
  var arrayBufferToBinaryString = jsPDFAPI2.__addimage__.arrayBufferToBinaryString = function(buffer) {
    var out = "";
    var buf = isArrayBufferView(buffer) ? buffer : new Uint8Array(buffer);
    for (var i2 = 0; i2 < buf.length; i2 += ARRAY_APPLY_BATCH) {
      out += String.fromCharCode.apply(null, buf.subarray(i2, i2 + ARRAY_APPLY_BATCH));
    }
    return out;
  };
  jsPDFAPI2.addImage = function() {
    var imageData, format, x2, y3, w, h2, alias, compression, rotation;
    imageData = arguments[0];
    if (typeof arguments[1] === "number") {
      format = UNKNOWN;
      x2 = arguments[1];
      y3 = arguments[2];
      w = arguments[3];
      h2 = arguments[4];
      alias = arguments[5];
      compression = arguments[6];
      rotation = arguments[7];
    } else {
      format = arguments[1];
      x2 = arguments[2];
      y3 = arguments[3];
      w = arguments[4];
      h2 = arguments[5];
      alias = arguments[6];
      compression = arguments[7];
      rotation = arguments[8];
    }
    if (_typeof(imageData) === "object" && !isDOMElement(imageData) && "imageData" in imageData) {
      var options = imageData;
      imageData = options.imageData;
      format = options.format || format || UNKNOWN;
      x2 = options.x || x2 || 0;
      y3 = options.y || y3 || 0;
      w = options.w || options.width || w;
      h2 = options.h || options.height || h2;
      alias = options.alias || alias;
      compression = options.compression || compression;
      rotation = options.rotation || options.angle || rotation;
    }
    var filter2 = this.internal.getFilters();
    if (compression === void 0 && filter2.indexOf("FlateEncode") !== -1) {
      compression = "SLOW";
    }
    if (isNaN(x2) || isNaN(y3)) {
      throw new Error("Invalid coordinates passed to jsPDF.addImage");
    }
    initialize.call(this);
    var image = processImageData.call(this, imageData, format, alias, compression);
    writeImageToPDF.call(this, x2, y3, w, h2, image, rotation);
    return this;
  };
  var processImageData = function processImageData2(imageData, format, alias, compression) {
    var result, dataAsBinaryString;
    if (typeof imageData === "string" && getImageFileTypeByImageData(imageData) === UNKNOWN) {
      imageData = unescape(imageData);
      var tmpImageData = convertBase64ToBinaryString(imageData, false);
      if (tmpImageData !== "") {
        imageData = tmpImageData;
      } else {
        tmpImageData = jsPDFAPI2.loadFile(imageData, true);
        if (tmpImageData !== void 0) {
          imageData = tmpImageData;
        }
      }
    }
    if (isDOMElement(imageData)) {
      imageData = getImageDataFromElement(imageData, format);
    }
    format = getImageFileTypeByImageData(imageData, format);
    if (!isImageTypeSupported(format)) {
      throw new Error("addImage does not support files of type '" + format + "', please ensure that a plugin for '" + format + "' support is added.");
    }
    if (notDefined(alias)) {
      alias = generateAliasFromImageData(imageData);
    }
    result = checkImagesForAlias.call(this, alias);
    if (!result) {
      if (supportsArrayBuffer()) {
        if (!(imageData instanceof Uint8Array) && format !== "RGBA") {
          dataAsBinaryString = imageData;
          imageData = binaryStringToUint8Array(imageData);
        }
      }
      result = this["process" + format.toUpperCase()](imageData, getImageIndex.call(this), alias, checkCompressValue(compression), dataAsBinaryString);
    }
    if (!result) {
      throw new Error("An unknown error occurred whilst processing the image.");
    }
    return result;
  };
  var convertBase64ToBinaryString = jsPDFAPI2.__addimage__.convertBase64ToBinaryString = function(stringData, throwError) {
    throwError = typeof throwError === "boolean" ? throwError : true;
    var base64Info;
    var imageData = "";
    var rawData;
    if (typeof stringData === "string") {
      base64Info = extractImageFromDataUrl(stringData);
      rawData = base64Info !== null ? base64Info.data : stringData;
      try {
        imageData = atob2(rawData);
      } catch (e2) {
        if (throwError) {
          if (!validateStringAsBase64(rawData)) {
            throw new Error("Supplied Data is not a valid base64-String jsPDF.convertBase64ToBinaryString ");
          } else {
            throw new Error("atob-Error in jsPDF.convertBase64ToBinaryString " + e2.message);
          }
        }
      }
    }
    return imageData;
  };
  jsPDFAPI2.getImageProperties = function(imageData) {
    var image;
    var tmpImageData = "";
    var format;
    if (isDOMElement(imageData)) {
      imageData = getImageDataFromElement(imageData);
    }
    if (typeof imageData === "string" && getImageFileTypeByImageData(imageData) === UNKNOWN) {
      tmpImageData = convertBase64ToBinaryString(imageData, false);
      if (tmpImageData === "") {
        tmpImageData = jsPDFAPI2.loadFile(imageData) || "";
      }
      imageData = tmpImageData;
    }
    format = getImageFileTypeByImageData(imageData);
    if (!isImageTypeSupported(format)) {
      throw new Error("addImage does not support files of type '" + format + "', please ensure that a plugin for '" + format + "' support is added.");
    }
    if (supportsArrayBuffer() && !(imageData instanceof Uint8Array)) {
      imageData = binaryStringToUint8Array(imageData);
    }
    image = this["process" + format.toUpperCase()](imageData);
    if (!image) {
      throw new Error("An unknown error occurred whilst processing the image");
    }
    image.fileType = format;
    return image;
  };
})(jsPDF.API);
(function(jsPDFAPI2) {
  var notEmpty = function notEmpty2(obj) {
    if (typeof obj != "undefined") {
      if (obj != "") {
        return true;
      }
    }
  };
  jsPDF.API.events.push(["addPage", function(addPageData) {
    var pageInfo = this.internal.getPageInfo(addPageData.pageNumber);
    pageInfo.pageContext.annotations = [];
  }]);
  jsPDFAPI2.events.push(["putPage", function(putPageData) {
    var getHorizontalCoordinateString = this.internal.getCoordinateString;
    var getVerticalCoordinateString = this.internal.getVerticalCoordinateString;
    var pageInfo = this.internal.getPageInfoByObjId(putPageData.objId);
    var pageAnnos = putPageData.pageContext.annotations;
    var anno, rect, line;
    var found = false;
    for (var a2 = 0; a2 < pageAnnos.length && !found; a2++) {
      anno = pageAnnos[a2];
      switch (anno.type) {
        case "link":
          if (notEmpty(anno.options.url) || notEmpty(anno.options.pageNumber)) {
            found = true;
          }
          break;
        case "reference":
        case "text":
        case "freetext":
          found = true;
          break;
      }
    }
    if (found == false) {
      return;
    }
    this.internal.write("/Annots [");
    for (var i2 = 0; i2 < pageAnnos.length; i2++) {
      anno = pageAnnos[i2];
      var escape2 = this.internal.pdfEscape;
      var encryptor = this.internal.getEncryptor(putPageData.objId);
      switch (anno.type) {
        case "reference":
          this.internal.write(" " + anno.object.objId + " 0 R ");
          break;
        case "text":
          var objText = this.internal.newAdditionalObject();
          var objPopup = this.internal.newAdditionalObject();
          var encryptorText = this.internal.getEncryptor(objText.objId);
          var title = anno.title || "Note";
          rect = "/Rect [" + getHorizontalCoordinateString(anno.bounds.x) + " " + getVerticalCoordinateString(anno.bounds.y + anno.bounds.h) + " " + getHorizontalCoordinateString(anno.bounds.x + anno.bounds.w) + " " + getVerticalCoordinateString(anno.bounds.y) + "] ";
          line = "<</Type /Annot /Subtype /Text " + rect + "/Contents (" + escape2(encryptorText(anno.contents)) + ")";
          line += " /Popup " + objPopup.objId + " 0 R";
          line += " /P " + pageInfo.objId + " 0 R";
          line += " /T (" + escape2(encryptorText(title)) + ") >>";
          objText.content = line;
          var parent = objText.objId + " 0 R";
          var popoff = 30;
          rect = "/Rect [" + getHorizontalCoordinateString(anno.bounds.x + popoff) + " " + getVerticalCoordinateString(anno.bounds.y + anno.bounds.h) + " " + getHorizontalCoordinateString(anno.bounds.x + anno.bounds.w + popoff) + " " + getVerticalCoordinateString(anno.bounds.y) + "] ";
          line = "<</Type /Annot /Subtype /Popup " + rect + " /Parent " + parent;
          if (anno.open) {
            line += " /Open true";
          }
          line += " >>";
          objPopup.content = line;
          this.internal.write(objText.objId, "0 R", objPopup.objId, "0 R");
          break;
        case "freetext":
          rect = "/Rect [" + getHorizontalCoordinateString(anno.bounds.x) + " " + getVerticalCoordinateString(anno.bounds.y) + " " + getHorizontalCoordinateString(anno.bounds.x + anno.bounds.w) + " " + getVerticalCoordinateString(anno.bounds.y + anno.bounds.h) + "] ";
          var color = anno.color || "#000000";
          line = "<</Type /Annot /Subtype /FreeText " + rect + "/Contents (" + escape2(encryptor(anno.contents)) + ")";
          line += " /DS(font: Helvetica,sans-serif 12.0pt; text-align:left; color:#" + color + ")";
          line += " /Border [0 0 0]";
          line += " >>";
          this.internal.write(line);
          break;
        case "link":
          if (anno.options.name) {
            var loc = this.annotations._nameMap[anno.options.name];
            anno.options.pageNumber = loc.page;
            anno.options.top = loc.y;
          } else {
            if (!anno.options.top) {
              anno.options.top = 0;
            }
          }
          rect = "/Rect [" + anno.finalBounds.x + " " + anno.finalBounds.y + " " + anno.finalBounds.w + " " + anno.finalBounds.h + "] ";
          line = "";
          if (anno.options.url) {
            line = "<</Type /Annot /Subtype /Link " + rect + "/Border [0 0 0] /A <</S /URI /URI (" + escape2(encryptor(anno.options.url)) + ") >>";
          } else if (anno.options.pageNumber) {
            var info = this.internal.getPageInfo(anno.options.pageNumber);
            line = "<</Type /Annot /Subtype /Link " + rect + "/Border [0 0 0] /Dest [" + info.objId + " 0 R";
            anno.options.magFactor = anno.options.magFactor || "XYZ";
            switch (anno.options.magFactor) {
              case "Fit":
                line += " /Fit]";
                break;
              case "FitH":
                line += " /FitH " + anno.options.top + "]";
                break;
              case "FitV":
                anno.options.left = anno.options.left || 0;
                line += " /FitV " + anno.options.left + "]";
                break;
              case "XYZ":
              default:
                var top = getVerticalCoordinateString(anno.options.top);
                anno.options.left = anno.options.left || 0;
                if (typeof anno.options.zoom === "undefined") {
                  anno.options.zoom = 0;
                }
                line += " /XYZ " + anno.options.left + " " + top + " " + anno.options.zoom + "]";
                break;
            }
          }
          if (line != "") {
            line += " >>";
            this.internal.write(line);
          }
          break;
      }
    }
    this.internal.write("]");
  }]);
  jsPDFAPI2.createAnnotation = function(options) {
    var pageInfo = this.internal.getCurrentPageInfo();
    switch (options.type) {
      case "link":
        this.link(options.bounds.x, options.bounds.y, options.bounds.w, options.bounds.h, options);
        break;
      case "text":
      case "freetext":
        pageInfo.pageContext.annotations.push(options);
        break;
    }
  };
  jsPDFAPI2.link = function(x2, y3, w, h2, options) {
    var pageInfo = this.internal.getCurrentPageInfo();
    var getHorizontalCoordinateString = this.internal.getCoordinateString;
    var getVerticalCoordinateString = this.internal.getVerticalCoordinateString;
    pageInfo.pageContext.annotations.push({
      finalBounds: {
        x: getHorizontalCoordinateString(x2),
        y: getVerticalCoordinateString(y3),
        w: getHorizontalCoordinateString(x2 + w),
        h: getVerticalCoordinateString(y3 + h2)
      },
      options,
      type: "link"
    });
  };
  jsPDFAPI2.textWithLink = function(text4, x2, y3, options) {
    var totalLineWidth = this.getTextWidth(text4);
    var lineHeight = this.internal.getLineHeight() / this.internal.scaleFactor;
    var linkHeight, linkWidth;
    if (options.maxWidth !== void 0) {
      var maxWidth = options.maxWidth;
      linkWidth = maxWidth;
      var numOfLines = this.splitTextToSize(text4, linkWidth).length;
      linkHeight = Math.ceil(lineHeight * numOfLines);
    } else {
      linkWidth = totalLineWidth;
      linkHeight = lineHeight;
    }
    this.text(text4, x2, y3, options);
    y3 += lineHeight * 0.2;
    if (options.align === "center") {
      x2 = x2 - totalLineWidth / 2;
    }
    if (options.align === "right") {
      x2 = x2 - totalLineWidth;
    }
    this.link(x2, y3 - lineHeight, linkWidth, linkHeight, options);
    return totalLineWidth;
  };
  jsPDFAPI2.getTextWidth = function(text4) {
    var fontSize = this.internal.getFontSize();
    var txtWidth = this.getStringUnitWidth(text4) * fontSize / this.internal.scaleFactor;
    return txtWidth;
  };
  return this;
})(jsPDF.API);
(function(jsPDFAPI2) {
  var arabicSubstitionA = {
    1569: [65152],
    // ARABIC LETTER HAMZA
    1570: [65153, 65154],
    // ARABIC LETTER ALEF WITH MADDA ABOVE
    1571: [65155, 65156],
    // ARABIC LETTER ALEF WITH HAMZA ABOVE
    1572: [65157, 65158],
    // ARABIC LETTER WAW WITH HAMZA ABOVE
    1573: [65159, 65160],
    // ARABIC LETTER ALEF WITH HAMZA BELOW
    1574: [65161, 65162, 65163, 65164],
    // ARABIC LETTER YEH WITH HAMZA ABOVE
    1575: [65165, 65166],
    // ARABIC LETTER ALEF
    1576: [65167, 65168, 65169, 65170],
    // ARABIC LETTER BEH
    1577: [65171, 65172],
    // ARABIC LETTER TEH MARBUTA
    1578: [65173, 65174, 65175, 65176],
    // ARABIC LETTER TEH
    1579: [65177, 65178, 65179, 65180],
    // ARABIC LETTER THEH
    1580: [65181, 65182, 65183, 65184],
    // ARABIC LETTER JEEM
    1581: [65185, 65186, 65187, 65188],
    // ARABIC LETTER HAH
    1582: [65189, 65190, 65191, 65192],
    // ARABIC LETTER KHAH
    1583: [65193, 65194],
    // ARABIC LETTER DAL
    1584: [65195, 65196],
    // ARABIC LETTER THAL
    1585: [65197, 65198],
    // ARABIC LETTER REH
    1586: [65199, 65200],
    // ARABIC LETTER ZAIN
    1587: [65201, 65202, 65203, 65204],
    // ARABIC LETTER SEEN
    1588: [65205, 65206, 65207, 65208],
    // ARABIC LETTER SHEEN
    1589: [65209, 65210, 65211, 65212],
    // ARABIC LETTER SAD
    1590: [65213, 65214, 65215, 65216],
    // ARABIC LETTER DAD
    1591: [65217, 65218, 65219, 65220],
    // ARABIC LETTER TAH
    1592: [65221, 65222, 65223, 65224],
    // ARABIC LETTER ZAH
    1593: [65225, 65226, 65227, 65228],
    // ARABIC LETTER AIN
    1594: [65229, 65230, 65231, 65232],
    // ARABIC LETTER GHAIN
    1601: [65233, 65234, 65235, 65236],
    // ARABIC LETTER FEH
    1602: [65237, 65238, 65239, 65240],
    // ARABIC LETTER QAF
    1603: [65241, 65242, 65243, 65244],
    // ARABIC LETTER KAF
    1604: [65245, 65246, 65247, 65248],
    // ARABIC LETTER LAM
    1605: [65249, 65250, 65251, 65252],
    // ARABIC LETTER MEEM
    1606: [65253, 65254, 65255, 65256],
    // ARABIC LETTER NOON
    1607: [65257, 65258, 65259, 65260],
    // ARABIC LETTER HEH
    1608: [65261, 65262],
    // ARABIC LETTER WAW
    1609: [65263, 65264, 64488, 64489],
    // ARABIC LETTER ALEF MAKSURA
    1610: [65265, 65266, 65267, 65268],
    // ARABIC LETTER YEH
    1649: [64336, 64337],
    // ARABIC LETTER ALEF WASLA
    1655: [64477],
    // ARABIC LETTER U WITH HAMZA ABOVE
    1657: [64358, 64359, 64360, 64361],
    // ARABIC LETTER TTEH
    1658: [64350, 64351, 64352, 64353],
    // ARABIC LETTER TTEHEH
    1659: [64338, 64339, 64340, 64341],
    // ARABIC LETTER BEEH
    1662: [64342, 64343, 64344, 64345],
    // ARABIC LETTER PEH
    1663: [64354, 64355, 64356, 64357],
    // ARABIC LETTER TEHEH
    1664: [64346, 64347, 64348, 64349],
    // ARABIC LETTER BEHEH
    1667: [64374, 64375, 64376, 64377],
    // ARABIC LETTER NYEH
    1668: [64370, 64371, 64372, 64373],
    // ARABIC LETTER DYEH
    1670: [64378, 64379, 64380, 64381],
    // ARABIC LETTER TCHEH
    1671: [64382, 64383, 64384, 64385],
    // ARABIC LETTER TCHEHEH
    1672: [64392, 64393],
    // ARABIC LETTER DDAL
    1676: [64388, 64389],
    // ARABIC LETTER DAHAL
    1677: [64386, 64387],
    // ARABIC LETTER DDAHAL
    1678: [64390, 64391],
    // ARABIC LETTER DUL
    1681: [64396, 64397],
    // ARABIC LETTER RREH
    1688: [64394, 64395],
    // ARABIC LETTER JEH
    1700: [64362, 64363, 64364, 64365],
    // ARABIC LETTER VEH
    1702: [64366, 64367, 64368, 64369],
    // ARABIC LETTER PEHEH
    1705: [64398, 64399, 64400, 64401],
    // ARABIC LETTER KEHEH
    1709: [64467, 64468, 64469, 64470],
    // ARABIC LETTER NG
    1711: [64402, 64403, 64404, 64405],
    // ARABIC LETTER GAF
    1713: [64410, 64411, 64412, 64413],
    // ARABIC LETTER NGOEH
    1715: [64406, 64407, 64408, 64409],
    // ARABIC LETTER GUEH
    1722: [64414, 64415],
    // ARABIC LETTER NOON GHUNNA
    1723: [64416, 64417, 64418, 64419],
    // ARABIC LETTER RNOON
    1726: [64426, 64427, 64428, 64429],
    // ARABIC LETTER HEH DOACHASHMEE
    1728: [64420, 64421],
    // ARABIC LETTER HEH WITH YEH ABOVE
    1729: [64422, 64423, 64424, 64425],
    // ARABIC LETTER HEH GOAL
    1733: [64480, 64481],
    // ARABIC LETTER KIRGHIZ OE
    1734: [64473, 64474],
    // ARABIC LETTER OE
    1735: [64471, 64472],
    // ARABIC LETTER U
    1736: [64475, 64476],
    // ARABIC LETTER YU
    1737: [64482, 64483],
    // ARABIC LETTER KIRGHIZ YU
    1739: [64478, 64479],
    // ARABIC LETTER VE
    1740: [64508, 64509, 64510, 64511],
    // ARABIC LETTER FARSI YEH
    1744: [64484, 64485, 64486, 64487],
    //ARABIC LETTER E
    1746: [64430, 64431],
    // ARABIC LETTER YEH BARREE
    1747: [64432, 64433]
    // ARABIC LETTER YEH BARREE WITH HAMZA ABOVE
  };
  var ligatures2 = {
    65247: {
      65154: 65269,
      // ARABIC LIGATURE LAM WITH ALEF WITH MADDA ABOVE ISOLATED FORM
      65156: 65271,
      // ARABIC LIGATURE LAM WITH ALEF WITH HAMZA ABOVE ISOLATED FORM
      65160: 65273,
      // ARABIC LIGATURE LAM WITH ALEF WITH HAMZA BELOW ISOLATED FORM
      65166: 65275
      // ARABIC LIGATURE LAM WITH ALEF ISOLATED FORM
    },
    65248: {
      65154: 65270,
      // ARABIC LIGATURE LAM WITH ALEF WITH MADDA ABOVE FINAL FORM
      65156: 65272,
      // ARABIC LIGATURE LAM WITH ALEF WITH HAMZA ABOVE FINAL FORM
      65160: 65274,
      // ARABIC LIGATURE LAM WITH ALEF WITH HAMZA BELOW FINAL FORM
      65166: 65276
      // ARABIC LIGATURE LAM WITH ALEF FINAL FORM
    },
    65165: {
      65247: {
        65248: {
          65258: 65010
        }
      }
    },
    // ALLAH
    1617: {
      1612: 64606,
      // Shadda + Dammatan
      1613: 64607,
      // Shadda + Kasratan
      1614: 64608,
      // Shadda + Fatha
      1615: 64609,
      // Shadda + Damma
      1616: 64610
      // Shadda + Kasra
    }
  };
  var arabic_diacritics = {
    1612: 64606,
    // Shadda + Dammatan
    1613: 64607,
    // Shadda + Kasratan
    1614: 64608,
    // Shadda + Fatha
    1615: 64609,
    // Shadda + Damma
    1616: 64610
    // Shadda + Kasra
  };
  var alfletter = [1570, 1571, 1573, 1575];
  var noChangeInForm = -1;
  var isolatedForm = 0;
  var finalForm = 1;
  var initialForm = 2;
  var medialForm = 3;
  jsPDFAPI2.__arabicParser__ = {};
  var isInArabicSubstitutionA = jsPDFAPI2.__arabicParser__.isInArabicSubstitutionA = function(letter) {
    return typeof arabicSubstitionA[letter.charCodeAt(0)] !== "undefined";
  };
  var isArabicLetter = jsPDFAPI2.__arabicParser__.isArabicLetter = function(letter) {
    return typeof letter === "string" && /^[\u0600-\u06FF\u0750-\u077F\u08A0-\u08FF\uFB50-\uFDFF\uFE70-\uFEFF]+$/.test(letter);
  };
  var isArabicEndLetter = jsPDFAPI2.__arabicParser__.isArabicEndLetter = function(letter) {
    return isArabicLetter(letter) && isInArabicSubstitutionA(letter) && arabicSubstitionA[letter.charCodeAt(0)].length <= 2;
  };
  var isArabicAlfLetter = jsPDFAPI2.__arabicParser__.isArabicAlfLetter = function(letter) {
    return isArabicLetter(letter) && alfletter.indexOf(letter.charCodeAt(0)) >= 0;
  };
  jsPDFAPI2.__arabicParser__.arabicLetterHasIsolatedForm = function(letter) {
    return isArabicLetter(letter) && isInArabicSubstitutionA(letter) && arabicSubstitionA[letter.charCodeAt(0)].length >= 1;
  };
  var arabicLetterHasFinalForm = jsPDFAPI2.__arabicParser__.arabicLetterHasFinalForm = function(letter) {
    return isArabicLetter(letter) && isInArabicSubstitutionA(letter) && arabicSubstitionA[letter.charCodeAt(0)].length >= 2;
  };
  jsPDFAPI2.__arabicParser__.arabicLetterHasInitialForm = function(letter) {
    return isArabicLetter(letter) && isInArabicSubstitutionA(letter) && arabicSubstitionA[letter.charCodeAt(0)].length >= 3;
  };
  var arabicLetterHasMedialForm = jsPDFAPI2.__arabicParser__.arabicLetterHasMedialForm = function(letter) {
    return isArabicLetter(letter) && isInArabicSubstitutionA(letter) && arabicSubstitionA[letter.charCodeAt(0)].length == 4;
  };
  var resolveLigatures = jsPDFAPI2.__arabicParser__.resolveLigatures = function(letters2) {
    var i2 = 0;
    var tmpLigatures = ligatures2;
    var result = "";
    var effectedLetters = 0;
    for (i2 = 0; i2 < letters2.length; i2 += 1) {
      if (typeof tmpLigatures[letters2.charCodeAt(i2)] !== "undefined") {
        effectedLetters++;
        tmpLigatures = tmpLigatures[letters2.charCodeAt(i2)];
        if (typeof tmpLigatures === "number") {
          result += String.fromCharCode(tmpLigatures);
          tmpLigatures = ligatures2;
          effectedLetters = 0;
        }
        if (i2 === letters2.length - 1) {
          tmpLigatures = ligatures2;
          result += letters2.charAt(i2 - (effectedLetters - 1));
          i2 = i2 - (effectedLetters - 1);
          effectedLetters = 0;
        }
      } else {
        tmpLigatures = ligatures2;
        result += letters2.charAt(i2 - effectedLetters);
        i2 = i2 - effectedLetters;
        effectedLetters = 0;
      }
    }
    return result;
  };
  jsPDFAPI2.__arabicParser__.isArabicDiacritic = function(letter) {
    return letter !== void 0 && arabic_diacritics[letter.charCodeAt(0)] !== void 0;
  };
  var getCorrectForm = jsPDFAPI2.__arabicParser__.getCorrectForm = function(currentChar, beforeChar, nextChar) {
    if (!isArabicLetter(currentChar)) {
      return -1;
    }
    if (isInArabicSubstitutionA(currentChar) === false) {
      return noChangeInForm;
    }
    if (!arabicLetterHasFinalForm(currentChar) || !isArabicLetter(beforeChar) && !isArabicLetter(nextChar) || !isArabicLetter(nextChar) && isArabicEndLetter(beforeChar) || isArabicEndLetter(currentChar) && !isArabicLetter(beforeChar) || isArabicEndLetter(currentChar) && isArabicAlfLetter(beforeChar) || isArabicEndLetter(currentChar) && isArabicEndLetter(beforeChar)) {
      return isolatedForm;
    }
    if (arabicLetterHasMedialForm(currentChar) && isArabicLetter(beforeChar) && !isArabicEndLetter(beforeChar) && isArabicLetter(nextChar) && arabicLetterHasFinalForm(nextChar)) {
      return medialForm;
    }
    if (isArabicEndLetter(currentChar) || !isArabicLetter(nextChar)) {
      return finalForm;
    }
    return initialForm;
  };
  var parseArabic = function parseArabic2(text4) {
    text4 = text4 || "";
    var result = "";
    var i2 = 0;
    var j = 0;
    var position3 = 0;
    var currentLetter = "";
    var prevLetter = "";
    var nextLetter = "";
    var words = text4.split("\\s+");
    var newWords = [];
    for (i2 = 0; i2 < words.length; i2 += 1) {
      newWords.push("");
      for (j = 0; j < words[i2].length; j += 1) {
        currentLetter = words[i2][j];
        prevLetter = words[i2][j - 1];
        nextLetter = words[i2][j + 1];
        if (isArabicLetter(currentLetter)) {
          position3 = getCorrectForm(currentLetter, prevLetter, nextLetter);
          if (position3 !== -1) {
            newWords[i2] += String.fromCharCode(arabicSubstitionA[currentLetter.charCodeAt(0)][position3]);
          } else {
            newWords[i2] += currentLetter;
          }
        } else {
          newWords[i2] += currentLetter;
        }
      }
      newWords[i2] = resolveLigatures(newWords[i2]);
    }
    result = newWords.join(" ");
    return result;
  };
  var processArabic = jsPDFAPI2.__arabicParser__.processArabic = jsPDFAPI2.processArabic = function() {
    var text4 = typeof arguments[0] === "string" ? arguments[0] : arguments[0].text;
    var tmpText = [];
    var result;
    if (Array.isArray(text4)) {
      var i2 = 0;
      tmpText = [];
      for (i2 = 0; i2 < text4.length; i2 += 1) {
        if (Array.isArray(text4[i2])) {
          tmpText.push([parseArabic(text4[i2][0]), text4[i2][1], text4[i2][2]]);
        } else {
          tmpText.push([parseArabic(text4[i2])]);
        }
      }
      result = tmpText;
    } else {
      result = parseArabic(text4);
    }
    if (typeof arguments[0] === "string") {
      return result;
    } else {
      arguments[0].text = result;
      return arguments[0];
    }
  };
  jsPDFAPI2.events.push(["preProcessText", processArabic]);
})(jsPDF.API);
(function(jsPDFAPI2) {
  jsPDFAPI2.autoPrint = function(options) {
    var refAutoPrintTag;
    options = options || {};
    options.variant = options.variant || "non-conform";
    switch (options.variant) {
      case "javascript":
        this.addJS("print({});");
        break;
      case "non-conform":
      default:
        this.internal.events.subscribe("postPutResources", function() {
          refAutoPrintTag = this.internal.newObject();
          this.internal.out("<<");
          this.internal.out("/S /Named");
          this.internal.out("/Type /Action");
          this.internal.out("/N /Print");
          this.internal.out(">>");
          this.internal.out("endobj");
        });
        this.internal.events.subscribe("putCatalog", function() {
          this.internal.out("/OpenAction " + refAutoPrintTag + " 0 R");
        });
        break;
    }
    return this;
  };
})(jsPDF.API);
(function(jsPDFAPI2) {
  var Canvas = function Canvas2() {
    var jsPdfInstance = void 0;
    Object.defineProperty(this, "pdf", {
      get: function get() {
        return jsPdfInstance;
      },
      set: function set(value) {
        jsPdfInstance = value;
      }
    });
    var _width = 150;
    Object.defineProperty(this, "width", {
      get: function get() {
        return _width;
      },
      set: function set(value) {
        if (isNaN(value) || Number.isInteger(value) === false || value < 0) {
          _width = 150;
        } else {
          _width = value;
        }
        if (this.getContext("2d").pageWrapXEnabled) {
          this.getContext("2d").pageWrapX = _width + 1;
        }
      }
    });
    var _height = 300;
    Object.defineProperty(this, "height", {
      get: function get() {
        return _height;
      },
      set: function set(value) {
        if (isNaN(value) || Number.isInteger(value) === false || value < 0) {
          _height = 300;
        } else {
          _height = value;
        }
        if (this.getContext("2d").pageWrapYEnabled) {
          this.getContext("2d").pageWrapY = _height + 1;
        }
      }
    });
    var _childNodes = [];
    Object.defineProperty(this, "childNodes", {
      get: function get() {
        return _childNodes;
      },
      set: function set(value) {
        _childNodes = value;
      }
    });
    var _style = {};
    Object.defineProperty(this, "style", {
      get: function get() {
        return _style;
      },
      set: function set(value) {
        _style = value;
      }
    });
    Object.defineProperty(this, "parentNode", {});
  };
  Canvas.prototype.getContext = function(contextType, contextAttributes) {
    contextType = contextType || "2d";
    var key;
    if (contextType !== "2d") {
      return null;
    }
    for (key in contextAttributes) {
      if (this.pdf.context2d.hasOwnProperty(key)) {
        this.pdf.context2d[key] = contextAttributes[key];
      }
    }
    this.pdf.context2d._canvas = this;
    return this.pdf.context2d;
  };
  Canvas.prototype.toDataURL = function() {
    throw new Error("toDataURL is not implemented.");
  };
  jsPDFAPI2.events.push(["initialized", function() {
    this.canvas = new Canvas();
    this.canvas.pdf = this;
  }]);
  return this;
})(jsPDF.API);
(function(jsPDFAPI2) {
  var NO_MARGINS = {
    left: 0,
    top: 0,
    bottom: 0,
    right: 0
  };
  var px2pt = 0.264583 * 72 / 25.4;
  var printingHeaderRow = false;
  var _initialize = function _initialize2() {
    if (typeof this.internal.__cell__ === "undefined") {
      this.internal.__cell__ = {};
      this.internal.__cell__.padding = 3;
      this.internal.__cell__.headerFunction = void 0;
      this.internal.__cell__.margins = Object.assign({}, NO_MARGINS);
      this.internal.__cell__.margins.width = this.getPageWidth();
      _reset.call(this);
    }
  };
  var _reset = function _reset2() {
    this.internal.__cell__.lastCell = new Cell();
    this.internal.__cell__.pages = 1;
  };
  var Cell = function Cell2() {
    var _x = arguments[0];
    Object.defineProperty(this, "x", {
      enumerable: true,
      get: function get() {
        return _x;
      },
      set: function set(value) {
        _x = value;
      }
    });
    var _y = arguments[1];
    Object.defineProperty(this, "y", {
      enumerable: true,
      get: function get() {
        return _y;
      },
      set: function set(value) {
        _y = value;
      }
    });
    var _width = arguments[2];
    Object.defineProperty(this, "width", {
      enumerable: true,
      get: function get() {
        return _width;
      },
      set: function set(value) {
        _width = value;
      }
    });
    var _height = arguments[3];
    Object.defineProperty(this, "height", {
      enumerable: true,
      get: function get() {
        return _height;
      },
      set: function set(value) {
        _height = value;
      }
    });
    var _text = arguments[4];
    Object.defineProperty(this, "text", {
      enumerable: true,
      get: function get() {
        return _text;
      },
      set: function set(value) {
        _text = value;
      }
    });
    var _lineNumber = arguments[5];
    Object.defineProperty(this, "lineNumber", {
      enumerable: true,
      get: function get() {
        return _lineNumber;
      },
      set: function set(value) {
        _lineNumber = value;
      }
    });
    var _align = arguments[6];
    Object.defineProperty(this, "align", {
      enumerable: true,
      get: function get() {
        return _align;
      },
      set: function set(value) {
        _align = value;
      }
    });
    return this;
  };
  Cell.prototype.clone = function() {
    return new Cell(this.x, this.y, this.width, this.height, this.text, this.lineNumber, this.align);
  };
  Cell.prototype.toArray = function() {
    return [this.x, this.y, this.width, this.height, this.text, this.lineNumber, this.align];
  };
  jsPDFAPI2.setHeaderFunction = function(func) {
    _initialize.call(this);
    this.internal.__cell__.headerFunction = typeof func === "function" ? func : void 0;
    return this;
  };
  jsPDFAPI2.getTextDimensions = function(text4, options) {
    _initialize.call(this);
    options = options || {};
    var fontSize = options.fontSize || this.getFontSize();
    var font = options.font || this.getFont();
    var scaleFactor2 = options.scaleFactor || this.internal.scaleFactor;
    var width2 = 0;
    var amountOfLines = 0;
    var height2 = 0;
    var tempWidth = 0;
    var scope = this;
    if (!Array.isArray(text4) && typeof text4 !== "string") {
      if (typeof text4 === "number") {
        text4 = String(text4);
      } else {
        throw new Error("getTextDimensions expects text-parameter to be of type String or type Number or an Array of Strings.");
      }
    }
    var maxWidth = options.maxWidth;
    if (maxWidth > 0) {
      if (typeof text4 === "string") {
        text4 = this.splitTextToSize(text4, maxWidth);
      } else if (Object.prototype.toString.call(text4) === "[object Array]") {
        text4 = text4.reduce(function(acc, textLine) {
          return acc.concat(scope.splitTextToSize(textLine, maxWidth));
        }, []);
      }
    } else {
      text4 = Array.isArray(text4) ? text4 : [text4];
    }
    for (var i2 = 0; i2 < text4.length; i2++) {
      tempWidth = this.getStringUnitWidth(text4[i2], {
        font
      }) * fontSize;
      if (width2 < tempWidth) {
        width2 = tempWidth;
      }
    }
    if (width2 !== 0) {
      amountOfLines = text4.length;
    }
    width2 = width2 / scaleFactor2;
    height2 = Math.max((amountOfLines * fontSize * this.getLineHeightFactor() - fontSize * (this.getLineHeightFactor() - 1)) / scaleFactor2, 0);
    return {
      w: width2,
      h: height2
    };
  };
  jsPDFAPI2.cellAddPage = function() {
    _initialize.call(this);
    this.addPage();
    var margins = this.internal.__cell__.margins || NO_MARGINS;
    this.internal.__cell__.lastCell = new Cell(margins.left, margins.top, void 0, void 0);
    this.internal.__cell__.pages += 1;
    return this;
  };
  var cell = jsPDFAPI2.cell = function() {
    var currentCell;
    if (arguments[0] instanceof Cell) {
      currentCell = arguments[0];
    } else {
      currentCell = new Cell(arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], arguments[5]);
    }
    _initialize.call(this);
    var lastCell = this.internal.__cell__.lastCell;
    var padding = this.internal.__cell__.padding;
    var margins = this.internal.__cell__.margins || NO_MARGINS;
    var tableHeaderRow = this.internal.__cell__.tableHeaderRow;
    var printHeaders = this.internal.__cell__.printHeaders;
    if (typeof lastCell.lineNumber !== "undefined") {
      if (lastCell.lineNumber === currentCell.lineNumber) {
        currentCell.x = (lastCell.x || 0) + (lastCell.width || 0);
        currentCell.y = lastCell.y || 0;
      } else {
        if (lastCell.y + lastCell.height + currentCell.height + margins.bottom > this.getPageHeight()) {
          this.cellAddPage();
          currentCell.y = margins.top;
          if (printHeaders && tableHeaderRow) {
            this.printHeaderRow(currentCell.lineNumber, true);
            currentCell.y += tableHeaderRow[0].height;
          }
        } else {
          currentCell.y = lastCell.y + lastCell.height || currentCell.y;
        }
      }
    }
    if (typeof currentCell.text[0] !== "undefined") {
      this.rect(currentCell.x, currentCell.y, currentCell.width, currentCell.height, printingHeaderRow === true ? "FD" : void 0);
      if (currentCell.align === "right") {
        this.text(currentCell.text, currentCell.x + currentCell.width - padding, currentCell.y + padding, {
          align: "right",
          baseline: "top"
        });
      } else if (currentCell.align === "center") {
        this.text(currentCell.text, currentCell.x + currentCell.width / 2, currentCell.y + padding, {
          align: "center",
          baseline: "top",
          maxWidth: currentCell.width - padding - padding
        });
      } else {
        this.text(currentCell.text, currentCell.x + padding, currentCell.y + padding, {
          align: "left",
          baseline: "top",
          maxWidth: currentCell.width - padding - padding
        });
      }
    }
    this.internal.__cell__.lastCell = currentCell;
    return this;
  };
  jsPDFAPI2.table = function(x2, y3, data2, headers, config) {
    _initialize.call(this);
    if (!data2) {
      throw new Error("No data for PDF table.");
    }
    config = config || {};
    var headerNames = [], headerLabels = [], headerAligns = [], i2, columnMatrix = {}, columnWidths = {}, column, columnMinWidths = [], j, tableHeaderConfigs = [], autoSize = config.autoSize || false, printHeaders = config.printHeaders === false ? false : true, fontSize = config.css && typeof config.css["font-size"] !== "undefined" ? config.css["font-size"] * 16 : config.fontSize || 12, margins = config.margins || Object.assign({
      width: this.getPageWidth()
    }, NO_MARGINS), padding = typeof config.padding === "number" ? config.padding : 3, headerBackgroundColor = config.headerBackgroundColor || "#c8c8c8", headerTextColor = config.headerTextColor || "#000";
    _reset.call(this);
    this.internal.__cell__.printHeaders = printHeaders;
    this.internal.__cell__.margins = margins;
    this.internal.__cell__.table_font_size = fontSize;
    this.internal.__cell__.padding = padding;
    this.internal.__cell__.headerBackgroundColor = headerBackgroundColor;
    this.internal.__cell__.headerTextColor = headerTextColor;
    this.setFontSize(fontSize);
    if (headers === void 0 || headers === null) {
      headerNames = Object.keys(data2[0]);
      headerLabels = headerNames;
      headerAligns = headerNames.map(function() {
        return "left";
      });
    } else if (Array.isArray(headers) && _typeof(headers[0]) === "object") {
      headerNames = headers.map(function(header) {
        return header.name;
      });
      headerLabels = headers.map(function(header) {
        return header.prompt || header.name || "";
      });
      headerAligns = headers.map(function(header) {
        return header.align || "left";
      });
      for (i2 = 0; i2 < headers.length; i2 += 1) {
        columnWidths[headers[i2].name] = headers[i2].width * px2pt;
      }
    } else if (Array.isArray(headers) && typeof headers[0] === "string") {
      headerNames = headers;
      headerLabels = headerNames;
      headerAligns = headerNames.map(function() {
        return "left";
      });
    }
    if (autoSize || Array.isArray(headers) && typeof headers[0] === "string") {
      var headerName;
      for (i2 = 0; i2 < headerNames.length; i2 += 1) {
        headerName = headerNames[i2];
        columnMatrix[headerName] = data2.map(function(rec) {
          return rec[headerName];
        });
        this.setFont(void 0, "bold");
        columnMinWidths.push(this.getTextDimensions(headerLabels[i2], {
          fontSize: this.internal.__cell__.table_font_size,
          scaleFactor: this.internal.scaleFactor
        }).w);
        column = columnMatrix[headerName];
        this.setFont(void 0, "normal");
        for (j = 0; j < column.length; j += 1) {
          columnMinWidths.push(this.getTextDimensions(column[j], {
            fontSize: this.internal.__cell__.table_font_size,
            scaleFactor: this.internal.scaleFactor
          }).w);
        }
        columnWidths[headerName] = Math.max.apply(null, columnMinWidths) + padding + padding;
        columnMinWidths = [];
      }
    }
    if (printHeaders) {
      var row = {};
      for (i2 = 0; i2 < headerNames.length; i2 += 1) {
        row[headerNames[i2]] = {};
        row[headerNames[i2]].text = headerLabels[i2];
        row[headerNames[i2]].align = headerAligns[i2];
      }
      var rowHeight = calculateLineHeight.call(this, row, columnWidths);
      tableHeaderConfigs = headerNames.map(function(value) {
        return new Cell(x2, y3, columnWidths[value], rowHeight, row[value].text, void 0, row[value].align);
      });
      this.setTableHeaderRow(tableHeaderConfigs);
      this.printHeaderRow(1, false);
    }
    var align = headers.reduce(function(pv, cv) {
      pv[cv.name] = cv.align;
      return pv;
    }, {});
    for (i2 = 0; i2 < data2.length; i2 += 1) {
      if ("rowStart" in config && config.rowStart instanceof Function) {
        config.rowStart({
          row: i2,
          data: data2[i2]
        }, this);
      }
      var lineHeight = calculateLineHeight.call(this, data2[i2], columnWidths);
      for (j = 0; j < headerNames.length; j += 1) {
        var cellData = data2[i2][headerNames[j]];
        if ("cellStart" in config && config.cellStart instanceof Function) {
          config.cellStart({
            row: i2,
            col: j,
            data: cellData
          }, this);
        }
        cell.call(this, new Cell(x2, y3, columnWidths[headerNames[j]], lineHeight, cellData, i2 + 2, align[headerNames[j]]));
      }
    }
    this.internal.__cell__.table_x = x2;
    this.internal.__cell__.table_y = y3;
    return this;
  };
  var calculateLineHeight = function calculateLineHeight2(model, columnWidths) {
    var padding = this.internal.__cell__.padding;
    var fontSize = this.internal.__cell__.table_font_size;
    var scaleFactor2 = this.internal.scaleFactor;
    return Object.keys(model).map(function(key) {
      var value = model[key];
      return this.splitTextToSize(value.hasOwnProperty("text") ? value.text : value, columnWidths[key] - padding - padding);
    }, this).map(function(value) {
      return this.getLineHeightFactor() * value.length * fontSize / scaleFactor2 + padding + padding;
    }, this).reduce(function(pv, cv) {
      return Math.max(pv, cv);
    }, 0);
  };
  jsPDFAPI2.setTableHeaderRow = function(config) {
    _initialize.call(this);
    this.internal.__cell__.tableHeaderRow = config;
  };
  jsPDFAPI2.printHeaderRow = function(lineNumber, new_page) {
    _initialize.call(this);
    if (!this.internal.__cell__.tableHeaderRow) {
      throw new Error("Property tableHeaderRow does not exist.");
    }
    var tableHeaderCell;
    printingHeaderRow = true;
    if (typeof this.internal.__cell__.headerFunction === "function") {
      var position3 = this.internal.__cell__.headerFunction(this, this.internal.__cell__.pages);
      this.internal.__cell__.lastCell = new Cell(position3[0], position3[1], position3[2], position3[3], void 0, -1);
    }
    this.setFont(void 0, "bold");
    var tempHeaderConf = [];
    for (var i2 = 0; i2 < this.internal.__cell__.tableHeaderRow.length; i2 += 1) {
      tableHeaderCell = this.internal.__cell__.tableHeaderRow[i2].clone();
      if (new_page) {
        tableHeaderCell.y = this.internal.__cell__.margins.top || 0;
        tempHeaderConf.push(tableHeaderCell);
      }
      tableHeaderCell.lineNumber = lineNumber;
      var currentTextColor = this.getTextColor();
      this.setTextColor(this.internal.__cell__.headerTextColor);
      this.setFillColor(this.internal.__cell__.headerBackgroundColor);
      cell.call(this, tableHeaderCell);
      this.setTextColor(currentTextColor);
    }
    if (tempHeaderConf.length > 0) {
      this.setTableHeaderRow(tempHeaderConf);
    }
    this.setFont(void 0, "normal");
    printingHeaderRow = false;
  };
})(jsPDF.API);
function toLookup(arr) {
  return arr.reduce(function(lookup, name, index3) {
    lookup[name] = index3;
    return lookup;
  }, {});
}
var fontStyleOrder = {
  italic: ["italic", "oblique", "normal"],
  oblique: ["oblique", "italic", "normal"],
  normal: ["normal", "oblique", "italic"]
};
var fontStretchOrder = ["ultra-condensed", "extra-condensed", "condensed", "semi-condensed", "normal", "semi-expanded", "expanded", "extra-expanded", "ultra-expanded"];
var fontStretchLookup = toLookup(fontStretchOrder);
var fontWeights = [100, 200, 300, 400, 500, 600, 700, 800, 900];
var fontWeightsLookup = toLookup(fontWeights);
function normalizeFontStretch(stretch) {
  stretch = stretch || "normal";
  return typeof fontStretchLookup[stretch] === "number" ? stretch : "normal";
}
function normalizeFontStyle(style) {
  style = style || "normal";
  return fontStyleOrder[style] ? style : "normal";
}
function normalizeFontWeight(weight) {
  if (!weight) {
    return 400;
  }
  if (typeof weight === "number") {
    return weight >= 100 && weight <= 900 && weight % 100 === 0 ? weight : 400;
  }
  if (/^\d00$/.test(weight)) {
    return parseInt(weight);
  }
  switch (weight) {
    case "bold":
      return 700;
    case "normal":
    default:
      return 400;
  }
}
function normalizeFontFace(fontFace) {
  var family = fontFace.family.replace(/"|'/g, "").toLowerCase();
  var style = normalizeFontStyle(fontFace.style);
  var weight = normalizeFontWeight(fontFace.weight);
  var stretch = normalizeFontStretch(fontFace.stretch);
  return {
    family,
    style,
    weight,
    stretch,
    src: fontFace.src || [],
    // The ref property maps this font-face to the font
    // added by the .addFont() method.
    ref: fontFace.ref || {
      name: family,
      style: [stretch, style, weight].join(" ")
    }
  };
}
function buildFontFaceMap(fontFaces) {
  var map3 = {};
  for (var i2 = 0; i2 < fontFaces.length; ++i2) {
    var normalized = normalizeFontFace(fontFaces[i2]);
    var name = normalized.family;
    var stretch = normalized.stretch;
    var style = normalized.style;
    var weight = normalized.weight;
    map3[name] = map3[name] || {};
    map3[name][stretch] = map3[name][stretch] || {};
    map3[name][stretch][style] = map3[name][stretch][style] || {};
    map3[name][stretch][style][weight] = normalized;
  }
  return map3;
}
function searchFromPivot(matchingSet, order, pivot, dir) {
  var i2;
  for (i2 = pivot; i2 >= 0 && i2 < order.length; i2 += dir) {
    if (matchingSet[order[i2]]) {
      return matchingSet[order[i2]];
    }
  }
  for (i2 = pivot; i2 >= 0 && i2 < order.length; i2 -= dir) {
    if (matchingSet[order[i2]]) {
      return matchingSet[order[i2]];
    }
  }
}
function resolveFontStretch(stretch, matchingSet) {
  if (matchingSet[stretch]) {
    return matchingSet[stretch];
  }
  var pivot = fontStretchLookup[stretch];
  var dir = pivot <= fontStretchLookup["normal"] ? -1 : 1;
  var match = searchFromPivot(matchingSet, fontStretchOrder, pivot, dir);
  if (!match) {
    throw new Error("Could not find a matching font-stretch value for " + stretch);
  }
  return match;
}
function resolveFontStyle(fontStyle, matchingSet) {
  if (matchingSet[fontStyle]) {
    return matchingSet[fontStyle];
  }
  var ordering = fontStyleOrder[fontStyle];
  for (var i2 = 0; i2 < ordering.length; ++i2) {
    if (matchingSet[ordering[i2]]) {
      return matchingSet[ordering[i2]];
    }
  }
  throw new Error("Could not find a matching font-style for " + fontStyle);
}
function resolveFontWeight(weight, matchingSet) {
  if (matchingSet[weight]) {
    return matchingSet[weight];
  }
  if (weight === 400 && matchingSet[500]) {
    return matchingSet[500];
  }
  if (weight === 500 && matchingSet[400]) {
    return matchingSet[400];
  }
  var pivot = fontWeightsLookup[weight];
  var dir = weight < 400 ? -1 : 1;
  var match = searchFromPivot(matchingSet, fontWeights, pivot, dir);
  if (!match) {
    throw new Error("Could not find a matching font-weight for value " + weight);
  }
  return match;
}
var defaultGenericFontFamilies = {
  "sans-serif": "helvetica",
  fixed: "courier",
  monospace: "courier",
  terminal: "courier",
  cursive: "times",
  fantasy: "times",
  serif: "times"
};
var systemFonts = {
  caption: "times",
  icon: "times",
  menu: "times",
  "message-box": "times",
  "small-caption": "times",
  "status-bar": "times"
};
function ruleToString(rule) {
  return [rule.stretch, rule.style, rule.weight, rule.family].join(" ");
}
function resolveFontFace(fontFaceMap, rules, opts) {
  opts = opts || {};
  var defaultFontFamily = opts.defaultFontFamily || "times";
  var genericFontFamilies = Object.assign({}, defaultGenericFontFamilies, opts.genericFontFamilies || {});
  var rule = null;
  var matches = null;
  for (var i2 = 0; i2 < rules.length; ++i2) {
    rule = normalizeFontFace(rules[i2]);
    if (genericFontFamilies[rule.family]) {
      rule.family = genericFontFamilies[rule.family];
    }
    if (fontFaceMap.hasOwnProperty(rule.family)) {
      matches = fontFaceMap[rule.family];
      break;
    }
  }
  matches = matches || fontFaceMap[defaultFontFamily];
  if (!matches) {
    throw new Error("Could not find a font-family for the rule '" + ruleToString(rule) + "' and default family '" + defaultFontFamily + "'.");
  }
  matches = resolveFontStretch(rule.stretch, matches);
  matches = resolveFontStyle(rule.style, matches);
  matches = resolveFontWeight(rule.weight, matches);
  if (!matches) {
    throw new Error("Failed to resolve a font for the rule '" + ruleToString(rule) + "'.");
  }
  return matches;
}
function eatWhiteSpace(input) {
  return input.trimLeft();
}
function parseQuotedFontFamily(input, quote) {
  var index3 = 0;
  while (index3 < input.length) {
    var current = input.charAt(index3);
    if (current === quote) {
      return [input.substring(0, index3), input.substring(index3 + 1)];
    }
    index3 += 1;
  }
  return null;
}
function parseNonQuotedFontFamily(input) {
  var match = input.match(/^(-[a-z_]|[a-z_])[a-z0-9_-]*/i);
  if (match === null) {
    return null;
  }
  return [match[0], input.substring(match[0].length)];
}
var defaultFont = ["times"];
function parseFontFamily(input) {
  var result = [];
  var ch, parsed;
  var remaining = input.trim();
  if (remaining === "") {
    return defaultFont;
  }
  if (remaining in systemFonts) {
    return [systemFonts[remaining]];
  }
  while (remaining !== "") {
    parsed = null;
    remaining = eatWhiteSpace(remaining);
    ch = remaining.charAt(0);
    switch (ch) {
      case '"':
      case "'":
        parsed = parseQuotedFontFamily(remaining.substring(1), ch);
        break;
      default:
        parsed = parseNonQuotedFontFamily(remaining);
        break;
    }
    if (parsed === null) {
      return defaultFont;
    }
    result.push(parsed[0]);
    remaining = eatWhiteSpace(parsed[1]);
    if (remaining !== "" && remaining.charAt(0) !== ",") {
      return defaultFont;
    }
    remaining = remaining.replace(/^,/, "");
  }
  return result;
}
(function(jsPDFAPI2) {
  var ContextLayer = function ContextLayer2(ctx) {
    ctx = ctx || {};
    this.isStrokeTransparent = ctx.isStrokeTransparent || false;
    this.strokeOpacity = ctx.strokeOpacity || 1;
    this.strokeStyle = ctx.strokeStyle || "#000000";
    this.fillStyle = ctx.fillStyle || "#000000";
    this.isFillTransparent = ctx.isFillTransparent || false;
    this.fillOpacity = ctx.fillOpacity || 1;
    this.font = ctx.font || "10px sans-serif";
    this.textBaseline = ctx.textBaseline || "alphabetic";
    this.textAlign = ctx.textAlign || "left";
    this.lineWidth = ctx.lineWidth || 1;
    this.lineJoin = ctx.lineJoin || "miter";
    this.lineCap = ctx.lineCap || "butt";
    this.path = ctx.path || [];
    this.transform = typeof ctx.transform !== "undefined" ? ctx.transform.clone() : new Matrix3();
    this.globalCompositeOperation = ctx.globalCompositeOperation || "normal";
    this.globalAlpha = ctx.globalAlpha || 1;
    this.clip_path = ctx.clip_path || [];
    this.currentPoint = ctx.currentPoint || new Point3();
    this.miterLimit = ctx.miterLimit || 10;
    this.lastPoint = ctx.lastPoint || new Point3();
    this.lineDashOffset = ctx.lineDashOffset || 0;
    this.lineDash = ctx.lineDash || [];
    this.margin = ctx.margin || [0, 0, 0, 0];
    this.prevPageLastElemOffset = ctx.prevPageLastElemOffset || 0;
    this.ignoreClearRect = typeof ctx.ignoreClearRect === "boolean" ? ctx.ignoreClearRect : true;
    return this;
  };
  var f23, getHorizontalCoordinateString, getVerticalCoordinateString, getHorizontalCoordinate, getVerticalCoordinate, Point3, Rectangle, Matrix3, _ctx;
  jsPDFAPI2.events.push(["initialized", function() {
    this.context2d = new Context2D(this);
    f23 = this.internal.f2;
    getHorizontalCoordinateString = this.internal.getCoordinateString;
    getVerticalCoordinateString = this.internal.getVerticalCoordinateString;
    getHorizontalCoordinate = this.internal.getHorizontalCoordinate;
    getVerticalCoordinate = this.internal.getVerticalCoordinate;
    Point3 = this.internal.Point;
    Rectangle = this.internal.Rectangle;
    Matrix3 = this.internal.Matrix;
    _ctx = new ContextLayer();
  }]);
  var Context2D = function Context2D2(pdf) {
    Object.defineProperty(this, "canvas", {
      get: function get() {
        return {
          parentNode: false,
          style: false
        };
      }
    });
    var _pdf = pdf;
    Object.defineProperty(this, "pdf", {
      get: function get() {
        return _pdf;
      }
    });
    var _pageWrapXEnabled = false;
    Object.defineProperty(this, "pageWrapXEnabled", {
      get: function get() {
        return _pageWrapXEnabled;
      },
      set: function set(value) {
        _pageWrapXEnabled = Boolean(value);
      }
    });
    var _pageWrapYEnabled = false;
    Object.defineProperty(this, "pageWrapYEnabled", {
      get: function get() {
        return _pageWrapYEnabled;
      },
      set: function set(value) {
        _pageWrapYEnabled = Boolean(value);
      }
    });
    var _posX = 0;
    Object.defineProperty(this, "posX", {
      get: function get() {
        return _posX;
      },
      set: function set(value) {
        if (!isNaN(value)) {
          _posX = value;
        }
      }
    });
    var _posY = 0;
    Object.defineProperty(this, "posY", {
      get: function get() {
        return _posY;
      },
      set: function set(value) {
        if (!isNaN(value)) {
          _posY = value;
        }
      }
    });
    Object.defineProperty(this, "margin", {
      get: function get() {
        return _ctx.margin;
      },
      set: function set(value) {
        var margin;
        if (typeof value === "number") {
          margin = [value, value, value, value];
        } else {
          margin = new Array(4);
          margin[0] = value[0];
          margin[1] = value.length >= 2 ? value[1] : margin[0];
          margin[2] = value.length >= 3 ? value[2] : margin[0];
          margin[3] = value.length >= 4 ? value[3] : margin[1];
        }
        _ctx.margin = margin;
      }
    });
    var _autoPaging = false;
    Object.defineProperty(this, "autoPaging", {
      get: function get() {
        return _autoPaging;
      },
      set: function set(value) {
        _autoPaging = value;
      }
    });
    var lastBreak = 0;
    Object.defineProperty(this, "lastBreak", {
      get: function get() {
        return lastBreak;
      },
      set: function set(value) {
        lastBreak = value;
      }
    });
    var pageBreaks = [];
    Object.defineProperty(this, "pageBreaks", {
      get: function get() {
        return pageBreaks;
      },
      set: function set(value) {
        pageBreaks = value;
      }
    });
    Object.defineProperty(this, "ctx", {
      get: function get() {
        return _ctx;
      },
      set: function set(value) {
        if (value instanceof ContextLayer) {
          _ctx = value;
        }
      }
    });
    Object.defineProperty(this, "path", {
      get: function get() {
        return _ctx.path;
      },
      set: function set(value) {
        _ctx.path = value;
      }
    });
    var _ctxStack = [];
    Object.defineProperty(this, "ctxStack", {
      get: function get() {
        return _ctxStack;
      },
      set: function set(value) {
        _ctxStack = value;
      }
    });
    Object.defineProperty(this, "fillStyle", {
      get: function get() {
        return this.ctx.fillStyle;
      },
      set: function set(value) {
        var rgba;
        rgba = getRGBA(value);
        this.ctx.fillStyle = rgba.style;
        this.ctx.isFillTransparent = rgba.a === 0;
        this.ctx.fillOpacity = rgba.a;
        this.pdf.setFillColor(rgba.r, rgba.g, rgba.b, {
          a: rgba.a
        });
        this.pdf.setTextColor(rgba.r, rgba.g, rgba.b, {
          a: rgba.a
        });
      }
    });
    Object.defineProperty(this, "strokeStyle", {
      get: function get() {
        return this.ctx.strokeStyle;
      },
      set: function set(value) {
        var rgba = getRGBA(value);
        this.ctx.strokeStyle = rgba.style;
        this.ctx.isStrokeTransparent = rgba.a === 0;
        this.ctx.strokeOpacity = rgba.a;
        if (rgba.a === 0) {
          this.pdf.setDrawColor(255, 255, 255);
        } else if (rgba.a === 1) {
          this.pdf.setDrawColor(rgba.r, rgba.g, rgba.b);
        } else {
          this.pdf.setDrawColor(rgba.r, rgba.g, rgba.b);
        }
      }
    });
    Object.defineProperty(this, "lineCap", {
      get: function get() {
        return this.ctx.lineCap;
      },
      set: function set(value) {
        if (["butt", "round", "square"].indexOf(value) !== -1) {
          this.ctx.lineCap = value;
          this.pdf.setLineCap(value);
        }
      }
    });
    Object.defineProperty(this, "lineWidth", {
      get: function get() {
        return this.ctx.lineWidth;
      },
      set: function set(value) {
        if (!isNaN(value)) {
          this.ctx.lineWidth = value;
          this.pdf.setLineWidth(value);
        }
      }
    });
    Object.defineProperty(this, "lineJoin", {
      get: function get() {
        return this.ctx.lineJoin;
      },
      set: function set(value) {
        if (["bevel", "round", "miter"].indexOf(value) !== -1) {
          this.ctx.lineJoin = value;
          this.pdf.setLineJoin(value);
        }
      }
    });
    Object.defineProperty(this, "miterLimit", {
      get: function get() {
        return this.ctx.miterLimit;
      },
      set: function set(value) {
        if (!isNaN(value)) {
          this.ctx.miterLimit = value;
          this.pdf.setMiterLimit(value);
        }
      }
    });
    Object.defineProperty(this, "textBaseline", {
      get: function get() {
        return this.ctx.textBaseline;
      },
      set: function set(value) {
        this.ctx.textBaseline = value;
      }
    });
    Object.defineProperty(this, "textAlign", {
      get: function get() {
        return this.ctx.textAlign;
      },
      set: function set(value) {
        if (["right", "end", "center", "left", "start"].indexOf(value) !== -1) {
          this.ctx.textAlign = value;
        }
      }
    });
    var _fontFaceMap = null;
    function getFontFaceMap(pdf2, fontFaces) {
      if (_fontFaceMap === null) {
        var fontMap2 = pdf2.getFontList();
        var convertedFontFaces = convertToFontFaces(fontMap2);
        _fontFaceMap = buildFontFaceMap(convertedFontFaces.concat(fontFaces));
      }
      return _fontFaceMap;
    }
    function convertToFontFaces(fontMap2) {
      var fontFaces = [];
      Object.keys(fontMap2).forEach(function(family) {
        var styles2 = fontMap2[family];
        styles2.forEach(function(style) {
          var fontFace = null;
          switch (style) {
            case "bold":
              fontFace = {
                family,
                weight: "bold"
              };
              break;
            case "italic":
              fontFace = {
                family,
                style: "italic"
              };
              break;
            case "bolditalic":
              fontFace = {
                family,
                weight: "bold",
                style: "italic"
              };
              break;
            case "":
            case "normal":
              fontFace = {
                family
              };
              break;
          }
          if (fontFace !== null) {
            fontFace.ref = {
              name: family,
              style
            };
            fontFaces.push(fontFace);
          }
        });
      });
      return fontFaces;
    }
    var _fontFaces = null;
    Object.defineProperty(this, "fontFaces", {
      get: function get() {
        return _fontFaces;
      },
      set: function set(value) {
        _fontFaceMap = null;
        _fontFaces = value;
      }
    });
    Object.defineProperty(this, "font", {
      get: function get() {
        return this.ctx.font;
      },
      set: function set(value) {
        this.ctx.font = value;
        var rx2, matches;
        rx2 = /^\s*(?=(?:(?:[-a-z]+\s*){0,2}(italic|oblique))?)(?=(?:(?:[-a-z]+\s*){0,2}(small-caps))?)(?=(?:(?:[-a-z]+\s*){0,2}(bold(?:er)?|lighter|[1-9]00))?)(?:(?:normal|\1|\2|\3)\s*){0,3}((?:xx?-)?(?:small|large)|medium|smaller|larger|[.\d]+(?:\%|in|[cem]m|ex|p[ctx]))(?:\s*\/\s*(normal|[.\d]+(?:\%|in|[cem]m|ex|p[ctx])))?\s*([-_,\"\'\sa-z]+?)\s*$/i;
        matches = rx2.exec(value);
        if (matches !== null) {
          var fontStyle = matches[1];
          var fontVariant = matches[2];
          var fontWeight = matches[3];
          var fontSize = matches[4];
          var lineHeight = matches[5];
          var fontFamily = matches[6];
        } else {
          return;
        }
        var rxFontSize = /^([.\d]+)((?:%|in|[cem]m|ex|p[ctx]))$/i;
        var fontSizeUnit = rxFontSize.exec(fontSize)[2];
        if ("px" === fontSizeUnit) {
          fontSize = Math.floor(parseFloat(fontSize) * this.pdf.internal.scaleFactor);
        } else if ("em" === fontSizeUnit) {
          fontSize = Math.floor(parseFloat(fontSize) * this.pdf.getFontSize());
        } else {
          fontSize = Math.floor(parseFloat(fontSize) * this.pdf.internal.scaleFactor);
        }
        this.pdf.setFontSize(fontSize);
        var parts = parseFontFamily(fontFamily);
        if (this.fontFaces) {
          var fontFaceMap = getFontFaceMap(this.pdf, this.fontFaces);
          var rules = parts.map(function(ff2) {
            return {
              family: ff2,
              stretch: "normal",
              // TODO: Extract font-stretch from font rule (perhaps write proper parser for it?)
              weight: fontWeight,
              style: fontStyle
            };
          });
          var font = resolveFontFace(fontFaceMap, rules);
          this.pdf.setFont(font.ref.name, font.ref.style);
          return;
        }
        var style = "";
        if (fontWeight === "bold" || parseInt(fontWeight, 10) >= 700 || fontStyle === "bold") {
          style = "bold";
        }
        if (fontStyle === "italic") {
          style += "italic";
        }
        if (style.length === 0) {
          style = "normal";
        }
        var jsPdfFontName = "";
        var fallbackFonts = {
          arial: "Helvetica",
          Arial: "Helvetica",
          verdana: "Helvetica",
          Verdana: "Helvetica",
          helvetica: "Helvetica",
          Helvetica: "Helvetica",
          "sans-serif": "Helvetica",
          fixed: "Courier",
          monospace: "Courier",
          terminal: "Courier",
          cursive: "Times",
          fantasy: "Times",
          serif: "Times"
        };
        for (var i2 = 0; i2 < parts.length; i2++) {
          if (this.pdf.internal.getFont(parts[i2], style, {
            noFallback: true,
            disableWarning: true
          }) !== void 0) {
            jsPdfFontName = parts[i2];
            break;
          } else if (style === "bolditalic" && this.pdf.internal.getFont(parts[i2], "bold", {
            noFallback: true,
            disableWarning: true
          }) !== void 0) {
            jsPdfFontName = parts[i2];
            style = "bold";
          } else if (this.pdf.internal.getFont(parts[i2], "normal", {
            noFallback: true,
            disableWarning: true
          }) !== void 0) {
            jsPdfFontName = parts[i2];
            style = "normal";
            break;
          }
        }
        if (jsPdfFontName === "") {
          for (var j = 0; j < parts.length; j++) {
            if (fallbackFonts[parts[j]]) {
              jsPdfFontName = fallbackFonts[parts[j]];
              break;
            }
          }
        }
        jsPdfFontName = jsPdfFontName === "" ? "Times" : jsPdfFontName;
        this.pdf.setFont(jsPdfFontName, style);
      }
    });
    Object.defineProperty(this, "globalCompositeOperation", {
      get: function get() {
        return this.ctx.globalCompositeOperation;
      },
      set: function set(value) {
        this.ctx.globalCompositeOperation = value;
      }
    });
    Object.defineProperty(this, "globalAlpha", {
      get: function get() {
        return this.ctx.globalAlpha;
      },
      set: function set(value) {
        this.ctx.globalAlpha = value;
      }
    });
    Object.defineProperty(this, "lineDashOffset", {
      get: function get() {
        return this.ctx.lineDashOffset;
      },
      set: function set(value) {
        this.ctx.lineDashOffset = value;
        setLineDash.call(this);
      }
    });
    Object.defineProperty(this, "lineDash", {
      get: function get() {
        return this.ctx.lineDash;
      },
      set: function set(value) {
        this.ctx.lineDash = value;
        setLineDash.call(this);
      }
    });
    Object.defineProperty(this, "ignoreClearRect", {
      get: function get() {
        return this.ctx.ignoreClearRect;
      },
      set: function set(value) {
        this.ctx.ignoreClearRect = Boolean(value);
      }
    });
  };
  Context2D.prototype.setLineDash = function(dashArray) {
    this.lineDash = dashArray;
  };
  Context2D.prototype.getLineDash = function() {
    if (this.lineDash.length % 2) {
      return this.lineDash.concat(this.lineDash);
    } else {
      return this.lineDash.slice();
    }
  };
  Context2D.prototype.fill = function() {
    pathPreProcess.call(this, "fill", false);
  };
  Context2D.prototype.stroke = function() {
    pathPreProcess.call(this, "stroke", false);
  };
  Context2D.prototype.beginPath = function() {
    this.path = [{
      type: "begin"
    }];
  };
  Context2D.prototype.moveTo = function(x2, y3) {
    if (isNaN(x2) || isNaN(y3)) {
      console2.error("jsPDF.context2d.moveTo: Invalid arguments", arguments);
      throw new Error("Invalid arguments passed to jsPDF.context2d.moveTo");
    }
    var pt = this.ctx.transform.applyToPoint(new Point3(x2, y3));
    this.path.push({
      type: "mt",
      x: pt.x,
      y: pt.y
    });
    this.ctx.lastPoint = new Point3(x2, y3);
  };
  Context2D.prototype.closePath = function() {
    var pathBegin = new Point3(0, 0);
    var i2 = 0;
    for (i2 = this.path.length - 1; i2 !== -1; i2--) {
      if (this.path[i2].type === "begin") {
        if (_typeof(this.path[i2 + 1]) === "object" && typeof this.path[i2 + 1].x === "number") {
          pathBegin = new Point3(this.path[i2 + 1].x, this.path[i2 + 1].y);
          break;
        }
      }
    }
    this.path.push({
      type: "close"
    });
    this.ctx.lastPoint = new Point3(pathBegin.x, pathBegin.y);
  };
  Context2D.prototype.lineTo = function(x2, y3) {
    if (isNaN(x2) || isNaN(y3)) {
      console2.error("jsPDF.context2d.lineTo: Invalid arguments", arguments);
      throw new Error("Invalid arguments passed to jsPDF.context2d.lineTo");
    }
    var pt = this.ctx.transform.applyToPoint(new Point3(x2, y3));
    this.path.push({
      type: "lt",
      x: pt.x,
      y: pt.y
    });
    this.ctx.lastPoint = new Point3(pt.x, pt.y);
  };
  Context2D.prototype.clip = function() {
    this.ctx.clip_path = JSON.parse(JSON.stringify(this.path));
    pathPreProcess.call(this, null, true);
  };
  Context2D.prototype.quadraticCurveTo = function(cpx, cpy, x2, y3) {
    if (isNaN(x2) || isNaN(y3) || isNaN(cpx) || isNaN(cpy)) {
      console2.error("jsPDF.context2d.quadraticCurveTo: Invalid arguments", arguments);
      throw new Error("Invalid arguments passed to jsPDF.context2d.quadraticCurveTo");
    }
    var pt0 = this.ctx.transform.applyToPoint(new Point3(x2, y3));
    var pt1 = this.ctx.transform.applyToPoint(new Point3(cpx, cpy));
    this.path.push({
      type: "qct",
      x1: pt1.x,
      y1: pt1.y,
      x: pt0.x,
      y: pt0.y
    });
    this.ctx.lastPoint = new Point3(pt0.x, pt0.y);
  };
  Context2D.prototype.bezierCurveTo = function(cp1x, cp1y, cp2x, cp2y, x2, y3) {
    if (isNaN(x2) || isNaN(y3) || isNaN(cp1x) || isNaN(cp1y) || isNaN(cp2x) || isNaN(cp2y)) {
      console2.error("jsPDF.context2d.bezierCurveTo: Invalid arguments", arguments);
      throw new Error("Invalid arguments passed to jsPDF.context2d.bezierCurveTo");
    }
    var pt0 = this.ctx.transform.applyToPoint(new Point3(x2, y3));
    var pt1 = this.ctx.transform.applyToPoint(new Point3(cp1x, cp1y));
    var pt2 = this.ctx.transform.applyToPoint(new Point3(cp2x, cp2y));
    this.path.push({
      type: "bct",
      x1: pt1.x,
      y1: pt1.y,
      x2: pt2.x,
      y2: pt2.y,
      x: pt0.x,
      y: pt0.y
    });
    this.ctx.lastPoint = new Point3(pt0.x, pt0.y);
  };
  Context2D.prototype.arc = function(x2, y3, radius, startAngle, endAngle, counterclockwise) {
    if (isNaN(x2) || isNaN(y3) || isNaN(radius) || isNaN(startAngle) || isNaN(endAngle)) {
      console2.error("jsPDF.context2d.arc: Invalid arguments", arguments);
      throw new Error("Invalid arguments passed to jsPDF.context2d.arc");
    }
    counterclockwise = Boolean(counterclockwise);
    if (!this.ctx.transform.isIdentity) {
      var xpt = this.ctx.transform.applyToPoint(new Point3(x2, y3));
      x2 = xpt.x;
      y3 = xpt.y;
      var x_radPt = this.ctx.transform.applyToPoint(new Point3(0, radius));
      var x_radPt0 = this.ctx.transform.applyToPoint(new Point3(0, 0));
      radius = Math.sqrt(Math.pow(x_radPt.x - x_radPt0.x, 2) + Math.pow(x_radPt.y - x_radPt0.y, 2));
    }
    if (Math.abs(endAngle - startAngle) >= 2 * Math.PI) {
      startAngle = 0;
      endAngle = 2 * Math.PI;
    }
    this.path.push({
      type: "arc",
      x: x2,
      y: y3,
      radius,
      startAngle,
      endAngle,
      counterclockwise
    });
  };
  Context2D.prototype.arcTo = function(x1, y1, x2, y22, radius) {
    throw new Error("arcTo not implemented.");
  };
  Context2D.prototype.rect = function(x2, y3, w, h2) {
    if (isNaN(x2) || isNaN(y3) || isNaN(w) || isNaN(h2)) {
      console2.error("jsPDF.context2d.rect: Invalid arguments", arguments);
      throw new Error("Invalid arguments passed to jsPDF.context2d.rect");
    }
    this.moveTo(x2, y3);
    this.lineTo(x2 + w, y3);
    this.lineTo(x2 + w, y3 + h2);
    this.lineTo(x2, y3 + h2);
    this.lineTo(x2, y3);
    this.lineTo(x2 + w, y3);
    this.lineTo(x2, y3);
  };
  Context2D.prototype.fillRect = function(x2, y3, w, h2) {
    if (isNaN(x2) || isNaN(y3) || isNaN(w) || isNaN(h2)) {
      console2.error("jsPDF.context2d.fillRect: Invalid arguments", arguments);
      throw new Error("Invalid arguments passed to jsPDF.context2d.fillRect");
    }
    if (isFillTransparent.call(this)) {
      return;
    }
    var tmp = {};
    if (this.lineCap !== "butt") {
      tmp.lineCap = this.lineCap;
      this.lineCap = "butt";
    }
    if (this.lineJoin !== "miter") {
      tmp.lineJoin = this.lineJoin;
      this.lineJoin = "miter";
    }
    this.beginPath();
    this.rect(x2, y3, w, h2);
    this.fill();
    if (tmp.hasOwnProperty("lineCap")) {
      this.lineCap = tmp.lineCap;
    }
    if (tmp.hasOwnProperty("lineJoin")) {
      this.lineJoin = tmp.lineJoin;
    }
  };
  Context2D.prototype.strokeRect = function strokeRect(x2, y3, w, h2) {
    if (isNaN(x2) || isNaN(y3) || isNaN(w) || isNaN(h2)) {
      console2.error("jsPDF.context2d.strokeRect: Invalid arguments", arguments);
      throw new Error("Invalid arguments passed to jsPDF.context2d.strokeRect");
    }
    if (isStrokeTransparent.call(this)) {
      return;
    }
    this.beginPath();
    this.rect(x2, y3, w, h2);
    this.stroke();
  };
  Context2D.prototype.clearRect = function(x2, y3, w, h2) {
    if (isNaN(x2) || isNaN(y3) || isNaN(w) || isNaN(h2)) {
      console2.error("jsPDF.context2d.clearRect: Invalid arguments", arguments);
      throw new Error("Invalid arguments passed to jsPDF.context2d.clearRect");
    }
    if (this.ignoreClearRect) {
      return;
    }
    this.fillStyle = "#ffffff";
    this.fillRect(x2, y3, w, h2);
  };
  Context2D.prototype.save = function(doStackPush) {
    doStackPush = typeof doStackPush === "boolean" ? doStackPush : true;
    var tmpPageNumber = this.pdf.internal.getCurrentPageInfo().pageNumber;
    for (var i2 = 0; i2 < this.pdf.internal.getNumberOfPages(); i2++) {
      this.pdf.setPage(i2 + 1);
      this.pdf.internal.out("q");
    }
    this.pdf.setPage(tmpPageNumber);
    if (doStackPush) {
      this.ctx.fontSize = this.pdf.internal.getFontSize();
      var ctx = new ContextLayer(this.ctx);
      this.ctxStack.push(this.ctx);
      this.ctx = ctx;
    }
  };
  Context2D.prototype.restore = function(doStackPop) {
    doStackPop = typeof doStackPop === "boolean" ? doStackPop : true;
    var tmpPageNumber = this.pdf.internal.getCurrentPageInfo().pageNumber;
    for (var i2 = 0; i2 < this.pdf.internal.getNumberOfPages(); i2++) {
      this.pdf.setPage(i2 + 1);
      this.pdf.internal.out("Q");
    }
    this.pdf.setPage(tmpPageNumber);
    if (doStackPop && this.ctxStack.length !== 0) {
      this.ctx = this.ctxStack.pop();
      this.fillStyle = this.ctx.fillStyle;
      this.strokeStyle = this.ctx.strokeStyle;
      this.font = this.ctx.font;
      this.lineCap = this.ctx.lineCap;
      this.lineWidth = this.ctx.lineWidth;
      this.lineJoin = this.ctx.lineJoin;
      this.lineDash = this.ctx.lineDash;
      this.lineDashOffset = this.ctx.lineDashOffset;
    }
  };
  Context2D.prototype.toDataURL = function() {
    throw new Error("toDataUrl not implemented.");
  };
  var getRGBA = function getRGBA2(style) {
    var rxRgb = /rgb\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)/;
    var rxRgba = /rgba\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*([\d.]+)\s*\)/;
    var rxTransparent = /transparent|rgba\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*0+\s*\)/;
    var r2, g, b, a2;
    if (style.isCanvasGradient === true) {
      style = style.getColor();
    }
    if (!style) {
      return {
        r: 0,
        g: 0,
        b: 0,
        a: 0,
        style
      };
    }
    if (rxTransparent.test(style)) {
      r2 = 0;
      g = 0;
      b = 0;
      a2 = 0;
    } else {
      var matches = rxRgb.exec(style);
      if (matches !== null) {
        r2 = parseInt(matches[1]);
        g = parseInt(matches[2]);
        b = parseInt(matches[3]);
        a2 = 1;
      } else {
        matches = rxRgba.exec(style);
        if (matches !== null) {
          r2 = parseInt(matches[1]);
          g = parseInt(matches[2]);
          b = parseInt(matches[3]);
          a2 = parseFloat(matches[4]);
        } else {
          a2 = 1;
          if (typeof style === "string" && style.charAt(0) !== "#") {
            var rgbColor = new RGBColor3(style);
            if (rgbColor.ok) {
              style = rgbColor.toHex();
            } else {
              style = "#000000";
            }
          }
          if (style.length === 4) {
            r2 = style.substring(1, 2);
            r2 += r2;
            g = style.substring(2, 3);
            g += g;
            b = style.substring(3, 4);
            b += b;
          } else {
            r2 = style.substring(1, 3);
            g = style.substring(3, 5);
            b = style.substring(5, 7);
          }
          r2 = parseInt(r2, 16);
          g = parseInt(g, 16);
          b = parseInt(b, 16);
        }
      }
    }
    return {
      r: r2,
      g,
      b,
      a: a2,
      style
    };
  };
  var isFillTransparent = function isFillTransparent2() {
    return this.ctx.isFillTransparent || this.globalAlpha == 0;
  };
  var isStrokeTransparent = function isStrokeTransparent2() {
    return Boolean(this.ctx.isStrokeTransparent || this.globalAlpha == 0);
  };
  Context2D.prototype.fillText = function(text4, x2, y3, maxWidth) {
    if (isNaN(x2) || isNaN(y3) || typeof text4 !== "string") {
      console2.error("jsPDF.context2d.fillText: Invalid arguments", arguments);
      throw new Error("Invalid arguments passed to jsPDF.context2d.fillText");
    }
    maxWidth = isNaN(maxWidth) ? void 0 : maxWidth;
    if (isFillTransparent.call(this)) {
      return;
    }
    var degs = rad2deg(this.ctx.transform.rotation);
    var scale3 = this.ctx.transform.scaleX;
    putText.call(this, {
      text: text4,
      x: x2,
      y: y3,
      scale: scale3,
      angle: degs,
      align: this.textAlign,
      maxWidth
    });
  };
  Context2D.prototype.strokeText = function(text4, x2, y3, maxWidth) {
    if (isNaN(x2) || isNaN(y3) || typeof text4 !== "string") {
      console2.error("jsPDF.context2d.strokeText: Invalid arguments", arguments);
      throw new Error("Invalid arguments passed to jsPDF.context2d.strokeText");
    }
    if (isStrokeTransparent.call(this)) {
      return;
    }
    maxWidth = isNaN(maxWidth) ? void 0 : maxWidth;
    var degs = rad2deg(this.ctx.transform.rotation);
    var scale3 = this.ctx.transform.scaleX;
    putText.call(this, {
      text: text4,
      x: x2,
      y: y3,
      scale: scale3,
      renderingMode: "stroke",
      angle: degs,
      align: this.textAlign,
      maxWidth
    });
  };
  Context2D.prototype.measureText = function(text4) {
    if (typeof text4 !== "string") {
      console2.error("jsPDF.context2d.measureText: Invalid arguments", arguments);
      throw new Error("Invalid arguments passed to jsPDF.context2d.measureText");
    }
    var pdf = this.pdf;
    var k = this.pdf.internal.scaleFactor;
    var fontSize = pdf.internal.getFontSize();
    var txtWidth = pdf.getStringUnitWidth(text4) * fontSize / pdf.internal.scaleFactor;
    txtWidth *= Math.round(k * 96 / 72 * 1e4) / 1e4;
    var TextMetrics = function TextMetrics2(options) {
      options = options || {};
      var _width = options.width || 0;
      Object.defineProperty(this, "width", {
        get: function get() {
          return _width;
        }
      });
      return this;
    };
    return new TextMetrics({
      width: txtWidth
    });
  };
  Context2D.prototype.scale = function(scalewidth, scaleheight) {
    if (isNaN(scalewidth) || isNaN(scaleheight)) {
      console2.error("jsPDF.context2d.scale: Invalid arguments", arguments);
      throw new Error("Invalid arguments passed to jsPDF.context2d.scale");
    }
    var matrix = new Matrix3(scalewidth, 0, 0, scaleheight, 0, 0);
    this.ctx.transform = this.ctx.transform.multiply(matrix);
  };
  Context2D.prototype.rotate = function(angle) {
    if (isNaN(angle)) {
      console2.error("jsPDF.context2d.rotate: Invalid arguments", arguments);
      throw new Error("Invalid arguments passed to jsPDF.context2d.rotate");
    }
    var matrix = new Matrix3(Math.cos(angle), Math.sin(angle), -Math.sin(angle), Math.cos(angle), 0, 0);
    this.ctx.transform = this.ctx.transform.multiply(matrix);
  };
  Context2D.prototype.translate = function(x2, y3) {
    if (isNaN(x2) || isNaN(y3)) {
      console2.error("jsPDF.context2d.translate: Invalid arguments", arguments);
      throw new Error("Invalid arguments passed to jsPDF.context2d.translate");
    }
    var matrix = new Matrix3(1, 0, 0, 1, x2, y3);
    this.ctx.transform = this.ctx.transform.multiply(matrix);
  };
  Context2D.prototype.transform = function(a2, b, c3, d, e2, f3) {
    if (isNaN(a2) || isNaN(b) || isNaN(c3) || isNaN(d) || isNaN(e2) || isNaN(f3)) {
      console2.error("jsPDF.context2d.transform: Invalid arguments", arguments);
      throw new Error("Invalid arguments passed to jsPDF.context2d.transform");
    }
    var matrix = new Matrix3(a2, b, c3, d, e2, f3);
    this.ctx.transform = this.ctx.transform.multiply(matrix);
  };
  Context2D.prototype.setTransform = function(a2, b, c3, d, e2, f3) {
    a2 = isNaN(a2) ? 1 : a2;
    b = isNaN(b) ? 0 : b;
    c3 = isNaN(c3) ? 0 : c3;
    d = isNaN(d) ? 1 : d;
    e2 = isNaN(e2) ? 0 : e2;
    f3 = isNaN(f3) ? 0 : f3;
    this.ctx.transform = new Matrix3(a2, b, c3, d, e2, f3);
  };
  var hasMargins = function hasMargins2() {
    return this.margin[0] > 0 || this.margin[1] > 0 || this.margin[2] > 0 || this.margin[3] > 0;
  };
  Context2D.prototype.drawImage = function(img, sx, sy, swidth, sheight, x2, y3, width2, height2) {
    var imageProperties = this.pdf.getImageProperties(img);
    var factorX = 1;
    var factorY = 1;
    var clipFactorX = 1;
    var clipFactorY = 1;
    if (typeof swidth !== "undefined" && typeof width2 !== "undefined") {
      clipFactorX = width2 / swidth;
      clipFactorY = height2 / sheight;
      factorX = imageProperties.width / swidth * width2 / swidth;
      factorY = imageProperties.height / sheight * height2 / sheight;
    }
    if (typeof x2 === "undefined") {
      x2 = sx;
      y3 = sy;
      sx = 0;
      sy = 0;
    }
    if (typeof swidth !== "undefined" && typeof width2 === "undefined") {
      width2 = swidth;
      height2 = sheight;
    }
    if (typeof swidth === "undefined" && typeof width2 === "undefined") {
      width2 = imageProperties.width;
      height2 = imageProperties.height;
    }
    var decomposedTransformationMatrix = this.ctx.transform.decompose();
    var angle = rad2deg(decomposedTransformationMatrix.rotate.shx);
    var matrix = new Matrix3();
    matrix = matrix.multiply(decomposedTransformationMatrix.translate);
    matrix = matrix.multiply(decomposedTransformationMatrix.skew);
    matrix = matrix.multiply(decomposedTransformationMatrix.scale);
    var xRect = matrix.applyToRectangle(new Rectangle(x2 - sx * clipFactorX, y3 - sy * clipFactorY, swidth * factorX, sheight * factorY));
    var pageArray = getPagesByPath.call(this, xRect);
    var pages = [];
    for (var ii2 = 0; ii2 < pageArray.length; ii2 += 1) {
      if (pages.indexOf(pageArray[ii2]) === -1) {
        pages.push(pageArray[ii2]);
      }
    }
    sortPages(pages);
    var clipPath;
    if (this.autoPaging) {
      var min = pages[0];
      var max2 = pages[pages.length - 1];
      for (var i2 = min; i2 < max2 + 1; i2++) {
        this.pdf.setPage(i2);
        var pageWidthMinusMargins = this.pdf.internal.pageSize.width - this.margin[3] - this.margin[1];
        var topMargin = i2 === 1 ? this.posY + this.margin[0] : this.margin[0];
        var firstPageHeight = this.pdf.internal.pageSize.height - this.posY - this.margin[0] - this.margin[2];
        var pageHeightMinusMargins = this.pdf.internal.pageSize.height - this.margin[0] - this.margin[2];
        var previousPageHeightSum = i2 === 1 ? 0 : firstPageHeight + (i2 - 2) * pageHeightMinusMargins;
        if (this.ctx.clip_path.length !== 0) {
          var tmpPaths = this.path;
          clipPath = JSON.parse(JSON.stringify(this.ctx.clip_path));
          this.path = pathPositionRedo(clipPath, this.posX + this.margin[3], -previousPageHeightSum + topMargin + this.ctx.prevPageLastElemOffset);
          drawPaths.call(this, "fill", true);
          this.path = tmpPaths;
        }
        var tmpRect = JSON.parse(JSON.stringify(xRect));
        tmpRect = pathPositionRedo([tmpRect], this.posX + this.margin[3], -previousPageHeightSum + topMargin + this.ctx.prevPageLastElemOffset)[0];
        var needsClipping = (i2 > min || i2 < max2) && hasMargins.call(this);
        if (needsClipping) {
          this.pdf.saveGraphicsState();
          this.pdf.rect(this.margin[3], this.margin[0], pageWidthMinusMargins, pageHeightMinusMargins, null).clip().discardPath();
        }
        this.pdf.addImage(img, "JPEG", tmpRect.x, tmpRect.y, tmpRect.w, tmpRect.h, null, null, angle);
        if (needsClipping) {
          this.pdf.restoreGraphicsState();
        }
      }
    } else {
      this.pdf.addImage(img, "JPEG", xRect.x, xRect.y, xRect.w, xRect.h, null, null, angle);
    }
  };
  var getPagesByPath = function getPagesByPath2(path2, pageWrapX, pageWrapY) {
    var result = [];
    pageWrapX = pageWrapX || this.pdf.internal.pageSize.width;
    pageWrapY = pageWrapY || this.pdf.internal.pageSize.height - this.margin[0] - this.margin[2];
    var yOffset = this.posY + this.ctx.prevPageLastElemOffset;
    switch (path2.type) {
      default:
      case "mt":
      case "lt":
        result.push(Math.floor((path2.y + yOffset) / pageWrapY) + 1);
        break;
      case "arc":
        result.push(Math.floor((path2.y + yOffset - path2.radius) / pageWrapY) + 1);
        result.push(Math.floor((path2.y + yOffset + path2.radius) / pageWrapY) + 1);
        break;
      case "qct":
        var rectOfQuadraticCurve = getQuadraticCurveBoundary(this.ctx.lastPoint.x, this.ctx.lastPoint.y, path2.x1, path2.y1, path2.x, path2.y);
        result.push(Math.floor((rectOfQuadraticCurve.y + yOffset) / pageWrapY) + 1);
        result.push(Math.floor((rectOfQuadraticCurve.y + rectOfQuadraticCurve.h + yOffset) / pageWrapY) + 1);
        break;
      case "bct":
        var rectOfBezierCurve = getBezierCurveBoundary(this.ctx.lastPoint.x, this.ctx.lastPoint.y, path2.x1, path2.y1, path2.x2, path2.y2, path2.x, path2.y);
        result.push(Math.floor((rectOfBezierCurve.y + yOffset) / pageWrapY) + 1);
        result.push(Math.floor((rectOfBezierCurve.y + rectOfBezierCurve.h + yOffset) / pageWrapY) + 1);
        break;
      case "rect":
        result.push(Math.floor((path2.y + yOffset) / pageWrapY) + 1);
        result.push(Math.floor((path2.y + path2.h + yOffset) / pageWrapY) + 1);
    }
    for (var i2 = 0; i2 < result.length; i2 += 1) {
      while (this.pdf.internal.getNumberOfPages() < result[i2]) {
        addPage.call(this);
      }
    }
    return result;
  };
  var addPage = function addPage2() {
    var fillStyle = this.fillStyle;
    var strokeStyle = this.strokeStyle;
    var font = this.font;
    var lineCap = this.lineCap;
    var lineWidth = this.lineWidth;
    var lineJoin = this.lineJoin;
    this.pdf.addPage();
    this.fillStyle = fillStyle;
    this.strokeStyle = strokeStyle;
    this.font = font;
    this.lineCap = lineCap;
    this.lineWidth = lineWidth;
    this.lineJoin = lineJoin;
  };
  var pathPositionRedo = function pathPositionRedo2(paths, x2, y3) {
    for (var i2 = 0; i2 < paths.length; i2++) {
      switch (paths[i2].type) {
        case "bct":
          paths[i2].x2 += x2;
          paths[i2].y2 += y3;
        case "qct":
          paths[i2].x1 += x2;
          paths[i2].y1 += y3;
        case "mt":
        case "lt":
        case "arc":
        default:
          paths[i2].x += x2;
          paths[i2].y += y3;
      }
    }
    return paths;
  };
  var sortPages = function sortPages2(pages) {
    return pages.sort(function(a2, b) {
      return a2 - b;
    });
  };
  var pathPreProcess = function pathPreProcess2(rule, isClip) {
    var fillStyle = this.fillStyle;
    var strokeStyle = this.strokeStyle;
    var lineCap = this.lineCap;
    var oldLineWidth = this.lineWidth;
    var lineWidth = Math.abs(oldLineWidth * this.ctx.transform.scaleX);
    var lineJoin = this.lineJoin;
    var origPath = JSON.parse(JSON.stringify(this.path));
    var xPath = JSON.parse(JSON.stringify(this.path));
    var clipPath;
    var tmpPath;
    var pages = [];
    for (var i2 = 0; i2 < xPath.length; i2++) {
      if (typeof xPath[i2].x !== "undefined") {
        var page = getPagesByPath.call(this, xPath[i2]);
        for (var ii2 = 0; ii2 < page.length; ii2 += 1) {
          if (pages.indexOf(page[ii2]) === -1) {
            pages.push(page[ii2]);
          }
        }
      }
    }
    for (var j = 0; j < pages.length; j++) {
      while (this.pdf.internal.getNumberOfPages() < pages[j]) {
        addPage.call(this);
      }
    }
    sortPages(pages);
    if (this.autoPaging) {
      var min = pages[0];
      var max2 = pages[pages.length - 1];
      for (var k = min; k < max2 + 1; k++) {
        this.pdf.setPage(k);
        this.fillStyle = fillStyle;
        this.strokeStyle = strokeStyle;
        this.lineCap = lineCap;
        this.lineWidth = lineWidth;
        this.lineJoin = lineJoin;
        var pageWidthMinusMargins = this.pdf.internal.pageSize.width - this.margin[3] - this.margin[1];
        var topMargin = k === 1 ? this.posY + this.margin[0] : this.margin[0];
        var firstPageHeight = this.pdf.internal.pageSize.height - this.posY - this.margin[0] - this.margin[2];
        var pageHeightMinusMargins = this.pdf.internal.pageSize.height - this.margin[0] - this.margin[2];
        var previousPageHeightSum = k === 1 ? 0 : firstPageHeight + (k - 2) * pageHeightMinusMargins;
        if (this.ctx.clip_path.length !== 0) {
          var tmpPaths = this.path;
          clipPath = JSON.parse(JSON.stringify(this.ctx.clip_path));
          this.path = pathPositionRedo(clipPath, this.posX + this.margin[3], -previousPageHeightSum + topMargin + this.ctx.prevPageLastElemOffset);
          drawPaths.call(this, rule, true);
          this.path = tmpPaths;
        }
        tmpPath = JSON.parse(JSON.stringify(origPath));
        this.path = pathPositionRedo(tmpPath, this.posX + this.margin[3], -previousPageHeightSum + topMargin + this.ctx.prevPageLastElemOffset);
        if (isClip === false || k === 0) {
          var needsClipping = (k > min || k < max2) && hasMargins.call(this);
          if (needsClipping) {
            this.pdf.saveGraphicsState();
            this.pdf.rect(this.margin[3], this.margin[0], pageWidthMinusMargins, pageHeightMinusMargins, null).clip().discardPath();
          }
          drawPaths.call(this, rule, isClip);
          if (needsClipping) {
            this.pdf.restoreGraphicsState();
          }
        }
        this.lineWidth = oldLineWidth;
      }
    } else {
      this.lineWidth = lineWidth;
      drawPaths.call(this, rule, isClip);
      this.lineWidth = oldLineWidth;
    }
    this.path = origPath;
  };
  var drawPaths = function drawPaths2(rule, isClip) {
    if (rule === "stroke" && !isClip && isStrokeTransparent.call(this)) {
      return;
    }
    if (rule !== "stroke" && !isClip && isFillTransparent.call(this)) {
      return;
    }
    var moves = [];
    var delta;
    var xPath = this.path;
    for (var i2 = 0; i2 < xPath.length; i2++) {
      var pt = xPath[i2];
      switch (pt.type) {
        case "begin":
          moves.push({
            begin: true
          });
          break;
        case "close":
          moves.push({
            close: true
          });
          break;
        case "mt":
          moves.push({
            start: pt,
            deltas: [],
            abs: []
          });
          break;
        case "lt":
          var iii = moves.length;
          if (xPath[i2 - 1] && !isNaN(xPath[i2 - 1].x)) {
            delta = [pt.x - xPath[i2 - 1].x, pt.y - xPath[i2 - 1].y];
            if (iii > 0) {
              for (iii; iii >= 0; iii--) {
                if (moves[iii - 1].close !== true && moves[iii - 1].begin !== true) {
                  moves[iii - 1].deltas.push(delta);
                  moves[iii - 1].abs.push(pt);
                  break;
                }
              }
            }
          }
          break;
        case "bct":
          delta = [pt.x1 - xPath[i2 - 1].x, pt.y1 - xPath[i2 - 1].y, pt.x2 - xPath[i2 - 1].x, pt.y2 - xPath[i2 - 1].y, pt.x - xPath[i2 - 1].x, pt.y - xPath[i2 - 1].y];
          moves[moves.length - 1].deltas.push(delta);
          break;
        case "qct":
          var x1 = xPath[i2 - 1].x + 2 / 3 * (pt.x1 - xPath[i2 - 1].x);
          var y1 = xPath[i2 - 1].y + 2 / 3 * (pt.y1 - xPath[i2 - 1].y);
          var x2 = pt.x + 2 / 3 * (pt.x1 - pt.x);
          var y22 = pt.y + 2 / 3 * (pt.y1 - pt.y);
          var x3 = pt.x;
          var y3 = pt.y;
          delta = [x1 - xPath[i2 - 1].x, y1 - xPath[i2 - 1].y, x2 - xPath[i2 - 1].x, y22 - xPath[i2 - 1].y, x3 - xPath[i2 - 1].x, y3 - xPath[i2 - 1].y];
          moves[moves.length - 1].deltas.push(delta);
          break;
        case "arc":
          moves.push({
            deltas: [],
            abs: [],
            arc: true
          });
          if (Array.isArray(moves[moves.length - 1].abs)) {
            moves[moves.length - 1].abs.push(pt);
          }
          break;
      }
    }
    var style;
    if (!isClip) {
      if (rule === "stroke") {
        style = "stroke";
      } else {
        style = "fill";
      }
    } else {
      style = null;
    }
    var began = false;
    for (var k = 0; k < moves.length; k++) {
      if (moves[k].arc) {
        var arcs = moves[k].abs;
        for (var ii2 = 0; ii2 < arcs.length; ii2++) {
          var arc = arcs[ii2];
          if (arc.type === "arc") {
            drawArc.call(this, arc.x, arc.y, arc.radius, arc.startAngle, arc.endAngle, arc.counterclockwise, void 0, isClip, !began);
          } else {
            drawLine.call(this, arc.x, arc.y);
          }
          began = true;
        }
      } else if (moves[k].close === true) {
        this.pdf.internal.out("h");
        began = false;
      } else if (moves[k].begin !== true) {
        var x4 = moves[k].start.x;
        var y4 = moves[k].start.y;
        drawLines.call(this, moves[k].deltas, x4, y4);
        began = true;
      }
    }
    if (style) {
      putStyle.call(this, style);
    }
    if (isClip) {
      doClip.call(this);
    }
  };
  var getBaseline = function getBaseline2(y3) {
    var height2 = this.pdf.internal.getFontSize() / this.pdf.internal.scaleFactor;
    var descent = height2 * (this.pdf.internal.getLineHeightFactor() - 1);
    switch (this.ctx.textBaseline) {
      case "bottom":
        return y3 - descent;
      case "top":
        return y3 + height2 - descent;
      case "hanging":
        return y3 + height2 - 2 * descent;
      case "middle":
        return y3 + height2 / 2 - descent;
      case "ideographic":
        return y3;
      case "alphabetic":
      default:
        return y3;
    }
  };
  var getTextBottom = function getTextBottom2(yBaseLine) {
    var height2 = this.pdf.internal.getFontSize() / this.pdf.internal.scaleFactor;
    var descent = height2 * (this.pdf.internal.getLineHeightFactor() - 1);
    return yBaseLine + descent;
  };
  Context2D.prototype.createLinearGradient = function createLinearGradient() {
    var canvasGradient = function canvasGradient2() {
    };
    canvasGradient.colorStops = [];
    canvasGradient.addColorStop = function(offset, color) {
      this.colorStops.push([offset, color]);
    };
    canvasGradient.getColor = function() {
      if (this.colorStops.length === 0) {
        return "#000000";
      }
      return this.colorStops[0][1];
    };
    canvasGradient.isCanvasGradient = true;
    return canvasGradient;
  };
  Context2D.prototype.createPattern = function createPattern() {
    return this.createLinearGradient();
  };
  Context2D.prototype.createRadialGradient = function createRadialGradient() {
    return this.createLinearGradient();
  };
  var drawArc = function drawArc2(x2, y3, r2, a1, a2, counterclockwise, style, isClip, includeMove) {
    var curves = createArc.call(this, r2, a1, a2, counterclockwise);
    for (var i2 = 0; i2 < curves.length; i2++) {
      var curve = curves[i2];
      if (i2 === 0) {
        if (includeMove) {
          doMove.call(this, curve.x1 + x2, curve.y1 + y3);
        } else {
          drawLine.call(this, curve.x1 + x2, curve.y1 + y3);
        }
      }
      drawCurve.call(this, x2, y3, curve.x2, curve.y2, curve.x3, curve.y3, curve.x4, curve.y4);
    }
    if (!isClip) {
      putStyle.call(this, style);
    } else {
      doClip.call(this);
    }
  };
  var putStyle = function putStyle2(style) {
    switch (style) {
      case "stroke":
        this.pdf.internal.out("S");
        break;
      case "fill":
        this.pdf.internal.out("f");
        break;
    }
  };
  var doClip = function doClip2() {
    this.pdf.clip();
    this.pdf.discardPath();
  };
  var doMove = function doMove2(x2, y3) {
    this.pdf.internal.out(getHorizontalCoordinateString(x2) + " " + getVerticalCoordinateString(y3) + " m");
  };
  var putText = function putText2(options) {
    var textAlign;
    switch (options.align) {
      case "right":
      case "end":
        textAlign = "right";
        break;
      case "center":
        textAlign = "center";
        break;
      case "left":
      case "start":
      default:
        textAlign = "left";
        break;
    }
    var textDimensions = this.pdf.getTextDimensions(options.text);
    var yBaseLine = getBaseline.call(this, options.y);
    var yBottom = getTextBottom.call(this, yBaseLine);
    var yTop = yBottom - textDimensions.h;
    var pt = this.ctx.transform.applyToPoint(new Point3(options.x, yBaseLine));
    var decomposedTransformationMatrix = this.ctx.transform.decompose();
    var matrix = new Matrix3();
    matrix = matrix.multiply(decomposedTransformationMatrix.translate);
    matrix = matrix.multiply(decomposedTransformationMatrix.skew);
    matrix = matrix.multiply(decomposedTransformationMatrix.scale);
    var baselineRect = this.ctx.transform.applyToRectangle(new Rectangle(options.x, yBaseLine, textDimensions.w, textDimensions.h));
    var textBounds = matrix.applyToRectangle(new Rectangle(options.x, yTop, textDimensions.w, textDimensions.h));
    var pageArray = getPagesByPath.call(this, textBounds);
    var pages = [];
    for (var ii2 = 0; ii2 < pageArray.length; ii2 += 1) {
      if (pages.indexOf(pageArray[ii2]) === -1) {
        pages.push(pageArray[ii2]);
      }
    }
    sortPages(pages);
    var clipPath, oldSize, oldLineWidth;
    if (this.autoPaging) {
      var min = pages[0];
      var max2 = pages[pages.length - 1];
      for (var i2 = min; i2 < max2 + 1; i2++) {
        this.pdf.setPage(i2);
        var topMargin = i2 === 1 ? this.posY + this.margin[0] : this.margin[0];
        var firstPageHeight = this.pdf.internal.pageSize.height - this.posY - this.margin[0] - this.margin[2];
        var pageHeightMinusBottomMargin = this.pdf.internal.pageSize.height - this.margin[2];
        var pageHeightMinusMargins = pageHeightMinusBottomMargin - this.margin[0];
        var pageWidthMinusRightMargin = this.pdf.internal.pageSize.width - this.margin[1];
        var pageWidthMinusMargins = pageWidthMinusRightMargin - this.margin[3];
        var previousPageHeightSum = i2 === 1 ? 0 : firstPageHeight + (i2 - 2) * pageHeightMinusMargins;
        if (this.ctx.clip_path.length !== 0) {
          var tmpPaths = this.path;
          clipPath = JSON.parse(JSON.stringify(this.ctx.clip_path));
          this.path = pathPositionRedo(clipPath, this.posX + this.margin[3], -1 * previousPageHeightSum + topMargin);
          drawPaths.call(this, "fill", true);
          this.path = tmpPaths;
        }
        var textBoundsOnPage = pathPositionRedo([JSON.parse(JSON.stringify(textBounds))], this.posX + this.margin[3], -previousPageHeightSum + topMargin + this.ctx.prevPageLastElemOffset)[0];
        if (options.scale >= 0.01) {
          oldSize = this.pdf.internal.getFontSize();
          this.pdf.setFontSize(oldSize * options.scale);
          oldLineWidth = this.lineWidth;
          this.lineWidth = oldLineWidth * options.scale;
        }
        var doSlice = this.autoPaging !== "text";
        if (doSlice || textBoundsOnPage.y + textBoundsOnPage.h <= pageHeightMinusBottomMargin) {
          if (doSlice || textBoundsOnPage.y >= topMargin && textBoundsOnPage.x <= pageWidthMinusRightMargin) {
            var croppedText = doSlice ? options.text : this.pdf.splitTextToSize(options.text, options.maxWidth || pageWidthMinusRightMargin - textBoundsOnPage.x)[0];
            var baseLineRectOnPage = pathPositionRedo([JSON.parse(JSON.stringify(baselineRect))], this.posX + this.margin[3], -previousPageHeightSum + topMargin + this.ctx.prevPageLastElemOffset)[0];
            var needsClipping = doSlice && (i2 > min || i2 < max2) && hasMargins.call(this);
            if (needsClipping) {
              this.pdf.saveGraphicsState();
              this.pdf.rect(this.margin[3], this.margin[0], pageWidthMinusMargins, pageHeightMinusMargins, null).clip().discardPath();
            }
            this.pdf.text(croppedText, baseLineRectOnPage.x, baseLineRectOnPage.y, {
              angle: options.angle,
              align: textAlign,
              renderingMode: options.renderingMode
            });
            if (needsClipping) {
              this.pdf.restoreGraphicsState();
            }
          }
        } else {
          if (textBoundsOnPage.y < pageHeightMinusBottomMargin) {
            this.ctx.prevPageLastElemOffset += pageHeightMinusBottomMargin - textBoundsOnPage.y;
          }
        }
        if (options.scale >= 0.01) {
          this.pdf.setFontSize(oldSize);
          this.lineWidth = oldLineWidth;
        }
      }
    } else {
      if (options.scale >= 0.01) {
        oldSize = this.pdf.internal.getFontSize();
        this.pdf.setFontSize(oldSize * options.scale);
        oldLineWidth = this.lineWidth;
        this.lineWidth = oldLineWidth * options.scale;
      }
      this.pdf.text(options.text, pt.x + this.posX, pt.y + this.posY, {
        angle: options.angle,
        align: textAlign,
        renderingMode: options.renderingMode,
        maxWidth: options.maxWidth
      });
      if (options.scale >= 0.01) {
        this.pdf.setFontSize(oldSize);
        this.lineWidth = oldLineWidth;
      }
    }
  };
  var drawLine = function drawLine2(x2, y3, prevX, prevY) {
    prevX = prevX || 0;
    prevY = prevY || 0;
    this.pdf.internal.out(getHorizontalCoordinateString(x2 + prevX) + " " + getVerticalCoordinateString(y3 + prevY) + " l");
  };
  var drawLines = function drawLines2(lines, x2, y3) {
    return this.pdf.lines(lines, x2, y3, null, null);
  };
  var drawCurve = function drawCurve2(x2, y3, x1, y1, x22, y22, x3, y32) {
    this.pdf.internal.out([f23(getHorizontalCoordinate(x1 + x2)), f23(getVerticalCoordinate(y1 + y3)), f23(getHorizontalCoordinate(x22 + x2)), f23(getVerticalCoordinate(y22 + y3)), f23(getHorizontalCoordinate(x3 + x2)), f23(getVerticalCoordinate(y32 + y3)), "c"].join(" "));
  };
  var createArc = function createArc2(radius, startAngle, endAngle, anticlockwise) {
    var EPSILON = 1e-5;
    var twoPi = Math.PI * 2;
    var halfPi = Math.PI / 2;
    while (startAngle > endAngle) {
      startAngle = startAngle - twoPi;
    }
    var totalAngle = Math.abs(endAngle - startAngle);
    if (totalAngle < twoPi) {
      if (anticlockwise) {
        totalAngle = twoPi - totalAngle;
      }
    }
    var curves = [];
    var sgn = anticlockwise ? -1 : 1;
    var a1 = startAngle;
    for (; totalAngle > EPSILON; ) {
      var remain = sgn * Math.min(totalAngle, halfPi);
      var a2 = a1 + remain;
      curves.push(createSmallArc.call(this, radius, a1, a2));
      totalAngle -= Math.abs(a2 - a1);
      a1 = a2;
    }
    return curves;
  };
  var createSmallArc = function createSmallArc2(r2, a1, a2) {
    var a3 = (a2 - a1) / 2;
    var x4 = r2 * Math.cos(a3);
    var y4 = r2 * Math.sin(a3);
    var x1 = x4;
    var y1 = -y4;
    var q1 = x1 * x1 + y1 * y1;
    var q2 = q1 + x1 * x4 + y1 * y4;
    var k2 = 4 / 3 * (Math.sqrt(2 * q1 * q2) - q2) / (x1 * y4 - y1 * x4);
    var x2 = x1 - k2 * y1;
    var y22 = y1 + k2 * x1;
    var x3 = x2;
    var y3 = -y22;
    var ar = a3 + a1;
    var cos_ar = Math.cos(ar);
    var sin_ar = Math.sin(ar);
    return {
      x1: r2 * Math.cos(a1),
      y1: r2 * Math.sin(a1),
      x2: x2 * cos_ar - y22 * sin_ar,
      y2: x2 * sin_ar + y22 * cos_ar,
      x3: x3 * cos_ar - y3 * sin_ar,
      y3: x3 * sin_ar + y3 * cos_ar,
      x4: r2 * Math.cos(a2),
      y4: r2 * Math.sin(a2)
    };
  };
  var rad2deg = function rad2deg2(value) {
    return value * 180 / Math.PI;
  };
  var getQuadraticCurveBoundary = function getQuadraticCurveBoundary2(sx, sy, cpx, cpy, ex, ey) {
    var midX1 = sx + (cpx - sx) * 0.5;
    var midY1 = sy + (cpy - sy) * 0.5;
    var midX2 = ex + (cpx - ex) * 0.5;
    var midY2 = ey + (cpy - ey) * 0.5;
    var resultX1 = Math.min(sx, ex, midX1, midX2);
    var resultX2 = Math.max(sx, ex, midX1, midX2);
    var resultY1 = Math.min(sy, ey, midY1, midY2);
    var resultY2 = Math.max(sy, ey, midY1, midY2);
    return new Rectangle(resultX1, resultY1, resultX2 - resultX1, resultY2 - resultY1);
  };
  var getBezierCurveBoundary = function getBezierCurveBoundary2(ax2, ay2, bx, by, cx2, cy2, dx2, dy2) {
    var tobx = bx - ax2;
    var toby = by - ay2;
    var tocx = cx2 - bx;
    var tocy = cy2 - by;
    var todx = dx2 - cx2;
    var tody = dy2 - cy2;
    var precision = 40;
    var d, i2, px, py, qx, qy, rx2, ry2, tx, ty, sx, sy, x2, y3, minx, miny, maxx, maxy, toqx, toqy, torx, tory, totx, toty;
    for (i2 = 0; i2 < precision + 1; i2++) {
      d = i2 / precision;
      px = ax2 + d * tobx;
      py = ay2 + d * toby;
      qx = bx + d * tocx;
      qy = by + d * tocy;
      rx2 = cx2 + d * todx;
      ry2 = cy2 + d * tody;
      toqx = qx - px;
      toqy = qy - py;
      torx = rx2 - qx;
      tory = ry2 - qy;
      sx = px + d * toqx;
      sy = py + d * toqy;
      tx = qx + d * torx;
      ty = qy + d * tory;
      totx = tx - sx;
      toty = ty - sy;
      x2 = sx + d * totx;
      y3 = sy + d * toty;
      if (i2 == 0) {
        minx = x2;
        miny = y3;
        maxx = x2;
        maxy = y3;
      } else {
        minx = Math.min(minx, x2);
        miny = Math.min(miny, y3);
        maxx = Math.max(maxx, x2);
        maxy = Math.max(maxy, y3);
      }
    }
    return new Rectangle(Math.round(minx), Math.round(miny), Math.round(maxx - minx), Math.round(maxy - miny));
  };
  var getPrevLineDashValue = function getPrevLineDashValue2(lineDash, lineDashOffset) {
    return JSON.stringify({
      lineDash,
      lineDashOffset
    });
  };
  var setLineDash = function setLineDash2() {
    if (!this.prevLineDash && !this.ctx.lineDash.length && !this.ctx.lineDashOffset) {
      return;
    }
    var nextLineDash = getPrevLineDashValue(this.ctx.lineDash, this.ctx.lineDashOffset);
    if (this.prevLineDash !== nextLineDash) {
      this.pdf.setLineDash(this.ctx.lineDash, this.ctx.lineDashOffset);
      this.prevLineDash = nextLineDash;
    }
  };
})(jsPDF.API);
(function(jsPDFAPI2) {
  var ASCII85Encode = function ASCII85Encode2(a2) {
    var b, c3, d, e2, f3, g, h2, i2, j, k;
    for (!/[^\x00-\xFF]/.test(a2), b = "\0\0\0\0".slice(a2.length % 4 || 4), a2 += b, c3 = [], d = 0, e2 = a2.length; e2 > d; d += 4) {
      f3 = (a2.charCodeAt(d) << 24) + (a2.charCodeAt(d + 1) << 16) + (a2.charCodeAt(d + 2) << 8) + a2.charCodeAt(d + 3), 0 !== f3 ? (k = f3 % 85, f3 = (f3 - k) / 85, j = f3 % 85, f3 = (f3 - j) / 85, i2 = f3 % 85, f3 = (f3 - i2) / 85, h2 = f3 % 85, f3 = (f3 - h2) / 85, g = f3 % 85, c3.push(g + 33, h2 + 33, i2 + 33, j + 33, k + 33)) : c3.push(122);
    }
    return function(a3, b2) {
      for (var c4 = b2; c4 > 0; c4--) {
        a3.pop();
      }
    }(c3, b.length), String.fromCharCode.apply(String, c3) + "~>";
  };
  var ASCII85Decode = function ASCII85Decode2(a2) {
    var c3, d, e2, f3, g, h2 = String, l2 = "length", w = 255, x2 = "charCodeAt", y3 = "slice", z = "replace";
    for ("~>" === a2[y3](-2), a2 = a2[y3](0, -2)[z](/\s/g, "")[z]("z", "!!!!!"), c3 = "uuuuu"[y3](a2[l2] % 5 || 5), a2 += c3, e2 = [], f3 = 0, g = a2[l2]; g > f3; f3 += 5) {
      d = 52200625 * (a2[x2](f3) - 33) + 614125 * (a2[x2](f3 + 1) - 33) + 7225 * (a2[x2](f3 + 2) - 33) + 85 * (a2[x2](f3 + 3) - 33) + (a2[x2](f3 + 4) - 33), e2.push(w & d >> 24, w & d >> 16, w & d >> 8, w & d);
    }
    return function(a3, b) {
      for (var c4 = b; c4 > 0; c4--) {
        a3.pop();
      }
    }(e2, c3[l2]), h2.fromCharCode.apply(h2, e2);
  };
  var ASCIIHexEncode = function ASCIIHexEncode2(value) {
    return value.split("").map(function(value2) {
      return ("0" + value2.charCodeAt().toString(16)).slice(-2);
    }).join("") + ">";
  };
  var ASCIIHexDecode = function ASCIIHexDecode2(value) {
    var regexCheckIfHex = new RegExp(/^([0-9A-Fa-f]{2})+$/);
    value = value.replace(/\s/g, "");
    if (value.indexOf(">") !== -1) {
      value = value.substr(0, value.indexOf(">"));
    }
    if (value.length % 2) {
      value += "0";
    }
    if (regexCheckIfHex.test(value) === false) {
      return "";
    }
    var result = "";
    for (var i2 = 0; i2 < value.length; i2 += 2) {
      result += String.fromCharCode("0x" + (value[i2] + value[i2 + 1]));
    }
    return result;
  };
  var FlateEncode = function FlateEncode2(data2) {
    var arr = new Uint8Array(data2.length);
    var i2 = data2.length;
    while (i2--) {
      arr[i2] = data2.charCodeAt(i2);
    }
    arr = zlibSync(arr);
    data2 = arr.reduce(function(data3, byte) {
      return data3 + String.fromCharCode(byte);
    }, "");
    return data2;
  };
  jsPDFAPI2.processDataByFilters = function(origData, filterChain) {
    var i2 = 0;
    var data2 = origData || "";
    var reverseChain = [];
    filterChain = filterChain || [];
    if (typeof filterChain === "string") {
      filterChain = [filterChain];
    }
    for (i2 = 0; i2 < filterChain.length; i2 += 1) {
      switch (filterChain[i2]) {
        case "ASCII85Decode":
        case "/ASCII85Decode":
          data2 = ASCII85Decode(data2);
          reverseChain.push("/ASCII85Encode");
          break;
        case "ASCII85Encode":
        case "/ASCII85Encode":
          data2 = ASCII85Encode(data2);
          reverseChain.push("/ASCII85Decode");
          break;
        case "ASCIIHexDecode":
        case "/ASCIIHexDecode":
          data2 = ASCIIHexDecode(data2);
          reverseChain.push("/ASCIIHexEncode");
          break;
        case "ASCIIHexEncode":
        case "/ASCIIHexEncode":
          data2 = ASCIIHexEncode(data2);
          reverseChain.push("/ASCIIHexDecode");
          break;
        case "FlateEncode":
        case "/FlateEncode":
          data2 = FlateEncode(data2);
          reverseChain.push("/FlateDecode");
          break;
        default:
          throw new Error('The filter: "' + filterChain[i2] + '" is not implemented');
      }
    }
    return {
      data: data2,
      reverseChain: reverseChain.reverse().join(" ")
    };
  };
})(jsPDF.API);
(function(jsPDFAPI2) {
  jsPDFAPI2.loadFile = function(url, sync, callback) {
    return browserRequest(url, sync, callback);
  };
  jsPDFAPI2.loadImageFile = jsPDFAPI2.loadFile;
  function browserRequest(url, sync, callback) {
    sync = sync === false ? false : true;
    callback = typeof callback === "function" ? callback : function() {
    };
    var result = void 0;
    var xhr = function xhr2(url2, sync2, callback2) {
      var request = new XMLHttpRequest();
      var i2 = 0;
      var sanitizeUnicode = function sanitizeUnicode2(data2) {
        var dataLength = data2.length;
        var charArray = [];
        var StringFromCharCode = String.fromCharCode;
        for (i2 = 0; i2 < dataLength; i2 += 1) {
          charArray.push(StringFromCharCode(data2.charCodeAt(i2) & 255));
        }
        return charArray.join("");
      };
      request.open("GET", url2, !sync2);
      request.overrideMimeType("text/plain; charset=x-user-defined");
      if (sync2 === false) {
        request.onload = function() {
          if (request.status === 200) {
            callback2(sanitizeUnicode(this.responseText));
          } else {
            callback2(void 0);
          }
        };
      }
      request.send(null);
      if (sync2 && request.status === 200) {
        return sanitizeUnicode(request.responseText);
      }
    };
    try {
      result = xhr(url, sync, callback);
    } catch (e2) {
    }
    return result;
  }
})(jsPDF.API);
(function(jsPDFAPI2) {
  function loadHtml2Canvas() {
    return function() {
      if (globalObject["html2canvas"]) {
        return Promise.resolve(globalObject["html2canvas"]);
      }
      return Promise.resolve().then(() => __toESM(require_html2canvas()));
    }().catch(function(e2) {
      return Promise.reject(new Error("Could not load html2canvas: " + e2));
    }).then(function(html2canvas) {
      return html2canvas.default ? html2canvas.default : html2canvas;
    });
  }
  function loadDomPurify() {
    return function() {
      if (globalObject["DOMPurify"]) {
        return Promise.resolve(globalObject["DOMPurify"]);
      }
      return Promise.resolve().then(() => __toESM(require_purify()));
    }().catch(function(e2) {
      return Promise.reject(new Error("Could not load dompurify: " + e2));
    }).then(function(dompurify) {
      return dompurify.default ? dompurify.default : dompurify;
    });
  }
  var objType = function objType2(obj) {
    var type = _typeof(obj);
    if (type === "undefined")
      return "undefined";
    else if (type === "string" || obj instanceof String)
      return "string";
    else if (type === "number" || obj instanceof Number)
      return "number";
    else if (type === "function" || obj instanceof Function)
      return "function";
    else if (!!obj && obj.constructor === Array)
      return "array";
    else if (obj && obj.nodeType === 1)
      return "element";
    else if (type === "object")
      return "object";
    else
      return "unknown";
  };
  var createElement = function createElement2(tagName, opt) {
    var el2 = document.createElement(tagName);
    if (opt.className)
      el2.className = opt.className;
    if (opt.innerHTML && opt.dompurify) {
      el2.innerHTML = opt.dompurify.sanitize(opt.innerHTML);
    }
    for (var key in opt.style) {
      el2.style[key] = opt.style[key];
    }
    return el2;
  };
  var cloneNode = function cloneNode2(node3, javascriptEnabled) {
    var clone = node3.nodeType === 3 ? document.createTextNode(node3.nodeValue) : node3.cloneNode(false);
    for (var child = node3.firstChild; child; child = child.nextSibling) {
      if (javascriptEnabled === true || child.nodeType !== 1 || child.nodeName !== "SCRIPT") {
        clone.appendChild(cloneNode2(child, javascriptEnabled));
      }
    }
    if (node3.nodeType === 1) {
      if (node3.nodeName === "CANVAS") {
        clone.width = node3.width;
        clone.height = node3.height;
        clone.getContext("2d").drawImage(node3, 0, 0);
      } else if (node3.nodeName === "TEXTAREA" || node3.nodeName === "SELECT") {
        clone.value = node3.value;
      }
      clone.addEventListener("load", function() {
        clone.scrollTop = node3.scrollTop;
        clone.scrollLeft = node3.scrollLeft;
      }, true);
    }
    return clone;
  };
  var Worker2 = function Worker3(opt) {
    var root2 = Object.assign(Worker3.convert(Promise.resolve()), JSON.parse(JSON.stringify(Worker3.template)));
    var self2 = Worker3.convert(Promise.resolve(), root2);
    self2 = self2.setProgress(1, Worker3, 1, [Worker3]);
    self2 = self2.set(opt);
    return self2;
  };
  Worker2.prototype = Object.create(Promise.prototype);
  Worker2.prototype.constructor = Worker2;
  Worker2.convert = function convert(promise, inherit3) {
    promise.__proto__ = inherit3 || Worker2.prototype;
    return promise;
  };
  Worker2.template = {
    prop: {
      src: null,
      container: null,
      overlay: null,
      canvas: null,
      img: null,
      pdf: null,
      pageSize: null,
      callback: function callback() {
      }
    },
    progress: {
      val: 0,
      state: null,
      n: 0,
      stack: []
    },
    opt: {
      filename: "file.pdf",
      margin: [0, 0, 0, 0],
      enableLinks: true,
      x: 0,
      y: 0,
      html2canvas: {},
      jsPDF: {},
      backgroundColor: "transparent"
    }
  };
  Worker2.prototype.from = function from2(src, type) {
    function getType2(src2) {
      switch (objType(src2)) {
        case "string":
          return "string";
        case "element":
          return src2.nodeName.toLowerCase() === "canvas" ? "canvas" : "element";
        default:
          return "unknown";
      }
    }
    return this.then(function from_main() {
      type = type || getType2(src);
      switch (type) {
        case "string":
          return this.then(loadDomPurify).then(function(dompurify) {
            return this.set({
              src: createElement("div", {
                innerHTML: src,
                dompurify
              })
            });
          });
        case "element":
          return this.set({
            src
          });
        case "canvas":
          return this.set({
            canvas: src
          });
        case "img":
          return this.set({
            img: src
          });
        default:
          return this.error("Unknown source type.");
      }
    });
  };
  Worker2.prototype.to = function to2(target) {
    switch (target) {
      case "container":
        return this.toContainer();
      case "canvas":
        return this.toCanvas();
      case "img":
        return this.toImg();
      case "pdf":
        return this.toPdf();
      default:
        return this.error("Invalid target.");
    }
  };
  Worker2.prototype.toContainer = function toContainer() {
    var prereqs = [function checkSrc() {
      return this.prop.src || this.error("Cannot duplicate - no source HTML.");
    }, function checkPageSize() {
      return this.prop.pageSize || this.setPageSize();
    }];
    return this.thenList(prereqs).then(function toContainer_main() {
      var overlayCSS = {
        position: "fixed",
        overflow: "hidden",
        zIndex: 1e3,
        left: "-100000px",
        right: 0,
        bottom: 0,
        top: 0
      };
      var containerCSS = {
        position: "relative",
        display: "inline-block",
        width: (typeof this.opt.width === "number" && !isNaN(this.opt.width) && typeof this.opt.windowWidth === "number" && !isNaN(this.opt.windowWidth) ? this.opt.windowWidth : Math.max(this.prop.src.clientWidth, this.prop.src.scrollWidth, this.prop.src.offsetWidth)) + "px",
        left: 0,
        right: 0,
        top: 0,
        margin: "auto",
        backgroundColor: this.opt.backgroundColor
      };
      var source = cloneNode(this.prop.src, this.opt.html2canvas.javascriptEnabled);
      if (source.tagName === "BODY") {
        containerCSS.height = Math.max(document.body.scrollHeight, document.body.offsetHeight, document.documentElement.clientHeight, document.documentElement.scrollHeight, document.documentElement.offsetHeight) + "px";
      }
      this.prop.overlay = createElement("div", {
        className: "html2pdf__overlay",
        style: overlayCSS
      });
      this.prop.container = createElement("div", {
        className: "html2pdf__container",
        style: containerCSS
      });
      this.prop.container.appendChild(source);
      this.prop.container.firstChild.appendChild(createElement("div", {
        style: {
          clear: "both",
          border: "0 none transparent",
          margin: 0,
          padding: 0,
          height: 0
        }
      }));
      this.prop.container.style.float = "none";
      this.prop.overlay.appendChild(this.prop.container);
      document.body.appendChild(this.prop.overlay);
      this.prop.container.firstChild.style.position = "relative";
      this.prop.container.height = Math.max(this.prop.container.firstChild.clientHeight, this.prop.container.firstChild.scrollHeight, this.prop.container.firstChild.offsetHeight) + "px";
    });
  };
  Worker2.prototype.toCanvas = function toCanvas() {
    var prereqs = [function checkContainer() {
      return document.body.contains(this.prop.container) || this.toContainer();
    }];
    return this.thenList(prereqs).then(loadHtml2Canvas).then(function toCanvas_main(html2canvas) {
      var options = Object.assign({}, this.opt.html2canvas);
      delete options.onrendered;
      return html2canvas(this.prop.container, options);
    }).then(function toCanvas_post(canvas) {
      var onRendered = this.opt.html2canvas.onrendered || function() {
      };
      onRendered(canvas);
      this.prop.canvas = canvas;
      document.body.removeChild(this.prop.overlay);
    });
  };
  Worker2.prototype.toContext2d = function toContext2d() {
    var prereqs = [function checkContainer() {
      return document.body.contains(this.prop.container) || this.toContainer();
    }];
    return this.thenList(prereqs).then(loadHtml2Canvas).then(function toContext2d_main(html2canvas) {
      var pdf = this.opt.jsPDF;
      var fontFaces = this.opt.fontFaces;
      var scale3 = typeof this.opt.width === "number" && !isNaN(this.opt.width) && typeof this.opt.windowWidth === "number" && !isNaN(this.opt.windowWidth) ? this.opt.width / this.opt.windowWidth : 1;
      var options = Object.assign({
        async: true,
        allowTaint: true,
        scale: scale3,
        scrollX: this.opt.scrollX || 0,
        scrollY: this.opt.scrollY || 0,
        backgroundColor: "#ffffff",
        imageTimeout: 15e3,
        logging: true,
        proxy: null,
        removeContainer: true,
        foreignObjectRendering: false,
        useCORS: false
      }, this.opt.html2canvas);
      delete options.onrendered;
      pdf.context2d.autoPaging = typeof this.opt.autoPaging === "undefined" ? true : this.opt.autoPaging;
      pdf.context2d.posX = this.opt.x;
      pdf.context2d.posY = this.opt.y;
      pdf.context2d.margin = this.opt.margin;
      pdf.context2d.fontFaces = fontFaces;
      if (fontFaces) {
        for (var i2 = 0; i2 < fontFaces.length; ++i2) {
          var font = fontFaces[i2];
          var src = font.src.find(function(src2) {
            return src2.format === "truetype";
          });
          if (src) {
            pdf.addFont(src.url, font.ref.name, font.ref.style);
          }
        }
      }
      options.windowHeight = options.windowHeight || 0;
      options.windowHeight = options.windowHeight == 0 ? Math.max(this.prop.container.clientHeight, this.prop.container.scrollHeight, this.prop.container.offsetHeight) : options.windowHeight;
      pdf.context2d.save(true);
      return html2canvas(this.prop.container, options);
    }).then(function toContext2d_post(canvas) {
      this.opt.jsPDF.context2d.restore(true);
      var onRendered = this.opt.html2canvas.onrendered || function() {
      };
      onRendered(canvas);
      this.prop.canvas = canvas;
      document.body.removeChild(this.prop.overlay);
    });
  };
  Worker2.prototype.toImg = function toImg() {
    var prereqs = [function checkCanvas() {
      return this.prop.canvas || this.toCanvas();
    }];
    return this.thenList(prereqs).then(function toImg_main() {
      var imgData = this.prop.canvas.toDataURL("image/" + this.opt.image.type, this.opt.image.quality);
      this.prop.img = document.createElement("img");
      this.prop.img.src = imgData;
    });
  };
  Worker2.prototype.toPdf = function toPdf() {
    var prereqs = [
      function checkContext2d() {
        return this.toContext2d();
      }
      //function checkCanvas() { return this.prop.canvas || this.toCanvas(); }
    ];
    return this.thenList(prereqs).then(function toPdf_main() {
      this.prop.pdf = this.prop.pdf || this.opt.jsPDF;
    });
  };
  Worker2.prototype.output = function output(type, options, src) {
    src = src || "pdf";
    if (src.toLowerCase() === "img" || src.toLowerCase() === "image") {
      return this.outputImg(type, options);
    } else {
      return this.outputPdf(type, options);
    }
  };
  Worker2.prototype.outputPdf = function outputPdf(type, options) {
    var prereqs = [function checkPdf() {
      return this.prop.pdf || this.toPdf();
    }];
    return this.thenList(prereqs).then(function outputPdf_main() {
      return this.prop.pdf.output(type, options);
    });
  };
  Worker2.prototype.outputImg = function outputImg(type) {
    var prereqs = [function checkImg() {
      return this.prop.img || this.toImg();
    }];
    return this.thenList(prereqs).then(function outputImg_main() {
      switch (type) {
        case void 0:
        case "img":
          return this.prop.img;
        case "datauristring":
        case "dataurlstring":
          return this.prop.img.src;
        case "datauri":
        case "dataurl":
          return document.location.href = this.prop.img.src;
        default:
          throw 'Image output type "' + type + '" is not supported.';
      }
    });
  };
  Worker2.prototype.save = function save(filename) {
    var prereqs = [function checkPdf() {
      return this.prop.pdf || this.toPdf();
    }];
    return this.thenList(prereqs).set(filename ? {
      filename
    } : null).then(function save_main() {
      this.prop.pdf.save(this.opt.filename);
    });
  };
  Worker2.prototype.doCallback = function doCallback() {
    var prereqs = [function checkPdf() {
      return this.prop.pdf || this.toPdf();
    }];
    return this.thenList(prereqs).then(function doCallback_main() {
      this.prop.callback(this.prop.pdf);
    });
  };
  Worker2.prototype.set = function set(opt) {
    if (objType(opt) !== "object") {
      return this;
    }
    var fns = Object.keys(opt || {}).map(function(key) {
      if (key in Worker2.template.prop) {
        return function set_prop() {
          this.prop[key] = opt[key];
        };
      } else {
        switch (key) {
          case "margin":
            return this.setMargin.bind(this, opt.margin);
          case "jsPDF":
            return function set_jsPDF() {
              this.opt.jsPDF = opt.jsPDF;
              return this.setPageSize();
            };
          case "pageSize":
            return this.setPageSize.bind(this, opt.pageSize);
          default:
            return function set_opt() {
              this.opt[key] = opt[key];
            };
        }
      }
    }, this);
    return this.then(function set_main() {
      return this.thenList(fns);
    });
  };
  Worker2.prototype.get = function get(key, cbk) {
    return this.then(function get_main() {
      var val = key in Worker2.template.prop ? this.prop[key] : this.opt[key];
      return cbk ? cbk(val) : val;
    });
  };
  Worker2.prototype.setMargin = function setMargin(margin) {
    return this.then(function setMargin_main() {
      switch (objType(margin)) {
        case "number":
          margin = [margin, margin, margin, margin];
        case "array":
          if (margin.length === 2) {
            margin = [margin[0], margin[1], margin[0], margin[1]];
          }
          if (margin.length === 4) {
            break;
          }
        default:
          return this.error("Invalid margin array.");
      }
      this.opt.margin = margin;
    }).then(this.setPageSize);
  };
  Worker2.prototype.setPageSize = function setPageSize(pageSize) {
    function toPx(val, k) {
      return Math.floor(val * k / 72 * 96);
    }
    return this.then(function setPageSize_main() {
      pageSize = pageSize || jsPDF.getPageSize(this.opt.jsPDF);
      if (!pageSize.hasOwnProperty("inner")) {
        pageSize.inner = {
          width: pageSize.width - this.opt.margin[1] - this.opt.margin[3],
          height: pageSize.height - this.opt.margin[0] - this.opt.margin[2]
        };
        pageSize.inner.px = {
          width: toPx(pageSize.inner.width, pageSize.k),
          height: toPx(pageSize.inner.height, pageSize.k)
        };
        pageSize.inner.ratio = pageSize.inner.height / pageSize.inner.width;
      }
      this.prop.pageSize = pageSize;
    });
  };
  Worker2.prototype.setProgress = function setProgress(val, state, n2, stack) {
    if (val != null)
      this.progress.val = val;
    if (state != null)
      this.progress.state = state;
    if (n2 != null)
      this.progress.n = n2;
    if (stack != null)
      this.progress.stack = stack;
    this.progress.ratio = this.progress.val / this.progress.state;
    return this;
  };
  Worker2.prototype.updateProgress = function updateProgress(val, state, n2, stack) {
    return this.setProgress(val ? this.progress.val + val : null, state ? state : null, n2 ? this.progress.n + n2 : null, stack ? this.progress.stack.concat(stack) : null);
  };
  Worker2.prototype.then = function then(onFulfilled, onRejected) {
    var self2 = this;
    return this.thenCore(onFulfilled, onRejected, function then_main(onFulfilled2, onRejected2) {
      self2.updateProgress(null, null, 1, [onFulfilled2]);
      return Promise.prototype.then.call(this, function then_pre(val) {
        self2.updateProgress(null, onFulfilled2);
        return val;
      }).then(onFulfilled2, onRejected2).then(function then_post(val) {
        self2.updateProgress(1);
        return val;
      });
    });
  };
  Worker2.prototype.thenCore = function thenCore(onFulfilled, onRejected, thenBase) {
    thenBase = thenBase || Promise.prototype.then;
    var self2 = this;
    if (onFulfilled) {
      onFulfilled = onFulfilled.bind(self2);
    }
    if (onRejected) {
      onRejected = onRejected.bind(self2);
    }
    var isNative = Promise.toString().indexOf("[native code]") !== -1 && Promise.name === "Promise";
    var selfPromise = isNative ? self2 : Worker2.convert(Object.assign({}, self2), Promise.prototype);
    var returnVal = thenBase.call(selfPromise, onFulfilled, onRejected);
    return Worker2.convert(returnVal, self2.__proto__);
  };
  Worker2.prototype.thenExternal = function thenExternal(onFulfilled, onRejected) {
    return Promise.prototype.then.call(this, onFulfilled, onRejected);
  };
  Worker2.prototype.thenList = function thenList(fns) {
    var self2 = this;
    fns.forEach(function thenList_forEach(fn) {
      self2 = self2.thenCore(fn);
    });
    return self2;
  };
  Worker2.prototype["catch"] = function(onRejected) {
    if (onRejected) {
      onRejected = onRejected.bind(this);
    }
    var returnVal = Promise.prototype["catch"].call(this, onRejected);
    return Worker2.convert(returnVal, this);
  };
  Worker2.prototype.catchExternal = function catchExternal(onRejected) {
    return Promise.prototype["catch"].call(this, onRejected);
  };
  Worker2.prototype.error = function error(msg) {
    return this.then(function error_main() {
      throw new Error(msg);
    });
  };
  Worker2.prototype.using = Worker2.prototype.set;
  Worker2.prototype.saveAs = Worker2.prototype.save;
  Worker2.prototype.export = Worker2.prototype.output;
  Worker2.prototype.run = Worker2.prototype.then;
  jsPDF.getPageSize = function(orientation, unit, format) {
    if (_typeof(orientation) === "object") {
      var options = orientation;
      orientation = options.orientation;
      unit = options.unit || unit;
      format = options.format || format;
    }
    unit = unit || "mm";
    format = format || "a4";
    orientation = ("" + (orientation || "P")).toLowerCase();
    var format_as_string = ("" + format).toLowerCase();
    var pageFormats = {
      a0: [2383.94, 3370.39],
      a1: [1683.78, 2383.94],
      a2: [1190.55, 1683.78],
      a3: [841.89, 1190.55],
      a4: [595.28, 841.89],
      a5: [419.53, 595.28],
      a6: [297.64, 419.53],
      a7: [209.76, 297.64],
      a8: [147.4, 209.76],
      a9: [104.88, 147.4],
      a10: [73.7, 104.88],
      b0: [2834.65, 4008.19],
      b1: [2004.09, 2834.65],
      b2: [1417.32, 2004.09],
      b3: [1000.63, 1417.32],
      b4: [708.66, 1000.63],
      b5: [498.9, 708.66],
      b6: [354.33, 498.9],
      b7: [249.45, 354.33],
      b8: [175.75, 249.45],
      b9: [124.72, 175.75],
      b10: [87.87, 124.72],
      c0: [2599.37, 3676.54],
      c1: [1836.85, 2599.37],
      c2: [1298.27, 1836.85],
      c3: [918.43, 1298.27],
      c4: [649.13, 918.43],
      c5: [459.21, 649.13],
      c6: [323.15, 459.21],
      c7: [229.61, 323.15],
      c8: [161.57, 229.61],
      c9: [113.39, 161.57],
      c10: [79.37, 113.39],
      dl: [311.81, 623.62],
      letter: [612, 792],
      "government-letter": [576, 756],
      legal: [612, 1008],
      "junior-legal": [576, 360],
      ledger: [1224, 792],
      tabloid: [792, 1224],
      "credit-card": [153, 243]
    };
    var k;
    switch (unit) {
      case "pt":
        k = 1;
        break;
      case "mm":
        k = 72 / 25.4;
        break;
      case "cm":
        k = 72 / 2.54;
        break;
      case "in":
        k = 72;
        break;
      case "px":
        k = 72 / 96;
        break;
      case "pc":
        k = 12;
        break;
      case "em":
        k = 12;
        break;
      case "ex":
        k = 6;
        break;
      default:
        throw "Invalid unit: " + unit;
    }
    var pageHeight = 0;
    var pageWidth = 0;
    if (pageFormats.hasOwnProperty(format_as_string)) {
      pageHeight = pageFormats[format_as_string][1] / k;
      pageWidth = pageFormats[format_as_string][0] / k;
    } else {
      try {
        pageHeight = format[1];
        pageWidth = format[0];
      } catch (err) {
        throw new Error("Invalid format: " + format);
      }
    }
    var tmp;
    if (orientation === "p" || orientation === "portrait") {
      orientation = "p";
      if (pageWidth > pageHeight) {
        tmp = pageWidth;
        pageWidth = pageHeight;
        pageHeight = tmp;
      }
    } else if (orientation === "l" || orientation === "landscape") {
      orientation = "l";
      if (pageHeight > pageWidth) {
        tmp = pageWidth;
        pageWidth = pageHeight;
        pageHeight = tmp;
      }
    } else {
      throw "Invalid orientation: " + orientation;
    }
    var info = {
      width: pageWidth,
      height: pageHeight,
      unit,
      k,
      orientation
    };
    return info;
  };
  jsPDFAPI2.html = function(src, options) {
    options = options || {};
    options.callback = options.callback || function() {
    };
    options.html2canvas = options.html2canvas || {};
    options.html2canvas.canvas = options.html2canvas.canvas || this.canvas;
    options.jsPDF = options.jsPDF || this;
    options.fontFaces = options.fontFaces ? options.fontFaces.map(normalizeFontFace) : null;
    var worker = new Worker2(options);
    if (!options.worker) {
      return worker.from(src).doCallback();
    } else {
      return worker;
    }
  };
})(jsPDF.API);
(function(jsPDFAPI2) {
  var jsNamesObj, jsJsObj, text4;
  jsPDFAPI2.addJS = function(javascript) {
    text4 = javascript;
    this.internal.events.subscribe("postPutResources", function() {
      jsNamesObj = this.internal.newObject();
      this.internal.out("<<");
      this.internal.out("/Names [(EmbeddedJS) " + (jsNamesObj + 1) + " 0 R]");
      this.internal.out(">>");
      this.internal.out("endobj");
      jsJsObj = this.internal.newObject();
      this.internal.out("<<");
      this.internal.out("/S /JavaScript");
      this.internal.out("/JS (" + text4 + ")");
      this.internal.out(">>");
      this.internal.out("endobj");
    });
    this.internal.events.subscribe("putCatalog", function() {
      if (jsNamesObj !== void 0 && jsJsObj !== void 0) {
        this.internal.out("/Names <</JavaScript " + jsNamesObj + " 0 R>>");
      }
    });
    return this;
  };
})(jsPDF.API);
(function(jsPDFAPI2) {
  var namesOid;
  jsPDFAPI2.events.push(["postPutResources", function() {
    var pdf = this;
    var rx2 = /^(\d+) 0 obj$/;
    if (this.outline.root.children.length > 0) {
      var lines = pdf.outline.render().split(/\r\n/);
      for (var i2 = 0; i2 < lines.length; i2++) {
        var line = lines[i2];
        var m3 = rx2.exec(line);
        if (m3 != null) {
          var oid = m3[1];
          pdf.internal.newObjectDeferredBegin(oid, false);
        }
        pdf.internal.write(line);
      }
    }
    if (this.outline.createNamedDestinations) {
      var totalPages = this.internal.pages.length;
      var dests = [];
      for (var i2 = 0; i2 < totalPages; i2++) {
        var id = pdf.internal.newObject();
        dests.push(id);
        var info = pdf.internal.getPageInfo(i2 + 1);
        pdf.internal.write("<< /D[" + info.objId + " 0 R /XYZ null null null]>> endobj");
      }
      var names2Oid = pdf.internal.newObject();
      pdf.internal.write("<< /Names [ ");
      for (var i2 = 0; i2 < dests.length; i2++) {
        pdf.internal.write("(page_" + (i2 + 1) + ")" + dests[i2] + " 0 R");
      }
      pdf.internal.write(" ] >>", "endobj");
      namesOid = pdf.internal.newObject();
      pdf.internal.write("<< /Dests " + names2Oid + " 0 R");
      pdf.internal.write(">>", "endobj");
    }
  }]);
  jsPDFAPI2.events.push(["putCatalog", function() {
    var pdf = this;
    if (pdf.outline.root.children.length > 0) {
      pdf.internal.write("/Outlines", this.outline.makeRef(this.outline.root));
      if (this.outline.createNamedDestinations) {
        pdf.internal.write("/Names " + namesOid + " 0 R");
      }
    }
  }]);
  jsPDFAPI2.events.push(["initialized", function() {
    var pdf = this;
    pdf.outline = {
      createNamedDestinations: false,
      root: {
        children: []
      }
    };
    pdf.outline.add = function(parent, title, options) {
      var item = {
        title,
        options,
        children: []
      };
      if (parent == null) {
        parent = this.root;
      }
      parent.children.push(item);
      return item;
    };
    pdf.outline.render = function() {
      this.ctx = {};
      this.ctx.val = "";
      this.ctx.pdf = pdf;
      this.genIds_r(this.root);
      this.renderRoot(this.root);
      this.renderItems(this.root);
      return this.ctx.val;
    };
    pdf.outline.genIds_r = function(node3) {
      node3.id = pdf.internal.newObjectDeferred();
      for (var i2 = 0; i2 < node3.children.length; i2++) {
        this.genIds_r(node3.children[i2]);
      }
    };
    pdf.outline.renderRoot = function(node3) {
      this.objStart(node3);
      this.line("/Type /Outlines");
      if (node3.children.length > 0) {
        this.line("/First " + this.makeRef(node3.children[0]));
        this.line("/Last " + this.makeRef(node3.children[node3.children.length - 1]));
      }
      this.line("/Count " + this.count_r({
        count: 0
      }, node3));
      this.objEnd();
    };
    pdf.outline.renderItems = function(node3) {
      var getVerticalCoordinateString = this.ctx.pdf.internal.getVerticalCoordinateString;
      for (var i2 = 0; i2 < node3.children.length; i2++) {
        var item = node3.children[i2];
        this.objStart(item);
        this.line("/Title " + this.makeString(item.title));
        this.line("/Parent " + this.makeRef(node3));
        if (i2 > 0) {
          this.line("/Prev " + this.makeRef(node3.children[i2 - 1]));
        }
        if (i2 < node3.children.length - 1) {
          this.line("/Next " + this.makeRef(node3.children[i2 + 1]));
        }
        if (item.children.length > 0) {
          this.line("/First " + this.makeRef(item.children[0]));
          this.line("/Last " + this.makeRef(item.children[item.children.length - 1]));
        }
        var count = this.count = this.count_r({
          count: 0
        }, item);
        if (count > 0) {
          this.line("/Count " + count);
        }
        if (item.options) {
          if (item.options.pageNumber) {
            var info = pdf.internal.getPageInfo(item.options.pageNumber);
            this.line("/Dest [" + info.objId + " 0 R /XYZ 0 " + getVerticalCoordinateString(0) + " 0]");
          }
        }
        this.objEnd();
      }
      for (var z = 0; z < node3.children.length; z++) {
        this.renderItems(node3.children[z]);
      }
    };
    pdf.outline.line = function(text4) {
      this.ctx.val += text4 + "\r\n";
    };
    pdf.outline.makeRef = function(node3) {
      return node3.id + " 0 R";
    };
    pdf.outline.makeString = function(val) {
      return "(" + pdf.internal.pdfEscape(val) + ")";
    };
    pdf.outline.objStart = function(node3) {
      this.ctx.val += "\r\n" + node3.id + " 0 obj\r\n<<\r\n";
    };
    pdf.outline.objEnd = function() {
      this.ctx.val += ">> \r\nendobj\r\n";
    };
    pdf.outline.count_r = function(ctx, node3) {
      for (var i2 = 0; i2 < node3.children.length; i2++) {
        ctx.count++;
        this.count_r(ctx, node3.children[i2]);
      }
      return ctx.count;
    };
  }]);
  return this;
})(jsPDF.API);
(function(jsPDFAPI2) {
  var markers = [192, 193, 194, 195, 196, 197, 198, 199];
  var getJpegInfo = function getJpegInfo2(imgData) {
    var width2, height2, numcomponents;
    var blockLength = imgData.charCodeAt(4) * 256 + imgData.charCodeAt(5);
    var len = imgData.length;
    var result = {
      width: 0,
      height: 0,
      numcomponents: 1
    };
    for (var i2 = 4; i2 < len; i2 += 2) {
      i2 += blockLength;
      if (markers.indexOf(imgData.charCodeAt(i2 + 1)) !== -1) {
        height2 = imgData.charCodeAt(i2 + 5) * 256 + imgData.charCodeAt(i2 + 6);
        width2 = imgData.charCodeAt(i2 + 7) * 256 + imgData.charCodeAt(i2 + 8);
        numcomponents = imgData.charCodeAt(i2 + 9);
        result = {
          width: width2,
          height: height2,
          numcomponents
        };
        break;
      } else {
        blockLength = imgData.charCodeAt(i2 + 2) * 256 + imgData.charCodeAt(i2 + 3);
      }
    }
    return result;
  };
  jsPDFAPI2.processJPEG = function(data2, index3, alias, compression, dataAsBinaryString, colorSpace) {
    var filter2 = this.decode.DCT_DECODE, bpc = 8, dims, result = null;
    if (typeof data2 === "string" || this.__addimage__.isArrayBuffer(data2) || this.__addimage__.isArrayBufferView(data2)) {
      data2 = dataAsBinaryString || data2;
      data2 = this.__addimage__.isArrayBuffer(data2) ? new Uint8Array(data2) : data2;
      data2 = this.__addimage__.isArrayBufferView(data2) ? this.__addimage__.arrayBufferToBinaryString(data2) : data2;
      dims = getJpegInfo(data2);
      switch (dims.numcomponents) {
        case 1:
          colorSpace = this.color_spaces.DEVICE_GRAY;
          break;
        case 4:
          colorSpace = this.color_spaces.DEVICE_CMYK;
          break;
        case 3:
          colorSpace = this.color_spaces.DEVICE_RGB;
          break;
      }
      result = {
        data: data2,
        width: dims.width,
        height: dims.height,
        colorSpace,
        bitsPerComponent: bpc,
        filter: filter2,
        index: index3,
        alias
      };
    }
    return result;
  };
})(jsPDF.API);
var PNG = function() {
  var APNG_BLEND_OP_SOURCE, APNG_DISPOSE_OP_BACKGROUND, APNG_DISPOSE_OP_PREVIOUS, makeImage, scratchCanvas, scratchCtx;
  APNG_DISPOSE_OP_BACKGROUND = 1;
  APNG_DISPOSE_OP_PREVIOUS = 2;
  APNG_BLEND_OP_SOURCE = 0;
  function PNG2(data2) {
    var chunkSize, colors, palLen, delayDen, delayNum, frame, i2, index3, key, section, palShort, text4, _i, _j, _ref;
    this.data = data2;
    this.pos = 8;
    this.palette = [];
    this.imgData = [];
    this.transparency = {};
    this.animation = null;
    this.text = {};
    frame = null;
    while (true) {
      chunkSize = this.readUInt32();
      section = function() {
        var _i2, _results;
        _results = [];
        for (i2 = _i2 = 0; _i2 < 4; i2 = ++_i2) {
          _results.push(String.fromCharCode(this.data[this.pos++]));
        }
        return _results;
      }.call(this).join("");
      switch (section) {
        case "IHDR":
          this.width = this.readUInt32();
          this.height = this.readUInt32();
          this.bits = this.data[this.pos++];
          this.colorType = this.data[this.pos++];
          this.compressionMethod = this.data[this.pos++];
          this.filterMethod = this.data[this.pos++];
          this.interlaceMethod = this.data[this.pos++];
          break;
        case "acTL":
          this.animation = {
            numFrames: this.readUInt32(),
            numPlays: this.readUInt32() || Infinity,
            frames: []
          };
          break;
        case "PLTE":
          this.palette = this.read(chunkSize);
          break;
        case "fcTL":
          if (frame) {
            this.animation.frames.push(frame);
          }
          this.pos += 4;
          frame = {
            width: this.readUInt32(),
            height: this.readUInt32(),
            xOffset: this.readUInt32(),
            yOffset: this.readUInt32()
          };
          delayNum = this.readUInt16();
          delayDen = this.readUInt16() || 100;
          frame.delay = 1e3 * delayNum / delayDen;
          frame.disposeOp = this.data[this.pos++];
          frame.blendOp = this.data[this.pos++];
          frame.data = [];
          break;
        case "IDAT":
        case "fdAT":
          if (section === "fdAT") {
            this.pos += 4;
            chunkSize -= 4;
          }
          data2 = (frame != null ? frame.data : void 0) || this.imgData;
          for (i2 = _i = 0; 0 <= chunkSize ? _i < chunkSize : _i > chunkSize; i2 = 0 <= chunkSize ? ++_i : --_i) {
            data2.push(this.data[this.pos++]);
          }
          break;
        case "tRNS":
          this.transparency = {};
          switch (this.colorType) {
            case 3:
              palLen = this.palette.length / 3;
              this.transparency.indexed = this.read(chunkSize);
              if (this.transparency.indexed.length > palLen)
                throw new Error("More transparent colors than palette size");
              palShort = palLen - this.transparency.indexed.length;
              if (palShort > 0) {
                for (i2 = _j = 0; 0 <= palShort ? _j < palShort : _j > palShort; i2 = 0 <= palShort ? ++_j : --_j) {
                  this.transparency.indexed.push(255);
                }
              }
              break;
            case 0:
              this.transparency.grayscale = this.read(chunkSize)[0];
              break;
            case 2:
              this.transparency.rgb = this.read(chunkSize);
          }
          break;
        case "tEXt":
          text4 = this.read(chunkSize);
          index3 = text4.indexOf(0);
          key = String.fromCharCode.apply(String, text4.slice(0, index3));
          this.text[key] = String.fromCharCode.apply(String, text4.slice(index3 + 1));
          break;
        case "IEND":
          if (frame) {
            this.animation.frames.push(frame);
          }
          this.colors = function() {
            switch (this.colorType) {
              case 0:
              case 3:
              case 4:
                return 1;
              case 2:
              case 6:
                return 3;
            }
          }.call(this);
          this.hasAlphaChannel = (_ref = this.colorType) === 4 || _ref === 6;
          colors = this.colors + (this.hasAlphaChannel ? 1 : 0);
          this.pixelBitlength = this.bits * colors;
          this.colorSpace = function() {
            switch (this.colors) {
              case 1:
                return "DeviceGray";
              case 3:
                return "DeviceRGB";
            }
          }.call(this);
          this.imgData = new Uint8Array(this.imgData);
          return;
        default:
          this.pos += chunkSize;
      }
      this.pos += 4;
      if (this.pos > this.data.length) {
        throw new Error("Incomplete or corrupt PNG file");
      }
    }
  }
  PNG2.prototype.read = function(bytes) {
    var i2, _i, _results;
    _results = [];
    for (i2 = _i = 0; 0 <= bytes ? _i < bytes : _i > bytes; i2 = 0 <= bytes ? ++_i : --_i) {
      _results.push(this.data[this.pos++]);
    }
    return _results;
  };
  PNG2.prototype.readUInt32 = function() {
    var b1, b2, b3, b4;
    b1 = this.data[this.pos++] << 24;
    b2 = this.data[this.pos++] << 16;
    b3 = this.data[this.pos++] << 8;
    b4 = this.data[this.pos++];
    return b1 | b2 | b3 | b4;
  };
  PNG2.prototype.readUInt16 = function() {
    var b1, b2;
    b1 = this.data[this.pos++] << 8;
    b2 = this.data[this.pos++];
    return b1 | b2;
  };
  PNG2.prototype.decodePixels = function(data2) {
    var pixelBytes = this.pixelBitlength / 8;
    var fullPixels = new Uint8Array(this.width * this.height * pixelBytes);
    var pos = 0;
    var _this = this;
    if (data2 == null) {
      data2 = this.imgData;
    }
    if (data2.length === 0) {
      return new Uint8Array(0);
    }
    data2 = unzlibSync(data2);
    function pass(x0, y0, dx2, dy2) {
      var abyte, c3, col, i2, left, length2, p2, pa, paeth, pb, pc, pixels, row, scanlineLength, upper, upperLeft, _i, _j, _k, _l, _m;
      var w = Math.ceil((_this.width - x0) / dx2), h2 = Math.ceil((_this.height - y0) / dy2);
      var isFull = _this.width == w && _this.height == h2;
      scanlineLength = pixelBytes * w;
      pixels = isFull ? fullPixels : new Uint8Array(scanlineLength * h2);
      length2 = data2.length;
      row = 0;
      c3 = 0;
      while (row < h2 && pos < length2) {
        switch (data2[pos++]) {
          case 0:
            for (i2 = _i = 0; _i < scanlineLength; i2 = _i += 1) {
              pixels[c3++] = data2[pos++];
            }
            break;
          case 1:
            for (i2 = _j = 0; _j < scanlineLength; i2 = _j += 1) {
              abyte = data2[pos++];
              left = i2 < pixelBytes ? 0 : pixels[c3 - pixelBytes];
              pixels[c3++] = (abyte + left) % 256;
            }
            break;
          case 2:
            for (i2 = _k = 0; _k < scanlineLength; i2 = _k += 1) {
              abyte = data2[pos++];
              col = (i2 - i2 % pixelBytes) / pixelBytes;
              upper = row && pixels[(row - 1) * scanlineLength + col * pixelBytes + i2 % pixelBytes];
              pixels[c3++] = (upper + abyte) % 256;
            }
            break;
          case 3:
            for (i2 = _l = 0; _l < scanlineLength; i2 = _l += 1) {
              abyte = data2[pos++];
              col = (i2 - i2 % pixelBytes) / pixelBytes;
              left = i2 < pixelBytes ? 0 : pixels[c3 - pixelBytes];
              upper = row && pixels[(row - 1) * scanlineLength + col * pixelBytes + i2 % pixelBytes];
              pixels[c3++] = (abyte + Math.floor((left + upper) / 2)) % 256;
            }
            break;
          case 4:
            for (i2 = _m = 0; _m < scanlineLength; i2 = _m += 1) {
              abyte = data2[pos++];
              col = (i2 - i2 % pixelBytes) / pixelBytes;
              left = i2 < pixelBytes ? 0 : pixels[c3 - pixelBytes];
              if (row === 0) {
                upper = upperLeft = 0;
              } else {
                upper = pixels[(row - 1) * scanlineLength + col * pixelBytes + i2 % pixelBytes];
                upperLeft = col && pixels[(row - 1) * scanlineLength + (col - 1) * pixelBytes + i2 % pixelBytes];
              }
              p2 = left + upper - upperLeft;
              pa = Math.abs(p2 - left);
              pb = Math.abs(p2 - upper);
              pc = Math.abs(p2 - upperLeft);
              if (pa <= pb && pa <= pc) {
                paeth = left;
              } else if (pb <= pc) {
                paeth = upper;
              } else {
                paeth = upperLeft;
              }
              pixels[c3++] = (abyte + paeth) % 256;
            }
            break;
          default:
            throw new Error("Invalid filter algorithm: " + data2[pos - 1]);
        }
        if (!isFull) {
          var fullPos = ((y0 + row * dy2) * _this.width + x0) * pixelBytes;
          var partPos = row * scanlineLength;
          for (i2 = 0; i2 < w; i2 += 1) {
            for (var j = 0; j < pixelBytes; j += 1) {
              fullPixels[fullPos++] = pixels[partPos++];
            }
            fullPos += (dx2 - 1) * pixelBytes;
          }
        }
        row++;
      }
    }
    if (_this.interlaceMethod == 1) {
      pass(0, 0, 8, 8);
      pass(4, 0, 8, 8);
      pass(0, 4, 4, 8);
      pass(2, 0, 4, 4);
      pass(0, 2, 2, 4);
      pass(1, 0, 2, 2);
      pass(0, 1, 1, 2);
    } else {
      pass(0, 0, 1, 1);
    }
    return fullPixels;
  };
  PNG2.prototype.decodePalette = function() {
    var c3, i2, length2, palette, pos, ret, transparency, _i, _ref, _ref1;
    palette = this.palette;
    transparency = this.transparency.indexed || [];
    ret = new Uint8Array((transparency.length || 0) + palette.length);
    pos = 0;
    length2 = palette.length;
    c3 = 0;
    for (i2 = _i = 0, _ref = length2; _i < _ref; i2 = _i += 3) {
      ret[pos++] = palette[i2];
      ret[pos++] = palette[i2 + 1];
      ret[pos++] = palette[i2 + 2];
      ret[pos++] = (_ref1 = transparency[c3++]) != null ? _ref1 : 255;
    }
    return ret;
  };
  PNG2.prototype.copyToImageData = function(imageData, pixels) {
    var alpha, colors, data2, i2, input, j, k, length2, palette, v2, _ref;
    colors = this.colors;
    palette = null;
    alpha = this.hasAlphaChannel;
    if (this.palette.length) {
      palette = (_ref = this._decodedPalette) != null ? _ref : this._decodedPalette = this.decodePalette();
      colors = 4;
      alpha = true;
    }
    data2 = imageData.data || imageData;
    length2 = data2.length;
    input = palette || pixels;
    i2 = j = 0;
    if (colors === 1) {
      while (i2 < length2) {
        k = palette ? pixels[i2 / 4] * 4 : j;
        v2 = input[k++];
        data2[i2++] = v2;
        data2[i2++] = v2;
        data2[i2++] = v2;
        data2[i2++] = alpha ? input[k++] : 255;
        j = k;
      }
    } else {
      while (i2 < length2) {
        k = palette ? pixels[i2 / 4] * 4 : j;
        data2[i2++] = input[k++];
        data2[i2++] = input[k++];
        data2[i2++] = input[k++];
        data2[i2++] = alpha ? input[k++] : 255;
        j = k;
      }
    }
  };
  PNG2.prototype.decode = function() {
    var ret;
    ret = new Uint8Array(this.width * this.height * 4);
    this.copyToImageData(ret, this.decodePixels());
    return ret;
  };
  var hasBrowserCanvas = function hasBrowserCanvas2() {
    if (Object.prototype.toString.call(globalObject) === "[object Window]") {
      try {
        scratchCanvas = globalObject.document.createElement("canvas");
        scratchCtx = scratchCanvas.getContext("2d");
      } catch (e2) {
        return false;
      }
      return true;
    }
    return false;
  };
  hasBrowserCanvas();
  makeImage = function makeImage2(imageData) {
    if (hasBrowserCanvas() === true) {
      var img;
      scratchCtx.width = imageData.width;
      scratchCtx.height = imageData.height;
      scratchCtx.clearRect(0, 0, imageData.width, imageData.height);
      scratchCtx.putImageData(imageData, 0, 0);
      img = new Image();
      img.src = scratchCanvas.toDataURL();
      return img;
    }
    throw new Error("This method requires a Browser with Canvas-capability.");
  };
  PNG2.prototype.decodeFrames = function(ctx) {
    var frame, i2, imageData, pixels, _i, _len, _ref, _results;
    if (!this.animation) {
      return;
    }
    _ref = this.animation.frames;
    _results = [];
    for (i2 = _i = 0, _len = _ref.length; _i < _len; i2 = ++_i) {
      frame = _ref[i2];
      imageData = ctx.createImageData(frame.width, frame.height);
      pixels = this.decodePixels(new Uint8Array(frame.data));
      this.copyToImageData(imageData, pixels);
      frame.imageData = imageData;
      _results.push(frame.image = makeImage(imageData));
    }
    return _results;
  };
  PNG2.prototype.renderFrame = function(ctx, number) {
    var frame, frames, prev2;
    frames = this.animation.frames;
    frame = frames[number];
    prev2 = frames[number - 1];
    if (number === 0) {
      ctx.clearRect(0, 0, this.width, this.height);
    }
    if ((prev2 != null ? prev2.disposeOp : void 0) === APNG_DISPOSE_OP_BACKGROUND) {
      ctx.clearRect(prev2.xOffset, prev2.yOffset, prev2.width, prev2.height);
    } else if ((prev2 != null ? prev2.disposeOp : void 0) === APNG_DISPOSE_OP_PREVIOUS) {
      ctx.putImageData(prev2.imageData, prev2.xOffset, prev2.yOffset);
    }
    if (frame.blendOp === APNG_BLEND_OP_SOURCE) {
      ctx.clearRect(frame.xOffset, frame.yOffset, frame.width, frame.height);
    }
    return ctx.drawImage(frame.image, frame.xOffset, frame.yOffset);
  };
  PNG2.prototype.animate = function(ctx) {
    var _doFrame, frameNumber, frames, numFrames, numPlays, _ref, _this = this;
    frameNumber = 0;
    _ref = this.animation, numFrames = _ref.numFrames, frames = _ref.frames, numPlays = _ref.numPlays;
    return (_doFrame = function doFrame() {
      var f3, frame;
      f3 = frameNumber++ % numFrames;
      frame = frames[f3];
      _this.renderFrame(ctx, f3);
      if (numFrames > 1 && frameNumber / numFrames < numPlays) {
        return _this.animation._timeout = setTimeout(_doFrame, frame.delay);
      }
    })();
  };
  PNG2.prototype.stopAnimation = function() {
    var _ref;
    return clearTimeout((_ref = this.animation) != null ? _ref._timeout : void 0);
  };
  PNG2.prototype.render = function(canvas) {
    var ctx, data2;
    if (canvas._png) {
      canvas._png.stopAnimation();
    }
    canvas._png = this;
    canvas.width = this.width;
    canvas.height = this.height;
    ctx = canvas.getContext("2d");
    if (this.animation) {
      this.decodeFrames(ctx);
      return this.animate(ctx);
    } else {
      data2 = ctx.createImageData(this.width, this.height);
      this.copyToImageData(data2, this.decodePixels());
      return ctx.putImageData(data2, 0, 0);
    }
  };
  return PNG2;
}();
(function(jsPDFAPI2) {
  var canCompress = function canCompress2(value) {
    return value !== jsPDFAPI2.image_compression.NONE && hasCompressionJS();
  };
  var hasCompressionJS = function hasCompressionJS2() {
    return typeof zlibSync === "function";
  };
  var compressBytes = function compressBytes2(bytes, lineLength, colorsPerPixel, compression) {
    var level = 4;
    var filter_method = filterUp;
    switch (compression) {
      case jsPDFAPI2.image_compression.FAST:
        level = 1;
        filter_method = filterSub;
        break;
      case jsPDFAPI2.image_compression.MEDIUM:
        level = 6;
        filter_method = filterAverage;
        break;
      case jsPDFAPI2.image_compression.SLOW:
        level = 9;
        filter_method = filterPaeth;
        break;
    }
    bytes = applyPngFilterMethod(bytes, lineLength, colorsPerPixel, filter_method);
    var dat = zlibSync(bytes, {
      level
    });
    return jsPDFAPI2.__addimage__.arrayBufferToBinaryString(dat);
  };
  var applyPngFilterMethod = function applyPngFilterMethod2(bytes, lineLength, colorsPerPixel, filter_method) {
    var lines = bytes.length / lineLength, result = new Uint8Array(bytes.length + lines), filter_methods = getFilterMethods(), line, prevLine, offset;
    for (var i2 = 0; i2 < lines; i2 += 1) {
      offset = i2 * lineLength;
      line = bytes.subarray(offset, offset + lineLength);
      if (filter_method) {
        result.set(filter_method(line, colorsPerPixel, prevLine), offset + i2);
      } else {
        var len = filter_methods.length, results = [];
        for (var j; j < len; j += 1) {
          results[j] = filter_methods[j](line, colorsPerPixel, prevLine);
        }
        var ind = getIndexOfSmallestSum(results.concat());
        result.set(results[ind], offset + i2);
      }
      prevLine = line;
    }
    return result;
  };
  var filterNone = function filterNone2(line) {
    var result = Array.apply([], line);
    result.unshift(0);
    return result;
  };
  var filterSub = function filterSub2(line, colorsPerPixel) {
    var result = [], len = line.length, left;
    result[0] = 1;
    for (var i2 = 0; i2 < len; i2 += 1) {
      left = line[i2 - colorsPerPixel] || 0;
      result[i2 + 1] = line[i2] - left + 256 & 255;
    }
    return result;
  };
  var filterUp = function filterUp2(line, colorsPerPixel, prevLine) {
    var result = [], len = line.length, up;
    result[0] = 2;
    for (var i2 = 0; i2 < len; i2 += 1) {
      up = prevLine && prevLine[i2] || 0;
      result[i2 + 1] = line[i2] - up + 256 & 255;
    }
    return result;
  };
  var filterAverage = function filterAverage2(line, colorsPerPixel, prevLine) {
    var result = [], len = line.length, left, up;
    result[0] = 3;
    for (var i2 = 0; i2 < len; i2 += 1) {
      left = line[i2 - colorsPerPixel] || 0;
      up = prevLine && prevLine[i2] || 0;
      result[i2 + 1] = line[i2] + 256 - (left + up >>> 1) & 255;
    }
    return result;
  };
  var filterPaeth = function filterPaeth2(line, colorsPerPixel, prevLine) {
    var result = [], len = line.length, left, up, upLeft, paeth;
    result[0] = 4;
    for (var i2 = 0; i2 < len; i2 += 1) {
      left = line[i2 - colorsPerPixel] || 0;
      up = prevLine && prevLine[i2] || 0;
      upLeft = prevLine && prevLine[i2 - colorsPerPixel] || 0;
      paeth = paethPredictor(left, up, upLeft);
      result[i2 + 1] = line[i2] - paeth + 256 & 255;
    }
    return result;
  };
  var paethPredictor = function paethPredictor2(left, up, upLeft) {
    if (left === up && up === upLeft) {
      return left;
    }
    var pLeft = Math.abs(up - upLeft), pUp = Math.abs(left - upLeft), pUpLeft = Math.abs(left + up - upLeft - upLeft);
    return pLeft <= pUp && pLeft <= pUpLeft ? left : pUp <= pUpLeft ? up : upLeft;
  };
  var getFilterMethods = function getFilterMethods2() {
    return [filterNone, filterSub, filterUp, filterAverage, filterPaeth];
  };
  var getIndexOfSmallestSum = function getIndexOfSmallestSum2(arrays) {
    var sum = arrays.map(function(value) {
      return value.reduce(function(pv, cv) {
        return pv + Math.abs(cv);
      }, 0);
    });
    return sum.indexOf(Math.min.apply(null, sum));
  };
  var getPredictorFromCompression = function getPredictorFromCompression2(compression) {
    var predictor;
    switch (compression) {
      case jsPDFAPI2.image_compression.FAST:
        predictor = 11;
        break;
      case jsPDFAPI2.image_compression.MEDIUM:
        predictor = 13;
        break;
      case jsPDFAPI2.image_compression.SLOW:
        predictor = 14;
        break;
      default:
        predictor = 12;
        break;
    }
    return predictor;
  };
  jsPDFAPI2.processPNG = function(imageData, index3, alias, compression) {
    var colorSpace, filter2 = this.decode.FLATE_DECODE, bitsPerComponent, image, decodeParameters = "", trns, colors, pal, smask, pixels, len, alphaData, imgData, hasColors, pixel, i2, n2;
    if (this.__addimage__.isArrayBuffer(imageData))
      imageData = new Uint8Array(imageData);
    if (this.__addimage__.isArrayBufferView(imageData)) {
      image = new PNG(imageData);
      imageData = image.imgData;
      bitsPerComponent = image.bits;
      colorSpace = image.colorSpace;
      colors = image.colors;
      if ([4, 6].indexOf(image.colorType) !== -1) {
        if (image.bits === 8) {
          pixels = image.pixelBitlength == 32 ? new Uint32Array(image.decodePixels().buffer) : image.pixelBitlength == 16 ? new Uint16Array(image.decodePixels().buffer) : new Uint8Array(image.decodePixels().buffer);
          len = pixels.length;
          imgData = new Uint8Array(len * image.colors);
          alphaData = new Uint8Array(len);
          var pDiff = image.pixelBitlength - image.bits;
          i2 = 0;
          n2 = 0;
          var pbl;
          for (; i2 < len; i2++) {
            pixel = pixels[i2];
            pbl = 0;
            while (pbl < pDiff) {
              imgData[n2++] = pixel >>> pbl & 255;
              pbl = pbl + image.bits;
            }
            alphaData[i2] = pixel >>> pbl & 255;
          }
        }
        if (image.bits === 16) {
          pixels = new Uint32Array(image.decodePixels().buffer);
          len = pixels.length;
          imgData = new Uint8Array(len * (32 / image.pixelBitlength) * image.colors);
          alphaData = new Uint8Array(len * (32 / image.pixelBitlength));
          hasColors = image.colors > 1;
          i2 = 0;
          n2 = 0;
          var a2 = 0;
          while (i2 < len) {
            pixel = pixels[i2++];
            imgData[n2++] = pixel >>> 0 & 255;
            if (hasColors) {
              imgData[n2++] = pixel >>> 16 & 255;
              pixel = pixels[i2++];
              imgData[n2++] = pixel >>> 0 & 255;
            }
            alphaData[a2++] = pixel >>> 16 & 255;
          }
          bitsPerComponent = 8;
        }
        if (canCompress(compression)) {
          imageData = compressBytes(imgData, image.width * image.colors, image.colors, compression);
          smask = compressBytes(alphaData, image.width, 1, compression);
        } else {
          imageData = imgData;
          smask = alphaData;
          filter2 = void 0;
        }
      }
      if (image.colorType === 3) {
        colorSpace = this.color_spaces.INDEXED;
        pal = image.palette;
        if (image.transparency.indexed) {
          var trans = image.transparency.indexed;
          var total = 0;
          i2 = 0;
          len = trans.length;
          for (; i2 < len; ++i2) {
            total += trans[i2];
          }
          total = total / 255;
          if (total === len - 1 && trans.indexOf(0) !== -1) {
            trns = [trans.indexOf(0)];
          } else if (total !== len) {
            pixels = image.decodePixels();
            alphaData = new Uint8Array(pixels.length);
            i2 = 0;
            len = pixels.length;
            for (; i2 < len; i2++) {
              alphaData[i2] = trans[pixels[i2]];
            }
            smask = compressBytes(alphaData, image.width, 1);
          }
        }
      }
      var predictor = getPredictorFromCompression(compression);
      if (filter2 === this.decode.FLATE_DECODE) {
        decodeParameters = "/Predictor " + predictor + " ";
      }
      decodeParameters += "/Colors " + colors + " /BitsPerComponent " + bitsPerComponent + " /Columns " + image.width;
      if (this.__addimage__.isArrayBuffer(imageData) || this.__addimage__.isArrayBufferView(imageData)) {
        imageData = this.__addimage__.arrayBufferToBinaryString(imageData);
      }
      if (smask && this.__addimage__.isArrayBuffer(smask) || this.__addimage__.isArrayBufferView(smask)) {
        smask = this.__addimage__.arrayBufferToBinaryString(smask);
      }
      return {
        alias,
        data: imageData,
        index: index3,
        filter: filter2,
        decodeParameters,
        transparency: trns,
        palette: pal,
        sMask: smask,
        predictor,
        width: image.width,
        height: image.height,
        bitsPerComponent,
        colorSpace
      };
    }
  };
})(jsPDF.API);
function GifReader(buf) {
  var p2 = 0;
  if (buf[p2++] !== 71 || buf[p2++] !== 73 || buf[p2++] !== 70 || buf[p2++] !== 56 || (buf[p2++] + 1 & 253) !== 56 || buf[p2++] !== 97) {
    throw new Error("Invalid GIF 87a/89a header.");
  }
  var width2 = buf[p2++] | buf[p2++] << 8;
  var height2 = buf[p2++] | buf[p2++] << 8;
  var pf0 = buf[p2++];
  var global_palette_flag = pf0 >> 7;
  var num_global_colors_pow2 = pf0 & 7;
  var num_global_colors = 1 << num_global_colors_pow2 + 1;
  var background = buf[p2++];
  buf[p2++];
  var global_palette_offset = null;
  var global_palette_size = null;
  if (global_palette_flag) {
    global_palette_offset = p2;
    global_palette_size = num_global_colors;
    p2 += num_global_colors * 3;
  }
  var no_eof = true;
  var frames = [];
  var delay = 0;
  var transparent_index = null;
  var disposal = 0;
  var loop_count = null;
  this.width = width2;
  this.height = height2;
  while (no_eof && p2 < buf.length) {
    switch (buf[p2++]) {
      case 33:
        switch (buf[p2++]) {
          case 255:
            if (buf[p2] !== 11 || // 21 FF already read, check block size.
            // NETSCAPE2.0
            buf[p2 + 1] == 78 && buf[p2 + 2] == 69 && buf[p2 + 3] == 84 && buf[p2 + 4] == 83 && buf[p2 + 5] == 67 && buf[p2 + 6] == 65 && buf[p2 + 7] == 80 && buf[p2 + 8] == 69 && buf[p2 + 9] == 50 && buf[p2 + 10] == 46 && buf[p2 + 11] == 48 && // Sub-block
            buf[p2 + 12] == 3 && buf[p2 + 13] == 1 && buf[p2 + 16] == 0) {
              p2 += 14;
              loop_count = buf[p2++] | buf[p2++] << 8;
              p2++;
            } else {
              p2 += 12;
              while (true) {
                var block_size = buf[p2++];
                if (!(block_size >= 0))
                  throw Error("Invalid block size");
                if (block_size === 0)
                  break;
                p2 += block_size;
              }
            }
            break;
          case 249:
            if (buf[p2++] !== 4 || buf[p2 + 4] !== 0)
              throw new Error("Invalid graphics extension block.");
            var pf1 = buf[p2++];
            delay = buf[p2++] | buf[p2++] << 8;
            transparent_index = buf[p2++];
            if ((pf1 & 1) === 0)
              transparent_index = null;
            disposal = pf1 >> 2 & 7;
            p2++;
            break;
          case 254:
            while (true) {
              var block_size = buf[p2++];
              if (!(block_size >= 0))
                throw Error("Invalid block size");
              if (block_size === 0)
                break;
              p2 += block_size;
            }
            break;
          default:
            throw new Error("Unknown graphic control label: 0x" + buf[p2 - 1].toString(16));
        }
        break;
      case 44:
        var x2 = buf[p2++] | buf[p2++] << 8;
        var y3 = buf[p2++] | buf[p2++] << 8;
        var w = buf[p2++] | buf[p2++] << 8;
        var h2 = buf[p2++] | buf[p2++] << 8;
        var pf2 = buf[p2++];
        var local_palette_flag = pf2 >> 7;
        var interlace_flag = pf2 >> 6 & 1;
        var num_local_colors_pow2 = pf2 & 7;
        var num_local_colors = 1 << num_local_colors_pow2 + 1;
        var palette_offset = global_palette_offset;
        var palette_size = global_palette_size;
        var has_local_palette = false;
        if (local_palette_flag) {
          var has_local_palette = true;
          palette_offset = p2;
          palette_size = num_local_colors;
          p2 += num_local_colors * 3;
        }
        var data_offset = p2;
        p2++;
        while (true) {
          var block_size = buf[p2++];
          if (!(block_size >= 0))
            throw Error("Invalid block size");
          if (block_size === 0)
            break;
          p2 += block_size;
        }
        frames.push({
          x: x2,
          y: y3,
          width: w,
          height: h2,
          has_local_palette,
          palette_offset,
          palette_size,
          data_offset,
          data_length: p2 - data_offset,
          transparent_index,
          interlaced: !!interlace_flag,
          delay,
          disposal
        });
        break;
      case 59:
        no_eof = false;
        break;
      default:
        throw new Error("Unknown gif block: 0x" + buf[p2 - 1].toString(16));
    }
  }
  this.numFrames = function() {
    return frames.length;
  };
  this.loopCount = function() {
    return loop_count;
  };
  this.frameInfo = function(frame_num) {
    if (frame_num < 0 || frame_num >= frames.length)
      throw new Error("Frame index out of range.");
    return frames[frame_num];
  };
  this.decodeAndBlitFrameBGRA = function(frame_num, pixels) {
    var frame = this.frameInfo(frame_num);
    var num_pixels = frame.width * frame.height;
    var index_stream = new Uint8Array(num_pixels);
    GifReaderLZWOutputIndexStream(buf, frame.data_offset, index_stream, num_pixels);
    var palette_offset2 = frame.palette_offset;
    var trans = frame.transparent_index;
    if (trans === null)
      trans = 256;
    var framewidth = frame.width;
    var framestride = width2 - framewidth;
    var xleft = framewidth;
    var opbeg = (frame.y * width2 + frame.x) * 4;
    var opend = ((frame.y + frame.height) * width2 + frame.x) * 4;
    var op2 = opbeg;
    var scanstride = framestride * 4;
    if (frame.interlaced === true) {
      scanstride += width2 * 4 * 7;
    }
    var interlaceskip = 8;
    for (var i2 = 0, il = index_stream.length; i2 < il; ++i2) {
      var index3 = index_stream[i2];
      if (xleft === 0) {
        op2 += scanstride;
        xleft = framewidth;
        if (op2 >= opend) {
          scanstride = framestride * 4 + width2 * 4 * (interlaceskip - 1);
          op2 = opbeg + (framewidth + framestride) * (interlaceskip << 1);
          interlaceskip >>= 1;
        }
      }
      if (index3 === trans) {
        op2 += 4;
      } else {
        var r2 = buf[palette_offset2 + index3 * 3];
        var g = buf[palette_offset2 + index3 * 3 + 1];
        var b = buf[palette_offset2 + index3 * 3 + 2];
        pixels[op2++] = b;
        pixels[op2++] = g;
        pixels[op2++] = r2;
        pixels[op2++] = 255;
      }
      --xleft;
    }
  };
  this.decodeAndBlitFrameRGBA = function(frame_num, pixels) {
    var frame = this.frameInfo(frame_num);
    var num_pixels = frame.width * frame.height;
    var index_stream = new Uint8Array(num_pixels);
    GifReaderLZWOutputIndexStream(buf, frame.data_offset, index_stream, num_pixels);
    var palette_offset2 = frame.palette_offset;
    var trans = frame.transparent_index;
    if (trans === null)
      trans = 256;
    var framewidth = frame.width;
    var framestride = width2 - framewidth;
    var xleft = framewidth;
    var opbeg = (frame.y * width2 + frame.x) * 4;
    var opend = ((frame.y + frame.height) * width2 + frame.x) * 4;
    var op2 = opbeg;
    var scanstride = framestride * 4;
    if (frame.interlaced === true) {
      scanstride += width2 * 4 * 7;
    }
    var interlaceskip = 8;
    for (var i2 = 0, il = index_stream.length; i2 < il; ++i2) {
      var index3 = index_stream[i2];
      if (xleft === 0) {
        op2 += scanstride;
        xleft = framewidth;
        if (op2 >= opend) {
          scanstride = framestride * 4 + width2 * 4 * (interlaceskip - 1);
          op2 = opbeg + (framewidth + framestride) * (interlaceskip << 1);
          interlaceskip >>= 1;
        }
      }
      if (index3 === trans) {
        op2 += 4;
      } else {
        var r2 = buf[palette_offset2 + index3 * 3];
        var g = buf[palette_offset2 + index3 * 3 + 1];
        var b = buf[palette_offset2 + index3 * 3 + 2];
        pixels[op2++] = r2;
        pixels[op2++] = g;
        pixels[op2++] = b;
        pixels[op2++] = 255;
      }
      --xleft;
    }
  };
}
function GifReaderLZWOutputIndexStream(code_stream, p2, output, output_length) {
  var min_code_size = code_stream[p2++];
  var clear_code = 1 << min_code_size;
  var eoi_code = clear_code + 1;
  var next_code = eoi_code + 1;
  var cur_code_size = min_code_size + 1;
  var code_mask = (1 << cur_code_size) - 1;
  var cur_shift = 0;
  var cur = 0;
  var op2 = 0;
  var subblock_size = code_stream[p2++];
  var code_table = new Int32Array(4096);
  var prev_code = null;
  while (true) {
    while (cur_shift < 16) {
      if (subblock_size === 0)
        break;
      cur |= code_stream[p2++] << cur_shift;
      cur_shift += 8;
      if (subblock_size === 1) {
        subblock_size = code_stream[p2++];
      } else {
        --subblock_size;
      }
    }
    if (cur_shift < cur_code_size)
      break;
    var code = cur & code_mask;
    cur >>= cur_code_size;
    cur_shift -= cur_code_size;
    if (code === clear_code) {
      next_code = eoi_code + 1;
      cur_code_size = min_code_size + 1;
      code_mask = (1 << cur_code_size) - 1;
      prev_code = null;
      continue;
    } else if (code === eoi_code) {
      break;
    }
    var chase_code = code < next_code ? code : prev_code;
    var chase_length = 0;
    var chase = chase_code;
    while (chase > clear_code) {
      chase = code_table[chase] >> 8;
      ++chase_length;
    }
    var k = chase;
    var op_end = op2 + chase_length + (chase_code !== code ? 1 : 0);
    if (op_end > output_length) {
      console2.log("Warning, gif stream longer than expected.");
      return;
    }
    output[op2++] = k;
    op2 += chase_length;
    var b = op2;
    if (chase_code !== code)
      output[op2++] = k;
    chase = chase_code;
    while (chase_length--) {
      chase = code_table[chase];
      output[--b] = chase & 255;
      chase >>= 8;
    }
    if (prev_code !== null && next_code < 4096) {
      code_table[next_code++] = prev_code << 8 | k;
      if (next_code >= code_mask + 1 && cur_code_size < 12) {
        ++cur_code_size;
        code_mask = code_mask << 1 | 1;
      }
    }
    prev_code = code;
  }
  if (op2 !== output_length) {
    console2.log("Warning, gif stream shorter than expected.");
  }
  return output;
}
function JPEGEncoder(quality) {
  var ffloor = Math.floor;
  var YTable = new Array(64);
  var UVTable = new Array(64);
  var fdtbl_Y = new Array(64);
  var fdtbl_UV = new Array(64);
  var YDC_HT;
  var UVDC_HT;
  var YAC_HT;
  var UVAC_HT;
  var bitcode = new Array(65535);
  var category = new Array(65535);
  var outputfDCTQuant = new Array(64);
  var DU = new Array(64);
  var byteout = [];
  var bytenew = 0;
  var bytepos = 7;
  var YDU = new Array(64);
  var UDU = new Array(64);
  var VDU = new Array(64);
  var clt = new Array(256);
  var RGB_YUV_TABLE = new Array(2048);
  var currentQuality;
  var ZigZag = [0, 1, 5, 6, 14, 15, 27, 28, 2, 4, 7, 13, 16, 26, 29, 42, 3, 8, 12, 17, 25, 30, 41, 43, 9, 11, 18, 24, 31, 40, 44, 53, 10, 19, 23, 32, 39, 45, 52, 54, 20, 22, 33, 38, 46, 51, 55, 60, 21, 34, 37, 47, 50, 56, 59, 61, 35, 36, 48, 49, 57, 58, 62, 63];
  var std_dc_luminance_nrcodes = [0, 0, 1, 5, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0];
  var std_dc_luminance_values = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11];
  var std_ac_luminance_nrcodes = [0, 0, 2, 1, 3, 3, 2, 4, 3, 5, 5, 4, 4, 0, 0, 1, 125];
  var std_ac_luminance_values = [1, 2, 3, 0, 4, 17, 5, 18, 33, 49, 65, 6, 19, 81, 97, 7, 34, 113, 20, 50, 129, 145, 161, 8, 35, 66, 177, 193, 21, 82, 209, 240, 36, 51, 98, 114, 130, 9, 10, 22, 23, 24, 25, 26, 37, 38, 39, 40, 41, 42, 52, 53, 54, 55, 56, 57, 58, 67, 68, 69, 70, 71, 72, 73, 74, 83, 84, 85, 86, 87, 88, 89, 90, 99, 100, 101, 102, 103, 104, 105, 106, 115, 116, 117, 118, 119, 120, 121, 122, 131, 132, 133, 134, 135, 136, 137, 138, 146, 147, 148, 149, 150, 151, 152, 153, 154, 162, 163, 164, 165, 166, 167, 168, 169, 170, 178, 179, 180, 181, 182, 183, 184, 185, 186, 194, 195, 196, 197, 198, 199, 200, 201, 202, 210, 211, 212, 213, 214, 215, 216, 217, 218, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250];
  var std_dc_chrominance_nrcodes = [0, 0, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0];
  var std_dc_chrominance_values = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11];
  var std_ac_chrominance_nrcodes = [0, 0, 2, 1, 2, 4, 4, 3, 4, 7, 5, 4, 4, 0, 1, 2, 119];
  var std_ac_chrominance_values = [0, 1, 2, 3, 17, 4, 5, 33, 49, 6, 18, 65, 81, 7, 97, 113, 19, 34, 50, 129, 8, 20, 66, 145, 161, 177, 193, 9, 35, 51, 82, 240, 21, 98, 114, 209, 10, 22, 36, 52, 225, 37, 241, 23, 24, 25, 26, 38, 39, 40, 41, 42, 53, 54, 55, 56, 57, 58, 67, 68, 69, 70, 71, 72, 73, 74, 83, 84, 85, 86, 87, 88, 89, 90, 99, 100, 101, 102, 103, 104, 105, 106, 115, 116, 117, 118, 119, 120, 121, 122, 130, 131, 132, 133, 134, 135, 136, 137, 138, 146, 147, 148, 149, 150, 151, 152, 153, 154, 162, 163, 164, 165, 166, 167, 168, 169, 170, 178, 179, 180, 181, 182, 183, 184, 185, 186, 194, 195, 196, 197, 198, 199, 200, 201, 202, 210, 211, 212, 213, 214, 215, 216, 217, 218, 226, 227, 228, 229, 230, 231, 232, 233, 234, 242, 243, 244, 245, 246, 247, 248, 249, 250];
  function initQuantTables(sf) {
    var YQT = [16, 11, 10, 16, 24, 40, 51, 61, 12, 12, 14, 19, 26, 58, 60, 55, 14, 13, 16, 24, 40, 57, 69, 56, 14, 17, 22, 29, 51, 87, 80, 62, 18, 22, 37, 56, 68, 109, 103, 77, 24, 35, 55, 64, 81, 104, 113, 92, 49, 64, 78, 87, 103, 121, 120, 101, 72, 92, 95, 98, 112, 100, 103, 99];
    for (var i2 = 0; i2 < 64; i2++) {
      var t2 = ffloor((YQT[i2] * sf + 50) / 100);
      t2 = Math.min(Math.max(t2, 1), 255);
      YTable[ZigZag[i2]] = t2;
    }
    var UVQT = [17, 18, 24, 47, 99, 99, 99, 99, 18, 21, 26, 66, 99, 99, 99, 99, 24, 26, 56, 99, 99, 99, 99, 99, 47, 66, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99];
    for (var j = 0; j < 64; j++) {
      var u2 = ffloor((UVQT[j] * sf + 50) / 100);
      u2 = Math.min(Math.max(u2, 1), 255);
      UVTable[ZigZag[j]] = u2;
    }
    var aasf = [1, 1.387039845, 1.306562965, 1.175875602, 1, 0.785694958, 0.5411961, 0.275899379];
    var k = 0;
    for (var row = 0; row < 8; row++) {
      for (var col = 0; col < 8; col++) {
        fdtbl_Y[k] = 1 / (YTable[ZigZag[k]] * aasf[row] * aasf[col] * 8);
        fdtbl_UV[k] = 1 / (UVTable[ZigZag[k]] * aasf[row] * aasf[col] * 8);
        k++;
      }
    }
  }
  function computeHuffmanTbl(nrcodes, std_table) {
    var codevalue = 0;
    var pos_in_table = 0;
    var HT = new Array();
    for (var k = 1; k <= 16; k++) {
      for (var j = 1; j <= nrcodes[k]; j++) {
        HT[std_table[pos_in_table]] = [];
        HT[std_table[pos_in_table]][0] = codevalue;
        HT[std_table[pos_in_table]][1] = k;
        pos_in_table++;
        codevalue++;
      }
      codevalue *= 2;
    }
    return HT;
  }
  function initHuffmanTbl() {
    YDC_HT = computeHuffmanTbl(std_dc_luminance_nrcodes, std_dc_luminance_values);
    UVDC_HT = computeHuffmanTbl(std_dc_chrominance_nrcodes, std_dc_chrominance_values);
    YAC_HT = computeHuffmanTbl(std_ac_luminance_nrcodes, std_ac_luminance_values);
    UVAC_HT = computeHuffmanTbl(std_ac_chrominance_nrcodes, std_ac_chrominance_values);
  }
  function initCategoryNumber() {
    var nrlower = 1;
    var nrupper = 2;
    for (var cat = 1; cat <= 15; cat++) {
      for (var nr = nrlower; nr < nrupper; nr++) {
        category[32767 + nr] = cat;
        bitcode[32767 + nr] = [];
        bitcode[32767 + nr][1] = cat;
        bitcode[32767 + nr][0] = nr;
      }
      for (var nrneg = -(nrupper - 1); nrneg <= -nrlower; nrneg++) {
        category[32767 + nrneg] = cat;
        bitcode[32767 + nrneg] = [];
        bitcode[32767 + nrneg][1] = cat;
        bitcode[32767 + nrneg][0] = nrupper - 1 + nrneg;
      }
      nrlower <<= 1;
      nrupper <<= 1;
    }
  }
  function initRGBYUVTable() {
    for (var i2 = 0; i2 < 256; i2++) {
      RGB_YUV_TABLE[i2] = 19595 * i2;
      RGB_YUV_TABLE[i2 + 256 >> 0] = 38470 * i2;
      RGB_YUV_TABLE[i2 + 512 >> 0] = 7471 * i2 + 32768;
      RGB_YUV_TABLE[i2 + 768 >> 0] = -11059 * i2;
      RGB_YUV_TABLE[i2 + 1024 >> 0] = -21709 * i2;
      RGB_YUV_TABLE[i2 + 1280 >> 0] = 32768 * i2 + 8421375;
      RGB_YUV_TABLE[i2 + 1536 >> 0] = -27439 * i2;
      RGB_YUV_TABLE[i2 + 1792 >> 0] = -5329 * i2;
    }
  }
  function writeBits(bs) {
    var value = bs[0];
    var posval = bs[1] - 1;
    while (posval >= 0) {
      if (value & 1 << posval) {
        bytenew |= 1 << bytepos;
      }
      posval--;
      bytepos--;
      if (bytepos < 0) {
        if (bytenew == 255) {
          writeByte(255);
          writeByte(0);
        } else {
          writeByte(bytenew);
        }
        bytepos = 7;
        bytenew = 0;
      }
    }
  }
  function writeByte(value) {
    byteout.push(value);
  }
  function writeWord(value) {
    writeByte(value >> 8 & 255);
    writeByte(value & 255);
  }
  function fDCTQuant(data2, fdtbl) {
    var d0, d1, d2, d3, d4, d5, d6, d7;
    var dataOff = 0;
    var i2;
    var I8 = 8;
    var I64 = 64;
    for (i2 = 0; i2 < I8; ++i2) {
      d0 = data2[dataOff];
      d1 = data2[dataOff + 1];
      d2 = data2[dataOff + 2];
      d3 = data2[dataOff + 3];
      d4 = data2[dataOff + 4];
      d5 = data2[dataOff + 5];
      d6 = data2[dataOff + 6];
      d7 = data2[dataOff + 7];
      var tmp0 = d0 + d7;
      var tmp7 = d0 - d7;
      var tmp1 = d1 + d6;
      var tmp6 = d1 - d6;
      var tmp2 = d2 + d5;
      var tmp5 = d2 - d5;
      var tmp3 = d3 + d4;
      var tmp4 = d3 - d4;
      var tmp10 = tmp0 + tmp3;
      var tmp13 = tmp0 - tmp3;
      var tmp11 = tmp1 + tmp2;
      var tmp12 = tmp1 - tmp2;
      data2[dataOff] = tmp10 + tmp11;
      data2[dataOff + 4] = tmp10 - tmp11;
      var z1 = (tmp12 + tmp13) * 0.707106781;
      data2[dataOff + 2] = tmp13 + z1;
      data2[dataOff + 6] = tmp13 - z1;
      tmp10 = tmp4 + tmp5;
      tmp11 = tmp5 + tmp6;
      tmp12 = tmp6 + tmp7;
      var z5 = (tmp10 - tmp12) * 0.382683433;
      var z2 = 0.5411961 * tmp10 + z5;
      var z4 = 1.306562965 * tmp12 + z5;
      var z3 = tmp11 * 0.707106781;
      var z11 = tmp7 + z3;
      var z13 = tmp7 - z3;
      data2[dataOff + 5] = z13 + z2;
      data2[dataOff + 3] = z13 - z2;
      data2[dataOff + 1] = z11 + z4;
      data2[dataOff + 7] = z11 - z4;
      dataOff += 8;
    }
    dataOff = 0;
    for (i2 = 0; i2 < I8; ++i2) {
      d0 = data2[dataOff];
      d1 = data2[dataOff + 8];
      d2 = data2[dataOff + 16];
      d3 = data2[dataOff + 24];
      d4 = data2[dataOff + 32];
      d5 = data2[dataOff + 40];
      d6 = data2[dataOff + 48];
      d7 = data2[dataOff + 56];
      var tmp0p2 = d0 + d7;
      var tmp7p2 = d0 - d7;
      var tmp1p2 = d1 + d6;
      var tmp6p2 = d1 - d6;
      var tmp2p2 = d2 + d5;
      var tmp5p2 = d2 - d5;
      var tmp3p2 = d3 + d4;
      var tmp4p2 = d3 - d4;
      var tmp10p2 = tmp0p2 + tmp3p2;
      var tmp13p2 = tmp0p2 - tmp3p2;
      var tmp11p2 = tmp1p2 + tmp2p2;
      var tmp12p2 = tmp1p2 - tmp2p2;
      data2[dataOff] = tmp10p2 + tmp11p2;
      data2[dataOff + 32] = tmp10p2 - tmp11p2;
      var z1p2 = (tmp12p2 + tmp13p2) * 0.707106781;
      data2[dataOff + 16] = tmp13p2 + z1p2;
      data2[dataOff + 48] = tmp13p2 - z1p2;
      tmp10p2 = tmp4p2 + tmp5p2;
      tmp11p2 = tmp5p2 + tmp6p2;
      tmp12p2 = tmp6p2 + tmp7p2;
      var z5p2 = (tmp10p2 - tmp12p2) * 0.382683433;
      var z2p2 = 0.5411961 * tmp10p2 + z5p2;
      var z4p2 = 1.306562965 * tmp12p2 + z5p2;
      var z3p2 = tmp11p2 * 0.707106781;
      var z11p2 = tmp7p2 + z3p2;
      var z13p2 = tmp7p2 - z3p2;
      data2[dataOff + 40] = z13p2 + z2p2;
      data2[dataOff + 24] = z13p2 - z2p2;
      data2[dataOff + 8] = z11p2 + z4p2;
      data2[dataOff + 56] = z11p2 - z4p2;
      dataOff++;
    }
    var fDCTQuant2;
    for (i2 = 0; i2 < I64; ++i2) {
      fDCTQuant2 = data2[i2] * fdtbl[i2];
      outputfDCTQuant[i2] = fDCTQuant2 > 0 ? fDCTQuant2 + 0.5 | 0 : fDCTQuant2 - 0.5 | 0;
    }
    return outputfDCTQuant;
  }
  function writeAPP0() {
    writeWord(65504);
    writeWord(16);
    writeByte(74);
    writeByte(70);
    writeByte(73);
    writeByte(70);
    writeByte(0);
    writeByte(1);
    writeByte(1);
    writeByte(0);
    writeWord(1);
    writeWord(1);
    writeByte(0);
    writeByte(0);
  }
  function writeSOF0(width2, height2) {
    writeWord(65472);
    writeWord(17);
    writeByte(8);
    writeWord(height2);
    writeWord(width2);
    writeByte(3);
    writeByte(1);
    writeByte(17);
    writeByte(0);
    writeByte(2);
    writeByte(17);
    writeByte(1);
    writeByte(3);
    writeByte(17);
    writeByte(1);
  }
  function writeDQT() {
    writeWord(65499);
    writeWord(132);
    writeByte(0);
    for (var i2 = 0; i2 < 64; i2++) {
      writeByte(YTable[i2]);
    }
    writeByte(1);
    for (var j = 0; j < 64; j++) {
      writeByte(UVTable[j]);
    }
  }
  function writeDHT() {
    writeWord(65476);
    writeWord(418);
    writeByte(0);
    for (var i2 = 0; i2 < 16; i2++) {
      writeByte(std_dc_luminance_nrcodes[i2 + 1]);
    }
    for (var j = 0; j <= 11; j++) {
      writeByte(std_dc_luminance_values[j]);
    }
    writeByte(16);
    for (var k = 0; k < 16; k++) {
      writeByte(std_ac_luminance_nrcodes[k + 1]);
    }
    for (var l2 = 0; l2 <= 161; l2++) {
      writeByte(std_ac_luminance_values[l2]);
    }
    writeByte(1);
    for (var m3 = 0; m3 < 16; m3++) {
      writeByte(std_dc_chrominance_nrcodes[m3 + 1]);
    }
    for (var n2 = 0; n2 <= 11; n2++) {
      writeByte(std_dc_chrominance_values[n2]);
    }
    writeByte(17);
    for (var o2 = 0; o2 < 16; o2++) {
      writeByte(std_ac_chrominance_nrcodes[o2 + 1]);
    }
    for (var p2 = 0; p2 <= 161; p2++) {
      writeByte(std_ac_chrominance_values[p2]);
    }
  }
  function writeSOS() {
    writeWord(65498);
    writeWord(12);
    writeByte(3);
    writeByte(1);
    writeByte(0);
    writeByte(2);
    writeByte(17);
    writeByte(3);
    writeByte(17);
    writeByte(0);
    writeByte(63);
    writeByte(0);
  }
  function processDU(CDU, fdtbl, DC, HTDC, HTAC) {
    var EOB = HTAC[0];
    var M16zeroes = HTAC[240];
    var pos;
    var I16 = 16;
    var I63 = 63;
    var I64 = 64;
    var DU_DCT = fDCTQuant(CDU, fdtbl);
    for (var j = 0; j < I64; ++j) {
      DU[ZigZag[j]] = DU_DCT[j];
    }
    var Diff = DU[0] - DC;
    DC = DU[0];
    if (Diff == 0) {
      writeBits(HTDC[0]);
    } else {
      pos = 32767 + Diff;
      writeBits(HTDC[category[pos]]);
      writeBits(bitcode[pos]);
    }
    var end0pos = 63;
    while (end0pos > 0 && DU[end0pos] == 0) {
      end0pos--;
    }
    if (end0pos == 0) {
      writeBits(EOB);
      return DC;
    }
    var i2 = 1;
    var lng;
    while (i2 <= end0pos) {
      var startpos = i2;
      while (DU[i2] == 0 && i2 <= end0pos) {
        ++i2;
      }
      var nrzeroes = i2 - startpos;
      if (nrzeroes >= I16) {
        lng = nrzeroes >> 4;
        for (var nrmarker = 1; nrmarker <= lng; ++nrmarker) {
          writeBits(M16zeroes);
        }
        nrzeroes = nrzeroes & 15;
      }
      pos = 32767 + DU[i2];
      writeBits(HTAC[(nrzeroes << 4) + category[pos]]);
      writeBits(bitcode[pos]);
      i2++;
    }
    if (end0pos != I63) {
      writeBits(EOB);
    }
    return DC;
  }
  function initCharLookupTable() {
    var sfcc = String.fromCharCode;
    for (var i2 = 0; i2 < 256; i2++) {
      clt[i2] = sfcc(i2);
    }
  }
  this.encode = function(image, quality2) {
    if (quality2)
      setQuality(quality2);
    byteout = new Array();
    bytenew = 0;
    bytepos = 7;
    writeWord(65496);
    writeAPP0();
    writeDQT();
    writeSOF0(image.width, image.height);
    writeDHT();
    writeSOS();
    var DCY = 0;
    var DCU = 0;
    var DCV = 0;
    bytenew = 0;
    bytepos = 7;
    this.encode.displayName = "_encode_";
    var imageData = image.data;
    var width2 = image.width;
    var height2 = image.height;
    var quadWidth = width2 * 4;
    var x2, y3 = 0;
    var r2, g, b;
    var start, p2, col, row, pos;
    while (y3 < height2) {
      x2 = 0;
      while (x2 < quadWidth) {
        start = quadWidth * y3 + x2;
        col = -1;
        row = 0;
        for (pos = 0; pos < 64; pos++) {
          row = pos >> 3;
          col = (pos & 7) * 4;
          p2 = start + row * quadWidth + col;
          if (y3 + row >= height2) {
            p2 -= quadWidth * (y3 + 1 + row - height2);
          }
          if (x2 + col >= quadWidth) {
            p2 -= x2 + col - quadWidth + 4;
          }
          r2 = imageData[p2++];
          g = imageData[p2++];
          b = imageData[p2++];
          YDU[pos] = (RGB_YUV_TABLE[r2] + RGB_YUV_TABLE[g + 256 >> 0] + RGB_YUV_TABLE[b + 512 >> 0] >> 16) - 128;
          UDU[pos] = (RGB_YUV_TABLE[r2 + 768 >> 0] + RGB_YUV_TABLE[g + 1024 >> 0] + RGB_YUV_TABLE[b + 1280 >> 0] >> 16) - 128;
          VDU[pos] = (RGB_YUV_TABLE[r2 + 1280 >> 0] + RGB_YUV_TABLE[g + 1536 >> 0] + RGB_YUV_TABLE[b + 1792 >> 0] >> 16) - 128;
        }
        DCY = processDU(YDU, fdtbl_Y, DCY, YDC_HT, YAC_HT);
        DCU = processDU(UDU, fdtbl_UV, DCU, UVDC_HT, UVAC_HT);
        DCV = processDU(VDU, fdtbl_UV, DCV, UVDC_HT, UVAC_HT);
        x2 += 32;
      }
      y3 += 8;
    }
    if (bytepos >= 0) {
      var fillbits = [];
      fillbits[1] = bytepos + 1;
      fillbits[0] = (1 << bytepos + 1) - 1;
      writeBits(fillbits);
    }
    writeWord(65497);
    return new Uint8Array(byteout);
  };
  function setQuality(quality2) {
    quality2 = Math.min(Math.max(quality2, 1), 100);
    if (currentQuality == quality2)
      return;
    var sf = quality2 < 50 ? Math.floor(5e3 / quality2) : Math.floor(200 - quality2 * 2);
    initQuantTables(sf);
    currentQuality = quality2;
  }
  function init() {
    quality = quality || 50;
    initCharLookupTable();
    initHuffmanTbl();
    initCategoryNumber();
    initRGBYUVTable();
    setQuality(quality);
  }
  init();
}
(function(jsPDFAPI2) {
  jsPDFAPI2.processGIF89A = function(imageData, index3, alias, compression) {
    var reader = new GifReader(imageData);
    var width2 = reader.width, height2 = reader.height;
    var qu = 100;
    var pixels = [];
    reader.decodeAndBlitFrameRGBA(0, pixels);
    var rawImageData = {
      data: pixels,
      width: width2,
      height: height2
    };
    var encoder = new JPEGEncoder(qu);
    var data2 = encoder.encode(rawImageData, qu);
    return jsPDFAPI2.processJPEG.call(this, data2, index3, alias, compression);
  };
  jsPDFAPI2.processGIF87A = jsPDFAPI2.processGIF89A;
})(jsPDF.API);
function BmpDecoder(buffer, is_with_alpha) {
  this.pos = 0;
  this.buffer = buffer;
  this.datav = new DataView(buffer.buffer);
  this.is_with_alpha = !!is_with_alpha;
  this.bottom_up = true;
  this.flag = String.fromCharCode(this.buffer[0]) + String.fromCharCode(this.buffer[1]);
  this.pos += 2;
  if (["BM", "BA", "CI", "CP", "IC", "PT"].indexOf(this.flag) === -1)
    throw new Error("Invalid BMP File");
  this.parseHeader();
  this.parseBGR();
}
BmpDecoder.prototype.parseHeader = function() {
  this.fileSize = this.datav.getUint32(this.pos, true);
  this.pos += 4;
  this.reserved = this.datav.getUint32(this.pos, true);
  this.pos += 4;
  this.offset = this.datav.getUint32(this.pos, true);
  this.pos += 4;
  this.headerSize = this.datav.getUint32(this.pos, true);
  this.pos += 4;
  this.width = this.datav.getUint32(this.pos, true);
  this.pos += 4;
  this.height = this.datav.getInt32(this.pos, true);
  this.pos += 4;
  this.planes = this.datav.getUint16(this.pos, true);
  this.pos += 2;
  this.bitPP = this.datav.getUint16(this.pos, true);
  this.pos += 2;
  this.compress = this.datav.getUint32(this.pos, true);
  this.pos += 4;
  this.rawSize = this.datav.getUint32(this.pos, true);
  this.pos += 4;
  this.hr = this.datav.getUint32(this.pos, true);
  this.pos += 4;
  this.vr = this.datav.getUint32(this.pos, true);
  this.pos += 4;
  this.colors = this.datav.getUint32(this.pos, true);
  this.pos += 4;
  this.importantColors = this.datav.getUint32(this.pos, true);
  this.pos += 4;
  if (this.bitPP === 16 && this.is_with_alpha) {
    this.bitPP = 15;
  }
  if (this.bitPP < 15) {
    var len = this.colors === 0 ? 1 << this.bitPP : this.colors;
    this.palette = new Array(len);
    for (var i2 = 0; i2 < len; i2++) {
      var blue = this.datav.getUint8(this.pos++, true);
      var green = this.datav.getUint8(this.pos++, true);
      var red = this.datav.getUint8(this.pos++, true);
      var quad = this.datav.getUint8(this.pos++, true);
      this.palette[i2] = {
        red,
        green,
        blue,
        quad
      };
    }
  }
  if (this.height < 0) {
    this.height *= -1;
    this.bottom_up = false;
  }
};
BmpDecoder.prototype.parseBGR = function() {
  this.pos = this.offset;
  try {
    var bitn = "bit" + this.bitPP;
    var len = this.width * this.height * 4;
    this.data = new Uint8Array(len);
    this[bitn]();
  } catch (e2) {
    console2.log("bit decode error:" + e2);
  }
};
BmpDecoder.prototype.bit1 = function() {
  var xlen = Math.ceil(this.width / 8);
  var mode = xlen % 4;
  var y3;
  for (y3 = this.height - 1; y3 >= 0; y3--) {
    var line = this.bottom_up ? y3 : this.height - 1 - y3;
    for (var x2 = 0; x2 < xlen; x2++) {
      var b = this.datav.getUint8(this.pos++, true);
      var location2 = line * this.width * 4 + x2 * 8 * 4;
      for (var i2 = 0; i2 < 8; i2++) {
        if (x2 * 8 + i2 < this.width) {
          var rgb2 = this.palette[b >> 7 - i2 & 1];
          this.data[location2 + i2 * 4] = rgb2.blue;
          this.data[location2 + i2 * 4 + 1] = rgb2.green;
          this.data[location2 + i2 * 4 + 2] = rgb2.red;
          this.data[location2 + i2 * 4 + 3] = 255;
        } else {
          break;
        }
      }
    }
    if (mode !== 0) {
      this.pos += 4 - mode;
    }
  }
};
BmpDecoder.prototype.bit4 = function() {
  var xlen = Math.ceil(this.width / 2);
  var mode = xlen % 4;
  for (var y3 = this.height - 1; y3 >= 0; y3--) {
    var line = this.bottom_up ? y3 : this.height - 1 - y3;
    for (var x2 = 0; x2 < xlen; x2++) {
      var b = this.datav.getUint8(this.pos++, true);
      var location2 = line * this.width * 4 + x2 * 2 * 4;
      var before2 = b >> 4;
      var after2 = b & 15;
      var rgb2 = this.palette[before2];
      this.data[location2] = rgb2.blue;
      this.data[location2 + 1] = rgb2.green;
      this.data[location2 + 2] = rgb2.red;
      this.data[location2 + 3] = 255;
      if (x2 * 2 + 1 >= this.width)
        break;
      rgb2 = this.palette[after2];
      this.data[location2 + 4] = rgb2.blue;
      this.data[location2 + 4 + 1] = rgb2.green;
      this.data[location2 + 4 + 2] = rgb2.red;
      this.data[location2 + 4 + 3] = 255;
    }
    if (mode !== 0) {
      this.pos += 4 - mode;
    }
  }
};
BmpDecoder.prototype.bit8 = function() {
  var mode = this.width % 4;
  for (var y3 = this.height - 1; y3 >= 0; y3--) {
    var line = this.bottom_up ? y3 : this.height - 1 - y3;
    for (var x2 = 0; x2 < this.width; x2++) {
      var b = this.datav.getUint8(this.pos++, true);
      var location2 = line * this.width * 4 + x2 * 4;
      if (b < this.palette.length) {
        var rgb2 = this.palette[b];
        this.data[location2] = rgb2.red;
        this.data[location2 + 1] = rgb2.green;
        this.data[location2 + 2] = rgb2.blue;
        this.data[location2 + 3] = 255;
      } else {
        this.data[location2] = 255;
        this.data[location2 + 1] = 255;
        this.data[location2 + 2] = 255;
        this.data[location2 + 3] = 255;
      }
    }
    if (mode !== 0) {
      this.pos += 4 - mode;
    }
  }
};
BmpDecoder.prototype.bit15 = function() {
  var dif_w = this.width % 3;
  var _11111 = parseInt("11111", 2), _1_5 = _11111;
  for (var y3 = this.height - 1; y3 >= 0; y3--) {
    var line = this.bottom_up ? y3 : this.height - 1 - y3;
    for (var x2 = 0; x2 < this.width; x2++) {
      var B = this.datav.getUint16(this.pos, true);
      this.pos += 2;
      var blue = (B & _1_5) / _1_5 * 255 | 0;
      var green = (B >> 5 & _1_5) / _1_5 * 255 | 0;
      var red = (B >> 10 & _1_5) / _1_5 * 255 | 0;
      var alpha = B >> 15 ? 255 : 0;
      var location2 = line * this.width * 4 + x2 * 4;
      this.data[location2] = red;
      this.data[location2 + 1] = green;
      this.data[location2 + 2] = blue;
      this.data[location2 + 3] = alpha;
    }
    this.pos += dif_w;
  }
};
BmpDecoder.prototype.bit16 = function() {
  var dif_w = this.width % 3;
  var _11111 = parseInt("11111", 2), _1_5 = _11111;
  var _111111 = parseInt("111111", 2), _1_6 = _111111;
  for (var y3 = this.height - 1; y3 >= 0; y3--) {
    var line = this.bottom_up ? y3 : this.height - 1 - y3;
    for (var x2 = 0; x2 < this.width; x2++) {
      var B = this.datav.getUint16(this.pos, true);
      this.pos += 2;
      var alpha = 255;
      var blue = (B & _1_5) / _1_5 * 255 | 0;
      var green = (B >> 5 & _1_6) / _1_6 * 255 | 0;
      var red = (B >> 11) / _1_5 * 255 | 0;
      var location2 = line * this.width * 4 + x2 * 4;
      this.data[location2] = red;
      this.data[location2 + 1] = green;
      this.data[location2 + 2] = blue;
      this.data[location2 + 3] = alpha;
    }
    this.pos += dif_w;
  }
};
BmpDecoder.prototype.bit24 = function() {
  for (var y3 = this.height - 1; y3 >= 0; y3--) {
    var line = this.bottom_up ? y3 : this.height - 1 - y3;
    for (var x2 = 0; x2 < this.width; x2++) {
      var blue = this.datav.getUint8(this.pos++, true);
      var green = this.datav.getUint8(this.pos++, true);
      var red = this.datav.getUint8(this.pos++, true);
      var location2 = line * this.width * 4 + x2 * 4;
      this.data[location2] = red;
      this.data[location2 + 1] = green;
      this.data[location2 + 2] = blue;
      this.data[location2 + 3] = 255;
    }
    this.pos += this.width % 4;
  }
};
BmpDecoder.prototype.bit32 = function() {
  for (var y3 = this.height - 1; y3 >= 0; y3--) {
    var line = this.bottom_up ? y3 : this.height - 1 - y3;
    for (var x2 = 0; x2 < this.width; x2++) {
      var blue = this.datav.getUint8(this.pos++, true);
      var green = this.datav.getUint8(this.pos++, true);
      var red = this.datav.getUint8(this.pos++, true);
      var alpha = this.datav.getUint8(this.pos++, true);
      var location2 = line * this.width * 4 + x2 * 4;
      this.data[location2] = red;
      this.data[location2 + 1] = green;
      this.data[location2 + 2] = blue;
      this.data[location2 + 3] = alpha;
    }
  }
};
BmpDecoder.prototype.getData = function() {
  return this.data;
};
(function(jsPDFAPI2) {
  jsPDFAPI2.processBMP = function(imageData, index3, alias, compression) {
    var reader = new BmpDecoder(imageData, false);
    var width2 = reader.width, height2 = reader.height;
    var qu = 100;
    var pixels = reader.getData();
    var rawImageData = {
      data: pixels,
      width: width2,
      height: height2
    };
    var encoder = new JPEGEncoder(qu);
    var data2 = encoder.encode(rawImageData, qu);
    return jsPDFAPI2.processJPEG.call(this, data2, index3, alias, compression);
  };
})(jsPDF.API);
function WebPDecoder(imageData) {
  function x2(F) {
    if (!F)
      throw Error("assert :P");
  }
  function fa(F, L, J) {
    for (var H = 0; 4 > H; H++) {
      if (F[L + H] != J.charCodeAt(H))
        return true;
    }
    return false;
  }
  function I(F, L, J, H, Z) {
    for (var O2 = 0; O2 < Z; O2++) {
      F[L + O2] = J[H + O2];
    }
  }
  function M(F, L, J, H) {
    for (var Z = 0; Z < H; Z++) {
      F[L + Z] = J;
    }
  }
  function V(F) {
    return new Int32Array(F);
  }
  function wa(F, L) {
    for (var J = [], H = 0; H < F; H++) {
      J.push(new L());
    }
    return J;
  }
  function wb() {
    function F(J, H, Z) {
      for (var O2 = Z[H], L2 = 0; L2 < O2; L2++) {
        J.push(Z.length > H + 1 ? [] : 0);
        if (Z.length < H + 1)
          break;
        F(J[L2], H + 1, Z);
      }
    }
    var L = [];
    F(L, 0, [3, 11]);
    return L;
  }
  function Ed(F, L) {
    function J(H2, O2, F2) {
      for (var Z = F2[O2], ma = 0; ma < Z; ma++) {
        H2.push(F2.length > O2 + 1 ? [] : new L());
        if (F2.length < O2 + 1)
          break;
        J(H2[ma], O2 + 1, F2);
      }
    }
    var H = [];
    J(H, 0, F);
    return H;
  }
  var _WebPDecoder = function _WebPDecoder2() {
    var self2 = this;
    function L(a2, b) {
      for (var c3 = 1 << b - 1 >>> 0; a2 & c3; ) {
        c3 >>>= 1;
      }
      return c3 ? (a2 & c3 - 1) + c3 : a2;
    }
    function J(a2, b, c3, d, e2) {
      x2(!(d % c3));
      do {
        d -= c3, a2[b + d] = e2;
      } while (0 < d);
    }
    function H(a2, b, c3, d, e2, f4) {
      var g = b, h2 = 1 << c3, k, l2, m3 = V(16), n2 = V(16);
      x2(0 != e2);
      x2(null != d);
      x2(null != a2);
      x2(0 < c3);
      for (l2 = 0; l2 < e2; ++l2) {
        if (15 < d[l2])
          return 0;
        ++m3[d[l2]];
      }
      if (m3[0] == e2)
        return 0;
      n2[1] = 0;
      for (k = 1; 15 > k; ++k) {
        if (m3[k] > 1 << k)
          return 0;
        n2[k + 1] = n2[k] + m3[k];
      }
      for (l2 = 0; l2 < e2; ++l2) {
        k = d[l2], 0 < d[l2] && (f4[n2[k]++] = l2);
      }
      if (1 == n2[15])
        return d = new O2(), d.g = 0, d.value = f4[0], J(a2, g, 1, h2, d), h2;
      var r2 = -1, q = h2 - 1, t2 = 0, v2 = 1, p2 = 1, u2, w = 1 << c3;
      l2 = 0;
      k = 1;
      for (e2 = 2; k <= c3; ++k, e2 <<= 1) {
        p2 <<= 1;
        v2 += p2;
        p2 -= m3[k];
        if (0 > p2)
          return 0;
        for (; 0 < m3[k]; --m3[k]) {
          d = new O2(), d.g = k, d.value = f4[l2++], J(a2, g + t2, e2, w, d), t2 = L(t2, k);
        }
      }
      k = c3 + 1;
      for (e2 = 2; 15 >= k; ++k, e2 <<= 1) {
        p2 <<= 1;
        v2 += p2;
        p2 -= m3[k];
        if (0 > p2)
          return 0;
        for (; 0 < m3[k]; --m3[k]) {
          d = new O2();
          if ((t2 & q) != r2) {
            g += w;
            r2 = k;
            for (u2 = 1 << r2 - c3; 15 > r2; ) {
              u2 -= m3[r2];
              if (0 >= u2)
                break;
              ++r2;
              u2 <<= 1;
            }
            u2 = r2 - c3;
            w = 1 << u2;
            h2 += w;
            r2 = t2 & q;
            a2[b + r2].g = u2 + c3;
            a2[b + r2].value = g - b - r2;
          }
          d.g = k - c3;
          d.value = f4[l2++];
          J(a2, g + (t2 >> c3), e2, w, d);
          t2 = L(t2, k);
        }
      }
      return v2 != 2 * n2[15] - 1 ? 0 : h2;
    }
    function Z(a2, b, c3, d, e2) {
      x2(2328 >= e2);
      if (512 >= e2)
        var f4 = V(512);
      else if (f4 = V(e2), null == f4)
        return 0;
      return H(a2, b, c3, d, e2, f4);
    }
    function O2() {
      this.value = this.g = 0;
    }
    function Fd() {
      this.value = this.g = 0;
    }
    function Ub() {
      this.G = wa(5, O2);
      this.H = V(5);
      this.jc = this.Qb = this.qb = this.nd = 0;
      this.pd = wa(xb, Fd);
    }
    function ma(a2, b, c3, d) {
      x2(null != a2);
      x2(null != b);
      x2(2147483648 > d);
      a2.Ca = 254;
      a2.I = 0;
      a2.b = -8;
      a2.Ka = 0;
      a2.oa = b;
      a2.pa = c3;
      a2.Jd = b;
      a2.Yc = c3 + d;
      a2.Zc = 4 <= d ? c3 + d - 4 + 1 : c3;
      Qa(a2);
    }
    function na(a2, b) {
      for (var c3 = 0; 0 < b--; ) {
        c3 |= K(a2, 128) << b;
      }
      return c3;
    }
    function ca(a2, b) {
      var c3 = na(a2, b);
      return G2(a2) ? -c3 : c3;
    }
    function cb(a2, b, c3, d) {
      var e2, f4 = 0;
      x2(null != a2);
      x2(null != b);
      x2(4294967288 > d);
      a2.Sb = d;
      a2.Ra = 0;
      a2.u = 0;
      a2.h = 0;
      4 < d && (d = 4);
      for (e2 = 0; e2 < d; ++e2) {
        f4 += b[c3 + e2] << 8 * e2;
      }
      a2.Ra = f4;
      a2.bb = d;
      a2.oa = b;
      a2.pa = c3;
    }
    function Vb(a2) {
      for (; 8 <= a2.u && a2.bb < a2.Sb; ) {
        a2.Ra >>>= 8, a2.Ra += a2.oa[a2.pa + a2.bb] << ob - 8 >>> 0, ++a2.bb, a2.u -= 8;
      }
      db(a2) && (a2.h = 1, a2.u = 0);
    }
    function D2(a2, b) {
      x2(0 <= b);
      if (!a2.h && b <= Gd) {
        var c3 = pb(a2) & Hd[b];
        a2.u += b;
        Vb(a2);
        return c3;
      }
      a2.h = 1;
      return a2.u = 0;
    }
    function Wb() {
      this.b = this.Ca = this.I = 0;
      this.oa = [];
      this.pa = 0;
      this.Jd = [];
      this.Yc = 0;
      this.Zc = [];
      this.Ka = 0;
    }
    function Ra() {
      this.Ra = 0;
      this.oa = [];
      this.h = this.u = this.bb = this.Sb = this.pa = 0;
    }
    function pb(a2) {
      return a2.Ra >>> (a2.u & ob - 1) >>> 0;
    }
    function db(a2) {
      x2(a2.bb <= a2.Sb);
      return a2.h || a2.bb == a2.Sb && a2.u > ob;
    }
    function qb(a2, b) {
      a2.u = b;
      a2.h = db(a2);
    }
    function Sa(a2) {
      a2.u >= Xb && (x2(a2.u >= Xb), Vb(a2));
    }
    function Qa(a2) {
      x2(null != a2 && null != a2.oa);
      a2.pa < a2.Zc ? (a2.I = (a2.oa[a2.pa++] | a2.I << 8) >>> 0, a2.b += 8) : (x2(null != a2 && null != a2.oa), a2.pa < a2.Yc ? (a2.b += 8, a2.I = a2.oa[a2.pa++] | a2.I << 8) : a2.Ka ? a2.b = 0 : (a2.I <<= 8, a2.b += 8, a2.Ka = 1));
    }
    function G2(a2) {
      return na(a2, 1);
    }
    function K(a2, b) {
      var c3 = a2.Ca;
      0 > a2.b && Qa(a2);
      var d = a2.b, e2 = c3 * b >>> 8, f4 = (a2.I >>> d > e2) + 0;
      f4 ? (c3 -= e2, a2.I -= e2 + 1 << d >>> 0) : c3 = e2 + 1;
      d = c3;
      for (e2 = 0; 256 <= d; ) {
        e2 += 8, d >>= 8;
      }
      d = 7 ^ e2 + Id[d];
      a2.b -= d;
      a2.Ca = (c3 << d) - 1;
      return f4;
    }
    function ra(a2, b, c3) {
      a2[b + 0] = c3 >> 24 & 255;
      a2[b + 1] = c3 >> 16 & 255;
      a2[b + 2] = c3 >> 8 & 255;
      a2[b + 3] = c3 >> 0 & 255;
    }
    function Ta(a2, b) {
      return a2[b + 0] << 0 | a2[b + 1] << 8;
    }
    function Yb(a2, b) {
      return Ta(a2, b) | a2[b + 2] << 16;
    }
    function Ha(a2, b) {
      return Ta(a2, b) | Ta(a2, b + 2) << 16;
    }
    function Zb(a2, b) {
      var c3 = 1 << b;
      x2(null != a2);
      x2(0 < b);
      a2.X = V(c3);
      if (null == a2.X)
        return 0;
      a2.Mb = 32 - b;
      a2.Xa = b;
      return 1;
    }
    function $b(a2, b) {
      x2(null != a2);
      x2(null != b);
      x2(a2.Xa == b.Xa);
      I(b.X, 0, a2.X, 0, 1 << b.Xa);
    }
    function ac() {
      this.X = [];
      this.Xa = this.Mb = 0;
    }
    function bc(a2, b, c3, d) {
      x2(null != c3);
      x2(null != d);
      var e2 = c3[0], f4 = d[0];
      0 == e2 && (e2 = (a2 * f4 + b / 2) / b);
      0 == f4 && (f4 = (b * e2 + a2 / 2) / a2);
      if (0 >= e2 || 0 >= f4)
        return 0;
      c3[0] = e2;
      d[0] = f4;
      return 1;
    }
    function xa(a2, b) {
      return a2 + (1 << b) - 1 >>> b;
    }
    function yb(a2, b) {
      return ((a2 & 4278255360) + (b & 4278255360) >>> 0 & 4278255360) + ((a2 & 16711935) + (b & 16711935) >>> 0 & 16711935) >>> 0;
    }
    function X(a2, b) {
      self2[b] = function(b2, d, e2, f4, g, h2, k) {
        var c3;
        for (c3 = 0; c3 < g; ++c3) {
          var m3 = self2[a2](h2[k + c3 - 1], e2, f4 + c3);
          h2[k + c3] = yb(b2[d + c3], m3);
        }
      };
    }
    function Jd() {
      this.ud = this.hd = this.jd = 0;
    }
    function aa(a2, b) {
      return (((a2 ^ b) & 4278124286) >>> 1) + (a2 & b) >>> 0;
    }
    function sa(a2) {
      if (0 <= a2 && 256 > a2)
        return a2;
      if (0 > a2)
        return 0;
      if (255 < a2)
        return 255;
    }
    function eb(a2, b) {
      return sa(a2 + (a2 - b + 0.5 >> 1));
    }
    function Ia(a2, b, c3) {
      return Math.abs(b - c3) - Math.abs(a2 - c3);
    }
    function cc(a2, b, c3, d, e2, f4, g) {
      d = f4[g - 1];
      for (c3 = 0; c3 < e2; ++c3) {
        f4[g + c3] = d = yb(a2[b + c3], d);
      }
    }
    function Kd(a2, b, c3, d, e2) {
      var f4;
      for (f4 = 0; f4 < c3; ++f4) {
        var g = a2[b + f4], h2 = g >> 8 & 255, k = g & 16711935, k = k + ((h2 << 16) + h2), k = k & 16711935;
        d[e2 + f4] = (g & 4278255360) + k >>> 0;
      }
    }
    function dc(a2, b) {
      b.jd = a2 >> 0 & 255;
      b.hd = a2 >> 8 & 255;
      b.ud = a2 >> 16 & 255;
    }
    function Ld(a2, b, c3, d, e2, f4) {
      var g;
      for (g = 0; g < d; ++g) {
        var h2 = b[c3 + g], k = h2 >>> 8, l2 = h2 >>> 16, m3 = h2, l2 = l2 + ((a2.jd << 24 >> 24) * (k << 24 >> 24) >>> 5), l2 = l2 & 255, m3 = m3 + ((a2.hd << 24 >> 24) * (k << 24 >> 24) >>> 5), m3 = m3 + ((a2.ud << 24 >> 24) * (l2 << 24 >> 24) >>> 5), m3 = m3 & 255;
        e2[f4 + g] = (h2 & 4278255360) + (l2 << 16) + m3;
      }
    }
    function ec(a2, b, c3, d, e2) {
      self2[b] = function(a3, b2, c4, k, l2, m3, n2, r2, q) {
        for (k = n2; k < r2; ++k) {
          for (n2 = 0; n2 < q; ++n2) {
            l2[m3++] = e2(c4[d(a3[b2++])]);
          }
        }
      };
      self2[a2] = function(a3, b2, h2, k, l2, m3, n2) {
        var f4 = 8 >> a3.b, g = a3.Ea, t2 = a3.K[0], v2 = a3.w;
        if (8 > f4)
          for (a3 = (1 << a3.b) - 1, v2 = (1 << f4) - 1; b2 < h2; ++b2) {
            var p2 = 0, u2;
            for (u2 = 0; u2 < g; ++u2) {
              u2 & a3 || (p2 = d(k[l2++])), m3[n2++] = e2(t2[p2 & v2]), p2 >>= f4;
            }
          }
        else
          self2["VP8LMapColor" + c3](k, l2, t2, v2, m3, n2, b2, h2, g);
      };
    }
    function Md(a2, b, c3, d, e2) {
      for (c3 = b + c3; b < c3; ) {
        var f4 = a2[b++];
        d[e2++] = f4 >> 16 & 255;
        d[e2++] = f4 >> 8 & 255;
        d[e2++] = f4 >> 0 & 255;
      }
    }
    function Nd(a2, b, c3, d, e2) {
      for (c3 = b + c3; b < c3; ) {
        var f4 = a2[b++];
        d[e2++] = f4 >> 16 & 255;
        d[e2++] = f4 >> 8 & 255;
        d[e2++] = f4 >> 0 & 255;
        d[e2++] = f4 >> 24 & 255;
      }
    }
    function Od(a2, b, c3, d, e2) {
      for (c3 = b + c3; b < c3; ) {
        var f4 = a2[b++], g = f4 >> 16 & 240 | f4 >> 12 & 15, f4 = f4 >> 0 & 240 | f4 >> 28 & 15;
        d[e2++] = g;
        d[e2++] = f4;
      }
    }
    function Pd(a2, b, c3, d, e2) {
      for (c3 = b + c3; b < c3; ) {
        var f4 = a2[b++], g = f4 >> 16 & 248 | f4 >> 13 & 7, f4 = f4 >> 5 & 224 | f4 >> 3 & 31;
        d[e2++] = g;
        d[e2++] = f4;
      }
    }
    function Qd(a2, b, c3, d, e2) {
      for (c3 = b + c3; b < c3; ) {
        var f4 = a2[b++];
        d[e2++] = f4 >> 0 & 255;
        d[e2++] = f4 >> 8 & 255;
        d[e2++] = f4 >> 16 & 255;
      }
    }
    function fb(a2, b, c3, d, e2, f4) {
      if (0 == f4)
        for (c3 = b + c3; b < c3; ) {
          f4 = a2[b++], ra(d, (f4[0] >> 24 | f4[1] >> 8 & 65280 | f4[2] << 8 & 16711680 | f4[3] << 24) >>> 0), e2 += 32;
        }
      else
        I(d, e2, a2, b, c3);
    }
    function gb(a2, b) {
      self2[b][0] = self2[a2 + "0"];
      self2[b][1] = self2[a2 + "1"];
      self2[b][2] = self2[a2 + "2"];
      self2[b][3] = self2[a2 + "3"];
      self2[b][4] = self2[a2 + "4"];
      self2[b][5] = self2[a2 + "5"];
      self2[b][6] = self2[a2 + "6"];
      self2[b][7] = self2[a2 + "7"];
      self2[b][8] = self2[a2 + "8"];
      self2[b][9] = self2[a2 + "9"];
      self2[b][10] = self2[a2 + "10"];
      self2[b][11] = self2[a2 + "11"];
      self2[b][12] = self2[a2 + "12"];
      self2[b][13] = self2[a2 + "13"];
      self2[b][14] = self2[a2 + "0"];
      self2[b][15] = self2[a2 + "0"];
    }
    function hb(a2) {
      return a2 == zb || a2 == Ab || a2 == Ja || a2 == Bb;
    }
    function Rd() {
      this.eb = [];
      this.size = this.A = this.fb = 0;
    }
    function Sd() {
      this.y = [];
      this.f = [];
      this.ea = [];
      this.F = [];
      this.Tc = this.Ed = this.Cd = this.Fd = this.lb = this.Db = this.Ab = this.fa = this.J = this.W = this.N = this.O = 0;
    }
    function Cb() {
      this.Rd = this.height = this.width = this.S = 0;
      this.f = {};
      this.f.RGBA = new Rd();
      this.f.kb = new Sd();
      this.sd = null;
    }
    function Td() {
      this.width = [0];
      this.height = [0];
      this.Pd = [0];
      this.Qd = [0];
      this.format = [0];
    }
    function Ud() {
      this.Id = this.fd = this.Md = this.hb = this.ib = this.da = this.bd = this.cd = this.j = this.v = this.Da = this.Sd = this.ob = 0;
    }
    function Vd(a2) {
      alert("todo:WebPSamplerProcessPlane");
      return a2.T;
    }
    function Wd(a2, b) {
      var c3 = a2.T, d = b.ba.f.RGBA, e2 = d.eb, f4 = d.fb + a2.ka * d.A, g = P[b.ba.S], h2 = a2.y, k = a2.O, l2 = a2.f, m3 = a2.N, n2 = a2.ea, r2 = a2.W, q = b.cc, t2 = b.dc, v2 = b.Mc, p2 = b.Nc, u2 = a2.ka, w = a2.ka + a2.T, y3 = a2.U, A2 = y3 + 1 >> 1;
      0 == u2 ? g(h2, k, null, null, l2, m3, n2, r2, l2, m3, n2, r2, e2, f4, null, null, y3) : (g(b.ec, b.fc, h2, k, q, t2, v2, p2, l2, m3, n2, r2, e2, f4 - d.A, e2, f4, y3), ++c3);
      for (; u2 + 2 < w; u2 += 2) {
        q = l2, t2 = m3, v2 = n2, p2 = r2, m3 += a2.Rc, r2 += a2.Rc, f4 += 2 * d.A, k += 2 * a2.fa, g(h2, k - a2.fa, h2, k, q, t2, v2, p2, l2, m3, n2, r2, e2, f4 - d.A, e2, f4, y3);
      }
      k += a2.fa;
      a2.j + w < a2.o ? (I(b.ec, b.fc, h2, k, y3), I(b.cc, b.dc, l2, m3, A2), I(b.Mc, b.Nc, n2, r2, A2), c3--) : w & 1 || g(h2, k, null, null, l2, m3, n2, r2, l2, m3, n2, r2, e2, f4 + d.A, null, null, y3);
      return c3;
    }
    function Xd(a2, b, c3) {
      var d = a2.F, e2 = [a2.J];
      if (null != d) {
        var f4 = a2.U, g = b.ba.S, h2 = g == ya || g == Ja;
        b = b.ba.f.RGBA;
        var k = [0], l2 = a2.ka;
        k[0] = a2.T;
        a2.Kb && (0 == l2 ? --k[0] : (--l2, e2[0] -= a2.width), a2.j + a2.ka + a2.T == a2.o && (k[0] = a2.o - a2.j - l2));
        var m3 = b.eb, l2 = b.fb + l2 * b.A;
        a2 = fc(d, e2[0], a2.width, f4, k, m3, l2 + (h2 ? 0 : 3), b.A);
        x2(c3 == k);
        a2 && hb(g) && za(m3, l2, h2, f4, k, b.A);
      }
      return 0;
    }
    function gc(a2) {
      var b = a2.ma, c3 = b.ba.S, d = 11 > c3, e2 = c3 == Ua || c3 == Va || c3 == ya || c3 == Db || 12 == c3 || hb(c3);
      b.memory = null;
      b.Ib = null;
      b.Jb = null;
      b.Nd = null;
      if (!hc(b.Oa, a2, e2 ? 11 : 12))
        return 0;
      e2 && hb(c3) && ic();
      if (a2.da)
        alert("todo:use_scaling");
      else {
        if (d) {
          if (b.Ib = Vd, a2.Kb) {
            c3 = a2.U + 1 >> 1;
            b.memory = V(a2.U + 2 * c3);
            if (null == b.memory)
              return 0;
            b.ec = b.memory;
            b.fc = 0;
            b.cc = b.ec;
            b.dc = b.fc + a2.U;
            b.Mc = b.cc;
            b.Nc = b.dc + c3;
            b.Ib = Wd;
            ic();
          }
        } else
          alert("todo:EmitYUV");
        e2 && (b.Jb = Xd, d && Aa());
      }
      if (d && !jc) {
        for (a2 = 0; 256 > a2; ++a2) {
          Yd[a2] = 89858 * (a2 - 128) + Ba >> Wa, Zd[a2] = -22014 * (a2 - 128) + Ba, $d[a2] = -45773 * (a2 - 128), ae[a2] = 113618 * (a2 - 128) + Ba >> Wa;
        }
        for (a2 = ta; a2 < Eb; ++a2) {
          b = 76283 * (a2 - 16) + Ba >> Wa, be[a2 - ta] = ga(b, 255), ce[a2 - ta] = ga(b + 8 >> 4, 15);
        }
        jc = 1;
      }
      return 1;
    }
    function kc(a2) {
      var b = a2.ma, c3 = a2.U, d = a2.T;
      x2(!(a2.ka & 1));
      if (0 >= c3 || 0 >= d)
        return 0;
      c3 = b.Ib(a2, b);
      null != b.Jb && b.Jb(a2, b, c3);
      b.Dc += c3;
      return 1;
    }
    function lc2(a2) {
      a2.ma.memory = null;
    }
    function mc(a2, b, c3, d) {
      if (47 != D2(a2, 8))
        return 0;
      b[0] = D2(a2, 14) + 1;
      c3[0] = D2(a2, 14) + 1;
      d[0] = D2(a2, 1);
      return 0 != D2(a2, 3) ? 0 : !a2.h;
    }
    function ib(a2, b) {
      if (4 > a2)
        return a2 + 1;
      var c3 = a2 - 2 >> 1;
      return (2 + (a2 & 1) << c3) + D2(b, c3) + 1;
    }
    function nc(a2, b) {
      if (120 < b)
        return b - 120;
      var c3 = de[b - 1], c3 = (c3 >> 4) * a2 + (8 - (c3 & 15));
      return 1 <= c3 ? c3 : 1;
    }
    function ua(a2, b, c3) {
      var d = pb(c3);
      b += d & 255;
      var e2 = a2[b].g - 8;
      0 < e2 && (qb(c3, c3.u + 8), d = pb(c3), b += a2[b].value, b += d & (1 << e2) - 1);
      qb(c3, c3.u + a2[b].g);
      return a2[b].value;
    }
    function ub(a2, b, c3) {
      c3.g += a2.g;
      c3.value += a2.value << b >>> 0;
      x2(8 >= c3.g);
      return a2.g;
    }
    function ha(a2, b, c3) {
      var d = a2.xc;
      b = 0 == d ? 0 : a2.vc[a2.md * (c3 >> d) + (b >> d)];
      x2(b < a2.Wb);
      return a2.Ya[b];
    }
    function oc(a2, b, c3, d) {
      var e2 = a2.ab, f4 = a2.c * b, g = a2.C;
      b = g + b;
      var h2 = c3, k = d;
      d = a2.Ta;
      for (c3 = a2.Ua; 0 < e2--; ) {
        var l2 = a2.gc[e2], m3 = g, n2 = b, r2 = h2, q = k, k = d, h2 = c3, t2 = l2.Ea;
        x2(m3 < n2);
        x2(n2 <= l2.nc);
        switch (l2.hc) {
          case 2:
            pc(r2, q, (n2 - m3) * t2, k, h2);
            break;
          case 0:
            var v2 = l2, p2 = m3, u2 = n2, w = k, y3 = h2, A2 = v2.Ea;
            0 == p2 && (ee(r2, q, null, null, 1, w, y3), cc(r2, q + 1, 0, 0, A2 - 1, w, y3 + 1), q += A2, y3 += A2, ++p2);
            for (var E = 1 << v2.b, B = E - 1, C = xa(A2, v2.b), N2 = v2.K, v2 = v2.w + (p2 >> v2.b) * C; p2 < u2; ) {
              var z2 = N2, Q = v2, S2 = 1;
              for (fe(r2, q, w, y3 - A2, 1, w, y3); S2 < A2; ) {
                var K2 = qc[z2[Q++] >> 8 & 15], D3 = (S2 & ~B) + E;
                D3 > A2 && (D3 = A2);
                K2(r2, q + +S2, w, y3 + S2 - A2, D3 - S2, w, y3 + S2);
                S2 = D3;
              }
              q += A2;
              y3 += A2;
              ++p2;
              p2 & B || (v2 += C);
            }
            n2 != l2.nc && I(k, h2 - t2, k, h2 + (n2 - m3 - 1) * t2, t2);
            break;
          case 1:
            t2 = r2;
            u2 = q;
            r2 = l2.Ea;
            q = 1 << l2.b;
            w = q - 1;
            y3 = r2 & ~w;
            A2 = r2 - y3;
            p2 = xa(r2, l2.b);
            E = l2.K;
            for (l2 = l2.w + (m3 >> l2.b) * p2; m3 < n2; ) {
              B = E;
              C = l2;
              N2 = new Jd();
              v2 = u2 + y3;
              for (z2 = u2 + r2; u2 < v2; ) {
                dc(B[C++], N2), Fb(N2, t2, u2, q, k, h2), u2 += q, h2 += q;
              }
              u2 < z2 && (dc(B[C++], N2), Fb(N2, t2, u2, A2, k, h2), u2 += A2, h2 += A2);
              ++m3;
              m3 & w || (l2 += p2);
            }
            break;
          case 3:
            if (r2 == k && q == h2 && 0 < l2.b) {
              y3 = (n2 - m3) * xa(l2.Ea, l2.b);
              t2 = h2 + (n2 - m3) * t2 - y3;
              u2 = k;
              r2 = t2;
              q = k;
              w = h2;
              A2 = y3;
              p2 = [];
              for (y3 = A2 - 1; 0 <= y3; --y3) {
                p2[y3] = q[w + y3];
              }
              for (y3 = A2 - 1; 0 <= y3; --y3) {
                u2[r2 + y3] = p2[y3];
              }
              rc(l2, m3, n2, k, t2, k, h2);
            } else
              rc(l2, m3, n2, r2, q, k, h2);
        }
        h2 = d;
        k = c3;
      }
      k != c3 && I(d, c3, h2, k, f4);
    }
    function ge(a2, b) {
      var c3 = a2.V, d = a2.Ba + a2.c * a2.C, e2 = b - a2.C;
      x2(b <= a2.l.o);
      x2(16 >= e2);
      if (0 < e2) {
        var f4 = a2.l, g = a2.Ta, h2 = a2.Ua, k = f4.width;
        oc(a2, e2, c3, d);
        h2 = [h2];
        c3 = a2.C;
        d = b;
        e2 = h2;
        x2(c3 < d);
        x2(f4.v < f4.va);
        d > f4.o && (d = f4.o);
        if (c3 < f4.j) {
          var l2 = f4.j - c3, c3 = f4.j;
          e2[0] += l2 * k;
        }
        c3 >= d ? c3 = 0 : (e2[0] += 4 * f4.v, f4.ka = c3 - f4.j, f4.U = f4.va - f4.v, f4.T = d - c3, c3 = 1);
        if (c3) {
          h2 = h2[0];
          c3 = a2.ca;
          if (11 > c3.S) {
            for (var m3 = c3.f.RGBA, d = c3.S, e2 = f4.U, f4 = f4.T, l2 = m3.eb, n2 = m3.A, r2 = f4, m3 = m3.fb + a2.Ma * m3.A; 0 < r2--; ) {
              var q = g, t2 = h2, v2 = e2, p2 = l2, u2 = m3;
              switch (d) {
                case Ca:
                  sc(q, t2, v2, p2, u2);
                  break;
                case Ua:
                  Gb(q, t2, v2, p2, u2);
                  break;
                case zb:
                  Gb(q, t2, v2, p2, u2);
                  za(p2, u2, 0, v2, 1, 0);
                  break;
                case tc:
                  uc(q, t2, v2, p2, u2);
                  break;
                case Va:
                  fb(q, t2, v2, p2, u2, 1);
                  break;
                case Ab:
                  fb(q, t2, v2, p2, u2, 1);
                  za(p2, u2, 0, v2, 1, 0);
                  break;
                case ya:
                  fb(q, t2, v2, p2, u2, 0);
                  break;
                case Ja:
                  fb(q, t2, v2, p2, u2, 0);
                  za(p2, u2, 1, v2, 1, 0);
                  break;
                case Db:
                  Hb(q, t2, v2, p2, u2);
                  break;
                case Bb:
                  Hb(q, t2, v2, p2, u2);
                  vc(p2, u2, v2, 1, 0);
                  break;
                case wc:
                  xc(q, t2, v2, p2, u2);
                  break;
                default:
                  x2(0);
              }
              h2 += k;
              m3 += n2;
            }
            a2.Ma += f4;
          } else
            alert("todo:EmitRescaledRowsYUVA");
          x2(a2.Ma <= c3.height);
        }
      }
      a2.C = b;
      x2(a2.C <= a2.i);
    }
    function yc(a2) {
      var b;
      if (0 < a2.ua)
        return 0;
      for (b = 0; b < a2.Wb; ++b) {
        var c3 = a2.Ya[b].G, d = a2.Ya[b].H;
        if (0 < c3[1][d[1] + 0].g || 0 < c3[2][d[2] + 0].g || 0 < c3[3][d[3] + 0].g)
          return 0;
      }
      return 1;
    }
    function zc(a2, b, c3, d, e2, f4) {
      if (0 != a2.Z) {
        var g = a2.qd, h2 = a2.rd;
        for (x2(null != ia[a2.Z]); b < c3; ++b) {
          ia[a2.Z](g, h2, d, e2, d, e2, f4), g = d, h2 = e2, e2 += f4;
        }
        a2.qd = g;
        a2.rd = h2;
      }
    }
    function Ib(a2, b) {
      var c3 = a2.l.ma, d = 0 == c3.Z || 1 == c3.Z ? a2.l.j : a2.C, d = a2.C < d ? d : a2.C;
      x2(b <= a2.l.o);
      if (b > d) {
        var e2 = a2.l.width, f4 = c3.ca, g = c3.tb + e2 * d, h2 = a2.V, k = a2.Ba + a2.c * d, l2 = a2.gc;
        x2(1 == a2.ab);
        x2(3 == l2[0].hc);
        he(l2[0], d, b, h2, k, f4, g);
        zc(c3, d, b, f4, g, e2);
      }
      a2.C = a2.Ma = b;
    }
    function Jb(a2, b, c3, d, e2, f4, g) {
      var h2 = a2.$ / d, k = a2.$ % d, l2 = a2.m, m3 = a2.s, n2 = c3 + a2.$, r2 = n2;
      e2 = c3 + d * e2;
      var q = c3 + d * f4, t2 = 280 + m3.ua, v2 = a2.Pb ? h2 : 16777216, p2 = 0 < m3.ua ? m3.Wa : null, u2 = m3.wc, w = n2 < q ? ha(m3, k, h2) : null;
      x2(a2.C < f4);
      x2(q <= e2);
      var y3 = false;
      a:
        for (; ; ) {
          for (; y3 || n2 < q; ) {
            var A2 = 0;
            if (h2 >= v2) {
              var v2 = a2, E = n2 - c3;
              x2(v2.Pb);
              v2.wd = v2.m;
              v2.xd = E;
              0 < v2.s.ua && $b(v2.s.Wa, v2.s.vb);
              v2 = h2 + ie;
            }
            k & u2 || (w = ha(m3, k, h2));
            x2(null != w);
            w.Qb && (b[n2] = w.qb, y3 = true);
            if (!y3)
              if (Sa(l2), w.jc) {
                var A2 = l2, E = b, B = n2, C = w.pd[pb(A2) & xb - 1];
                x2(w.jc);
                256 > C.g ? (qb(A2, A2.u + C.g), E[B] = C.value, A2 = 0) : (qb(A2, A2.u + C.g - 256), x2(256 <= C.value), A2 = C.value);
                0 == A2 && (y3 = true);
              } else
                A2 = ua(w.G[0], w.H[0], l2);
            if (l2.h)
              break;
            if (y3 || 256 > A2) {
              if (!y3)
                if (w.nd)
                  b[n2] = (w.qb | A2 << 8) >>> 0;
                else {
                  Sa(l2);
                  y3 = ua(w.G[1], w.H[1], l2);
                  Sa(l2);
                  E = ua(w.G[2], w.H[2], l2);
                  B = ua(w.G[3], w.H[3], l2);
                  if (l2.h)
                    break;
                  b[n2] = (B << 24 | y3 << 16 | A2 << 8 | E) >>> 0;
                }
              y3 = false;
              ++n2;
              ++k;
              if (k >= d && (k = 0, ++h2, null != g && h2 <= f4 && !(h2 % 16) && g(a2, h2), null != p2))
                for (; r2 < n2; ) {
                  A2 = b[r2++], p2.X[(506832829 * A2 & 4294967295) >>> p2.Mb] = A2;
                }
            } else if (280 > A2) {
              A2 = ib(A2 - 256, l2);
              E = ua(w.G[4], w.H[4], l2);
              Sa(l2);
              E = ib(E, l2);
              E = nc(d, E);
              if (l2.h)
                break;
              if (n2 - c3 < E || e2 - n2 < A2)
                break a;
              else
                for (B = 0; B < A2; ++B) {
                  b[n2 + B] = b[n2 + B - E];
                }
              n2 += A2;
              for (k += A2; k >= d; ) {
                k -= d, ++h2, null != g && h2 <= f4 && !(h2 % 16) && g(a2, h2);
              }
              x2(n2 <= e2);
              k & u2 && (w = ha(m3, k, h2));
              if (null != p2)
                for (; r2 < n2; ) {
                  A2 = b[r2++], p2.X[(506832829 * A2 & 4294967295) >>> p2.Mb] = A2;
                }
            } else if (A2 < t2) {
              y3 = A2 - 280;
              for (x2(null != p2); r2 < n2; ) {
                A2 = b[r2++], p2.X[(506832829 * A2 & 4294967295) >>> p2.Mb] = A2;
              }
              A2 = n2;
              E = p2;
              x2(!(y3 >>> E.Xa));
              b[A2] = E.X[y3];
              y3 = true;
            } else
              break a;
            y3 || x2(l2.h == db(l2));
          }
          if (a2.Pb && l2.h && n2 < e2)
            x2(a2.m.h), a2.a = 5, a2.m = a2.wd, a2.$ = a2.xd, 0 < a2.s.ua && $b(a2.s.vb, a2.s.Wa);
          else if (l2.h)
            break a;
          else
            null != g && g(a2, h2 > f4 ? f4 : h2), a2.a = 0, a2.$ = n2 - c3;
          return 1;
        }
      a2.a = 3;
      return 0;
    }
    function Ac(a2) {
      x2(null != a2);
      a2.vc = null;
      a2.yc = null;
      a2.Ya = null;
      var b = a2.Wa;
      null != b && (b.X = null);
      a2.vb = null;
      x2(null != a2);
    }
    function Bc() {
      var a2 = new je();
      if (null == a2)
        return null;
      a2.a = 0;
      a2.xb = Cc;
      gb("Predictor", "VP8LPredictors");
      gb("Predictor", "VP8LPredictors_C");
      gb("PredictorAdd", "VP8LPredictorsAdd");
      gb("PredictorAdd", "VP8LPredictorsAdd_C");
      pc = Kd;
      Fb = Ld;
      sc = Md;
      Gb = Nd;
      Hb = Od;
      xc = Pd;
      uc = Qd;
      self2.VP8LMapColor32b = ke;
      self2.VP8LMapColor8b = le;
      return a2;
    }
    function rb(a2, b, c3, d, e2) {
      var f4 = 1, g = [a2], h2 = [b], k = d.m, l2 = d.s, m3 = null, n2 = 0;
      a:
        for (; ; ) {
          if (c3)
            for (; f4 && D2(k, 1); ) {
              var r2 = g, q = h2, t2 = d, v2 = 1, p2 = t2.m, u2 = t2.gc[t2.ab], w = D2(p2, 2);
              if (t2.Oc & 1 << w)
                f4 = 0;
              else {
                t2.Oc |= 1 << w;
                u2.hc = w;
                u2.Ea = r2[0];
                u2.nc = q[0];
                u2.K = [null];
                ++t2.ab;
                x2(4 >= t2.ab);
                switch (w) {
                  case 0:
                  case 1:
                    u2.b = D2(p2, 3) + 2;
                    v2 = rb(xa(u2.Ea, u2.b), xa(u2.nc, u2.b), 0, t2, u2.K);
                    u2.K = u2.K[0];
                    break;
                  case 3:
                    var y3 = D2(p2, 8) + 1, A2 = 16 < y3 ? 0 : 4 < y3 ? 1 : 2 < y3 ? 2 : 3;
                    r2[0] = xa(u2.Ea, A2);
                    u2.b = A2;
                    var v2 = rb(y3, 1, 0, t2, u2.K), E;
                    if (E = v2) {
                      var B, C = y3, N2 = u2, z2 = 1 << (8 >> N2.b), Q = V(z2);
                      if (null == Q)
                        E = 0;
                      else {
                        var S2 = N2.K[0], K2 = N2.w;
                        Q[0] = N2.K[0][0];
                        for (B = 1; B < 1 * C; ++B) {
                          Q[B] = yb(S2[K2 + B], Q[B - 1]);
                        }
                        for (; B < 4 * z2; ++B) {
                          Q[B] = 0;
                        }
                        N2.K[0] = null;
                        N2.K[0] = Q;
                        E = 1;
                      }
                    }
                    v2 = E;
                    break;
                  case 2:
                    break;
                  default:
                    x2(0);
                }
                f4 = v2;
              }
            }
          g = g[0];
          h2 = h2[0];
          if (f4 && D2(k, 1) && (n2 = D2(k, 4), f4 = 1 <= n2 && 11 >= n2, !f4)) {
            d.a = 3;
            break a;
          }
          var H2;
          if (H2 = f4)
            b: {
              var F = d, G3 = g, L2 = h2, J2 = n2, T4 = c3, Da, ba, X2 = F.m, R2 = F.s, P2 = [null], U2, W2 = 1, aa2 = 0, na2 = me[J2];
              c:
                for (; ; ) {
                  if (T4 && D2(X2, 1)) {
                    var ca2 = D2(X2, 3) + 2, ga2 = xa(G3, ca2), ka2 = xa(L2, ca2), qa2 = ga2 * ka2;
                    if (!rb(ga2, ka2, 0, F, P2))
                      break c;
                    P2 = P2[0];
                    R2.xc = ca2;
                    for (Da = 0; Da < qa2; ++Da) {
                      var ia2 = P2[Da] >> 8 & 65535;
                      P2[Da] = ia2;
                      ia2 >= W2 && (W2 = ia2 + 1);
                    }
                  }
                  if (X2.h)
                    break c;
                  for (ba = 0; 5 > ba; ++ba) {
                    var Y2 = Dc2[ba];
                    !ba && 0 < J2 && (Y2 += 1 << J2);
                    aa2 < Y2 && (aa2 = Y2);
                  }
                  var ma2 = wa(W2 * na2, O2);
                  var ua2 = W2, va2 = wa(ua2, Ub);
                  if (null == va2)
                    var la2 = null;
                  else
                    x2(65536 >= ua2), la2 = va2;
                  var ha2 = V(aa2);
                  if (null == la2 || null == ha2 || null == ma2) {
                    F.a = 1;
                    break c;
                  }
                  var pa2 = ma2;
                  for (Da = U2 = 0; Da < W2; ++Da) {
                    var ja = la2[Da], da2 = ja.G, ea2 = ja.H, Fa2 = 0, ra2 = 1, Ha2 = 0;
                    for (ba = 0; 5 > ba; ++ba) {
                      Y2 = Dc2[ba];
                      da2[ba] = pa2;
                      ea2[ba] = U2;
                      !ba && 0 < J2 && (Y2 += 1 << J2);
                      d: {
                        var sa2, za2 = Y2, ta2 = F, oa2 = ha2, db2 = pa2, eb2 = U2, Ia2 = 0, Ka = ta2.m, fb2 = D2(Ka, 1);
                        M(oa2, 0, 0, za2);
                        if (fb2) {
                          var gb2 = D2(Ka, 1) + 1, hb2 = D2(Ka, 1), Ja2 = D2(Ka, 0 == hb2 ? 1 : 8);
                          oa2[Ja2] = 1;
                          2 == gb2 && (Ja2 = D2(Ka, 8), oa2[Ja2] = 1);
                          var ya2 = 1;
                        } else {
                          var Ua2 = V(19), Va2 = D2(Ka, 4) + 4;
                          if (19 < Va2) {
                            ta2.a = 3;
                            var Aa2 = 0;
                            break d;
                          }
                          for (sa2 = 0; sa2 < Va2; ++sa2) {
                            Ua2[ne[sa2]] = D2(Ka, 3);
                          }
                          var Ba2 = void 0, sb = void 0, Wa2 = ta2, ib2 = Ua2, Ca2 = za2, Xa2 = oa2, Oa2 = 0, La = Wa2.m, Ya2 = 8, Za2 = wa(128, O2);
                          e:
                            for (; ; ) {
                              if (!Z(Za2, 0, 7, ib2, 19))
                                break e;
                              if (D2(La, 1)) {
                                var kb2 = 2 + 2 * D2(La, 3), Ba2 = 2 + D2(La, kb2);
                                if (Ba2 > Ca2)
                                  break e;
                              } else
                                Ba2 = Ca2;
                              for (sb = 0; sb < Ca2 && Ba2--; ) {
                                Sa(La);
                                var $a2 = Za2[0 + (pb(La) & 127)];
                                qb(La, La.u + $a2.g);
                                var jb = $a2.value;
                                if (16 > jb)
                                  Xa2[sb++] = jb, 0 != jb && (Ya2 = jb);
                                else {
                                  var lb2 = 16 == jb, ab2 = jb - 16, mb2 = oe[ab2], bb2 = D2(La, pe[ab2]) + mb2;
                                  if (sb + bb2 > Ca2)
                                    break e;
                                  else
                                    for (var nb2 = lb2 ? Ya2 : 0; 0 < bb2--; ) {
                                      Xa2[sb++] = nb2;
                                    }
                                }
                              }
                              Oa2 = 1;
                              break e;
                            }
                          Oa2 || (Wa2.a = 3);
                          ya2 = Oa2;
                        }
                        (ya2 = ya2 && !Ka.h) && (Ia2 = Z(db2, eb2, 8, oa2, za2));
                        ya2 && 0 != Ia2 ? Aa2 = Ia2 : (ta2.a = 3, Aa2 = 0);
                      }
                      if (0 == Aa2)
                        break c;
                      ra2 && 1 == qe[ba] && (ra2 = 0 == pa2[U2].g);
                      Fa2 += pa2[U2].g;
                      U2 += Aa2;
                      if (3 >= ba) {
                        var Pa2 = ha2[0], tb;
                        for (tb = 1; tb < Y2; ++tb) {
                          ha2[tb] > Pa2 && (Pa2 = ha2[tb]);
                        }
                        Ha2 += Pa2;
                      }
                    }
                    ja.nd = ra2;
                    ja.Qb = 0;
                    ra2 && (ja.qb = (da2[3][ea2[3] + 0].value << 24 | da2[1][ea2[1] + 0].value << 16 | da2[2][ea2[2] + 0].value) >>> 0, 0 == Fa2 && 256 > da2[0][ea2[0] + 0].value && (ja.Qb = 1, ja.qb += da2[0][ea2[0] + 0].value << 8));
                    ja.jc = !ja.Qb && 6 > Ha2;
                    if (ja.jc) {
                      var Ga2, Ea = ja;
                      for (Ga2 = 0; Ga2 < xb; ++Ga2) {
                        var Ma = Ga2, Na = Ea.pd[Ma], vb = Ea.G[0][Ea.H[0] + Ma];
                        256 <= vb.value ? (Na.g = vb.g + 256, Na.value = vb.value) : (Na.g = 0, Na.value = 0, Ma >>= ub(vb, 8, Na), Ma >>= ub(Ea.G[1][Ea.H[1] + Ma], 16, Na), Ma >>= ub(Ea.G[2][Ea.H[2] + Ma], 0, Na), ub(Ea.G[3][Ea.H[3] + Ma], 24, Na));
                      }
                    }
                  }
                  R2.vc = P2;
                  R2.Wb = W2;
                  R2.Ya = la2;
                  R2.yc = ma2;
                  H2 = 1;
                  break b;
                }
              H2 = 0;
            }
          f4 = H2;
          if (!f4) {
            d.a = 3;
            break a;
          }
          if (0 < n2) {
            if (l2.ua = 1 << n2, !Zb(l2.Wa, n2)) {
              d.a = 1;
              f4 = 0;
              break a;
            }
          } else
            l2.ua = 0;
          var Qa2 = d, cb2 = g, ob2 = h2, Ra2 = Qa2.s, Ta2 = Ra2.xc;
          Qa2.c = cb2;
          Qa2.i = ob2;
          Ra2.md = xa(cb2, Ta2);
          Ra2.wc = 0 == Ta2 ? -1 : (1 << Ta2) - 1;
          if (c3) {
            d.xb = re;
            break a;
          }
          m3 = V(g * h2);
          if (null == m3) {
            d.a = 1;
            f4 = 0;
            break a;
          }
          f4 = (f4 = Jb(d, m3, 0, g, h2, h2, null)) && !k.h;
          break a;
        }
      f4 ? (null != e2 ? e2[0] = m3 : (x2(null == m3), x2(c3)), d.$ = 0, c3 || Ac(l2)) : Ac(l2);
      return f4;
    }
    function Ec(a2, b) {
      var c3 = a2.c * a2.i, d = c3 + b + 16 * b;
      x2(a2.c <= b);
      a2.V = V(d);
      if (null == a2.V)
        return a2.Ta = null, a2.Ua = 0, a2.a = 1, 0;
      a2.Ta = a2.V;
      a2.Ua = a2.Ba + c3 + b;
      return 1;
    }
    function se(a2, b) {
      var c3 = a2.C, d = b - c3, e2 = a2.V, f4 = a2.Ba + a2.c * c3;
      for (x2(b <= a2.l.o); 0 < d; ) {
        var g = 16 < d ? 16 : d, h2 = a2.l.ma, k = a2.l.width, l2 = k * g, m3 = h2.ca, n2 = h2.tb + k * c3, r2 = a2.Ta, q = a2.Ua;
        oc(a2, g, e2, f4);
        Fc(r2, q, m3, n2, l2);
        zc(h2, c3, c3 + g, m3, n2, k);
        d -= g;
        e2 += g * a2.c;
        c3 += g;
      }
      x2(c3 == b);
      a2.C = a2.Ma = b;
    }
    function te(a2, b) {
      var c3 = [0], d = [0], e2 = [0];
      a:
        for (; ; ) {
          if (null == a2)
            return 0;
          if (null == b)
            return a2.a = 2, 0;
          a2.l = b;
          a2.a = 0;
          cb(a2.m, b.data, b.w, b.ha);
          if (!mc(a2.m, c3, d, e2)) {
            a2.a = 3;
            break a;
          }
          a2.xb = Cc;
          b.width = c3[0];
          b.height = d[0];
          if (!rb(c3[0], d[0], 1, a2, null))
            break a;
          return 1;
        }
      x2(0 != a2.a);
      return 0;
    }
    function ue() {
      this.ub = this.yd = this.td = this.Rb = 0;
    }
    function ve() {
      this.Kd = this.Ld = this.Ud = this.Td = this.i = this.c = 0;
    }
    function we() {
      this.Fb = this.Bb = this.Cb = 0;
      this.Zb = V(4);
      this.Lb = V(4);
    }
    function Gc() {
      this.Yb = wb();
    }
    function xe() {
      this.jb = V(3);
      this.Wc = Ed([4, 8], Gc);
      this.Xc = Ed([4, 17], Gc);
    }
    function ye() {
      this.Pc = this.wb = this.Tb = this.zd = 0;
      this.vd = new V(4);
      this.od = new V(4);
    }
    function Xa() {
      this.ld = this.La = this.dd = this.tc = 0;
    }
    function Hc() {
      this.Na = this.la = 0;
    }
    function ze() {
      this.Sc = [0, 0];
      this.Eb = [0, 0];
      this.Qc = [0, 0];
      this.ia = this.lc = 0;
    }
    function Kb() {
      this.ad = V(384);
      this.Za = 0;
      this.Ob = V(16);
      this.$b = this.Ad = this.ia = this.Gc = this.Hc = this.Dd = 0;
    }
    function Ae() {
      this.uc = this.M = this.Nb = 0;
      this.wa = Array(new Xa());
      this.Y = 0;
      this.ya = Array(new Kb());
      this.aa = 0;
      this.l = new Oa();
    }
    function Ic() {
      this.y = V(16);
      this.f = V(8);
      this.ea = V(8);
    }
    function Be() {
      this.cb = this.a = 0;
      this.sc = "";
      this.m = new Wb();
      this.Od = new ue();
      this.Kc = new ve();
      this.ed = new ye();
      this.Qa = new we();
      this.Ic = this.$c = this.Aa = 0;
      this.D = new Ae();
      this.Xb = this.Va = this.Hb = this.zb = this.yb = this.Ub = this.za = 0;
      this.Jc = wa(8, Wb);
      this.ia = 0;
      this.pb = wa(4, ze);
      this.Pa = new xe();
      this.Bd = this.kc = 0;
      this.Ac = [];
      this.Bc = 0;
      this.zc = [0, 0, 0, 0];
      this.Gd = Array(new Ic());
      this.Hd = 0;
      this.rb = Array(new Hc());
      this.sb = 0;
      this.wa = Array(new Xa());
      this.Y = 0;
      this.oc = [];
      this.pc = 0;
      this.sa = [];
      this.ta = 0;
      this.qa = [];
      this.ra = 0;
      this.Ha = [];
      this.B = this.R = this.Ia = 0;
      this.Ec = [];
      this.M = this.ja = this.Vb = this.Fc = 0;
      this.ya = Array(new Kb());
      this.L = this.aa = 0;
      this.gd = Ed([4, 2], Xa);
      this.ga = null;
      this.Fa = [];
      this.Cc = this.qc = this.P = 0;
      this.Gb = [];
      this.Uc = 0;
      this.mb = [];
      this.nb = 0;
      this.rc = [];
      this.Ga = this.Vc = 0;
    }
    function ga(a2, b) {
      return 0 > a2 ? 0 : a2 > b ? b : a2;
    }
    function Oa() {
      this.T = this.U = this.ka = this.height = this.width = 0;
      this.y = [];
      this.f = [];
      this.ea = [];
      this.Rc = this.fa = this.W = this.N = this.O = 0;
      this.ma = "void";
      this.put = "VP8IoPutHook";
      this.ac = "VP8IoSetupHook";
      this.bc = "VP8IoTeardownHook";
      this.ha = this.Kb = 0;
      this.data = [];
      this.hb = this.ib = this.da = this.o = this.j = this.va = this.v = this.Da = this.ob = this.w = 0;
      this.F = [];
      this.J = 0;
    }
    function Ce() {
      var a2 = new Be();
      null != a2 && (a2.a = 0, a2.sc = "OK", a2.cb = 0, a2.Xb = 0, oa || (oa = De));
      return a2;
    }
    function T3(a2, b, c3) {
      0 == a2.a && (a2.a = b, a2.sc = c3, a2.cb = 0);
      return 0;
    }
    function Jc(a2, b, c3) {
      return 3 <= c3 && 157 == a2[b + 0] && 1 == a2[b + 1] && 42 == a2[b + 2];
    }
    function Kc(a2, b) {
      if (null == a2)
        return 0;
      a2.a = 0;
      a2.sc = "OK";
      if (null == b)
        return T3(a2, 2, "null VP8Io passed to VP8GetHeaders()");
      var c3 = b.data;
      var d = b.w;
      var e2 = b.ha;
      if (4 > e2)
        return T3(a2, 7, "Truncated header.");
      var f4 = c3[d + 0] | c3[d + 1] << 8 | c3[d + 2] << 16;
      var g = a2.Od;
      g.Rb = !(f4 & 1);
      g.td = f4 >> 1 & 7;
      g.yd = f4 >> 4 & 1;
      g.ub = f4 >> 5;
      if (3 < g.td)
        return T3(a2, 3, "Incorrect keyframe parameters.");
      if (!g.yd)
        return T3(a2, 4, "Frame not displayable.");
      d += 3;
      e2 -= 3;
      var h2 = a2.Kc;
      if (g.Rb) {
        if (7 > e2)
          return T3(a2, 7, "cannot parse picture header");
        if (!Jc(c3, d, e2))
          return T3(a2, 3, "Bad code word");
        h2.c = (c3[d + 4] << 8 | c3[d + 3]) & 16383;
        h2.Td = c3[d + 4] >> 6;
        h2.i = (c3[d + 6] << 8 | c3[d + 5]) & 16383;
        h2.Ud = c3[d + 6] >> 6;
        d += 7;
        e2 -= 7;
        a2.za = h2.c + 15 >> 4;
        a2.Ub = h2.i + 15 >> 4;
        b.width = h2.c;
        b.height = h2.i;
        b.Da = 0;
        b.j = 0;
        b.v = 0;
        b.va = b.width;
        b.o = b.height;
        b.da = 0;
        b.ib = b.width;
        b.hb = b.height;
        b.U = b.width;
        b.T = b.height;
        f4 = a2.Pa;
        M(f4.jb, 0, 255, f4.jb.length);
        f4 = a2.Qa;
        x2(null != f4);
        f4.Cb = 0;
        f4.Bb = 0;
        f4.Fb = 1;
        M(f4.Zb, 0, 0, f4.Zb.length);
        M(f4.Lb, 0, 0, f4.Lb);
      }
      if (g.ub > e2)
        return T3(a2, 7, "bad partition length");
      f4 = a2.m;
      ma(f4, c3, d, g.ub);
      d += g.ub;
      e2 -= g.ub;
      g.Rb && (h2.Ld = G2(f4), h2.Kd = G2(f4));
      h2 = a2.Qa;
      var k = a2.Pa, l2;
      x2(null != f4);
      x2(null != h2);
      h2.Cb = G2(f4);
      if (h2.Cb) {
        h2.Bb = G2(f4);
        if (G2(f4)) {
          h2.Fb = G2(f4);
          for (l2 = 0; 4 > l2; ++l2) {
            h2.Zb[l2] = G2(f4) ? ca(f4, 7) : 0;
          }
          for (l2 = 0; 4 > l2; ++l2) {
            h2.Lb[l2] = G2(f4) ? ca(f4, 6) : 0;
          }
        }
        if (h2.Bb)
          for (l2 = 0; 3 > l2; ++l2) {
            k.jb[l2] = G2(f4) ? na(f4, 8) : 255;
          }
      } else
        h2.Bb = 0;
      if (f4.Ka)
        return T3(a2, 3, "cannot parse segment header");
      h2 = a2.ed;
      h2.zd = G2(f4);
      h2.Tb = na(f4, 6);
      h2.wb = na(f4, 3);
      h2.Pc = G2(f4);
      if (h2.Pc && G2(f4)) {
        for (k = 0; 4 > k; ++k) {
          G2(f4) && (h2.vd[k] = ca(f4, 6));
        }
        for (k = 0; 4 > k; ++k) {
          G2(f4) && (h2.od[k] = ca(f4, 6));
        }
      }
      a2.L = 0 == h2.Tb ? 0 : h2.zd ? 1 : 2;
      if (f4.Ka)
        return T3(a2, 3, "cannot parse filter header");
      l2 = d;
      var m3 = e2;
      e2 = l2;
      d = l2 + m3;
      h2 = m3;
      a2.Xb = (1 << na(a2.m, 2)) - 1;
      k = a2.Xb;
      if (m3 < 3 * k)
        c3 = 7;
      else {
        l2 += 3 * k;
        h2 -= 3 * k;
        for (m3 = 0; m3 < k; ++m3) {
          var n2 = c3[e2 + 0] | c3[e2 + 1] << 8 | c3[e2 + 2] << 16;
          n2 > h2 && (n2 = h2);
          ma(a2.Jc[+m3], c3, l2, n2);
          l2 += n2;
          h2 -= n2;
          e2 += 3;
        }
        ma(a2.Jc[+k], c3, l2, h2);
        c3 = l2 < d ? 0 : 5;
      }
      if (0 != c3)
        return T3(a2, c3, "cannot parse partitions");
      l2 = a2.m;
      c3 = na(l2, 7);
      e2 = G2(l2) ? ca(l2, 4) : 0;
      d = G2(l2) ? ca(l2, 4) : 0;
      h2 = G2(l2) ? ca(l2, 4) : 0;
      k = G2(l2) ? ca(l2, 4) : 0;
      l2 = G2(l2) ? ca(l2, 4) : 0;
      m3 = a2.Qa;
      for (n2 = 0; 4 > n2; ++n2) {
        if (m3.Cb) {
          var r2 = m3.Zb[n2];
          m3.Fb || (r2 += c3);
        } else if (0 < n2) {
          a2.pb[n2] = a2.pb[0];
          continue;
        } else
          r2 = c3;
        var q = a2.pb[n2];
        q.Sc[0] = Lb[ga(r2 + e2, 127)];
        q.Sc[1] = Mb[ga(r2 + 0, 127)];
        q.Eb[0] = 2 * Lb[ga(r2 + d, 127)];
        q.Eb[1] = 101581 * Mb[ga(r2 + h2, 127)] >> 16;
        8 > q.Eb[1] && (q.Eb[1] = 8);
        q.Qc[0] = Lb[ga(r2 + k, 117)];
        q.Qc[1] = Mb[ga(r2 + l2, 127)];
        q.lc = r2 + l2;
      }
      if (!g.Rb)
        return T3(a2, 4, "Not a key frame.");
      G2(f4);
      g = a2.Pa;
      for (c3 = 0; 4 > c3; ++c3) {
        for (e2 = 0; 8 > e2; ++e2) {
          for (d = 0; 3 > d; ++d) {
            for (h2 = 0; 11 > h2; ++h2) {
              k = K(f4, Ee[c3][e2][d][h2]) ? na(f4, 8) : Fe[c3][e2][d][h2], g.Wc[c3][e2].Yb[d][h2] = k;
            }
          }
        }
        for (e2 = 0; 17 > e2; ++e2) {
          g.Xc[c3][e2] = g.Wc[c3][Ge[e2]];
        }
      }
      a2.kc = G2(f4);
      a2.kc && (a2.Bd = na(f4, 8));
      return a2.cb = 1;
    }
    function De(a2, b, c3, d, e2, f4, g) {
      var h2 = b[e2].Yb[c3];
      for (c3 = 0; 16 > e2; ++e2) {
        if (!K(a2, h2[c3 + 0]))
          return e2;
        for (; !K(a2, h2[c3 + 1]); ) {
          if (h2 = b[++e2].Yb[0], c3 = 0, 16 == e2)
            return 16;
        }
        var k = b[e2 + 1].Yb;
        if (K(a2, h2[c3 + 2])) {
          var l2 = a2, m3 = h2, n2 = c3;
          var r2 = 0;
          if (K(l2, m3[n2 + 3])) {
            if (K(l2, m3[n2 + 6])) {
              h2 = 0;
              r2 = K(l2, m3[n2 + 8]);
              m3 = K(l2, m3[n2 + 9 + r2]);
              n2 = 2 * r2 + m3;
              r2 = 0;
              for (m3 = He[n2]; m3[h2]; ++h2) {
                r2 += r2 + K(l2, m3[h2]);
              }
              r2 += 3 + (8 << n2);
            } else
              K(l2, m3[n2 + 7]) ? (r2 = 7 + 2 * K(l2, 165), r2 += K(l2, 145)) : r2 = 5 + K(l2, 159);
          } else
            K(l2, m3[n2 + 4]) ? r2 = 3 + K(l2, m3[n2 + 5]) : r2 = 2;
          h2 = k[2];
        } else
          r2 = 1, h2 = k[1];
        k = g + Ie[e2];
        l2 = a2;
        0 > l2.b && Qa(l2);
        var m3 = l2.b, n2 = l2.Ca >> 1, q = n2 - (l2.I >> m3) >> 31;
        --l2.b;
        l2.Ca += q;
        l2.Ca |= 1;
        l2.I -= (n2 + 1 & q) << m3;
        f4[k] = ((r2 ^ q) - q) * d[(0 < e2) + 0];
      }
      return 16;
    }
    function Lc(a2) {
      var b = a2.rb[a2.sb - 1];
      b.la = 0;
      b.Na = 0;
      M(a2.zc, 0, 0, a2.zc.length);
      a2.ja = 0;
    }
    function Je(a2, b) {
      for (a2.M = 0; a2.M < a2.Va; ++a2.M) {
        var c3 = a2.Jc[a2.M & a2.Xb], d = a2.m, e2 = a2, f4;
        for (f4 = 0; f4 < e2.za; ++f4) {
          var g = d;
          var h2 = e2;
          var k = h2.Ac, l2 = h2.Bc + 4 * f4, m3 = h2.zc, n2 = h2.ya[h2.aa + f4];
          h2.Qa.Bb ? n2.$b = K(g, h2.Pa.jb[0]) ? 2 + K(g, h2.Pa.jb[2]) : K(g, h2.Pa.jb[1]) : n2.$b = 0;
          h2.kc && (n2.Ad = K(g, h2.Bd));
          n2.Za = !K(g, 145) + 0;
          if (n2.Za) {
            var r2 = n2.Ob, q = 0;
            for (h2 = 0; 4 > h2; ++h2) {
              var t2 = m3[0 + h2];
              var v2;
              for (v2 = 0; 4 > v2; ++v2) {
                t2 = Ke[k[l2 + v2]][t2];
                for (var p2 = Mc[K(g, t2[0])]; 0 < p2; ) {
                  p2 = Mc[2 * p2 + K(g, t2[p2])];
                }
                t2 = -p2;
                k[l2 + v2] = t2;
              }
              I(r2, q, k, l2, 4);
              q += 4;
              m3[0 + h2] = t2;
            }
          } else
            t2 = K(g, 156) ? K(g, 128) ? 1 : 3 : K(g, 163) ? 2 : 0, n2.Ob[0] = t2, M(k, l2, t2, 4), M(m3, 0, t2, 4);
          n2.Dd = K(g, 142) ? K(g, 114) ? K(g, 183) ? 1 : 3 : 2 : 0;
        }
        if (e2.m.Ka)
          return T3(a2, 7, "Premature end-of-partition0 encountered.");
        for (; a2.ja < a2.za; ++a2.ja) {
          d = a2;
          e2 = c3;
          g = d.rb[d.sb - 1];
          k = d.rb[d.sb + d.ja];
          f4 = d.ya[d.aa + d.ja];
          if (l2 = d.kc ? f4.Ad : 0)
            g.la = k.la = 0, f4.Za || (g.Na = k.Na = 0), f4.Hc = 0, f4.Gc = 0, f4.ia = 0;
          else {
            var u2, w, g = k, k = e2, l2 = d.Pa.Xc, m3 = d.ya[d.aa + d.ja], n2 = d.pb[m3.$b];
            h2 = m3.ad;
            r2 = 0;
            q = d.rb[d.sb - 1];
            t2 = v2 = 0;
            M(h2, r2, 0, 384);
            if (m3.Za) {
              var y3 = 0;
              var A2 = l2[3];
            } else {
              p2 = V(16);
              var E = g.Na + q.Na;
              E = oa(k, l2[1], E, n2.Eb, 0, p2, 0);
              g.Na = q.Na = (0 < E) + 0;
              if (1 < E)
                Nc(p2, 0, h2, r2);
              else {
                var B = p2[0] + 3 >> 3;
                for (p2 = 0; 256 > p2; p2 += 16) {
                  h2[r2 + p2] = B;
                }
              }
              y3 = 1;
              A2 = l2[0];
            }
            var C = g.la & 15;
            var N2 = q.la & 15;
            for (p2 = 0; 4 > p2; ++p2) {
              var z2 = N2 & 1;
              for (B = w = 0; 4 > B; ++B) {
                E = z2 + (C & 1), E = oa(k, A2, E, n2.Sc, y3, h2, r2), z2 = E > y3, C = C >> 1 | z2 << 7, w = w << 2 | (3 < E ? 3 : 1 < E ? 2 : 0 != h2[r2 + 0]), r2 += 16;
              }
              C >>= 4;
              N2 = N2 >> 1 | z2 << 7;
              v2 = (v2 << 8 | w) >>> 0;
            }
            A2 = C;
            y3 = N2 >> 4;
            for (u2 = 0; 4 > u2; u2 += 2) {
              w = 0;
              C = g.la >> 4 + u2;
              N2 = q.la >> 4 + u2;
              for (p2 = 0; 2 > p2; ++p2) {
                z2 = N2 & 1;
                for (B = 0; 2 > B; ++B) {
                  E = z2 + (C & 1), E = oa(k, l2[2], E, n2.Qc, 0, h2, r2), z2 = 0 < E, C = C >> 1 | z2 << 3, w = w << 2 | (3 < E ? 3 : 1 < E ? 2 : 0 != h2[r2 + 0]), r2 += 16;
                }
                C >>= 2;
                N2 = N2 >> 1 | z2 << 5;
              }
              t2 |= w << 4 * u2;
              A2 |= C << 4 << u2;
              y3 |= (N2 & 240) << u2;
            }
            g.la = A2;
            q.la = y3;
            m3.Hc = v2;
            m3.Gc = t2;
            m3.ia = t2 & 43690 ? 0 : n2.ia;
            l2 = !(v2 | t2);
          }
          0 < d.L && (d.wa[d.Y + d.ja] = d.gd[f4.$b][f4.Za], d.wa[d.Y + d.ja].La |= !l2);
          if (e2.Ka)
            return T3(a2, 7, "Premature end-of-file encountered.");
        }
        Lc(a2);
        c3 = a2;
        d = b;
        e2 = 1;
        f4 = c3.D;
        g = 0 < c3.L && c3.M >= c3.zb && c3.M <= c3.Va;
        if (0 == c3.Aa)
          a: {
            f4.M = c3.M, f4.uc = g, Oc(c3, f4), e2 = 1;
            w = c3.D;
            f4 = w.Nb;
            t2 = Ya[c3.L];
            g = t2 * c3.R;
            k = t2 / 2 * c3.B;
            p2 = 16 * f4 * c3.R;
            B = 8 * f4 * c3.B;
            l2 = c3.sa;
            m3 = c3.ta - g + p2;
            n2 = c3.qa;
            h2 = c3.ra - k + B;
            r2 = c3.Ha;
            q = c3.Ia - k + B;
            C = w.M;
            N2 = 0 == C;
            v2 = C >= c3.Va - 1;
            2 == c3.Aa && Oc(c3, w);
            if (w.uc)
              for (E = c3, z2 = E.D.M, x2(E.D.uc), w = E.yb; w < E.Hb; ++w) {
                var Q = E;
                y3 = w;
                A2 = z2;
                var S2 = Q.D, D3 = S2.Nb;
                u2 = Q.R;
                var S2 = S2.wa[S2.Y + y3], F = Q.sa, H2 = Q.ta + 16 * D3 * u2 + 16 * y3, J2 = S2.dd, G3 = S2.tc;
                if (0 != G3)
                  if (x2(3 <= G3), 1 == Q.L)
                    0 < y3 && Pc(F, H2, u2, G3 + 4), S2.La && Qc(F, H2, u2, G3), 0 < A2 && Rc(F, H2, u2, G3 + 4), S2.La && Sc2(F, H2, u2, G3);
                  else {
                    var L2 = Q.B, O3 = Q.qa, P2 = Q.ra + 8 * D3 * L2 + 8 * y3, R2 = Q.Ha, Q = Q.Ia + 8 * D3 * L2 + 8 * y3, D3 = S2.ld;
                    0 < y3 && (Tc2(F, H2, u2, G3 + 4, J2, D3), Uc(O3, P2, R2, Q, L2, G3 + 4, J2, D3));
                    S2.La && (Vc(F, H2, u2, G3, J2, D3), Wc(O3, P2, R2, Q, L2, G3, J2, D3));
                    0 < A2 && (Xc(F, H2, u2, G3 + 4, J2, D3), Yc(O3, P2, R2, Q, L2, G3 + 4, J2, D3));
                    S2.La && (Zc(F, H2, u2, G3, J2, D3), $c(O3, P2, R2, Q, L2, G3, J2, D3));
                  }
              }
            c3.ia && alert("todo:DitherRow");
            if (null != d.put) {
              w = 16 * C;
              C = 16 * (C + 1);
              N2 ? (d.y = c3.sa, d.O = c3.ta + p2, d.f = c3.qa, d.N = c3.ra + B, d.ea = c3.Ha, d.W = c3.Ia + B) : (w -= t2, d.y = l2, d.O = m3, d.f = n2, d.N = h2, d.ea = r2, d.W = q);
              v2 || (C -= t2);
              C > d.o && (C = d.o);
              d.F = null;
              d.J = null;
              if (null != c3.Fa && 0 < c3.Fa.length && w < C && (d.J = Le(c3, d, w, C - w), d.F = c3.mb, null == d.F && 0 == d.F.length)) {
                e2 = T3(c3, 3, "Could not decode alpha data.");
                break a;
              }
              w < d.j && (t2 = d.j - w, w = d.j, x2(!(t2 & 1)), d.O += c3.R * t2, d.N += c3.B * (t2 >> 1), d.W += c3.B * (t2 >> 1), null != d.F && (d.J += d.width * t2));
              w < C && (d.O += d.v, d.N += d.v >> 1, d.W += d.v >> 1, null != d.F && (d.J += d.v), d.ka = w - d.j, d.U = d.va - d.v, d.T = C - w, e2 = d.put(d));
            }
            f4 + 1 != c3.Ic || v2 || (I(c3.sa, c3.ta - g, l2, m3 + 16 * c3.R, g), I(c3.qa, c3.ra - k, n2, h2 + 8 * c3.B, k), I(c3.Ha, c3.Ia - k, r2, q + 8 * c3.B, k));
          }
        if (!e2)
          return T3(a2, 6, "Output aborted.");
      }
      return 1;
    }
    function Me(a2, b) {
      if (null == a2)
        return 0;
      if (null == b)
        return T3(a2, 2, "NULL VP8Io parameter in VP8Decode().");
      if (!a2.cb && !Kc(a2, b))
        return 0;
      x2(a2.cb);
      if (null == b.ac || b.ac(b)) {
        b.ob && (a2.L = 0);
        var c3 = Ya[a2.L];
        2 == a2.L ? (a2.yb = 0, a2.zb = 0) : (a2.yb = b.v - c3 >> 4, a2.zb = b.j - c3 >> 4, 0 > a2.yb && (a2.yb = 0), 0 > a2.zb && (a2.zb = 0));
        a2.Va = b.o + 15 + c3 >> 4;
        a2.Hb = b.va + 15 + c3 >> 4;
        a2.Hb > a2.za && (a2.Hb = a2.za);
        a2.Va > a2.Ub && (a2.Va = a2.Ub);
        if (0 < a2.L) {
          var d = a2.ed;
          for (c3 = 0; 4 > c3; ++c3) {
            var e2;
            if (a2.Qa.Cb) {
              var f4 = a2.Qa.Lb[c3];
              a2.Qa.Fb || (f4 += d.Tb);
            } else
              f4 = d.Tb;
            for (e2 = 0; 1 >= e2; ++e2) {
              var g = a2.gd[c3][e2], h2 = f4;
              d.Pc && (h2 += d.vd[0], e2 && (h2 += d.od[0]));
              h2 = 0 > h2 ? 0 : 63 < h2 ? 63 : h2;
              if (0 < h2) {
                var k = h2;
                0 < d.wb && (k = 4 < d.wb ? k >> 2 : k >> 1, k > 9 - d.wb && (k = 9 - d.wb));
                1 > k && (k = 1);
                g.dd = k;
                g.tc = 2 * h2 + k;
                g.ld = 40 <= h2 ? 2 : 15 <= h2 ? 1 : 0;
              } else
                g.tc = 0;
              g.La = e2;
            }
          }
        }
        c3 = 0;
      } else
        T3(a2, 6, "Frame setup failed"), c3 = a2.a;
      if (c3 = 0 == c3) {
        if (c3) {
          a2.$c = 0;
          0 < a2.Aa || (a2.Ic = Ne);
          b: {
            c3 = a2.Ic;
            var k = a2.za, d = 4 * k, l2 = 32 * k, m3 = k + 1, n2 = 0 < a2.L ? k * (0 < a2.Aa ? 2 : 1) : 0, r2 = (2 == a2.Aa ? 2 : 1) * k;
            e2 = 3 * (16 * c3 + Ya[a2.L]) / 2 * l2;
            f4 = null != a2.Fa && 0 < a2.Fa.length ? a2.Kc.c * a2.Kc.i : 0;
            g = d + 832 + e2 + f4;
            if (g != g)
              c3 = 0;
            else {
              if (g > a2.Vb) {
                a2.Vb = 0;
                a2.Ec = V(g);
                a2.Fc = 0;
                if (null == a2.Ec) {
                  c3 = T3(a2, 1, "no memory during frame initialization.");
                  break b;
                }
                a2.Vb = g;
              }
              g = a2.Ec;
              h2 = a2.Fc;
              a2.Ac = g;
              a2.Bc = h2;
              h2 += d;
              a2.Gd = wa(l2, Ic);
              a2.Hd = 0;
              a2.rb = wa(m3 + 1, Hc);
              a2.sb = 1;
              a2.wa = n2 ? wa(n2, Xa) : null;
              a2.Y = 0;
              a2.D.Nb = 0;
              a2.D.wa = a2.wa;
              a2.D.Y = a2.Y;
              0 < a2.Aa && (a2.D.Y += k);
              x2(true);
              a2.oc = g;
              a2.pc = h2;
              h2 += 832;
              a2.ya = wa(r2, Kb);
              a2.aa = 0;
              a2.D.ya = a2.ya;
              a2.D.aa = a2.aa;
              2 == a2.Aa && (a2.D.aa += k);
              a2.R = 16 * k;
              a2.B = 8 * k;
              l2 = Ya[a2.L];
              k = l2 * a2.R;
              l2 = l2 / 2 * a2.B;
              a2.sa = g;
              a2.ta = h2 + k;
              a2.qa = a2.sa;
              a2.ra = a2.ta + 16 * c3 * a2.R + l2;
              a2.Ha = a2.qa;
              a2.Ia = a2.ra + 8 * c3 * a2.B + l2;
              a2.$c = 0;
              h2 += e2;
              a2.mb = f4 ? g : null;
              a2.nb = f4 ? h2 : null;
              x2(h2 + f4 <= a2.Fc + a2.Vb);
              Lc(a2);
              M(a2.Ac, a2.Bc, 0, d);
              c3 = 1;
            }
          }
          if (c3) {
            b.ka = 0;
            b.y = a2.sa;
            b.O = a2.ta;
            b.f = a2.qa;
            b.N = a2.ra;
            b.ea = a2.Ha;
            b.Vd = a2.Ia;
            b.fa = a2.R;
            b.Rc = a2.B;
            b.F = null;
            b.J = 0;
            if (!ad) {
              for (c3 = -255; 255 >= c3; ++c3) {
                bd[255 + c3] = 0 > c3 ? -c3 : c3;
              }
              for (c3 = -1020; 1020 >= c3; ++c3) {
                cd[1020 + c3] = -128 > c3 ? -128 : 127 < c3 ? 127 : c3;
              }
              for (c3 = -112; 112 >= c3; ++c3) {
                dd[112 + c3] = -16 > c3 ? -16 : 15 < c3 ? 15 : c3;
              }
              for (c3 = -255; 510 >= c3; ++c3) {
                ed[255 + c3] = 0 > c3 ? 0 : 255 < c3 ? 255 : c3;
              }
              ad = 1;
            }
            Nc = Oe;
            Za = Pe;
            Nb = Qe;
            pa = Re;
            Ob = Se;
            fd2 = Te;
            Xc = Ue;
            Tc2 = Ve;
            Yc = We;
            Uc = Xe;
            Zc = Ye;
            Vc = Ze;
            $c = $e;
            Wc = af;
            Rc = gd;
            Pc = hd;
            Sc2 = bf;
            Qc = cf;
            W[0] = df;
            W[1] = ef;
            W[2] = ff2;
            W[3] = gf;
            W[4] = hf;
            W[5] = jf;
            W[6] = kf;
            W[7] = lf;
            W[8] = mf;
            W[9] = nf;
            Y[0] = of;
            Y[1] = pf;
            Y[2] = qf;
            Y[3] = rf;
            Y[4] = sf;
            Y[5] = tf;
            Y[6] = uf;
            ka[0] = vf;
            ka[1] = wf;
            ka[2] = xf;
            ka[3] = yf;
            ka[4] = zf;
            ka[5] = Af;
            ka[6] = Bf;
            c3 = 1;
          } else
            c3 = 0;
        }
        c3 && (c3 = Je(a2, b));
        null != b.bc && b.bc(b);
        c3 &= 1;
      }
      if (!c3)
        return 0;
      a2.cb = 0;
      return c3;
    }
    function qa(a2, b, c3, d, e2) {
      e2 = a2[b + c3 + 32 * d] + (e2 >> 3);
      a2[b + c3 + 32 * d] = e2 & -256 ? 0 > e2 ? 0 : 255 : e2;
    }
    function kb(a2, b, c3, d, e2, f4) {
      qa(a2, b, 0, c3, d + e2);
      qa(a2, b, 1, c3, d + f4);
      qa(a2, b, 2, c3, d - f4);
      qa(a2, b, 3, c3, d - e2);
    }
    function da(a2) {
      return (20091 * a2 >> 16) + a2;
    }
    function id(a2, b, c3, d) {
      var e2 = 0, f4;
      var g = V(16);
      for (f4 = 0; 4 > f4; ++f4) {
        var h2 = a2[b + 0] + a2[b + 8];
        var k = a2[b + 0] - a2[b + 8];
        var l2 = (35468 * a2[b + 4] >> 16) - da(a2[b + 12]);
        var m3 = da(a2[b + 4]) + (35468 * a2[b + 12] >> 16);
        g[e2 + 0] = h2 + m3;
        g[e2 + 1] = k + l2;
        g[e2 + 2] = k - l2;
        g[e2 + 3] = h2 - m3;
        e2 += 4;
        b++;
      }
      for (f4 = e2 = 0; 4 > f4; ++f4) {
        a2 = g[e2 + 0] + 4, h2 = a2 + g[e2 + 8], k = a2 - g[e2 + 8], l2 = (35468 * g[e2 + 4] >> 16) - da(g[e2 + 12]), m3 = da(g[e2 + 4]) + (35468 * g[e2 + 12] >> 16), qa(c3, d, 0, 0, h2 + m3), qa(c3, d, 1, 0, k + l2), qa(c3, d, 2, 0, k - l2), qa(c3, d, 3, 0, h2 - m3), e2++, d += 32;
      }
    }
    function Te(a2, b, c3, d) {
      var e2 = a2[b + 0] + 4, f4 = 35468 * a2[b + 4] >> 16, g = da(a2[b + 4]), h2 = 35468 * a2[b + 1] >> 16;
      a2 = da(a2[b + 1]);
      kb(c3, d, 0, e2 + g, a2, h2);
      kb(c3, d, 1, e2 + f4, a2, h2);
      kb(c3, d, 2, e2 - f4, a2, h2);
      kb(c3, d, 3, e2 - g, a2, h2);
    }
    function Pe(a2, b, c3, d, e2) {
      id(a2, b, c3, d);
      e2 && id(a2, b + 16, c3, d + 4);
    }
    function Qe(a2, b, c3, d) {
      Za(a2, b + 0, c3, d, 1);
      Za(a2, b + 32, c3, d + 128, 1);
    }
    function Re(a2, b, c3, d) {
      a2 = a2[b + 0] + 4;
      var e2;
      for (e2 = 0; 4 > e2; ++e2) {
        for (b = 0; 4 > b; ++b) {
          qa(c3, d, b, e2, a2);
        }
      }
    }
    function Se(a2, b, c3, d) {
      a2[b + 0] && pa(a2, b + 0, c3, d);
      a2[b + 16] && pa(a2, b + 16, c3, d + 4);
      a2[b + 32] && pa(a2, b + 32, c3, d + 128);
      a2[b + 48] && pa(a2, b + 48, c3, d + 128 + 4);
    }
    function Oe(a2, b, c3, d) {
      var e2 = V(16), f4;
      for (f4 = 0; 4 > f4; ++f4) {
        var g = a2[b + 0 + f4] + a2[b + 12 + f4];
        var h2 = a2[b + 4 + f4] + a2[b + 8 + f4];
        var k = a2[b + 4 + f4] - a2[b + 8 + f4];
        var l2 = a2[b + 0 + f4] - a2[b + 12 + f4];
        e2[0 + f4] = g + h2;
        e2[8 + f4] = g - h2;
        e2[4 + f4] = l2 + k;
        e2[12 + f4] = l2 - k;
      }
      for (f4 = 0; 4 > f4; ++f4) {
        a2 = e2[0 + 4 * f4] + 3, g = a2 + e2[3 + 4 * f4], h2 = e2[1 + 4 * f4] + e2[2 + 4 * f4], k = e2[1 + 4 * f4] - e2[2 + 4 * f4], l2 = a2 - e2[3 + 4 * f4], c3[d + 0] = g + h2 >> 3, c3[d + 16] = l2 + k >> 3, c3[d + 32] = g - h2 >> 3, c3[d + 48] = l2 - k >> 3, d += 64;
      }
    }
    function Pb(a2, b, c3) {
      var d = b - 32, e2 = R, f4 = 255 - a2[d - 1], g;
      for (g = 0; g < c3; ++g) {
        var h2 = e2, k = f4 + a2[b - 1], l2;
        for (l2 = 0; l2 < c3; ++l2) {
          a2[b + l2] = h2[k + a2[d + l2]];
        }
        b += 32;
      }
    }
    function ef(a2, b) {
      Pb(a2, b, 4);
    }
    function wf(a2, b) {
      Pb(a2, b, 8);
    }
    function pf(a2, b) {
      Pb(a2, b, 16);
    }
    function qf(a2, b) {
      var c3;
      for (c3 = 0; 16 > c3; ++c3) {
        I(a2, b + 32 * c3, a2, b - 32, 16);
      }
    }
    function rf(a2, b) {
      var c3;
      for (c3 = 16; 0 < c3; --c3) {
        M(a2, b, a2[b - 1], 16), b += 32;
      }
    }
    function $a(a2, b, c3) {
      var d;
      for (d = 0; 16 > d; ++d) {
        M(b, c3 + 32 * d, a2, 16);
      }
    }
    function of(a2, b) {
      var c3 = 16, d;
      for (d = 0; 16 > d; ++d) {
        c3 += a2[b - 1 + 32 * d] + a2[b + d - 32];
      }
      $a(c3 >> 5, a2, b);
    }
    function sf(a2, b) {
      var c3 = 8, d;
      for (d = 0; 16 > d; ++d) {
        c3 += a2[b - 1 + 32 * d];
      }
      $a(c3 >> 4, a2, b);
    }
    function tf(a2, b) {
      var c3 = 8, d;
      for (d = 0; 16 > d; ++d) {
        c3 += a2[b + d - 32];
      }
      $a(c3 >> 4, a2, b);
    }
    function uf(a2, b) {
      $a(128, a2, b);
    }
    function z(a2, b, c3) {
      return a2 + 2 * b + c3 + 2 >> 2;
    }
    function ff2(a2, b) {
      var c3 = b - 32, c3 = new Uint8Array([z(a2[c3 - 1], a2[c3 + 0], a2[c3 + 1]), z(a2[c3 + 0], a2[c3 + 1], a2[c3 + 2]), z(a2[c3 + 1], a2[c3 + 2], a2[c3 + 3]), z(a2[c3 + 2], a2[c3 + 3], a2[c3 + 4])]), d;
      for (d = 0; 4 > d; ++d) {
        I(a2, b + 32 * d, c3, 0, c3.length);
      }
    }
    function gf(a2, b) {
      var c3 = a2[b - 1], d = a2[b - 1 + 32], e2 = a2[b - 1 + 64], f4 = a2[b - 1 + 96];
      ra(a2, b + 0, 16843009 * z(a2[b - 1 - 32], c3, d));
      ra(a2, b + 32, 16843009 * z(c3, d, e2));
      ra(a2, b + 64, 16843009 * z(d, e2, f4));
      ra(a2, b + 96, 16843009 * z(e2, f4, f4));
    }
    function df(a2, b) {
      var c3 = 4, d;
      for (d = 0; 4 > d; ++d) {
        c3 += a2[b + d - 32] + a2[b - 1 + 32 * d];
      }
      c3 >>= 3;
      for (d = 0; 4 > d; ++d) {
        M(a2, b + 32 * d, c3, 4);
      }
    }
    function hf(a2, b) {
      var c3 = a2[b - 1 + 0], d = a2[b - 1 + 32], e2 = a2[b - 1 + 64], f4 = a2[b - 1 - 32], g = a2[b + 0 - 32], h2 = a2[b + 1 - 32], k = a2[b + 2 - 32], l2 = a2[b + 3 - 32];
      a2[b + 0 + 96] = z(d, e2, a2[b - 1 + 96]);
      a2[b + 1 + 96] = a2[b + 0 + 64] = z(c3, d, e2);
      a2[b + 2 + 96] = a2[b + 1 + 64] = a2[b + 0 + 32] = z(f4, c3, d);
      a2[b + 3 + 96] = a2[b + 2 + 64] = a2[b + 1 + 32] = a2[b + 0 + 0] = z(g, f4, c3);
      a2[b + 3 + 64] = a2[b + 2 + 32] = a2[b + 1 + 0] = z(h2, g, f4);
      a2[b + 3 + 32] = a2[b + 2 + 0] = z(k, h2, g);
      a2[b + 3 + 0] = z(l2, k, h2);
    }
    function kf(a2, b) {
      var c3 = a2[b + 1 - 32], d = a2[b + 2 - 32], e2 = a2[b + 3 - 32], f4 = a2[b + 4 - 32], g = a2[b + 5 - 32], h2 = a2[b + 6 - 32], k = a2[b + 7 - 32];
      a2[b + 0 + 0] = z(a2[b + 0 - 32], c3, d);
      a2[b + 1 + 0] = a2[b + 0 + 32] = z(c3, d, e2);
      a2[b + 2 + 0] = a2[b + 1 + 32] = a2[b + 0 + 64] = z(d, e2, f4);
      a2[b + 3 + 0] = a2[b + 2 + 32] = a2[b + 1 + 64] = a2[b + 0 + 96] = z(e2, f4, g);
      a2[b + 3 + 32] = a2[b + 2 + 64] = a2[b + 1 + 96] = z(f4, g, h2);
      a2[b + 3 + 64] = a2[b + 2 + 96] = z(g, h2, k);
      a2[b + 3 + 96] = z(h2, k, k);
    }
    function jf(a2, b) {
      var c3 = a2[b - 1 + 0], d = a2[b - 1 + 32], e2 = a2[b - 1 + 64], f4 = a2[b - 1 - 32], g = a2[b + 0 - 32], h2 = a2[b + 1 - 32], k = a2[b + 2 - 32], l2 = a2[b + 3 - 32];
      a2[b + 0 + 0] = a2[b + 1 + 64] = f4 + g + 1 >> 1;
      a2[b + 1 + 0] = a2[b + 2 + 64] = g + h2 + 1 >> 1;
      a2[b + 2 + 0] = a2[b + 3 + 64] = h2 + k + 1 >> 1;
      a2[b + 3 + 0] = k + l2 + 1 >> 1;
      a2[b + 0 + 96] = z(e2, d, c3);
      a2[b + 0 + 64] = z(d, c3, f4);
      a2[b + 0 + 32] = a2[b + 1 + 96] = z(c3, f4, g);
      a2[b + 1 + 32] = a2[b + 2 + 96] = z(f4, g, h2);
      a2[b + 2 + 32] = a2[b + 3 + 96] = z(g, h2, k);
      a2[b + 3 + 32] = z(h2, k, l2);
    }
    function lf(a2, b) {
      var c3 = a2[b + 0 - 32], d = a2[b + 1 - 32], e2 = a2[b + 2 - 32], f4 = a2[b + 3 - 32], g = a2[b + 4 - 32], h2 = a2[b + 5 - 32], k = a2[b + 6 - 32], l2 = a2[b + 7 - 32];
      a2[b + 0 + 0] = c3 + d + 1 >> 1;
      a2[b + 1 + 0] = a2[b + 0 + 64] = d + e2 + 1 >> 1;
      a2[b + 2 + 0] = a2[b + 1 + 64] = e2 + f4 + 1 >> 1;
      a2[b + 3 + 0] = a2[b + 2 + 64] = f4 + g + 1 >> 1;
      a2[b + 0 + 32] = z(c3, d, e2);
      a2[b + 1 + 32] = a2[b + 0 + 96] = z(d, e2, f4);
      a2[b + 2 + 32] = a2[b + 1 + 96] = z(e2, f4, g);
      a2[b + 3 + 32] = a2[b + 2 + 96] = z(f4, g, h2);
      a2[b + 3 + 64] = z(g, h2, k);
      a2[b + 3 + 96] = z(h2, k, l2);
    }
    function nf(a2, b) {
      var c3 = a2[b - 1 + 0], d = a2[b - 1 + 32], e2 = a2[b - 1 + 64], f4 = a2[b - 1 + 96];
      a2[b + 0 + 0] = c3 + d + 1 >> 1;
      a2[b + 2 + 0] = a2[b + 0 + 32] = d + e2 + 1 >> 1;
      a2[b + 2 + 32] = a2[b + 0 + 64] = e2 + f4 + 1 >> 1;
      a2[b + 1 + 0] = z(c3, d, e2);
      a2[b + 3 + 0] = a2[b + 1 + 32] = z(d, e2, f4);
      a2[b + 3 + 32] = a2[b + 1 + 64] = z(e2, f4, f4);
      a2[b + 3 + 64] = a2[b + 2 + 64] = a2[b + 0 + 96] = a2[b + 1 + 96] = a2[b + 2 + 96] = a2[b + 3 + 96] = f4;
    }
    function mf(a2, b) {
      var c3 = a2[b - 1 + 0], d = a2[b - 1 + 32], e2 = a2[b - 1 + 64], f4 = a2[b - 1 + 96], g = a2[b - 1 - 32], h2 = a2[b + 0 - 32], k = a2[b + 1 - 32], l2 = a2[b + 2 - 32];
      a2[b + 0 + 0] = a2[b + 2 + 32] = c3 + g + 1 >> 1;
      a2[b + 0 + 32] = a2[b + 2 + 64] = d + c3 + 1 >> 1;
      a2[b + 0 + 64] = a2[b + 2 + 96] = e2 + d + 1 >> 1;
      a2[b + 0 + 96] = f4 + e2 + 1 >> 1;
      a2[b + 3 + 0] = z(h2, k, l2);
      a2[b + 2 + 0] = z(g, h2, k);
      a2[b + 1 + 0] = a2[b + 3 + 32] = z(c3, g, h2);
      a2[b + 1 + 32] = a2[b + 3 + 64] = z(d, c3, g);
      a2[b + 1 + 64] = a2[b + 3 + 96] = z(e2, d, c3);
      a2[b + 1 + 96] = z(f4, e2, d);
    }
    function xf(a2, b) {
      var c3;
      for (c3 = 0; 8 > c3; ++c3) {
        I(a2, b + 32 * c3, a2, b - 32, 8);
      }
    }
    function yf(a2, b) {
      var c3;
      for (c3 = 0; 8 > c3; ++c3) {
        M(a2, b, a2[b - 1], 8), b += 32;
      }
    }
    function lb(a2, b, c3) {
      var d;
      for (d = 0; 8 > d; ++d) {
        M(b, c3 + 32 * d, a2, 8);
      }
    }
    function vf(a2, b) {
      var c3 = 8, d;
      for (d = 0; 8 > d; ++d) {
        c3 += a2[b + d - 32] + a2[b - 1 + 32 * d];
      }
      lb(c3 >> 4, a2, b);
    }
    function Af(a2, b) {
      var c3 = 4, d;
      for (d = 0; 8 > d; ++d) {
        c3 += a2[b + d - 32];
      }
      lb(c3 >> 3, a2, b);
    }
    function zf(a2, b) {
      var c3 = 4, d;
      for (d = 0; 8 > d; ++d) {
        c3 += a2[b - 1 + 32 * d];
      }
      lb(c3 >> 3, a2, b);
    }
    function Bf(a2, b) {
      lb(128, a2, b);
    }
    function ab(a2, b, c3) {
      var d = a2[b - c3], e2 = a2[b + 0], f4 = 3 * (e2 - d) + Qb[1020 + a2[b - 2 * c3] - a2[b + c3]], g = mb[112 + (f4 + 4 >> 3)];
      a2[b - c3] = R[255 + d + mb[112 + (f4 + 3 >> 3)]];
      a2[b + 0] = R[255 + e2 - g];
    }
    function jd(a2, b, c3, d) {
      var e2 = a2[b + 0], f4 = a2[b + c3];
      return U[255 + a2[b - 2 * c3] - a2[b - c3]] > d || U[255 + f4 - e2] > d;
    }
    function kd(a2, b, c3, d) {
      return 4 * U[255 + a2[b - c3] - a2[b + 0]] + U[255 + a2[b - 2 * c3] - a2[b + c3]] <= d;
    }
    function ld(a2, b, c3, d, e2) {
      var f4 = a2[b - 3 * c3], g = a2[b - 2 * c3], h2 = a2[b - c3], k = a2[b + 0], l2 = a2[b + c3], m3 = a2[b + 2 * c3], n2 = a2[b + 3 * c3];
      return 4 * U[255 + h2 - k] + U[255 + g - l2] > d ? 0 : U[255 + a2[b - 4 * c3] - f4] <= e2 && U[255 + f4 - g] <= e2 && U[255 + g - h2] <= e2 && U[255 + n2 - m3] <= e2 && U[255 + m3 - l2] <= e2 && U[255 + l2 - k] <= e2;
    }
    function gd(a2, b, c3, d) {
      var e2 = 2 * d + 1;
      for (d = 0; 16 > d; ++d) {
        kd(a2, b + d, c3, e2) && ab(a2, b + d, c3);
      }
    }
    function hd(a2, b, c3, d) {
      var e2 = 2 * d + 1;
      for (d = 0; 16 > d; ++d) {
        kd(a2, b + d * c3, 1, e2) && ab(a2, b + d * c3, 1);
      }
    }
    function bf(a2, b, c3, d) {
      var e2;
      for (e2 = 3; 0 < e2; --e2) {
        b += 4 * c3, gd(a2, b, c3, d);
      }
    }
    function cf(a2, b, c3, d) {
      var e2;
      for (e2 = 3; 0 < e2; --e2) {
        b += 4, hd(a2, b, c3, d);
      }
    }
    function ea(a2, b, c3, d, e2, f4, g, h2) {
      for (f4 = 2 * f4 + 1; 0 < e2--; ) {
        if (ld(a2, b, c3, f4, g))
          if (jd(a2, b, c3, h2))
            ab(a2, b, c3);
          else {
            var k = a2, l2 = b, m3 = c3, n2 = k[l2 - 2 * m3], r2 = k[l2 - m3], q = k[l2 + 0], t2 = k[l2 + m3], v2 = k[l2 + 2 * m3], p2 = Qb[1020 + 3 * (q - r2) + Qb[1020 + n2 - t2]], u2 = 27 * p2 + 63 >> 7, w = 18 * p2 + 63 >> 7, p2 = 9 * p2 + 63 >> 7;
            k[l2 - 3 * m3] = R[255 + k[l2 - 3 * m3] + p2];
            k[l2 - 2 * m3] = R[255 + n2 + w];
            k[l2 - m3] = R[255 + r2 + u2];
            k[l2 + 0] = R[255 + q - u2];
            k[l2 + m3] = R[255 + t2 - w];
            k[l2 + 2 * m3] = R[255 + v2 - p2];
          }
        b += d;
      }
    }
    function Fa(a2, b, c3, d, e2, f4, g, h2) {
      for (f4 = 2 * f4 + 1; 0 < e2--; ) {
        if (ld(a2, b, c3, f4, g))
          if (jd(a2, b, c3, h2))
            ab(a2, b, c3);
          else {
            var k = a2, l2 = b, m3 = c3, n2 = k[l2 - m3], r2 = k[l2 + 0], q = k[l2 + m3], t2 = 3 * (r2 - n2), v2 = mb[112 + (t2 + 4 >> 3)], t2 = mb[112 + (t2 + 3 >> 3)], p2 = v2 + 1 >> 1;
            k[l2 - 2 * m3] = R[255 + k[l2 - 2 * m3] + p2];
            k[l2 - m3] = R[255 + n2 + t2];
            k[l2 + 0] = R[255 + r2 - v2];
            k[l2 + m3] = R[255 + q - p2];
          }
        b += d;
      }
    }
    function Ue(a2, b, c3, d, e2, f4) {
      ea(a2, b, c3, 1, 16, d, e2, f4);
    }
    function Ve(a2, b, c3, d, e2, f4) {
      ea(a2, b, 1, c3, 16, d, e2, f4);
    }
    function Ye(a2, b, c3, d, e2, f4) {
      var g;
      for (g = 3; 0 < g; --g) {
        b += 4 * c3, Fa(a2, b, c3, 1, 16, d, e2, f4);
      }
    }
    function Ze(a2, b, c3, d, e2, f4) {
      var g;
      for (g = 3; 0 < g; --g) {
        b += 4, Fa(a2, b, 1, c3, 16, d, e2, f4);
      }
    }
    function We(a2, b, c3, d, e2, f4, g, h2) {
      ea(a2, b, e2, 1, 8, f4, g, h2);
      ea(c3, d, e2, 1, 8, f4, g, h2);
    }
    function Xe(a2, b, c3, d, e2, f4, g, h2) {
      ea(a2, b, 1, e2, 8, f4, g, h2);
      ea(c3, d, 1, e2, 8, f4, g, h2);
    }
    function $e(a2, b, c3, d, e2, f4, g, h2) {
      Fa(a2, b + 4 * e2, e2, 1, 8, f4, g, h2);
      Fa(c3, d + 4 * e2, e2, 1, 8, f4, g, h2);
    }
    function af(a2, b, c3, d, e2, f4, g, h2) {
      Fa(a2, b + 4, 1, e2, 8, f4, g, h2);
      Fa(c3, d + 4, 1, e2, 8, f4, g, h2);
    }
    function Cf() {
      this.ba = new Cb();
      this.ec = [];
      this.cc = [];
      this.Mc = [];
      this.Dc = this.Nc = this.dc = this.fc = 0;
      this.Oa = new Ud();
      this.memory = 0;
      this.Ib = "OutputFunc";
      this.Jb = "OutputAlphaFunc";
      this.Nd = "OutputRowFunc";
    }
    function md() {
      this.data = [];
      this.offset = this.kd = this.ha = this.w = 0;
      this.na = [];
      this.xa = this.gb = this.Ja = this.Sa = this.P = 0;
    }
    function Df() {
      this.nc = this.Ea = this.b = this.hc = 0;
      this.K = [];
      this.w = 0;
    }
    function Ef() {
      this.ua = 0;
      this.Wa = new ac();
      this.vb = new ac();
      this.md = this.xc = this.wc = 0;
      this.vc = [];
      this.Wb = 0;
      this.Ya = new Ub();
      this.yc = new O2();
    }
    function je() {
      this.xb = this.a = 0;
      this.l = new Oa();
      this.ca = new Cb();
      this.V = [];
      this.Ba = 0;
      this.Ta = [];
      this.Ua = 0;
      this.m = new Ra();
      this.Pb = 0;
      this.wd = new Ra();
      this.Ma = this.$ = this.C = this.i = this.c = this.xd = 0;
      this.s = new Ef();
      this.ab = 0;
      this.gc = wa(4, Df);
      this.Oc = 0;
    }
    function Ff() {
      this.Lc = this.Z = this.$a = this.i = this.c = 0;
      this.l = new Oa();
      this.ic = 0;
      this.ca = [];
      this.tb = 0;
      this.qd = null;
      this.rd = 0;
    }
    function Rb(a2, b, c3, d, e2, f4, g) {
      a2 = null == a2 ? 0 : a2[b + 0];
      for (b = 0; b < g; ++b) {
        e2[f4 + b] = a2 + c3[d + b] & 255, a2 = e2[f4 + b];
      }
    }
    function Gf(a2, b, c3, d, e2, f4, g) {
      if (null == a2)
        Rb(null, null, c3, d, e2, f4, g);
      else {
        var h2;
        for (h2 = 0; h2 < g; ++h2) {
          e2[f4 + h2] = a2[b + h2] + c3[d + h2] & 255;
        }
      }
    }
    function Hf(a2, b, c3, d, e2, f4, g) {
      if (null == a2)
        Rb(null, null, c3, d, e2, f4, g);
      else {
        var h2 = a2[b + 0], k = h2, l2 = h2, m3;
        for (m3 = 0; m3 < g; ++m3) {
          h2 = a2[b + m3], k = l2 + h2 - k, l2 = c3[d + m3] + (k & -256 ? 0 > k ? 0 : 255 : k) & 255, k = h2, e2[f4 + m3] = l2;
        }
      }
    }
    function Le(a2, b, c3, d) {
      var e2 = b.width, f4 = b.o;
      x2(null != a2 && null != b);
      if (0 > c3 || 0 >= d || c3 + d > f4)
        return null;
      if (!a2.Cc) {
        if (null == a2.ga) {
          a2.ga = new Ff();
          var g;
          (g = null == a2.ga) || (g = b.width * b.o, x2(0 == a2.Gb.length), a2.Gb = V(g), a2.Uc = 0, null == a2.Gb ? g = 0 : (a2.mb = a2.Gb, a2.nb = a2.Uc, a2.rc = null, g = 1), g = !g);
          if (!g) {
            g = a2.ga;
            var h2 = a2.Fa, k = a2.P, l2 = a2.qc, m3 = a2.mb, n2 = a2.nb, r2 = k + 1, q = l2 - 1, t2 = g.l;
            x2(null != h2 && null != m3 && null != b);
            ia[0] = null;
            ia[1] = Rb;
            ia[2] = Gf;
            ia[3] = Hf;
            g.ca = m3;
            g.tb = n2;
            g.c = b.width;
            g.i = b.height;
            x2(0 < g.c && 0 < g.i);
            if (1 >= l2)
              b = 0;
            else if (g.$a = h2[k + 0] >> 0 & 3, g.Z = h2[k + 0] >> 2 & 3, g.Lc = h2[k + 0] >> 4 & 3, k = h2[k + 0] >> 6 & 3, 0 > g.$a || 1 < g.$a || 4 <= g.Z || 1 < g.Lc || k)
              b = 0;
            else if (t2.put = kc, t2.ac = gc, t2.bc = lc2, t2.ma = g, t2.width = b.width, t2.height = b.height, t2.Da = b.Da, t2.v = b.v, t2.va = b.va, t2.j = b.j, t2.o = b.o, g.$a)
              b: {
                x2(1 == g.$a), b = Bc();
                c:
                  for (; ; ) {
                    if (null == b) {
                      b = 0;
                      break b;
                    }
                    x2(null != g);
                    g.mc = b;
                    b.c = g.c;
                    b.i = g.i;
                    b.l = g.l;
                    b.l.ma = g;
                    b.l.width = g.c;
                    b.l.height = g.i;
                    b.a = 0;
                    cb(b.m, h2, r2, q);
                    if (!rb(g.c, g.i, 1, b, null))
                      break c;
                    1 == b.ab && 3 == b.gc[0].hc && yc(b.s) ? (g.ic = 1, h2 = b.c * b.i, b.Ta = null, b.Ua = 0, b.V = V(h2), b.Ba = 0, null == b.V ? (b.a = 1, b = 0) : b = 1) : (g.ic = 0, b = Ec(b, g.c));
                    if (!b)
                      break c;
                    b = 1;
                    break b;
                  }
                g.mc = null;
                b = 0;
              }
            else
              b = q >= g.c * g.i;
            g = !b;
          }
          if (g)
            return null;
          1 != a2.ga.Lc ? a2.Ga = 0 : d = f4 - c3;
        }
        x2(null != a2.ga);
        x2(c3 + d <= f4);
        a: {
          h2 = a2.ga;
          b = h2.c;
          f4 = h2.l.o;
          if (0 == h2.$a) {
            r2 = a2.rc;
            q = a2.Vc;
            t2 = a2.Fa;
            k = a2.P + 1 + c3 * b;
            l2 = a2.mb;
            m3 = a2.nb + c3 * b;
            x2(k <= a2.P + a2.qc);
            if (0 != h2.Z)
              for (x2(null != ia[h2.Z]), g = 0; g < d; ++g) {
                ia[h2.Z](r2, q, t2, k, l2, m3, b), r2 = l2, q = m3, m3 += b, k += b;
              }
            else
              for (g = 0; g < d; ++g) {
                I(l2, m3, t2, k, b), r2 = l2, q = m3, m3 += b, k += b;
              }
            a2.rc = r2;
            a2.Vc = q;
          } else {
            x2(null != h2.mc);
            b = c3 + d;
            g = h2.mc;
            x2(null != g);
            x2(b <= g.i);
            if (g.C >= b)
              b = 1;
            else if (h2.ic || Aa(), h2.ic) {
              var h2 = g.V, r2 = g.Ba, q = g.c, v2 = g.i, t2 = 1, k = g.$ / q, l2 = g.$ % q, m3 = g.m, n2 = g.s, p2 = g.$, u2 = q * v2, w = q * b, y3 = n2.wc, A2 = p2 < w ? ha(n2, l2, k) : null;
              x2(p2 <= u2);
              x2(b <= v2);
              x2(yc(n2));
              c:
                for (; ; ) {
                  for (; !m3.h && p2 < w; ) {
                    l2 & y3 || (A2 = ha(n2, l2, k));
                    x2(null != A2);
                    Sa(m3);
                    v2 = ua(A2.G[0], A2.H[0], m3);
                    if (256 > v2)
                      h2[r2 + p2] = v2, ++p2, ++l2, l2 >= q && (l2 = 0, ++k, k <= b && !(k % 16) && Ib(g, k));
                    else if (280 > v2) {
                      var v2 = ib(v2 - 256, m3);
                      var E = ua(A2.G[4], A2.H[4], m3);
                      Sa(m3);
                      E = ib(E, m3);
                      E = nc(q, E);
                      if (p2 >= E && u2 - p2 >= v2) {
                        var B;
                        for (B = 0; B < v2; ++B) {
                          h2[r2 + p2 + B] = h2[r2 + p2 + B - E];
                        }
                      } else {
                        t2 = 0;
                        break c;
                      }
                      p2 += v2;
                      for (l2 += v2; l2 >= q; ) {
                        l2 -= q, ++k, k <= b && !(k % 16) && Ib(g, k);
                      }
                      p2 < w && l2 & y3 && (A2 = ha(n2, l2, k));
                    } else {
                      t2 = 0;
                      break c;
                    }
                    x2(m3.h == db(m3));
                  }
                  Ib(g, k > b ? b : k);
                  break c;
                }
              !t2 || m3.h && p2 < u2 ? (t2 = 0, g.a = m3.h ? 5 : 3) : g.$ = p2;
              b = t2;
            } else
              b = Jb(g, g.V, g.Ba, g.c, g.i, b, se);
            if (!b) {
              d = 0;
              break a;
            }
          }
          c3 + d >= f4 && (a2.Cc = 1);
          d = 1;
        }
        if (!d)
          return null;
        if (a2.Cc && (d = a2.ga, null != d && (d.mc = null), a2.ga = null, 0 < a2.Ga))
          return alert("todo:WebPDequantizeLevels"), null;
      }
      return a2.nb + c3 * e2;
    }
    function If(a2, b, c3, d, e2, f4) {
      for (; 0 < e2--; ) {
        var g = a2, h2 = b + (c3 ? 1 : 0), k = a2, l2 = b + (c3 ? 0 : 3), m3;
        for (m3 = 0; m3 < d; ++m3) {
          var n2 = k[l2 + 4 * m3];
          255 != n2 && (n2 *= 32897, g[h2 + 4 * m3 + 0] = g[h2 + 4 * m3 + 0] * n2 >> 23, g[h2 + 4 * m3 + 1] = g[h2 + 4 * m3 + 1] * n2 >> 23, g[h2 + 4 * m3 + 2] = g[h2 + 4 * m3 + 2] * n2 >> 23);
        }
        b += f4;
      }
    }
    function Jf(a2, b, c3, d, e2) {
      for (; 0 < d--; ) {
        var f4;
        for (f4 = 0; f4 < c3; ++f4) {
          var g = a2[b + 2 * f4 + 0], h2 = a2[b + 2 * f4 + 1], k = h2 & 15, l2 = 4369 * k, h2 = (h2 & 240 | h2 >> 4) * l2 >> 16;
          a2[b + 2 * f4 + 0] = (g & 240 | g >> 4) * l2 >> 16 & 240 | (g & 15 | g << 4) * l2 >> 16 >> 4 & 15;
          a2[b + 2 * f4 + 1] = h2 & 240 | k;
        }
        b += e2;
      }
    }
    function Kf(a2, b, c3, d, e2, f4, g, h2) {
      var k = 255, l2, m3;
      for (m3 = 0; m3 < e2; ++m3) {
        for (l2 = 0; l2 < d; ++l2) {
          var n2 = a2[b + l2];
          f4[g + 4 * l2] = n2;
          k &= n2;
        }
        b += c3;
        g += h2;
      }
      return 255 != k;
    }
    function Lf(a2, b, c3, d, e2) {
      var f4;
      for (f4 = 0; f4 < e2; ++f4) {
        c3[d + f4] = a2[b + f4] >> 8;
      }
    }
    function Aa() {
      za = If;
      vc = Jf;
      fc = Kf;
      Fc = Lf;
    }
    function va(a2, b, c3) {
      self2[a2] = function(a3, e2, f4, g, h2, k, l2, m3, n2, r2, q, t2, v2, p2, u2, w, y3) {
        var d, E = y3 - 1 >> 1;
        var B = h2[k + 0] | l2[m3 + 0] << 16;
        var C = n2[r2 + 0] | q[t2 + 0] << 16;
        x2(null != a3);
        var z2 = 3 * B + C + 131074 >> 2;
        b(a3[e2 + 0], z2 & 255, z2 >> 16, v2, p2);
        null != f4 && (z2 = 3 * C + B + 131074 >> 2, b(f4[g + 0], z2 & 255, z2 >> 16, u2, w));
        for (d = 1; d <= E; ++d) {
          var D3 = h2[k + d] | l2[m3 + d] << 16;
          var G3 = n2[r2 + d] | q[t2 + d] << 16;
          var F = B + D3 + C + G3 + 524296;
          var H2 = F + 2 * (D3 + C) >> 3;
          F = F + 2 * (B + G3) >> 3;
          z2 = H2 + B >> 1;
          B = F + D3 >> 1;
          b(a3[e2 + 2 * d - 1], z2 & 255, z2 >> 16, v2, p2 + (2 * d - 1) * c3);
          b(a3[e2 + 2 * d - 0], B & 255, B >> 16, v2, p2 + (2 * d - 0) * c3);
          null != f4 && (z2 = F + C >> 1, B = H2 + G3 >> 1, b(f4[g + 2 * d - 1], z2 & 255, z2 >> 16, u2, w + (2 * d - 1) * c3), b(f4[g + 2 * d + 0], B & 255, B >> 16, u2, w + (2 * d + 0) * c3));
          B = D3;
          C = G3;
        }
        y3 & 1 || (z2 = 3 * B + C + 131074 >> 2, b(a3[e2 + y3 - 1], z2 & 255, z2 >> 16, v2, p2 + (y3 - 1) * c3), null != f4 && (z2 = 3 * C + B + 131074 >> 2, b(f4[g + y3 - 1], z2 & 255, z2 >> 16, u2, w + (y3 - 1) * c3)));
      };
    }
    function ic() {
      P[Ca] = Mf;
      P[Ua] = nd;
      P[tc] = Nf;
      P[Va] = od;
      P[ya] = pd;
      P[Db] = qd;
      P[wc] = Of;
      P[zb] = nd;
      P[Ab] = od;
      P[Ja] = pd;
      P[Bb] = qd;
    }
    function Sb(a2) {
      return a2 & ~Pf ? 0 > a2 ? 0 : 255 : a2 >> rd;
    }
    function bb(a2, b) {
      return Sb((19077 * a2 >> 8) + (26149 * b >> 8) - 14234);
    }
    function nb(a2, b, c3) {
      return Sb((19077 * a2 >> 8) - (6419 * b >> 8) - (13320 * c3 >> 8) + 8708);
    }
    function Pa(a2, b) {
      return Sb((19077 * a2 >> 8) + (33050 * b >> 8) - 17685);
    }
    function Ga(a2, b, c3, d, e2) {
      d[e2 + 0] = bb(a2, c3);
      d[e2 + 1] = nb(a2, b, c3);
      d[e2 + 2] = Pa(a2, b);
    }
    function Tb(a2, b, c3, d, e2) {
      d[e2 + 0] = Pa(a2, b);
      d[e2 + 1] = nb(a2, b, c3);
      d[e2 + 2] = bb(a2, c3);
    }
    function sd(a2, b, c3, d, e2) {
      var f4 = nb(a2, b, c3);
      b = f4 << 3 & 224 | Pa(a2, b) >> 3;
      d[e2 + 0] = bb(a2, c3) & 248 | f4 >> 5;
      d[e2 + 1] = b;
    }
    function td(a2, b, c3, d, e2) {
      var f4 = Pa(a2, b) & 240 | 15;
      d[e2 + 0] = bb(a2, c3) & 240 | nb(a2, b, c3) >> 4;
      d[e2 + 1] = f4;
    }
    function ud(a2, b, c3, d, e2) {
      d[e2 + 0] = 255;
      Ga(a2, b, c3, d, e2 + 1);
    }
    function vd(a2, b, c3, d, e2) {
      Tb(a2, b, c3, d, e2);
      d[e2 + 3] = 255;
    }
    function wd(a2, b, c3, d, e2) {
      Ga(a2, b, c3, d, e2);
      d[e2 + 3] = 255;
    }
    function ga(a2, b) {
      return 0 > a2 ? 0 : a2 > b ? b : a2;
    }
    function la(a2, b, c3) {
      self2[a2] = function(a3, e2, f4, g, h2, k, l2, m3, n2) {
        for (var d = m3 + (n2 & -2) * c3; m3 != d; ) {
          b(a3[e2 + 0], f4[g + 0], h2[k + 0], l2, m3), b(a3[e2 + 1], f4[g + 0], h2[k + 0], l2, m3 + c3), e2 += 2, ++g, ++k, m3 += 2 * c3;
        }
        n2 & 1 && b(a3[e2 + 0], f4[g + 0], h2[k + 0], l2, m3);
      };
    }
    function xd(a2, b, c3) {
      return 0 == c3 ? 0 == a2 ? 0 == b ? 6 : 5 : 0 == b ? 4 : 0 : c3;
    }
    function yd(a2, b, c3, d, e2) {
      switch (a2 >>> 30) {
        case 3:
          Za(b, c3, d, e2, 0);
          break;
        case 2:
          fd2(b, c3, d, e2);
          break;
        case 1:
          pa(b, c3, d, e2);
      }
    }
    function Oc(a2, b) {
      var c3, d, e2 = b.M, f4 = b.Nb, g = a2.oc, h2 = a2.pc + 40, k = a2.oc, l2 = a2.pc + 584, m3 = a2.oc, n2 = a2.pc + 600;
      for (c3 = 0; 16 > c3; ++c3) {
        g[h2 + 32 * c3 - 1] = 129;
      }
      for (c3 = 0; 8 > c3; ++c3) {
        k[l2 + 32 * c3 - 1] = 129, m3[n2 + 32 * c3 - 1] = 129;
      }
      0 < e2 ? g[h2 - 1 - 32] = k[l2 - 1 - 32] = m3[n2 - 1 - 32] = 129 : (M(g, h2 - 32 - 1, 127, 21), M(k, l2 - 32 - 1, 127, 9), M(m3, n2 - 32 - 1, 127, 9));
      for (d = 0; d < a2.za; ++d) {
        var r2 = b.ya[b.aa + d];
        if (0 < d) {
          for (c3 = -1; 16 > c3; ++c3) {
            I(g, h2 + 32 * c3 - 4, g, h2 + 32 * c3 + 12, 4);
          }
          for (c3 = -1; 8 > c3; ++c3) {
            I(k, l2 + 32 * c3 - 4, k, l2 + 32 * c3 + 4, 4), I(m3, n2 + 32 * c3 - 4, m3, n2 + 32 * c3 + 4, 4);
          }
        }
        var q = a2.Gd, t2 = a2.Hd + d, v2 = r2.ad, p2 = r2.Hc;
        0 < e2 && (I(g, h2 - 32, q[t2].y, 0, 16), I(k, l2 - 32, q[t2].f, 0, 8), I(m3, n2 - 32, q[t2].ea, 0, 8));
        if (r2.Za) {
          var u2 = g;
          var w = h2 - 32 + 16;
          0 < e2 && (d >= a2.za - 1 ? M(u2, w, q[t2].y[15], 4) : I(u2, w, q[t2 + 1].y, 0, 4));
          for (c3 = 0; 4 > c3; c3++) {
            u2[w + 128 + c3] = u2[w + 256 + c3] = u2[w + 384 + c3] = u2[w + 0 + c3];
          }
          for (c3 = 0; 16 > c3; ++c3, p2 <<= 2) {
            u2 = g, w = h2 + zd[c3], W[r2.Ob[c3]](u2, w), yd(p2, v2, 16 * +c3, u2, w);
          }
        } else if (u2 = xd(d, e2, r2.Ob[0]), Y[u2](g, h2), 0 != p2)
          for (c3 = 0; 16 > c3; ++c3, p2 <<= 2) {
            yd(p2, v2, 16 * +c3, g, h2 + zd[c3]);
          }
        c3 = r2.Gc;
        u2 = xd(d, e2, r2.Dd);
        ka[u2](k, l2);
        ka[u2](m3, n2);
        r2 = c3 >> 0;
        p2 = v2;
        u2 = k;
        w = l2;
        r2 & 255 && (r2 & 170 ? Nb(p2, 256, u2, w) : Ob(p2, 256, u2, w));
        c3 >>= 8;
        r2 = m3;
        p2 = n2;
        c3 & 255 && (c3 & 170 ? Nb(v2, 320, r2, p2) : Ob(v2, 320, r2, p2));
        e2 < a2.Ub - 1 && (I(q[t2].y, 0, g, h2 + 480, 16), I(q[t2].f, 0, k, l2 + 224, 8), I(q[t2].ea, 0, m3, n2 + 224, 8));
        c3 = 8 * f4 * a2.B;
        q = a2.sa;
        t2 = a2.ta + 16 * d + 16 * f4 * a2.R;
        v2 = a2.qa;
        r2 = a2.ra + 8 * d + c3;
        p2 = a2.Ha;
        u2 = a2.Ia + 8 * d + c3;
        for (c3 = 0; 16 > c3; ++c3) {
          I(q, t2 + c3 * a2.R, g, h2 + 32 * c3, 16);
        }
        for (c3 = 0; 8 > c3; ++c3) {
          I(v2, r2 + c3 * a2.B, k, l2 + 32 * c3, 8), I(p2, u2 + c3 * a2.B, m3, n2 + 32 * c3, 8);
        }
      }
    }
    function Ad(a2, b, c3, d, e2, f4, g, h2, k) {
      var l2 = [0], m3 = [0], n2 = 0, r2 = null != k ? k.kd : 0, q = null != k ? k : new md();
      if (null == a2 || 12 > c3)
        return 7;
      q.data = a2;
      q.w = b;
      q.ha = c3;
      b = [b];
      c3 = [c3];
      q.gb = [q.gb];
      a: {
        var t2 = b;
        var v2 = c3;
        var p2 = q.gb;
        x2(null != a2);
        x2(null != v2);
        x2(null != p2);
        p2[0] = 0;
        if (12 <= v2[0] && !fa(a2, t2[0], "RIFF")) {
          if (fa(a2, t2[0] + 8, "WEBP")) {
            p2 = 3;
            break a;
          }
          var u2 = Ha(a2, t2[0] + 4);
          if (12 > u2 || 4294967286 < u2) {
            p2 = 3;
            break a;
          }
          if (r2 && u2 > v2[0] - 8) {
            p2 = 7;
            break a;
          }
          p2[0] = u2;
          t2[0] += 12;
          v2[0] -= 12;
        }
        p2 = 0;
      }
      if (0 != p2)
        return p2;
      u2 = 0 < q.gb[0];
      for (c3 = c3[0]; ; ) {
        t2 = [0];
        n2 = [n2];
        a: {
          var w = a2;
          v2 = b;
          p2 = c3;
          var y3 = n2, A2 = l2, z2 = m3, B = t2;
          y3[0] = 0;
          if (8 > p2[0])
            p2 = 7;
          else {
            if (!fa(w, v2[0], "VP8X")) {
              if (10 != Ha(w, v2[0] + 4)) {
                p2 = 3;
                break a;
              }
              if (18 > p2[0]) {
                p2 = 7;
                break a;
              }
              var C = Ha(w, v2[0] + 8);
              var D3 = 1 + Yb(w, v2[0] + 12);
              w = 1 + Yb(w, v2[0] + 15);
              if (2147483648 <= D3 * w) {
                p2 = 3;
                break a;
              }
              null != B && (B[0] = C);
              null != A2 && (A2[0] = D3);
              null != z2 && (z2[0] = w);
              v2[0] += 18;
              p2[0] -= 18;
              y3[0] = 1;
            }
            p2 = 0;
          }
        }
        n2 = n2[0];
        t2 = t2[0];
        if (0 != p2)
          return p2;
        v2 = !!(t2 & 2);
        if (!u2 && n2)
          return 3;
        null != f4 && (f4[0] = !!(t2 & 16));
        null != g && (g[0] = v2);
        null != h2 && (h2[0] = 0);
        g = l2[0];
        t2 = m3[0];
        if (n2 && v2 && null == k) {
          p2 = 0;
          break;
        }
        if (4 > c3) {
          p2 = 7;
          break;
        }
        if (u2 && n2 || !u2 && !n2 && !fa(a2, b[0], "ALPH")) {
          c3 = [c3];
          q.na = [q.na];
          q.P = [q.P];
          q.Sa = [q.Sa];
          a: {
            C = a2;
            p2 = b;
            u2 = c3;
            var y3 = q.gb, A2 = q.na, z2 = q.P, B = q.Sa;
            D3 = 22;
            x2(null != C);
            x2(null != u2);
            w = p2[0];
            var F = u2[0];
            x2(null != A2);
            x2(null != B);
            A2[0] = null;
            z2[0] = null;
            for (B[0] = 0; ; ) {
              p2[0] = w;
              u2[0] = F;
              if (8 > F) {
                p2 = 7;
                break a;
              }
              var G3 = Ha(C, w + 4);
              if (4294967286 < G3) {
                p2 = 3;
                break a;
              }
              var H2 = 8 + G3 + 1 & -2;
              D3 += H2;
              if (0 < y3 && D3 > y3) {
                p2 = 3;
                break a;
              }
              if (!fa(C, w, "VP8 ") || !fa(C, w, "VP8L")) {
                p2 = 0;
                break a;
              }
              if (F[0] < H2) {
                p2 = 7;
                break a;
              }
              fa(C, w, "ALPH") || (A2[0] = C, z2[0] = w + 8, B[0] = G3);
              w += H2;
              F -= H2;
            }
          }
          c3 = c3[0];
          q.na = q.na[0];
          q.P = q.P[0];
          q.Sa = q.Sa[0];
          if (0 != p2)
            break;
        }
        c3 = [c3];
        q.Ja = [q.Ja];
        q.xa = [q.xa];
        a:
          if (y3 = a2, p2 = b, u2 = c3, A2 = q.gb[0], z2 = q.Ja, B = q.xa, C = p2[0], w = !fa(y3, C, "VP8 "), D3 = !fa(y3, C, "VP8L"), x2(null != y3), x2(null != u2), x2(null != z2), x2(null != B), 8 > u2[0])
            p2 = 7;
          else {
            if (w || D3) {
              y3 = Ha(y3, C + 4);
              if (12 <= A2 && y3 > A2 - 12) {
                p2 = 3;
                break a;
              }
              if (r2 && y3 > u2[0] - 8) {
                p2 = 7;
                break a;
              }
              z2[0] = y3;
              p2[0] += 8;
              u2[0] -= 8;
              B[0] = D3;
            } else
              B[0] = 5 <= u2[0] && 47 == y3[C + 0] && !(y3[C + 4] >> 5), z2[0] = u2[0];
            p2 = 0;
          }
        c3 = c3[0];
        q.Ja = q.Ja[0];
        q.xa = q.xa[0];
        b = b[0];
        if (0 != p2)
          break;
        if (4294967286 < q.Ja)
          return 3;
        null == h2 || v2 || (h2[0] = q.xa ? 2 : 1);
        g = [g];
        t2 = [t2];
        if (q.xa) {
          if (5 > c3) {
            p2 = 7;
            break;
          }
          h2 = g;
          r2 = t2;
          v2 = f4;
          null == a2 || 5 > c3 ? a2 = 0 : 5 <= c3 && 47 == a2[b + 0] && !(a2[b + 4] >> 5) ? (u2 = [0], y3 = [0], A2 = [0], z2 = new Ra(), cb(z2, a2, b, c3), mc(z2, u2, y3, A2) ? (null != h2 && (h2[0] = u2[0]), null != r2 && (r2[0] = y3[0]), null != v2 && (v2[0] = A2[0]), a2 = 1) : a2 = 0) : a2 = 0;
        } else {
          if (10 > c3) {
            p2 = 7;
            break;
          }
          h2 = t2;
          null == a2 || 10 > c3 || !Jc(a2, b + 3, c3 - 3) ? a2 = 0 : (r2 = a2[b + 0] | a2[b + 1] << 8 | a2[b + 2] << 16, v2 = (a2[b + 7] << 8 | a2[b + 6]) & 16383, a2 = (a2[b + 9] << 8 | a2[b + 8]) & 16383, r2 & 1 || 3 < (r2 >> 1 & 7) || !(r2 >> 4 & 1) || r2 >> 5 >= q.Ja || !v2 || !a2 ? a2 = 0 : (g && (g[0] = v2), h2 && (h2[0] = a2), a2 = 1));
        }
        if (!a2)
          return 3;
        g = g[0];
        t2 = t2[0];
        if (n2 && (l2[0] != g || m3[0] != t2))
          return 3;
        null != k && (k[0] = q, k.offset = b - k.w, x2(4294967286 > b - k.w), x2(k.offset == k.ha - c3));
        break;
      }
      return 0 == p2 || 7 == p2 && n2 && null == k ? (null != f4 && (f4[0] |= null != q.na && 0 < q.na.length), null != d && (d[0] = g), null != e2 && (e2[0] = t2), 0) : p2;
    }
    function hc(a2, b, c3) {
      var d = b.width, e2 = b.height, f4 = 0, g = 0, h2 = d, k = e2;
      b.Da = null != a2 && 0 < a2.Da;
      if (b.Da && (h2 = a2.cd, k = a2.bd, f4 = a2.v, g = a2.j, 11 > c3 || (f4 &= -2, g &= -2), 0 > f4 || 0 > g || 0 >= h2 || 0 >= k || f4 + h2 > d || g + k > e2))
        return 0;
      b.v = f4;
      b.j = g;
      b.va = f4 + h2;
      b.o = g + k;
      b.U = h2;
      b.T = k;
      b.da = null != a2 && 0 < a2.da;
      if (b.da) {
        c3 = [a2.ib];
        f4 = [a2.hb];
        if (!bc(h2, k, c3, f4))
          return 0;
        b.ib = c3[0];
        b.hb = f4[0];
      }
      b.ob = null != a2 && a2.ob;
      b.Kb = null == a2 || !a2.Sd;
      b.da && (b.ob = b.ib < 3 * d / 4 && b.hb < 3 * e2 / 4, b.Kb = 0);
      return 1;
    }
    function Bd(a2) {
      if (null == a2)
        return 2;
      if (11 > a2.S) {
        var b = a2.f.RGBA;
        b.fb += (a2.height - 1) * b.A;
        b.A = -b.A;
      } else
        b = a2.f.kb, a2 = a2.height, b.O += (a2 - 1) * b.fa, b.fa = -b.fa, b.N += (a2 - 1 >> 1) * b.Ab, b.Ab = -b.Ab, b.W += (a2 - 1 >> 1) * b.Db, b.Db = -b.Db, null != b.F && (b.J += (a2 - 1) * b.lb, b.lb = -b.lb);
      return 0;
    }
    function Cd(a2, b, c3, d) {
      if (null == d || 0 >= a2 || 0 >= b)
        return 2;
      if (null != c3) {
        if (c3.Da) {
          var e2 = c3.cd, f4 = c3.bd, g = c3.v & -2, h2 = c3.j & -2;
          if (0 > g || 0 > h2 || 0 >= e2 || 0 >= f4 || g + e2 > a2 || h2 + f4 > b)
            return 2;
          a2 = e2;
          b = f4;
        }
        if (c3.da) {
          e2 = [c3.ib];
          f4 = [c3.hb];
          if (!bc(a2, b, e2, f4))
            return 2;
          a2 = e2[0];
          b = f4[0];
        }
      }
      d.width = a2;
      d.height = b;
      a: {
        var k = d.width;
        var l2 = d.height;
        a2 = d.S;
        if (0 >= k || 0 >= l2 || !(a2 >= Ca && 13 > a2))
          a2 = 2;
        else {
          if (0 >= d.Rd && null == d.sd) {
            var g = f4 = e2 = b = 0, h2 = k * Dd[a2], m3 = h2 * l2;
            11 > a2 || (b = (k + 1) / 2, f4 = (l2 + 1) / 2 * b, 12 == a2 && (e2 = k, g = e2 * l2));
            l2 = V(m3 + 2 * f4 + g);
            if (null == l2) {
              a2 = 1;
              break a;
            }
            d.sd = l2;
            11 > a2 ? (k = d.f.RGBA, k.eb = l2, k.fb = 0, k.A = h2, k.size = m3) : (k = d.f.kb, k.y = l2, k.O = 0, k.fa = h2, k.Fd = m3, k.f = l2, k.N = 0 + m3, k.Ab = b, k.Cd = f4, k.ea = l2, k.W = 0 + m3 + f4, k.Db = b, k.Ed = f4, 12 == a2 && (k.F = l2, k.J = 0 + m3 + 2 * f4), k.Tc = g, k.lb = e2);
          }
          b = 1;
          e2 = d.S;
          f4 = d.width;
          g = d.height;
          if (e2 >= Ca && 13 > e2) {
            if (11 > e2)
              a2 = d.f.RGBA, h2 = Math.abs(a2.A), b &= h2 * (g - 1) + f4 <= a2.size, b &= h2 >= f4 * Dd[e2], b &= null != a2.eb;
            else {
              a2 = d.f.kb;
              h2 = (f4 + 1) / 2;
              m3 = (g + 1) / 2;
              k = Math.abs(a2.fa);
              var l2 = Math.abs(a2.Ab), n2 = Math.abs(a2.Db), r2 = Math.abs(a2.lb), q = r2 * (g - 1) + f4;
              b &= k * (g - 1) + f4 <= a2.Fd;
              b &= l2 * (m3 - 1) + h2 <= a2.Cd;
              b &= n2 * (m3 - 1) + h2 <= a2.Ed;
              b = b & k >= f4 & l2 >= h2 & n2 >= h2;
              b &= null != a2.y;
              b &= null != a2.f;
              b &= null != a2.ea;
              12 == e2 && (b &= r2 >= f4, b &= q <= a2.Tc, b &= null != a2.F);
            }
          } else
            b = 0;
          a2 = b ? 0 : 2;
        }
      }
      if (0 != a2)
        return a2;
      null != c3 && c3.fd && (a2 = Bd(d));
      return a2;
    }
    var xb = 64, Hd = [0, 1, 3, 7, 15, 31, 63, 127, 255, 511, 1023, 2047, 4095, 8191, 16383, 32767, 65535, 131071, 262143, 524287, 1048575, 2097151, 4194303, 8388607, 16777215], Gd = 24, ob = 32, Xb = 8, Id = [0, 0, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7];
    X("Predictor0", "PredictorAdd0");
    self2.Predictor0 = function() {
      return 4278190080;
    };
    self2.Predictor1 = function(a2) {
      return a2;
    };
    self2.Predictor2 = function(a2, b, c3) {
      return b[c3 + 0];
    };
    self2.Predictor3 = function(a2, b, c3) {
      return b[c3 + 1];
    };
    self2.Predictor4 = function(a2, b, c3) {
      return b[c3 - 1];
    };
    self2.Predictor5 = function(a2, b, c3) {
      return aa(aa(a2, b[c3 + 1]), b[c3 + 0]);
    };
    self2.Predictor6 = function(a2, b, c3) {
      return aa(a2, b[c3 - 1]);
    };
    self2.Predictor7 = function(a2, b, c3) {
      return aa(a2, b[c3 + 0]);
    };
    self2.Predictor8 = function(a2, b, c3) {
      return aa(b[c3 - 1], b[c3 + 0]);
    };
    self2.Predictor9 = function(a2, b, c3) {
      return aa(b[c3 + 0], b[c3 + 1]);
    };
    self2.Predictor10 = function(a2, b, c3) {
      return aa(aa(a2, b[c3 - 1]), aa(b[c3 + 0], b[c3 + 1]));
    };
    self2.Predictor11 = function(a2, b, c3) {
      var d = b[c3 + 0];
      b = b[c3 - 1];
      return 0 >= Ia(d >> 24 & 255, a2 >> 24 & 255, b >> 24 & 255) + Ia(d >> 16 & 255, a2 >> 16 & 255, b >> 16 & 255) + Ia(d >> 8 & 255, a2 >> 8 & 255, b >> 8 & 255) + Ia(d & 255, a2 & 255, b & 255) ? d : a2;
    };
    self2.Predictor12 = function(a2, b, c3) {
      var d = b[c3 + 0];
      b = b[c3 - 1];
      return (sa((a2 >> 24 & 255) + (d >> 24 & 255) - (b >> 24 & 255)) << 24 | sa((a2 >> 16 & 255) + (d >> 16 & 255) - (b >> 16 & 255)) << 16 | sa((a2 >> 8 & 255) + (d >> 8 & 255) - (b >> 8 & 255)) << 8 | sa((a2 & 255) + (d & 255) - (b & 255))) >>> 0;
    };
    self2.Predictor13 = function(a2, b, c3) {
      var d = b[c3 - 1];
      a2 = aa(a2, b[c3 + 0]);
      return (eb(a2 >> 24 & 255, d >> 24 & 255) << 24 | eb(a2 >> 16 & 255, d >> 16 & 255) << 16 | eb(a2 >> 8 & 255, d >> 8 & 255) << 8 | eb(a2 >> 0 & 255, d >> 0 & 255)) >>> 0;
    };
    var ee = self2.PredictorAdd0;
    self2.PredictorAdd1 = cc;
    X("Predictor2", "PredictorAdd2");
    X("Predictor3", "PredictorAdd3");
    X("Predictor4", "PredictorAdd4");
    X("Predictor5", "PredictorAdd5");
    X("Predictor6", "PredictorAdd6");
    X("Predictor7", "PredictorAdd7");
    X("Predictor8", "PredictorAdd8");
    X("Predictor9", "PredictorAdd9");
    X("Predictor10", "PredictorAdd10");
    X("Predictor11", "PredictorAdd11");
    X("Predictor12", "PredictorAdd12");
    X("Predictor13", "PredictorAdd13");
    var fe = self2.PredictorAdd2;
    ec("ColorIndexInverseTransform", "MapARGB", "32b", function(a2) {
      return a2 >> 8 & 255;
    }, function(a2) {
      return a2;
    });
    ec("VP8LColorIndexInverseTransformAlpha", "MapAlpha", "8b", function(a2) {
      return a2;
    }, function(a2) {
      return a2 >> 8 & 255;
    });
    var rc = self2.ColorIndexInverseTransform, ke = self2.MapARGB, he = self2.VP8LColorIndexInverseTransformAlpha, le = self2.MapAlpha, pc, qc = self2.VP8LPredictorsAdd = [];
    qc.length = 16;
    (self2.VP8LPredictors = []).length = 16;
    (self2.VP8LPredictorsAdd_C = []).length = 16;
    (self2.VP8LPredictors_C = []).length = 16;
    var Fb, sc, Gb, Hb, xc, uc, bd = V(511), cd = V(2041), dd = V(225), ed = V(767), ad = 0, Qb = cd, mb = dd, R = ed, U = bd, Ca = 0, Ua = 1, tc = 2, Va = 3, ya = 4, Db = 5, wc = 6, zb = 7, Ab = 8, Ja = 9, Bb = 10, pe = [2, 3, 7], oe = [3, 3, 11], Dc2 = [280, 256, 256, 256, 40], qe = [0, 1, 1, 1, 0], ne = [17, 18, 0, 1, 2, 3, 4, 5, 16, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15], de = [24, 7, 23, 25, 40, 6, 39, 41, 22, 26, 38, 42, 56, 5, 55, 57, 21, 27, 54, 58, 37, 43, 72, 4, 71, 73, 20, 28, 53, 59, 70, 74, 36, 44, 88, 69, 75, 52, 60, 3, 87, 89, 19, 29, 86, 90, 35, 45, 68, 76, 85, 91, 51, 61, 104, 2, 103, 105, 18, 30, 102, 106, 34, 46, 84, 92, 67, 77, 101, 107, 50, 62, 120, 1, 119, 121, 83, 93, 17, 31, 100, 108, 66, 78, 118, 122, 33, 47, 117, 123, 49, 63, 99, 109, 82, 94, 0, 116, 124, 65, 79, 16, 32, 98, 110, 48, 115, 125, 81, 95, 64, 114, 126, 97, 111, 80, 113, 127, 96, 112], me = [2954, 2956, 2958, 2962, 2970, 2986, 3018, 3082, 3212, 3468, 3980, 5004], ie = 8, Lb = [4, 5, 6, 7, 8, 9, 10, 10, 11, 12, 13, 14, 15, 16, 17, 17, 18, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 25, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 91, 93, 95, 96, 98, 100, 101, 102, 104, 106, 108, 110, 112, 114, 116, 118, 122, 124, 126, 128, 130, 132, 134, 136, 138, 140, 143, 145, 148, 151, 154, 157], Mb = [4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112, 114, 116, 119, 122, 125, 128, 131, 134, 137, 140, 143, 146, 149, 152, 155, 158, 161, 164, 167, 170, 173, 177, 181, 185, 189, 193, 197, 201, 205, 209, 213, 217, 221, 225, 229, 234, 239, 245, 249, 254, 259, 264, 269, 274, 279, 284], oa = null, He = [[173, 148, 140, 0], [176, 155, 140, 135, 0], [180, 157, 141, 134, 130, 0], [254, 254, 243, 230, 196, 177, 153, 140, 133, 130, 129, 0]], Ie = [0, 1, 4, 8, 5, 2, 3, 6, 9, 12, 13, 10, 7, 11, 14, 15], Mc = [-0, 1, -1, 2, -2, 3, 4, 6, -3, 5, -4, -5, -6, 7, -7, 8, -8, -9], Fe = [[[[128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128], [128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128], [128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128]], [[253, 136, 254, 255, 228, 219, 128, 128, 128, 128, 128], [189, 129, 242, 255, 227, 213, 255, 219, 128, 128, 128], [106, 126, 227, 252, 214, 209, 255, 255, 128, 128, 128]], [[1, 98, 248, 255, 236, 226, 255, 255, 128, 128, 128], [181, 133, 238, 254, 221, 234, 255, 154, 128, 128, 128], [78, 134, 202, 247, 198, 180, 255, 219, 128, 128, 128]], [[1, 185, 249, 255, 243, 255, 128, 128, 128, 128, 128], [184, 150, 247, 255, 236, 224, 128, 128, 128, 128, 128], [77, 110, 216, 255, 236, 230, 128, 128, 128, 128, 128]], [[1, 101, 251, 255, 241, 255, 128, 128, 128, 128, 128], [170, 139, 241, 252, 236, 209, 255, 255, 128, 128, 128], [37, 116, 196, 243, 228, 255, 255, 255, 128, 128, 128]], [[1, 204, 254, 255, 245, 255, 128, 128, 128, 128, 128], [207, 160, 250, 255, 238, 128, 128, 128, 128, 128, 128], [102, 103, 231, 255, 211, 171, 128, 128, 128, 128, 128]], [[1, 152, 252, 255, 240, 255, 128, 128, 128, 128, 128], [177, 135, 243, 255, 234, 225, 128, 128, 128, 128, 128], [80, 129, 211, 255, 194, 224, 128, 128, 128, 128, 128]], [[1, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128], [246, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128], [255, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128]]], [[[198, 35, 237, 223, 193, 187, 162, 160, 145, 155, 62], [131, 45, 198, 221, 172, 176, 220, 157, 252, 221, 1], [68, 47, 146, 208, 149, 167, 221, 162, 255, 223, 128]], [[1, 149, 241, 255, 221, 224, 255, 255, 128, 128, 128], [184, 141, 234, 253, 222, 220, 255, 199, 128, 128, 128], [81, 99, 181, 242, 176, 190, 249, 202, 255, 255, 128]], [[1, 129, 232, 253, 214, 197, 242, 196, 255, 255, 128], [99, 121, 210, 250, 201, 198, 255, 202, 128, 128, 128], [23, 91, 163, 242, 170, 187, 247, 210, 255, 255, 128]], [[1, 200, 246, 255, 234, 255, 128, 128, 128, 128, 128], [109, 178, 241, 255, 231, 245, 255, 255, 128, 128, 128], [44, 130, 201, 253, 205, 192, 255, 255, 128, 128, 128]], [[1, 132, 239, 251, 219, 209, 255, 165, 128, 128, 128], [94, 136, 225, 251, 218, 190, 255, 255, 128, 128, 128], [22, 100, 174, 245, 186, 161, 255, 199, 128, 128, 128]], [[1, 182, 249, 255, 232, 235, 128, 128, 128, 128, 128], [124, 143, 241, 255, 227, 234, 128, 128, 128, 128, 128], [35, 77, 181, 251, 193, 211, 255, 205, 128, 128, 128]], [[1, 157, 247, 255, 236, 231, 255, 255, 128, 128, 128], [121, 141, 235, 255, 225, 227, 255, 255, 128, 128, 128], [45, 99, 188, 251, 195, 217, 255, 224, 128, 128, 128]], [[1, 1, 251, 255, 213, 255, 128, 128, 128, 128, 128], [203, 1, 248, 255, 255, 128, 128, 128, 128, 128, 128], [137, 1, 177, 255, 224, 255, 128, 128, 128, 128, 128]]], [[[253, 9, 248, 251, 207, 208, 255, 192, 128, 128, 128], [175, 13, 224, 243, 193, 185, 249, 198, 255, 255, 128], [73, 17, 171, 221, 161, 179, 236, 167, 255, 234, 128]], [[1, 95, 247, 253, 212, 183, 255, 255, 128, 128, 128], [239, 90, 244, 250, 211, 209, 255, 255, 128, 128, 128], [155, 77, 195, 248, 188, 195, 255, 255, 128, 128, 128]], [[1, 24, 239, 251, 218, 219, 255, 205, 128, 128, 128], [201, 51, 219, 255, 196, 186, 128, 128, 128, 128, 128], [69, 46, 190, 239, 201, 218, 255, 228, 128, 128, 128]], [[1, 191, 251, 255, 255, 128, 128, 128, 128, 128, 128], [223, 165, 249, 255, 213, 255, 128, 128, 128, 128, 128], [141, 124, 248, 255, 255, 128, 128, 128, 128, 128, 128]], [[1, 16, 248, 255, 255, 128, 128, 128, 128, 128, 128], [190, 36, 230, 255, 236, 255, 128, 128, 128, 128, 128], [149, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128]], [[1, 226, 255, 128, 128, 128, 128, 128, 128, 128, 128], [247, 192, 255, 128, 128, 128, 128, 128, 128, 128, 128], [240, 128, 255, 128, 128, 128, 128, 128, 128, 128, 128]], [[1, 134, 252, 255, 255, 128, 128, 128, 128, 128, 128], [213, 62, 250, 255, 255, 128, 128, 128, 128, 128, 128], [55, 93, 255, 128, 128, 128, 128, 128, 128, 128, 128]], [[128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128], [128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128], [128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128]]], [[[202, 24, 213, 235, 186, 191, 220, 160, 240, 175, 255], [126, 38, 182, 232, 169, 184, 228, 174, 255, 187, 128], [61, 46, 138, 219, 151, 178, 240, 170, 255, 216, 128]], [[1, 112, 230, 250, 199, 191, 247, 159, 255, 255, 128], [166, 109, 228, 252, 211, 215, 255, 174, 128, 128, 128], [39, 77, 162, 232, 172, 180, 245, 178, 255, 255, 128]], [[1, 52, 220, 246, 198, 199, 249, 220, 255, 255, 128], [124, 74, 191, 243, 183, 193, 250, 221, 255, 255, 128], [24, 71, 130, 219, 154, 170, 243, 182, 255, 255, 128]], [[1, 182, 225, 249, 219, 240, 255, 224, 128, 128, 128], [149, 150, 226, 252, 216, 205, 255, 171, 128, 128, 128], [28, 108, 170, 242, 183, 194, 254, 223, 255, 255, 128]], [[1, 81, 230, 252, 204, 203, 255, 192, 128, 128, 128], [123, 102, 209, 247, 188, 196, 255, 233, 128, 128, 128], [20, 95, 153, 243, 164, 173, 255, 203, 128, 128, 128]], [[1, 222, 248, 255, 216, 213, 128, 128, 128, 128, 128], [168, 175, 246, 252, 235, 205, 255, 255, 128, 128, 128], [47, 116, 215, 255, 211, 212, 255, 255, 128, 128, 128]], [[1, 121, 236, 253, 212, 214, 255, 255, 128, 128, 128], [141, 84, 213, 252, 201, 202, 255, 219, 128, 128, 128], [42, 80, 160, 240, 162, 185, 255, 205, 128, 128, 128]], [[1, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128], [244, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128], [238, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128]]]], Ke = [[[231, 120, 48, 89, 115, 113, 120, 152, 112], [152, 179, 64, 126, 170, 118, 46, 70, 95], [175, 69, 143, 80, 85, 82, 72, 155, 103], [56, 58, 10, 171, 218, 189, 17, 13, 152], [114, 26, 17, 163, 44, 195, 21, 10, 173], [121, 24, 80, 195, 26, 62, 44, 64, 85], [144, 71, 10, 38, 171, 213, 144, 34, 26], [170, 46, 55, 19, 136, 160, 33, 206, 71], [63, 20, 8, 114, 114, 208, 12, 9, 226], [81, 40, 11, 96, 182, 84, 29, 16, 36]], [[134, 183, 89, 137, 98, 101, 106, 165, 148], [72, 187, 100, 130, 157, 111, 32, 75, 80], [66, 102, 167, 99, 74, 62, 40, 234, 128], [41, 53, 9, 178, 241, 141, 26, 8, 107], [74, 43, 26, 146, 73, 166, 49, 23, 157], [65, 38, 105, 160, 51, 52, 31, 115, 128], [104, 79, 12, 27, 217, 255, 87, 17, 7], [87, 68, 71, 44, 114, 51, 15, 186, 23], [47, 41, 14, 110, 182, 183, 21, 17, 194], [66, 45, 25, 102, 197, 189, 23, 18, 22]], [[88, 88, 147, 150, 42, 46, 45, 196, 205], [43, 97, 183, 117, 85, 38, 35, 179, 61], [39, 53, 200, 87, 26, 21, 43, 232, 171], [56, 34, 51, 104, 114, 102, 29, 93, 77], [39, 28, 85, 171, 58, 165, 90, 98, 64], [34, 22, 116, 206, 23, 34, 43, 166, 73], [107, 54, 32, 26, 51, 1, 81, 43, 31], [68, 25, 106, 22, 64, 171, 36, 225, 114], [34, 19, 21, 102, 132, 188, 16, 76, 124], [62, 18, 78, 95, 85, 57, 50, 48, 51]], [[193, 101, 35, 159, 215, 111, 89, 46, 111], [60, 148, 31, 172, 219, 228, 21, 18, 111], [112, 113, 77, 85, 179, 255, 38, 120, 114], [40, 42, 1, 196, 245, 209, 10, 25, 109], [88, 43, 29, 140, 166, 213, 37, 43, 154], [61, 63, 30, 155, 67, 45, 68, 1, 209], [100, 80, 8, 43, 154, 1, 51, 26, 71], [142, 78, 78, 16, 255, 128, 34, 197, 171], [41, 40, 5, 102, 211, 183, 4, 1, 221], [51, 50, 17, 168, 209, 192, 23, 25, 82]], [[138, 31, 36, 171, 27, 166, 38, 44, 229], [67, 87, 58, 169, 82, 115, 26, 59, 179], [63, 59, 90, 180, 59, 166, 93, 73, 154], [40, 40, 21, 116, 143, 209, 34, 39, 175], [47, 15, 16, 183, 34, 223, 49, 45, 183], [46, 17, 33, 183, 6, 98, 15, 32, 183], [57, 46, 22, 24, 128, 1, 54, 17, 37], [65, 32, 73, 115, 28, 128, 23, 128, 205], [40, 3, 9, 115, 51, 192, 18, 6, 223], [87, 37, 9, 115, 59, 77, 64, 21, 47]], [[104, 55, 44, 218, 9, 54, 53, 130, 226], [64, 90, 70, 205, 40, 41, 23, 26, 57], [54, 57, 112, 184, 5, 41, 38, 166, 213], [30, 34, 26, 133, 152, 116, 10, 32, 134], [39, 19, 53, 221, 26, 114, 32, 73, 255], [31, 9, 65, 234, 2, 15, 1, 118, 73], [75, 32, 12, 51, 192, 255, 160, 43, 51], [88, 31, 35, 67, 102, 85, 55, 186, 85], [56, 21, 23, 111, 59, 205, 45, 37, 192], [55, 38, 70, 124, 73, 102, 1, 34, 98]], [[125, 98, 42, 88, 104, 85, 117, 175, 82], [95, 84, 53, 89, 128, 100, 113, 101, 45], [75, 79, 123, 47, 51, 128, 81, 171, 1], [57, 17, 5, 71, 102, 57, 53, 41, 49], [38, 33, 13, 121, 57, 73, 26, 1, 85], [41, 10, 67, 138, 77, 110, 90, 47, 114], [115, 21, 2, 10, 102, 255, 166, 23, 6], [101, 29, 16, 10, 85, 128, 101, 196, 26], [57, 18, 10, 102, 102, 213, 34, 20, 43], [117, 20, 15, 36, 163, 128, 68, 1, 26]], [[102, 61, 71, 37, 34, 53, 31, 243, 192], [69, 60, 71, 38, 73, 119, 28, 222, 37], [68, 45, 128, 34, 1, 47, 11, 245, 171], [62, 17, 19, 70, 146, 85, 55, 62, 70], [37, 43, 37, 154, 100, 163, 85, 160, 1], [63, 9, 92, 136, 28, 64, 32, 201, 85], [75, 15, 9, 9, 64, 255, 184, 119, 16], [86, 6, 28, 5, 64, 255, 25, 248, 1], [56, 8, 17, 132, 137, 255, 55, 116, 128], [58, 15, 20, 82, 135, 57, 26, 121, 40]], [[164, 50, 31, 137, 154, 133, 25, 35, 218], [51, 103, 44, 131, 131, 123, 31, 6, 158], [86, 40, 64, 135, 148, 224, 45, 183, 128], [22, 26, 17, 131, 240, 154, 14, 1, 209], [45, 16, 21, 91, 64, 222, 7, 1, 197], [56, 21, 39, 155, 60, 138, 23, 102, 213], [83, 12, 13, 54, 192, 255, 68, 47, 28], [85, 26, 85, 85, 128, 128, 32, 146, 171], [18, 11, 7, 63, 144, 171, 4, 4, 246], [35, 27, 10, 146, 174, 171, 12, 26, 128]], [[190, 80, 35, 99, 180, 80, 126, 54, 45], [85, 126, 47, 87, 176, 51, 41, 20, 32], [101, 75, 128, 139, 118, 146, 116, 128, 85], [56, 41, 15, 176, 236, 85, 37, 9, 62], [71, 30, 17, 119, 118, 255, 17, 18, 138], [101, 38, 60, 138, 55, 70, 43, 26, 142], [146, 36, 19, 30, 171, 255, 97, 27, 20], [138, 45, 61, 62, 219, 1, 81, 188, 64], [32, 41, 20, 117, 151, 142, 20, 21, 163], [112, 19, 12, 61, 195, 128, 48, 4, 24]]], Ee = [[[[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[176, 246, 255, 255, 255, 255, 255, 255, 255, 255, 255], [223, 241, 252, 255, 255, 255, 255, 255, 255, 255, 255], [249, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 244, 252, 255, 255, 255, 255, 255, 255, 255, 255], [234, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [253, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 246, 254, 255, 255, 255, 255, 255, 255, 255, 255], [239, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 248, 254, 255, 255, 255, 255, 255, 255, 255, 255], [251, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [251, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 254, 253, 255, 254, 255, 255, 255, 255, 255, 255], [250, 255, 254, 255, 254, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]]], [[[217, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [225, 252, 241, 253, 255, 255, 254, 255, 255, 255, 255], [234, 250, 241, 250, 253, 255, 253, 254, 255, 255, 255]], [[255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [223, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [238, 253, 254, 254, 255, 255, 255, 255, 255, 255, 255]], [[255, 248, 254, 255, 255, 255, 255, 255, 255, 255, 255], [249, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 253, 255, 255, 255, 255, 255, 255, 255, 255, 255], [247, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [252, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [253, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 254, 253, 255, 255, 255, 255, 255, 255, 255, 255], [250, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]]], [[[186, 251, 250, 255, 255, 255, 255, 255, 255, 255, 255], [234, 251, 244, 254, 255, 255, 255, 255, 255, 255, 255], [251, 251, 243, 253, 254, 255, 254, 255, 255, 255, 255]], [[255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [236, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [251, 253, 253, 254, 254, 255, 255, 255, 255, 255, 255]], [[255, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [254, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]]], [[[248, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [250, 254, 252, 254, 255, 255, 255, 255, 255, 255, 255], [248, 254, 249, 253, 255, 255, 255, 255, 255, 255, 255]], [[255, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255], [246, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255], [252, 254, 251, 254, 254, 255, 255, 255, 255, 255, 255]], [[255, 254, 252, 255, 255, 255, 255, 255, 255, 255, 255], [248, 254, 253, 255, 255, 255, 255, 255, 255, 255, 255], [253, 255, 254, 254, 255, 255, 255, 255, 255, 255, 255]], [[255, 251, 254, 255, 255, 255, 255, 255, 255, 255, 255], [245, 251, 254, 255, 255, 255, 255, 255, 255, 255, 255], [253, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 251, 253, 255, 255, 255, 255, 255, 255, 255, 255], [252, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 252, 255, 255, 255, 255, 255, 255, 255, 255, 255], [249, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 253, 255, 255, 255, 255, 255, 255, 255, 255], [250, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]]]], Ge = [0, 1, 2, 3, 6, 4, 5, 6, 6, 6, 6, 6, 6, 6, 6, 7, 0], Nc, Y = [], W = [], ka = [], Za, fd2, Nb, pa, Ob, Xc, Tc2, Yc, Uc, Zc, Vc, $c, Wc, Rc, Pc, Sc2, Qc, re = 1, Cc = 2, ia = [], za, vc, fc, Fc, P = [];
    va("UpsampleRgbLinePair", Ga, 3);
    va("UpsampleBgrLinePair", Tb, 3);
    va("UpsampleRgbaLinePair", wd, 4);
    va("UpsampleBgraLinePair", vd, 4);
    va("UpsampleArgbLinePair", ud, 4);
    va("UpsampleRgba4444LinePair", td, 2);
    va("UpsampleRgb565LinePair", sd, 2);
    var Mf = self2.UpsampleRgbLinePair, Nf = self2.UpsampleBgrLinePair, nd = self2.UpsampleRgbaLinePair, od = self2.UpsampleBgraLinePair, pd = self2.UpsampleArgbLinePair, qd = self2.UpsampleRgba4444LinePair, Of = self2.UpsampleRgb565LinePair, Wa = 16, Ba = 1 << Wa - 1, ta = -227, Eb = 482, rd = 6, Pf = (256 << rd) - 1, jc = 0, Yd = V(256), ae = V(256), $d = V(256), Zd = V(256), be = V(Eb - ta), ce = V(Eb - ta);
    la("YuvToRgbRow", Ga, 3);
    la("YuvToBgrRow", Tb, 3);
    la("YuvToRgbaRow", wd, 4);
    la("YuvToBgraRow", vd, 4);
    la("YuvToArgbRow", ud, 4);
    la("YuvToRgba4444Row", td, 2);
    la("YuvToRgb565Row", sd, 2);
    var zd = [0, 4, 8, 12, 128, 132, 136, 140, 256, 260, 264, 268, 384, 388, 392, 396], Ya = [0, 2, 8], Qf = [8, 7, 6, 4, 4, 2, 2, 2, 1, 1, 1, 1], Ne = 1;
    this.WebPDecodeRGBA = function(a2, b, c3, d, e2) {
      var f4 = Ua;
      var g = new Cf(), h2 = new Cb();
      g.ba = h2;
      h2.S = f4;
      h2.width = [h2.width];
      h2.height = [h2.height];
      var k = h2.width;
      var l2 = h2.height, m3 = new Td();
      if (null == m3 || null == a2)
        var n2 = 2;
      else
        x2(null != m3), n2 = Ad(a2, b, c3, m3.width, m3.height, m3.Pd, m3.Qd, m3.format, null);
      0 != n2 ? k = 0 : (null != k && (k[0] = m3.width[0]), null != l2 && (l2[0] = m3.height[0]), k = 1);
      if (k) {
        h2.width = h2.width[0];
        h2.height = h2.height[0];
        null != d && (d[0] = h2.width);
        null != e2 && (e2[0] = h2.height);
        b: {
          d = new Oa();
          e2 = new md();
          e2.data = a2;
          e2.w = b;
          e2.ha = c3;
          e2.kd = 1;
          b = [0];
          x2(null != e2);
          a2 = Ad(e2.data, e2.w, e2.ha, null, null, null, b, null, e2);
          (0 == a2 || 7 == a2) && b[0] && (a2 = 4);
          b = a2;
          if (0 == b) {
            x2(null != g);
            d.data = e2.data;
            d.w = e2.w + e2.offset;
            d.ha = e2.ha - e2.offset;
            d.put = kc;
            d.ac = gc;
            d.bc = lc2;
            d.ma = g;
            if (e2.xa) {
              a2 = Bc();
              if (null == a2) {
                g = 1;
                break b;
              }
              if (te(a2, d)) {
                b = Cd(d.width, d.height, g.Oa, g.ba);
                if (d = 0 == b) {
                  c: {
                    d = a2;
                    d:
                      for (; ; ) {
                        if (null == d) {
                          d = 0;
                          break c;
                        }
                        x2(null != d.s.yc);
                        x2(null != d.s.Ya);
                        x2(0 < d.s.Wb);
                        c3 = d.l;
                        x2(null != c3);
                        e2 = c3.ma;
                        x2(null != e2);
                        if (0 != d.xb) {
                          d.ca = e2.ba;
                          d.tb = e2.tb;
                          x2(null != d.ca);
                          if (!hc(e2.Oa, c3, Va)) {
                            d.a = 2;
                            break d;
                          }
                          if (!Ec(d, c3.width))
                            break d;
                          if (c3.da)
                            break d;
                          (c3.da || hb(d.ca.S)) && Aa();
                          11 > d.ca.S || (alert("todo:WebPInitConvertARGBToYUV"), null != d.ca.f.kb.F && Aa());
                          if (d.Pb && 0 < d.s.ua && null == d.s.vb.X && !Zb(d.s.vb, d.s.Wa.Xa)) {
                            d.a = 1;
                            break d;
                          }
                          d.xb = 0;
                        }
                        if (!Jb(d, d.V, d.Ba, d.c, d.i, c3.o, ge))
                          break d;
                        e2.Dc = d.Ma;
                        d = 1;
                        break c;
                      }
                    x2(0 != d.a);
                    d = 0;
                  }
                  d = !d;
                }
                d && (b = a2.a);
              } else
                b = a2.a;
            } else {
              a2 = new Ce();
              if (null == a2) {
                g = 1;
                break b;
              }
              a2.Fa = e2.na;
              a2.P = e2.P;
              a2.qc = e2.Sa;
              if (Kc(a2, d)) {
                if (b = Cd(d.width, d.height, g.Oa, g.ba), 0 == b) {
                  a2.Aa = 0;
                  c3 = g.Oa;
                  e2 = a2;
                  x2(null != e2);
                  if (null != c3) {
                    k = c3.Md;
                    k = 0 > k ? 0 : 100 < k ? 255 : 255 * k / 100;
                    if (0 < k) {
                      for (l2 = m3 = 0; 4 > l2; ++l2) {
                        n2 = e2.pb[l2], 12 > n2.lc && (n2.ia = k * Qf[0 > n2.lc ? 0 : n2.lc] >> 3), m3 |= n2.ia;
                      }
                      m3 && (alert("todo:VP8InitRandom"), e2.ia = 1);
                    }
                    e2.Ga = c3.Id;
                    100 < e2.Ga ? e2.Ga = 100 : 0 > e2.Ga && (e2.Ga = 0);
                  }
                  Me(a2, d) || (b = a2.a);
                }
              } else
                b = a2.a;
            }
            0 == b && null != g.Oa && g.Oa.fd && (b = Bd(g.ba));
          }
          g = b;
        }
        f4 = 0 != g ? null : 11 > f4 ? h2.f.RGBA.eb : h2.f.kb.y;
      } else
        f4 = null;
      return f4;
    };
    var Dd = [3, 4, 3, 4, 4, 2, 2, 4, 4, 4, 2, 1, 1];
  };
  new _WebPDecoder();
  function memcmp(data2, data_off, str, size2) {
    for (var i3 = 0; i3 < size2; i3++) {
      if (data2[data_off + i3] != str.charCodeAt(i3))
        return true;
    }
    return false;
  }
  function GetTag(data2, data_off) {
    var str = "";
    for (var i3 = 0; i3 < 4; i3++) {
      str += String.fromCharCode(data2[data_off++]);
    }
    return str;
  }
  function GetLE16(data2, data_off) {
    return data2[data_off + 0] << 0 | data2[data_off + 1] << 8;
  }
  function GetLE24(data2, data_off) {
    return (data2[data_off + 0] << 0 | data2[data_off + 1] << 8 | data2[data_off + 2] << 16) >>> 0;
  }
  function GetLE32(data2, data_off) {
    return (data2[data_off + 0] << 0 | data2[data_off + 1] << 8 | data2[data_off + 2] << 16 | data2[data_off + 3] << 24) >>> 0;
  }
  function WebPRiffParser(src, src_off) {
    var imagearray2 = {};
    var i3 = 0;
    var alpha_chunk = false;
    var alpha_size = 0;
    var alpha_offset = 0;
    imagearray2["frames"] = [];
    if (memcmp(src, src_off, "RIFF", 4))
      return;
    src_off += 4;
    var riff_size = GetLE32(src, src_off) + 8;
    src_off += 8;
    while (src_off < src.length) {
      var fourcc = GetTag(src, src_off);
      src_off += 4;
      var payload_size = GetLE32(src, src_off);
      src_off += 4;
      var payload_size_padded = payload_size + (payload_size & 1);
      switch (fourcc) {
        case "VP8 ":
        case "VP8L":
          if (typeof imagearray2["frames"][i3] === "undefined")
            imagearray2["frames"][i3] = {};
          var obj = imagearray2["frames"][i3];
          var height3 = [0];
          var width3 = [0];
          obj["src_off"] = alpha_chunk ? alpha_offset : src_off - 8;
          obj["src_size"] = alpha_size + payload_size + 8;
          i3++;
          if (alpha_chunk) {
            alpha_chunk = false;
            alpha_size = 0;
            alpha_offset = 0;
          }
          break;
        case "VP8X":
          var obj = imagearray2["header"] = {};
          var feature_flags = obj["feature_flags"] = src[src_off];
          var src_off_ = src_off + 4;
          var canvas_width = obj["canvas_width"] = 1 + GetLE24(src, src_off_);
          src_off_ += 3;
          var canvas_height = obj["canvas_height"] = 1 + GetLE24(src, src_off_);
          src_off_ += 3;
          break;
        case "ALPH":
          alpha_chunk = true;
          alpha_size = payload_size_padded + 8;
          alpha_offset = src_off - 8;
          break;
        case "ANIM":
          var obj = imagearray2["header"];
          var bgcolor = obj["bgcolor"] = GetLE32(src, src_off);
          src_off_ = src_off + 4;
          var loop_count = obj["loop_count"] = GetLE16(src, src_off_);
          src_off_ += 2;
          break;
        case "ANMF":
          var offset_x = 0, offset_y = 0, width3 = 0, height3 = 0, duration = 0, blend = 0, dispose = 0, temp = 0;
          var obj = imagearray2["frames"][i3] = {};
          obj["offset_x"] = offset_x = 2 * GetLE24(src, src_off);
          src_off += 3;
          obj["offset_y"] = offset_y = 2 * GetLE24(src, src_off);
          src_off += 3;
          obj["width"] = width3 = 1 + GetLE24(src, src_off);
          src_off += 3;
          obj["height"] = height3 = 1 + GetLE24(src, src_off);
          src_off += 3;
          obj["duration"] = duration = GetLE24(src, src_off);
          src_off += 3;
          temp = src[src_off++];
          obj["dispose"] = dispose = temp & 1;
          obj["blend"] = blend = temp >> 1 & 1;
          break;
      }
      if (fourcc != "ANMF")
        src_off += payload_size_padded;
    }
    return imagearray2;
  }
  var height2 = [0];
  var width2 = [0];
  var pixels = [];
  var webpdecoder = new _WebPDecoder();
  var response = imageData;
  var imagearray = WebPRiffParser(response, 0);
  imagearray["response"] = response;
  imagearray["rgbaoutput"] = true;
  imagearray["dataurl"] = false;
  var header = imagearray["header"] ? imagearray["header"] : null;
  var frames = imagearray["frames"] ? imagearray["frames"] : null;
  if (header) {
    header["loop_counter"] = header["loop_count"];
    height2 = [header["canvas_height"]];
    width2 = [header["canvas_width"]];
    for (var f3 = 0; f3 < frames.length; f3++) {
      if (frames[f3]["blend"] == 0) {
        break;
      }
    }
  }
  var frame = frames[0];
  var rgba = webpdecoder.WebPDecodeRGBA(response, frame["src_off"], frame["src_size"], width2, height2);
  frame["rgba"] = rgba;
  frame["imgwidth"] = width2[0];
  frame["imgheight"] = height2[0];
  for (var i2 = 0; i2 < width2[0] * height2[0] * 4; i2++) {
    pixels[i2] = rgba[i2];
  }
  this.width = width2;
  this.height = height2;
  this.data = pixels;
  return this;
}
WebPDecoder.prototype.getData = function() {
  return this.data;
};
(function(jsPDFAPI2) {
  jsPDFAPI2.processWEBP = function(imageData, index3, alias, compression) {
    var reader = new WebPDecoder(imageData, false);
    var width2 = reader.width, height2 = reader.height;
    var qu = 100;
    var pixels = reader.getData();
    var rawImageData = {
      data: pixels,
      width: width2,
      height: height2
    };
    var encoder = new JPEGEncoder(qu);
    var data2 = encoder.encode(rawImageData, qu);
    return jsPDFAPI2.processJPEG.call(this, data2, index3, alias, compression);
  };
})(jsPDF.API);
(function(jsPDFAPI2) {
  jsPDFAPI2.processRGBA = function(imageData, index3, alias) {
    var imagePixels = imageData.data;
    var length2 = imagePixels.length;
    var rgbOut = new Uint8Array(length2 / 4 * 3);
    var alphaOut = new Uint8Array(length2 / 4);
    var outIndex = 0;
    var alphaIndex = 0;
    for (var i2 = 0; i2 < length2; i2 += 4) {
      var r2 = imagePixels[i2];
      var g = imagePixels[i2 + 1];
      var b = imagePixels[i2 + 2];
      var alpha = imagePixels[i2 + 3];
      rgbOut[outIndex++] = r2;
      rgbOut[outIndex++] = g;
      rgbOut[outIndex++] = b;
      alphaOut[alphaIndex++] = alpha;
    }
    var rgbData = this.__addimage__.arrayBufferToBinaryString(rgbOut);
    var alphaData = this.__addimage__.arrayBufferToBinaryString(alphaOut);
    return {
      alpha: alphaData,
      data: rgbData,
      index: index3,
      alias,
      colorSpace: "DeviceRGB",
      bitsPerComponent: 8,
      width: imageData.width,
      height: imageData.height
    };
  };
})(jsPDF.API);
(function(jsPDFAPI2) {
  jsPDFAPI2.setLanguage = function(langCode) {
    var langCodes = {
      af: "Afrikaans",
      sq: "Albanian",
      ar: "Arabic (Standard)",
      "ar-DZ": "Arabic (Algeria)",
      "ar-BH": "Arabic (Bahrain)",
      "ar-EG": "Arabic (Egypt)",
      "ar-IQ": "Arabic (Iraq)",
      "ar-JO": "Arabic (Jordan)",
      "ar-KW": "Arabic (Kuwait)",
      "ar-LB": "Arabic (Lebanon)",
      "ar-LY": "Arabic (Libya)",
      "ar-MA": "Arabic (Morocco)",
      "ar-OM": "Arabic (Oman)",
      "ar-QA": "Arabic (Qatar)",
      "ar-SA": "Arabic (Saudi Arabia)",
      "ar-SY": "Arabic (Syria)",
      "ar-TN": "Arabic (Tunisia)",
      "ar-AE": "Arabic (U.A.E.)",
      "ar-YE": "Arabic (Yemen)",
      an: "Aragonese",
      hy: "Armenian",
      as: "Assamese",
      ast: "Asturian",
      az: "Azerbaijani",
      eu: "Basque",
      be: "Belarusian",
      bn: "Bengali",
      bs: "Bosnian",
      br: "Breton",
      bg: "Bulgarian",
      my: "Burmese",
      ca: "Catalan",
      ch: "Chamorro",
      ce: "Chechen",
      zh: "Chinese",
      "zh-HK": "Chinese (Hong Kong)",
      "zh-CN": "Chinese (PRC)",
      "zh-SG": "Chinese (Singapore)",
      "zh-TW": "Chinese (Taiwan)",
      cv: "Chuvash",
      co: "Corsican",
      cr: "Cree",
      hr: "Croatian",
      cs: "Czech",
      da: "Danish",
      nl: "Dutch (Standard)",
      "nl-BE": "Dutch (Belgian)",
      en: "English",
      "en-AU": "English (Australia)",
      "en-BZ": "English (Belize)",
      "en-CA": "English (Canada)",
      "en-IE": "English (Ireland)",
      "en-JM": "English (Jamaica)",
      "en-NZ": "English (New Zealand)",
      "en-PH": "English (Philippines)",
      "en-ZA": "English (South Africa)",
      "en-TT": "English (Trinidad & Tobago)",
      "en-GB": "English (United Kingdom)",
      "en-US": "English (United States)",
      "en-ZW": "English (Zimbabwe)",
      eo: "Esperanto",
      et: "Estonian",
      fo: "Faeroese",
      fj: "Fijian",
      fi: "Finnish",
      fr: "French (Standard)",
      "fr-BE": "French (Belgium)",
      "fr-CA": "French (Canada)",
      "fr-FR": "French (France)",
      "fr-LU": "French (Luxembourg)",
      "fr-MC": "French (Monaco)",
      "fr-CH": "French (Switzerland)",
      fy: "Frisian",
      fur: "Friulian",
      gd: "Gaelic (Scots)",
      "gd-IE": "Gaelic (Irish)",
      gl: "Galacian",
      ka: "Georgian",
      de: "German (Standard)",
      "de-AT": "German (Austria)",
      "de-DE": "German (Germany)",
      "de-LI": "German (Liechtenstein)",
      "de-LU": "German (Luxembourg)",
      "de-CH": "German (Switzerland)",
      el: "Greek",
      gu: "Gujurati",
      ht: "Haitian",
      he: "Hebrew",
      hi: "Hindi",
      hu: "Hungarian",
      is: "Icelandic",
      id: "Indonesian",
      iu: "Inuktitut",
      ga: "Irish",
      it: "Italian (Standard)",
      "it-CH": "Italian (Switzerland)",
      ja: "Japanese",
      kn: "Kannada",
      ks: "Kashmiri",
      kk: "Kazakh",
      km: "Khmer",
      ky: "Kirghiz",
      tlh: "Klingon",
      ko: "Korean",
      "ko-KP": "Korean (North Korea)",
      "ko-KR": "Korean (South Korea)",
      la: "Latin",
      lv: "Latvian",
      lt: "Lithuanian",
      lb: "Luxembourgish",
      mk: "North Macedonia",
      ms: "Malay",
      ml: "Malayalam",
      mt: "Maltese",
      mi: "Maori",
      mr: "Marathi",
      mo: "Moldavian",
      nv: "Navajo",
      ng: "Ndonga",
      ne: "Nepali",
      no: "Norwegian",
      nb: "Norwegian (Bokmal)",
      nn: "Norwegian (Nynorsk)",
      oc: "Occitan",
      or: "Oriya",
      om: "Oromo",
      fa: "Persian",
      "fa-IR": "Persian/Iran",
      pl: "Polish",
      pt: "Portuguese",
      "pt-BR": "Portuguese (Brazil)",
      pa: "Punjabi",
      "pa-IN": "Punjabi (India)",
      "pa-PK": "Punjabi (Pakistan)",
      qu: "Quechua",
      rm: "Rhaeto-Romanic",
      ro: "Romanian",
      "ro-MO": "Romanian (Moldavia)",
      ru: "Russian",
      "ru-MO": "Russian (Moldavia)",
      sz: "Sami (Lappish)",
      sg: "Sango",
      sa: "Sanskrit",
      sc: "Sardinian",
      sd: "Sindhi",
      si: "Singhalese",
      sr: "Serbian",
      sk: "Slovak",
      sl: "Slovenian",
      so: "Somani",
      sb: "Sorbian",
      es: "Spanish",
      "es-AR": "Spanish (Argentina)",
      "es-BO": "Spanish (Bolivia)",
      "es-CL": "Spanish (Chile)",
      "es-CO": "Spanish (Colombia)",
      "es-CR": "Spanish (Costa Rica)",
      "es-DO": "Spanish (Dominican Republic)",
      "es-EC": "Spanish (Ecuador)",
      "es-SV": "Spanish (El Salvador)",
      "es-GT": "Spanish (Guatemala)",
      "es-HN": "Spanish (Honduras)",
      "es-MX": "Spanish (Mexico)",
      "es-NI": "Spanish (Nicaragua)",
      "es-PA": "Spanish (Panama)",
      "es-PY": "Spanish (Paraguay)",
      "es-PE": "Spanish (Peru)",
      "es-PR": "Spanish (Puerto Rico)",
      "es-ES": "Spanish (Spain)",
      "es-UY": "Spanish (Uruguay)",
      "es-VE": "Spanish (Venezuela)",
      sx: "Sutu",
      sw: "Swahili",
      sv: "Swedish",
      "sv-FI": "Swedish (Finland)",
      "sv-SV": "Swedish (Sweden)",
      ta: "Tamil",
      tt: "Tatar",
      te: "Teluga",
      th: "Thai",
      tig: "Tigre",
      ts: "Tsonga",
      tn: "Tswana",
      tr: "Turkish",
      tk: "Turkmen",
      uk: "Ukrainian",
      hsb: "Upper Sorbian",
      ur: "Urdu",
      ve: "Venda",
      vi: "Vietnamese",
      vo: "Volapuk",
      wa: "Walloon",
      cy: "Welsh",
      xh: "Xhosa",
      ji: "Yiddish",
      zu: "Zulu"
    };
    if (this.internal.languageSettings === void 0) {
      this.internal.languageSettings = {};
      this.internal.languageSettings.isSubscribed = false;
    }
    if (langCodes[langCode] !== void 0) {
      this.internal.languageSettings.languageCode = langCode;
      if (this.internal.languageSettings.isSubscribed === false) {
        this.internal.events.subscribe("putCatalog", function() {
          this.internal.write("/Lang (" + this.internal.languageSettings.languageCode + ")");
        });
        this.internal.languageSettings.isSubscribed = true;
      }
    }
    return this;
  };
})(jsPDF.API);
(function(API) {
  var getCharWidthsArray = API.getCharWidthsArray = function(text4, options) {
    options = options || {};
    var activeFont = options.font || this.internal.getFont();
    var fontSize = options.fontSize || this.internal.getFontSize();
    var charSpace = options.charSpace || this.internal.getCharSpace();
    var widths = options.widths ? options.widths : activeFont.metadata.Unicode.widths;
    var widthsFractionOf = widths.fof ? widths.fof : 1;
    var kerning = options.kerning ? options.kerning : activeFont.metadata.Unicode.kerning;
    var kerningFractionOf = kerning.fof ? kerning.fof : 1;
    var doKerning = options.doKerning === false ? false : true;
    var kerningValue = 0;
    var i2;
    var length2 = text4.length;
    var char_code;
    var prior_char_code = 0;
    var default_char_width = widths[0] || widthsFractionOf;
    var output = [];
    for (i2 = 0; i2 < length2; i2++) {
      char_code = text4.charCodeAt(i2);
      if (typeof activeFont.metadata.widthOfString === "function") {
        output.push((activeFont.metadata.widthOfGlyph(activeFont.metadata.characterToGlyph(char_code)) + charSpace * (1e3 / fontSize) || 0) / 1e3);
      } else {
        if (doKerning && _typeof(kerning[char_code]) === "object" && !isNaN(parseInt(kerning[char_code][prior_char_code], 10))) {
          kerningValue = kerning[char_code][prior_char_code] / kerningFractionOf;
        } else {
          kerningValue = 0;
        }
        output.push((widths[char_code] || default_char_width) / widthsFractionOf + kerningValue);
      }
      prior_char_code = char_code;
    }
    return output;
  };
  var getStringUnitWidth = API.getStringUnitWidth = function(text4, options) {
    options = options || {};
    var fontSize = options.fontSize || this.internal.getFontSize();
    var font = options.font || this.internal.getFont();
    var charSpace = options.charSpace || this.internal.getCharSpace();
    var result = 0;
    if (API.processArabic) {
      text4 = API.processArabic(text4);
    }
    if (typeof font.metadata.widthOfString === "function") {
      result = font.metadata.widthOfString(text4, fontSize, charSpace) / fontSize;
    } else {
      result = getCharWidthsArray.apply(this, arguments).reduce(function(pv, cv) {
        return pv + cv;
      }, 0);
    }
    return result;
  };
  var splitLongWord = function splitLongWord2(word, widths_array, firstLineMaxLen, maxLen) {
    var answer = [];
    var i2 = 0, l2 = word.length, workingLen = 0;
    while (i2 !== l2 && workingLen + widths_array[i2] < firstLineMaxLen) {
      workingLen += widths_array[i2];
      i2++;
    }
    answer.push(word.slice(0, i2));
    var startOfLine = i2;
    workingLen = 0;
    while (i2 !== l2) {
      if (workingLen + widths_array[i2] > maxLen) {
        answer.push(word.slice(startOfLine, i2));
        workingLen = 0;
        startOfLine = i2;
      }
      workingLen += widths_array[i2];
      i2++;
    }
    if (startOfLine !== i2) {
      answer.push(word.slice(startOfLine, i2));
    }
    return answer;
  };
  var splitParagraphIntoLines = function splitParagraphIntoLines2(text4, maxlen, options) {
    if (!options) {
      options = {};
    }
    var line = [], lines = [line], line_length = options.textIndent || 0, separator_length = 0, current_word_length = 0, word, widths_array, words = text4.split(" "), spaceCharWidth = getCharWidthsArray.apply(this, [" ", options])[0], i2, l2, tmp, lineIndent;
    if (options.lineIndent === -1) {
      lineIndent = words[0].length + 2;
    } else {
      lineIndent = options.lineIndent || 0;
    }
    if (lineIndent) {
      var pad2 = Array(lineIndent).join(" "), wrds = [];
      words.map(function(wrd) {
        wrd = wrd.split(/\s*\n/);
        if (wrd.length > 1) {
          wrds = wrds.concat(wrd.map(function(wrd2, idx) {
            return (idx && wrd2.length ? "\n" : "") + wrd2;
          }));
        } else {
          wrds.push(wrd[0]);
        }
      });
      words = wrds;
      lineIndent = getStringUnitWidth.apply(this, [pad2, options]);
    }
    for (i2 = 0, l2 = words.length; i2 < l2; i2++) {
      var force = 0;
      word = words[i2];
      if (lineIndent && word[0] == "\n") {
        word = word.substr(1);
        force = 1;
      }
      widths_array = getCharWidthsArray.apply(this, [word, options]);
      current_word_length = widths_array.reduce(function(pv, cv) {
        return pv + cv;
      }, 0);
      if (line_length + separator_length + current_word_length > maxlen || force) {
        if (current_word_length > maxlen) {
          tmp = splitLongWord.apply(this, [word, widths_array, maxlen - (line_length + separator_length), maxlen]);
          line.push(tmp.shift());
          line = [tmp.pop()];
          while (tmp.length) {
            lines.push([tmp.shift()]);
          }
          current_word_length = widths_array.slice(word.length - (line[0] ? line[0].length : 0)).reduce(function(pv, cv) {
            return pv + cv;
          }, 0);
        } else {
          line = [word];
        }
        lines.push(line);
        line_length = current_word_length + lineIndent;
        separator_length = spaceCharWidth;
      } else {
        line.push(word);
        line_length += separator_length + current_word_length;
        separator_length = spaceCharWidth;
      }
    }
    var postProcess;
    if (lineIndent) {
      postProcess = function postProcess2(ln2, idx) {
        return (idx ? pad2 : "") + ln2.join(" ");
      };
    } else {
      postProcess = function postProcess2(ln2) {
        return ln2.join(" ");
      };
    }
    return lines.map(postProcess);
  };
  API.splitTextToSize = function(text4, maxlen, options) {
    options = options || {};
    var fsize = options.fontSize || this.internal.getFontSize(), newOptions = function(options2) {
      var widths = {
        0: 1
      }, kerning = {};
      if (!options2.widths || !options2.kerning) {
        var f3 = this.internal.getFont(options2.fontName, options2.fontStyle), encoding = "Unicode";
        if (f3.metadata[encoding]) {
          return {
            widths: f3.metadata[encoding].widths || widths,
            kerning: f3.metadata[encoding].kerning || kerning
          };
        } else {
          return {
            font: f3.metadata,
            fontSize: this.internal.getFontSize(),
            charSpace: this.internal.getCharSpace()
          };
        }
      } else {
        return {
          widths: options2.widths,
          kerning: options2.kerning
        };
      }
    }.call(this, options);
    var paragraphs;
    if (Array.isArray(text4)) {
      paragraphs = text4;
    } else {
      paragraphs = String(text4).split(/\r?\n/);
    }
    var fontUnit_maxLen = 1 * this.internal.scaleFactor * maxlen / fsize;
    newOptions.textIndent = options.textIndent ? options.textIndent * 1 * this.internal.scaleFactor / fsize : 0;
    newOptions.lineIndent = options.lineIndent;
    var i2, l2, output = [];
    for (i2 = 0, l2 = paragraphs.length; i2 < l2; i2++) {
      output = output.concat(splitParagraphIntoLines.apply(this, [paragraphs[i2], fontUnit_maxLen, newOptions]));
    }
    return output;
  };
})(jsPDF.API);
(function(API) {
  API.__fontmetrics__ = API.__fontmetrics__ || {};
  var decoded = "0123456789abcdef", encoded = "klmnopqrstuvwxyz", mappingUncompress = {}, mappingCompress = {};
  for (var i2 = 0; i2 < encoded.length; i2++) {
    mappingUncompress[encoded[i2]] = decoded[i2];
    mappingCompress[decoded[i2]] = encoded[i2];
  }
  var hex3 = function hex4(value) {
    return "0x" + parseInt(value, 10).toString(16);
  };
  var compress = API.__fontmetrics__.compress = function(data2) {
    var vals = ["{"];
    var value, keystring, valuestring, numberprefix;
    for (var key in data2) {
      value = data2[key];
      if (!isNaN(parseInt(key, 10))) {
        key = parseInt(key, 10);
        keystring = hex3(key).slice(2);
        keystring = keystring.slice(0, -1) + mappingCompress[keystring.slice(-1)];
      } else {
        keystring = "'" + key + "'";
      }
      if (typeof value == "number") {
        if (value < 0) {
          valuestring = hex3(value).slice(3);
          numberprefix = "-";
        } else {
          valuestring = hex3(value).slice(2);
          numberprefix = "";
        }
        valuestring = numberprefix + valuestring.slice(0, -1) + mappingCompress[valuestring.slice(-1)];
      } else {
        if (_typeof(value) === "object") {
          valuestring = compress(value);
        } else {
          throw new Error("Don't know what to do with value type " + _typeof(value) + ".");
        }
      }
      vals.push(keystring + valuestring);
    }
    vals.push("}");
    return vals.join("");
  };
  var uncompress = API.__fontmetrics__.uncompress = function(data2) {
    if (typeof data2 !== "string") {
      throw new Error("Invalid argument passed to uncompress.");
    }
    var output = {}, sign = 1, stringparts, activeobject = output, parentchain = [], parent_key_pair, keyparts = "", valueparts = "", key, datalen = data2.length - 1, ch;
    for (var i3 = 1; i3 < datalen; i3 += 1) {
      ch = data2[i3];
      if (ch == "'") {
        if (stringparts) {
          key = stringparts.join("");
          stringparts = void 0;
        } else {
          stringparts = [];
        }
      } else if (stringparts) {
        stringparts.push(ch);
      } else if (ch == "{") {
        parentchain.push([activeobject, key]);
        activeobject = {};
        key = void 0;
      } else if (ch == "}") {
        parent_key_pair = parentchain.pop();
        parent_key_pair[0][parent_key_pair[1]] = activeobject;
        key = void 0;
        activeobject = parent_key_pair[0];
      } else if (ch == "-") {
        sign = -1;
      } else {
        if (key === void 0) {
          if (mappingUncompress.hasOwnProperty(ch)) {
            keyparts += mappingUncompress[ch];
            key = parseInt(keyparts, 16) * sign;
            sign = 1;
            keyparts = "";
          } else {
            keyparts += ch;
          }
        } else {
          if (mappingUncompress.hasOwnProperty(ch)) {
            valueparts += mappingUncompress[ch];
            activeobject[key] = parseInt(valueparts, 16) * sign;
            sign = 1;
            key = void 0;
            valueparts = "";
          } else {
            valueparts += ch;
          }
        }
      }
    }
    return output;
  };
  var encodingBlock = {
    codePages: ["WinAnsiEncoding"],
    WinAnsiEncoding: uncompress("{19m8n201n9q201o9r201s9l201t9m201u8m201w9n201x9o201y8o202k8q202l8r202m9p202q8p20aw8k203k8t203t8v203u9v2cq8s212m9t15m8w15n9w2dw9s16k8u16l9u17s9z17x8y17y9y}")
  };
  var encodings = {
    Unicode: {
      Courier: encodingBlock,
      "Courier-Bold": encodingBlock,
      "Courier-BoldOblique": encodingBlock,
      "Courier-Oblique": encodingBlock,
      Helvetica: encodingBlock,
      "Helvetica-Bold": encodingBlock,
      "Helvetica-BoldOblique": encodingBlock,
      "Helvetica-Oblique": encodingBlock,
      "Times-Roman": encodingBlock,
      "Times-Bold": encodingBlock,
      "Times-BoldItalic": encodingBlock,
      "Times-Italic": encodingBlock
      //	, 'Symbol'
      //	, 'ZapfDingbats'
    }
  };
  var fontMetrics = {
    Unicode: {
      // all sizing numbers are n/fontMetricsFractionOf = one font size unit
      // this means that if fontMetricsFractionOf = 1000, and letter A's width is 476, it's
      // width is 476/1000 or 47.6% of its height (regardless of font size)
      // At this time this value applies to "widths" and "kerning" numbers.
      // char code 0 represents "default" (average) width - use it for chars missing in this table.
      // key 'fof' represents the "fontMetricsFractionOf" value
      "Courier-Oblique": uncompress("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"),
      "Times-BoldItalic": uncompress("{'widths'{k3o2q4ycx2r201n3m201o6o201s2l201t2l201u2l201w3m201x3m201y3m2k1t2l2r202m2n2n3m2o3m2p5n202q6o2r1w2s2l2t2l2u3m2v3t2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w3t3x3t3y3t3z3m4k5n4l4m4m4m4n4m4o4s4p4m4q4m4r4s4s4y4t2r4u3m4v4m4w3x4x5t4y4s4z4s5k3x5l4s5m4m5n3r5o3x5p4s5q4m5r5t5s4m5t3x5u3x5v2l5w1w5x2l5y3t5z3m6k2l6l3m6m3m6n2w6o3m6p2w6q2l6r3m6s3r6t1w6u1w6v3m6w1w6x4y6y3r6z3m7k3m7l3m7m2r7n2r7o1w7p3r7q2w7r4m7s3m7t2w7u2r7v2n7w1q7x2n7y3t202l3mcl4mal2ram3man3mao3map3mar3mas2lat4uau1uav3maw3way4uaz2lbk2sbl3t'fof'6obo2lbp3tbq3mbr1tbs2lbu1ybv3mbz3mck4m202k3mcm4mcn4mco4mcp4mcq5ycr4mcs4mct4mcu4mcv4mcw2r2m3rcy2rcz2rdl4sdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek3mel3mem3men3meo3mep3meq4ser2wes2wet2weu2wev2wew1wex1wey1wez1wfl3rfm3mfn3mfo3mfp3mfq3mfr3tfs3mft3rfu3rfv3rfw3rfz2w203k6o212m6o2dw2l2cq2l3t3m3u2l17s3x19m3m}'kerning'{cl{4qu5kt5qt5rs17ss5ts}201s{201ss}201t{cks4lscmscnscoscpscls2wu2yu201ts}201x{2wu2yu}2k{201ts}2w{4qx5kx5ou5qx5rs17su5tu}2x{17su5tu5ou}2y{4qx5kx5ou5qx5rs17ss5ts}'fof'-6ofn{17sw5tw5ou5qw5rs}7t{cksclscmscnscoscps4ls}3u{17su5tu5os5qs}3v{17su5tu5os5qs}7p{17su5tu}ck{4qu5kt5qt5rs17ss5ts}4l{4qu5kt5qt5rs17ss5ts}cm{4qu5kt5qt5rs17ss5ts}cn{4qu5kt5qt5rs17ss5ts}co{4qu5kt5qt5rs17ss5ts}cp{4qu5kt5qt5rs17ss5ts}6l{4qu5ou5qw5rt17su5tu}5q{ckuclucmucnucoucpu4lu}5r{ckuclucmucnucoucpu4lu}7q{cksclscmscnscoscps4ls}6p{4qu5ou5qw5rt17sw5tw}ek{4qu5ou5qw5rt17su5tu}el{4qu5ou5qw5rt17su5tu}em{4qu5ou5qw5rt17su5tu}en{4qu5ou5qw5rt17su5tu}eo{4qu5ou5qw5rt17su5tu}ep{4qu5ou5qw5rt17su5tu}es{17ss5ts5qs4qu}et{4qu5ou5qw5rt17sw5tw}eu{4qu5ou5qw5rt17ss5ts}ev{17ss5ts5qs4qu}6z{17sw5tw5ou5qw5rs}fm{17sw5tw5ou5qw5rs}7n{201ts}fo{17sw5tw5ou5qw5rs}fp{17sw5tw5ou5qw5rs}fq{17sw5tw5ou5qw5rs}7r{cksclscmscnscoscps4ls}fs{17sw5tw5ou5qw5rs}ft{17su5tu}fu{17su5tu}fv{17su5tu}fw{17su5tu}fz{cksclscmscnscoscps4ls}}}"),
      "Helvetica-Bold": uncompress("{'widths'{k3s2q4scx1w201n3r201o6o201s1w201t1w201u1w201w3m201x3m201y3m2k1w2l2l202m2n2n3r2o3r2p5t202q6o2r1s2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v2l3w3u3x3u3y3u3z3x4k6l4l4s4m4s4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3r4v4s4w3x4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v2l5w1w5x2l5y3u5z3r6k2l6l3r6m3x6n3r6o3x6p3r6q2l6r3x6s3x6t1w6u1w6v3r6w1w6x5t6y3x6z3x7k3x7l3x7m2r7n3r7o2l7p3x7q3r7r4y7s3r7t3r7u3m7v2r7w1w7x2r7y3u202l3rcl4sal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3xbq3rbr1wbs2lbu2obv3rbz3xck4s202k3rcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw1w2m2zcy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3res3ret3reu3rev3rew1wex1wey1wez1wfl3xfm3xfn3xfo3xfp3xfq3xfr3ufs3xft3xfu3xfv3xfw3xfz3r203k6o212m6o2dw2l2cq2l3t3r3u2l17s4m19m3r}'kerning'{cl{4qs5ku5ot5qs17sv5tv}201t{2ww4wy2yw}201w{2ks}201x{2ww4wy2yw}2k{201ts201xs}2w{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}2x{5ow5qs}2y{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}'fof'-6o7p{17su5tu5ot}ck{4qs5ku5ot5qs17sv5tv}4l{4qs5ku5ot5qs17sv5tv}cm{4qs5ku5ot5qs17sv5tv}cn{4qs5ku5ot5qs17sv5tv}co{4qs5ku5ot5qs17sv5tv}cp{4qs5ku5ot5qs17sv5tv}6l{17st5tt5os}17s{2kwclvcmvcnvcovcpv4lv4wwckv}5o{2kucltcmtcntcotcpt4lt4wtckt}5q{2ksclscmscnscoscps4ls4wvcks}5r{2ks4ws}5t{2kwclvcmvcnvcovcpv4lv4wwckv}eo{17st5tt5os}fu{17su5tu5ot}6p{17ss5ts}ek{17st5tt5os}el{17st5tt5os}em{17st5tt5os}en{17st5tt5os}6o{201ts}ep{17st5tt5os}es{17ss5ts}et{17ss5ts}eu{17ss5ts}ev{17ss5ts}6z{17su5tu5os5qt}fm{17su5tu5os5qt}fn{17su5tu5os5qt}fo{17su5tu5os5qt}fp{17su5tu5os5qt}fq{17su5tu5os5qt}fs{17su5tu5os5qt}ft{17su5tu5ot}7m{5os}fv{17su5tu5ot}fw{17su5tu5ot}}}"),
      Courier: uncompress("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"),
      "Courier-BoldOblique": uncompress("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"),
      "Times-Bold": uncompress("{'widths'{k3q2q5ncx2r201n3m201o6o201s2l201t2l201u2l201w3m201x3m201y3m2k1t2l2l202m2n2n3m2o3m2p6o202q6o2r1w2s2l2t2l2u3m2v3t2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w3t3x3t3y3t3z3m4k5x4l4s4m4m4n4s4o4s4p4m4q3x4r4y4s4y4t2r4u3m4v4y4w4m4x5y4y4s4z4y5k3x5l4y5m4s5n3r5o4m5p4s5q4s5r6o5s4s5t4s5u4m5v2l5w1w5x2l5y3u5z3m6k2l6l3m6m3r6n2w6o3r6p2w6q2l6r3m6s3r6t1w6u2l6v3r6w1w6x5n6y3r6z3m7k3r7l3r7m2w7n2r7o2l7p3r7q3m7r4s7s3m7t3m7u2w7v2r7w1q7x2r7y3o202l3mcl4sal2lam3man3mao3map3mar3mas2lat4uau1yav3maw3tay4uaz2lbk2sbl3t'fof'6obo2lbp3rbr1tbs2lbu2lbv3mbz3mck4s202k3mcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw2r2m3rcy2rcz2rdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3rek3mel3mem3men3meo3mep3meq4ser2wes2wet2weu2wev2wew1wex1wey1wez1wfl3rfm3mfn3mfo3mfp3mfq3mfr3tfs3mft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3m3u2l17s4s19m3m}'kerning'{cl{4qt5ks5ot5qy5rw17sv5tv}201t{cks4lscmscnscoscpscls4wv}2k{201ts}2w{4qu5ku7mu5os5qx5ru17su5tu}2x{17su5tu5ou5qs}2y{4qv5kv7mu5ot5qz5ru17su5tu}'fof'-6o7t{cksclscmscnscoscps4ls}3u{17su5tu5os5qu}3v{17su5tu5os5qu}fu{17su5tu5ou5qu}7p{17su5tu5ou5qu}ck{4qt5ks5ot5qy5rw17sv5tv}4l{4qt5ks5ot5qy5rw17sv5tv}cm{4qt5ks5ot5qy5rw17sv5tv}cn{4qt5ks5ot5qy5rw17sv5tv}co{4qt5ks5ot5qy5rw17sv5tv}cp{4qt5ks5ot5qy5rw17sv5tv}6l{17st5tt5ou5qu}17s{ckuclucmucnucoucpu4lu4wu}5o{ckuclucmucnucoucpu4lu4wu}5q{ckzclzcmzcnzcozcpz4lz4wu}5r{ckxclxcmxcnxcoxcpx4lx4wu}5t{ckuclucmucnucoucpu4lu4wu}7q{ckuclucmucnucoucpu4lu}6p{17sw5tw5ou5qu}ek{17st5tt5qu}el{17st5tt5ou5qu}em{17st5tt5qu}en{17st5tt5qu}eo{17st5tt5qu}ep{17st5tt5ou5qu}es{17ss5ts5qu}et{17sw5tw5ou5qu}eu{17sw5tw5ou5qu}ev{17ss5ts5qu}6z{17sw5tw5ou5qu5rs}fm{17sw5tw5ou5qu5rs}fn{17sw5tw5ou5qu5rs}fo{17sw5tw5ou5qu5rs}fp{17sw5tw5ou5qu5rs}fq{17sw5tw5ou5qu5rs}7r{cktcltcmtcntcotcpt4lt5os}fs{17sw5tw5ou5qu5rs}ft{17su5tu5ou5qu}7m{5os}fv{17su5tu5ou5qu}fw{17su5tu5ou5qu}fz{cksclscmscnscoscps4ls}}}"),
      Symbol: uncompress("{'widths'{k3uaw4r19m3m2k1t2l2l202m2y2n3m2p5n202q6o3k3m2s2l2t2l2v3r2w1t3m3m2y1t2z1wbk2sbl3r'fof'6o3n3m3o3m3p3m3q3m3r3m3s3m3t3m3u1w3v1w3w3r3x3r3y3r3z2wbp3t3l3m5v2l5x2l5z3m2q4yfr3r7v3k7w1o7x3k}'kerning'{'fof'-6o}}"),
      Helvetica: uncompress("{'widths'{k3p2q4mcx1w201n3r201o6o201s1q201t1q201u1q201w2l201x2l201y2l2k1w2l1w202m2n2n3r2o3r2p5t202q6o2r1n2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v1w3w3u3x3u3y3u3z3r4k6p4l4m4m4m4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3m4v4m4w3r4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v1w5w1w5x1w5y2z5z3r6k2l6l3r6m3r6n3m6o3r6p3r6q1w6r3r6s3r6t1q6u1q6v3m6w1q6x5n6y3r6z3r7k3r7l3r7m2l7n3m7o1w7p3r7q3m7r4s7s3m7t3m7u3m7v2l7w1u7x2l7y3u202l3rcl4mal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3rbr1wbs2lbu2obv3rbz3xck4m202k3rcm4mcn4mco4mcp4mcq6ocr4scs4mct4mcu4mcv4mcw1w2m2ncy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3mes3ret3reu3rev3rew1wex1wey1wez1wfl3rfm3rfn3rfo3rfp3rfq3rfr3ufs3xft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3r3u1w17s4m19m3r}'kerning'{5q{4wv}cl{4qs5kw5ow5qs17sv5tv}201t{2wu4w1k2yu}201x{2wu4wy2yu}17s{2ktclucmucnu4otcpu4lu4wycoucku}2w{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}2x{17sy5ty5oy5qs}2y{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}'fof'-6o7p{17sv5tv5ow}ck{4qs5kw5ow5qs17sv5tv}4l{4qs5kw5ow5qs17sv5tv}cm{4qs5kw5ow5qs17sv5tv}cn{4qs5kw5ow5qs17sv5tv}co{4qs5kw5ow5qs17sv5tv}cp{4qs5kw5ow5qs17sv5tv}6l{17sy5ty5ow}do{17st5tt}4z{17st5tt}7s{fst}dm{17st5tt}dn{17st5tt}5o{ckwclwcmwcnwcowcpw4lw4wv}dp{17st5tt}dq{17st5tt}7t{5ow}ds{17st5tt}5t{2ktclucmucnu4otcpu4lu4wycoucku}fu{17sv5tv5ow}6p{17sy5ty5ow5qs}ek{17sy5ty5ow}el{17sy5ty5ow}em{17sy5ty5ow}en{5ty}eo{17sy5ty5ow}ep{17sy5ty5ow}es{17sy5ty5qs}et{17sy5ty5ow5qs}eu{17sy5ty5ow5qs}ev{17sy5ty5ow5qs}6z{17sy5ty5ow5qs}fm{17sy5ty5ow5qs}fn{17sy5ty5ow5qs}fo{17sy5ty5ow5qs}fp{17sy5ty5qs}fq{17sy5ty5ow5qs}7r{5ow}fs{17sy5ty5ow5qs}ft{17sv5tv5ow}7m{5ow}fv{17sv5tv5ow}fw{17sv5tv5ow}}}"),
      "Helvetica-BoldOblique": uncompress("{'widths'{k3s2q4scx1w201n3r201o6o201s1w201t1w201u1w201w3m201x3m201y3m2k1w2l2l202m2n2n3r2o3r2p5t202q6o2r1s2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v2l3w3u3x3u3y3u3z3x4k6l4l4s4m4s4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3r4v4s4w3x4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v2l5w1w5x2l5y3u5z3r6k2l6l3r6m3x6n3r6o3x6p3r6q2l6r3x6s3x6t1w6u1w6v3r6w1w6x5t6y3x6z3x7k3x7l3x7m2r7n3r7o2l7p3x7q3r7r4y7s3r7t3r7u3m7v2r7w1w7x2r7y3u202l3rcl4sal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3xbq3rbr1wbs2lbu2obv3rbz3xck4s202k3rcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw1w2m2zcy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3res3ret3reu3rev3rew1wex1wey1wez1wfl3xfm3xfn3xfo3xfp3xfq3xfr3ufs3xft3xfu3xfv3xfw3xfz3r203k6o212m6o2dw2l2cq2l3t3r3u2l17s4m19m3r}'kerning'{cl{4qs5ku5ot5qs17sv5tv}201t{2ww4wy2yw}201w{2ks}201x{2ww4wy2yw}2k{201ts201xs}2w{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}2x{5ow5qs}2y{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}'fof'-6o7p{17su5tu5ot}ck{4qs5ku5ot5qs17sv5tv}4l{4qs5ku5ot5qs17sv5tv}cm{4qs5ku5ot5qs17sv5tv}cn{4qs5ku5ot5qs17sv5tv}co{4qs5ku5ot5qs17sv5tv}cp{4qs5ku5ot5qs17sv5tv}6l{17st5tt5os}17s{2kwclvcmvcnvcovcpv4lv4wwckv}5o{2kucltcmtcntcotcpt4lt4wtckt}5q{2ksclscmscnscoscps4ls4wvcks}5r{2ks4ws}5t{2kwclvcmvcnvcovcpv4lv4wwckv}eo{17st5tt5os}fu{17su5tu5ot}6p{17ss5ts}ek{17st5tt5os}el{17st5tt5os}em{17st5tt5os}en{17st5tt5os}6o{201ts}ep{17st5tt5os}es{17ss5ts}et{17ss5ts}eu{17ss5ts}ev{17ss5ts}6z{17su5tu5os5qt}fm{17su5tu5os5qt}fn{17su5tu5os5qt}fo{17su5tu5os5qt}fp{17su5tu5os5qt}fq{17su5tu5os5qt}fs{17su5tu5os5qt}ft{17su5tu5ot}7m{5os}fv{17su5tu5ot}fw{17su5tu5ot}}}"),
      ZapfDingbats: uncompress("{'widths'{k4u2k1w'fof'6o}'kerning'{'fof'-6o}}"),
      "Courier-Bold": uncompress("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"),
      "Times-Italic": uncompress("{'widths'{k3n2q4ycx2l201n3m201o5t201s2l201t2l201u2l201w3r201x3r201y3r2k1t2l2l202m2n2n3m2o3m2p5n202q5t2r1p2s2l2t2l2u3m2v4n2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w4n3x4n3y4n3z3m4k5w4l3x4m3x4n4m4o4s4p3x4q3x4r4s4s4s4t2l4u2w4v4m4w3r4x5n4y4m4z4s5k3x5l4s5m3x5n3m5o3r5p4s5q3x5r5n5s3x5t3r5u3r5v2r5w1w5x2r5y2u5z3m6k2l6l3m6m3m6n2w6o3m6p2w6q1w6r3m6s3m6t1w6u1w6v2w6w1w6x4s6y3m6z3m7k3m7l3m7m2r7n2r7o1w7p3m7q2w7r4m7s2w7t2w7u2r7v2s7w1v7x2s7y3q202l3mcl3xal2ram3man3mao3map3mar3mas2lat4wau1vav3maw4nay4waz2lbk2sbl4n'fof'6obo2lbp3mbq3obr1tbs2lbu1zbv3mbz3mck3x202k3mcm3xcn3xco3xcp3xcq5tcr4mcs3xct3xcu3xcv3xcw2l2m2ucy2lcz2ldl4mdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek3mel3mem3men3meo3mep3meq4mer2wes2wet2weu2wev2wew1wex1wey1wez1wfl3mfm3mfn3mfo3mfp3mfq3mfr4nfs3mft3mfu3mfv3mfw3mfz2w203k6o212m6m2dw2l2cq2l3t3m3u2l17s3r19m3m}'kerning'{cl{5kt4qw}201s{201sw}201t{201tw2wy2yy6q-t}201x{2wy2yy}2k{201tw}2w{7qs4qy7rs5ky7mw5os5qx5ru17su5tu}2x{17ss5ts5os}2y{7qs4qy7rs5ky7mw5os5qx5ru17su5tu}'fof'-6o6t{17ss5ts5qs}7t{5os}3v{5qs}7p{17su5tu5qs}ck{5kt4qw}4l{5kt4qw}cm{5kt4qw}cn{5kt4qw}co{5kt4qw}cp{5kt4qw}6l{4qs5ks5ou5qw5ru17su5tu}17s{2ks}5q{ckvclvcmvcnvcovcpv4lv}5r{ckuclucmucnucoucpu4lu}5t{2ks}6p{4qs5ks5ou5qw5ru17su5tu}ek{4qs5ks5ou5qw5ru17su5tu}el{4qs5ks5ou5qw5ru17su5tu}em{4qs5ks5ou5qw5ru17su5tu}en{4qs5ks5ou5qw5ru17su5tu}eo{4qs5ks5ou5qw5ru17su5tu}ep{4qs5ks5ou5qw5ru17su5tu}es{5ks5qs4qs}et{4qs5ks5ou5qw5ru17su5tu}eu{4qs5ks5qw5ru17su5tu}ev{5ks5qs4qs}ex{17ss5ts5qs}6z{4qv5ks5ou5qw5ru17su5tu}fm{4qv5ks5ou5qw5ru17su5tu}fn{4qv5ks5ou5qw5ru17su5tu}fo{4qv5ks5ou5qw5ru17su5tu}fp{4qv5ks5ou5qw5ru17su5tu}fq{4qv5ks5ou5qw5ru17su5tu}7r{5os}fs{4qv5ks5ou5qw5ru17su5tu}ft{17su5tu5qs}fu{17su5tu5qs}fv{17su5tu5qs}fw{17su5tu5qs}}}"),
      "Times-Roman": uncompress("{'widths'{k3n2q4ycx2l201n3m201o6o201s2l201t2l201u2l201w2w201x2w201y2w2k1t2l2l202m2n2n3m2o3m2p5n202q6o2r1m2s2l2t2l2u3m2v3s2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v1w3w3s3x3s3y3s3z2w4k5w4l4s4m4m4n4m4o4s4p3x4q3r4r4s4s4s4t2l4u2r4v4s4w3x4x5t4y4s4z4s5k3r5l4s5m4m5n3r5o3x5p4s5q4s5r5y5s4s5t4s5u3x5v2l5w1w5x2l5y2z5z3m6k2l6l2w6m3m6n2w6o3m6p2w6q2l6r3m6s3m6t1w6u1w6v3m6w1w6x4y6y3m6z3m7k3m7l3m7m2l7n2r7o1w7p3m7q3m7r4s7s3m7t3m7u2w7v3k7w1o7x3k7y3q202l3mcl4sal2lam3man3mao3map3mar3mas2lat4wau1vav3maw3say4waz2lbk2sbl3s'fof'6obo2lbp3mbq2xbr1tbs2lbu1zbv3mbz2wck4s202k3mcm4scn4sco4scp4scq5tcr4mcs3xct3xcu3xcv3xcw2l2m2tcy2lcz2ldl4sdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek2wel2wem2wen2weo2wep2weq4mer2wes2wet2weu2wev2wew1wex1wey1wez1wfl3mfm3mfn3mfo3mfp3mfq3mfr3sfs3mft3mfu3mfv3mfw3mfz3m203k6o212m6m2dw2l2cq2l3t3m3u1w17s4s19m3m}'kerning'{cl{4qs5ku17sw5ou5qy5rw201ss5tw201ws}201s{201ss}201t{ckw4lwcmwcnwcowcpwclw4wu201ts}2k{201ts}2w{4qs5kw5os5qx5ru17sx5tx}2x{17sw5tw5ou5qu}2y{4qs5kw5os5qx5ru17sx5tx}'fof'-6o7t{ckuclucmucnucoucpu4lu5os5rs}3u{17su5tu5qs}3v{17su5tu5qs}7p{17sw5tw5qs}ck{4qs5ku17sw5ou5qy5rw201ss5tw201ws}4l{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cm{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cn{4qs5ku17sw5ou5qy5rw201ss5tw201ws}co{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cp{4qs5ku17sw5ou5qy5rw201ss5tw201ws}6l{17su5tu5os5qw5rs}17s{2ktclvcmvcnvcovcpv4lv4wuckv}5o{ckwclwcmwcnwcowcpw4lw4wu}5q{ckyclycmycnycoycpy4ly4wu5ms}5r{cktcltcmtcntcotcpt4lt4ws}5t{2ktclvcmvcnvcovcpv4lv4wuckv}7q{cksclscmscnscoscps4ls}6p{17su5tu5qw5rs}ek{5qs5rs}el{17su5tu5os5qw5rs}em{17su5tu5os5qs5rs}en{17su5qs5rs}eo{5qs5rs}ep{17su5tu5os5qw5rs}es{5qs}et{17su5tu5qw5rs}eu{17su5tu5qs5rs}ev{5qs}6z{17sv5tv5os5qx5rs}fm{5os5qt5rs}fn{17sv5tv5os5qx5rs}fo{17sv5tv5os5qx5rs}fp{5os5qt5rs}fq{5os5qt5rs}7r{ckuclucmucnucoucpu4lu5os}fs{17sv5tv5os5qx5rs}ft{17ss5ts5qs}fu{17sw5tw5qs}fv{17sw5tw5qs}fw{17ss5ts5qs}fz{ckuclucmucnucoucpu4lu5os5rs}}}"),
      "Helvetica-Oblique": uncompress("{'widths'{k3p2q4mcx1w201n3r201o6o201s1q201t1q201u1q201w2l201x2l201y2l2k1w2l1w202m2n2n3r2o3r2p5t202q6o2r1n2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v1w3w3u3x3u3y3u3z3r4k6p4l4m4m4m4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3m4v4m4w3r4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v1w5w1w5x1w5y2z5z3r6k2l6l3r6m3r6n3m6o3r6p3r6q1w6r3r6s3r6t1q6u1q6v3m6w1q6x5n6y3r6z3r7k3r7l3r7m2l7n3m7o1w7p3r7q3m7r4s7s3m7t3m7u3m7v2l7w1u7x2l7y3u202l3rcl4mal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3rbr1wbs2lbu2obv3rbz3xck4m202k3rcm4mcn4mco4mcp4mcq6ocr4scs4mct4mcu4mcv4mcw1w2m2ncy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3mes3ret3reu3rev3rew1wex1wey1wez1wfl3rfm3rfn3rfo3rfp3rfq3rfr3ufs3xft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3r3u1w17s4m19m3r}'kerning'{5q{4wv}cl{4qs5kw5ow5qs17sv5tv}201t{2wu4w1k2yu}201x{2wu4wy2yu}17s{2ktclucmucnu4otcpu4lu4wycoucku}2w{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}2x{17sy5ty5oy5qs}2y{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}'fof'-6o7p{17sv5tv5ow}ck{4qs5kw5ow5qs17sv5tv}4l{4qs5kw5ow5qs17sv5tv}cm{4qs5kw5ow5qs17sv5tv}cn{4qs5kw5ow5qs17sv5tv}co{4qs5kw5ow5qs17sv5tv}cp{4qs5kw5ow5qs17sv5tv}6l{17sy5ty5ow}do{17st5tt}4z{17st5tt}7s{fst}dm{17st5tt}dn{17st5tt}5o{ckwclwcmwcnwcowcpw4lw4wv}dp{17st5tt}dq{17st5tt}7t{5ow}ds{17st5tt}5t{2ktclucmucnu4otcpu4lu4wycoucku}fu{17sv5tv5ow}6p{17sy5ty5ow5qs}ek{17sy5ty5ow}el{17sy5ty5ow}em{17sy5ty5ow}en{5ty}eo{17sy5ty5ow}ep{17sy5ty5ow}es{17sy5ty5qs}et{17sy5ty5ow5qs}eu{17sy5ty5ow5qs}ev{17sy5ty5ow5qs}6z{17sy5ty5ow5qs}fm{17sy5ty5ow5qs}fn{17sy5ty5ow5qs}fo{17sy5ty5ow5qs}fp{17sy5ty5qs}fq{17sy5ty5ow5qs}7r{5ow}fs{17sy5ty5ow5qs}ft{17sv5tv5ow}7m{5ow}fv{17sv5tv5ow}fw{17sv5tv5ow}}}")
    }
  };
  API.events.push(["addFont", function(data2) {
    var font = data2.font;
    var metrics = fontMetrics["Unicode"][font.postScriptName];
    if (metrics) {
      font.metadata["Unicode"] = {};
      font.metadata["Unicode"].widths = metrics.widths;
      font.metadata["Unicode"].kerning = metrics.kerning;
    }
    var encodingBlock2 = encodings["Unicode"][font.postScriptName];
    if (encodingBlock2) {
      font.metadata["Unicode"].encoding = encodingBlock2;
      font.encoding = encodingBlock2.codePages[0];
    }
  }]);
})(jsPDF.API);
(function(jsPDF2) {
  var binaryStringToUint8Array = function binaryStringToUint8Array2(binary_string) {
    var len = binary_string.length;
    var bytes = new Uint8Array(len);
    for (var i2 = 0; i2 < len; i2++) {
      bytes[i2] = binary_string.charCodeAt(i2);
    }
    return bytes;
  };
  var addFont = function addFont2(font, file) {
    if (/^\x00\x01\x00\x00/.test(file)) {
      file = binaryStringToUint8Array(file);
    } else {
      file = binaryStringToUint8Array(atob2(file));
    }
    font.metadata = jsPDF2.API.TTFFont.open(file);
    font.metadata.Unicode = font.metadata.Unicode || {
      encoding: {},
      kerning: {},
      widths: []
    };
    font.metadata.glyIdsUsed = [0];
  };
  jsPDF2.API.events.push(["addFont", function(data2) {
    var file = void 0;
    var font = data2.font;
    var instance = data2.instance;
    if (font.isStandardFont) {
      return;
    }
    if (typeof instance !== "undefined") {
      if (instance.existsFileInVFS(font.postScriptName) === false) {
        file = instance.loadFile(font.postScriptName);
      } else {
        file = instance.getFileFromVFS(font.postScriptName);
      }
      if (typeof file !== "string") {
        throw new Error("Font is not stored as string-data in vFS, import fonts or remove declaration doc.addFont('" + font.postScriptName + "').");
      }
      addFont(font, file);
    } else {
      throw new Error("Font does not exist in vFS, import fonts or remove declaration doc.addFont('" + font.postScriptName + "').");
    }
  }]);
})(jsPDF);
(function(jsPDFAPI2) {
  function loadCanvg() {
    return function() {
      if (globalObject["canvg"]) {
        return Promise.resolve(globalObject["canvg"]);
      }
      return Promise.resolve().then(() => (init_index_es(), index_es_exports));
    }().catch(function(e2) {
      return Promise.reject(new Error("Could not load canvg: " + e2));
    }).then(function(canvg) {
      return canvg.default ? canvg.default : canvg;
    });
  }
  jsPDFAPI2.addSvgAsImage = function(svg2, x2, y3, w, h2, alias, compression, rotation) {
    if (isNaN(x2) || isNaN(y3)) {
      console2.error("jsPDF.addSvgAsImage: Invalid coordinates", arguments);
      throw new Error("Invalid coordinates passed to jsPDF.addSvgAsImage");
    }
    if (isNaN(w) || isNaN(h2)) {
      console2.error("jsPDF.addSvgAsImage: Invalid measurements", arguments);
      throw new Error("Invalid measurements (width and/or height) passed to jsPDF.addSvgAsImage");
    }
    var canvas = document.createElement("canvas");
    canvas.width = w;
    canvas.height = h2;
    var ctx = canvas.getContext("2d");
    ctx.fillStyle = "#fff";
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    var options = {
      ignoreMouse: true,
      ignoreAnimation: true,
      ignoreDimensions: true
    };
    var doc = this;
    return loadCanvg().then(function(canvg) {
      return canvg.fromString(ctx, svg2, options);
    }, function() {
      return Promise.reject(new Error("Could not load canvg."));
    }).then(function(instance) {
      return instance.render(options);
    }).then(function() {
      doc.addImage(canvas.toDataURL("image/jpeg", 1), x2, y3, w, h2, compression, rotation);
    });
  };
})(jsPDF.API);
(function(jsPDFAPI2) {
  jsPDFAPI2.putTotalPages = function(pageExpression) {
    var replaceExpression;
    var totalNumberOfPages = 0;
    if (parseInt(this.internal.getFont().id.substr(1), 10) < 15) {
      replaceExpression = new RegExp(pageExpression, "g");
      totalNumberOfPages = this.internal.getNumberOfPages();
    } else {
      replaceExpression = new RegExp(this.pdfEscape16(pageExpression, this.internal.getFont()), "g");
      totalNumberOfPages = this.pdfEscape16(this.internal.getNumberOfPages() + "", this.internal.getFont());
    }
    for (var n2 = 1; n2 <= this.internal.getNumberOfPages(); n2++) {
      for (var i2 = 0; i2 < this.internal.pages[n2].length; i2++) {
        this.internal.pages[n2][i2] = this.internal.pages[n2][i2].replace(replaceExpression, totalNumberOfPages);
      }
    }
    return this;
  };
})(jsPDF.API);
(function(jsPDFAPI2) {
  jsPDFAPI2.viewerPreferences = function(options, doReset) {
    options = options || {};
    doReset = doReset || false;
    var configuration;
    var configurationTemplate = {
      HideToolbar: {
        defaultValue: false,
        value: false,
        type: "boolean",
        explicitSet: false,
        valueSet: [true, false],
        pdfVersion: 1.3
      },
      HideMenubar: {
        defaultValue: false,
        value: false,
        type: "boolean",
        explicitSet: false,
        valueSet: [true, false],
        pdfVersion: 1.3
      },
      HideWindowUI: {
        defaultValue: false,
        value: false,
        type: "boolean",
        explicitSet: false,
        valueSet: [true, false],
        pdfVersion: 1.3
      },
      FitWindow: {
        defaultValue: false,
        value: false,
        type: "boolean",
        explicitSet: false,
        valueSet: [true, false],
        pdfVersion: 1.3
      },
      CenterWindow: {
        defaultValue: false,
        value: false,
        type: "boolean",
        explicitSet: false,
        valueSet: [true, false],
        pdfVersion: 1.3
      },
      DisplayDocTitle: {
        defaultValue: false,
        value: false,
        type: "boolean",
        explicitSet: false,
        valueSet: [true, false],
        pdfVersion: 1.4
      },
      NonFullScreenPageMode: {
        defaultValue: "UseNone",
        value: "UseNone",
        type: "name",
        explicitSet: false,
        valueSet: ["UseNone", "UseOutlines", "UseThumbs", "UseOC"],
        pdfVersion: 1.3
      },
      Direction: {
        defaultValue: "L2R",
        value: "L2R",
        type: "name",
        explicitSet: false,
        valueSet: ["L2R", "R2L"],
        pdfVersion: 1.3
      },
      ViewArea: {
        defaultValue: "CropBox",
        value: "CropBox",
        type: "name",
        explicitSet: false,
        valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"],
        pdfVersion: 1.4
      },
      ViewClip: {
        defaultValue: "CropBox",
        value: "CropBox",
        type: "name",
        explicitSet: false,
        valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"],
        pdfVersion: 1.4
      },
      PrintArea: {
        defaultValue: "CropBox",
        value: "CropBox",
        type: "name",
        explicitSet: false,
        valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"],
        pdfVersion: 1.4
      },
      PrintClip: {
        defaultValue: "CropBox",
        value: "CropBox",
        type: "name",
        explicitSet: false,
        valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"],
        pdfVersion: 1.4
      },
      PrintScaling: {
        defaultValue: "AppDefault",
        value: "AppDefault",
        type: "name",
        explicitSet: false,
        valueSet: ["AppDefault", "None"],
        pdfVersion: 1.6
      },
      Duplex: {
        defaultValue: "",
        value: "none",
        type: "name",
        explicitSet: false,
        valueSet: ["Simplex", "DuplexFlipShortEdge", "DuplexFlipLongEdge", "none"],
        pdfVersion: 1.7
      },
      PickTrayByPDFSize: {
        defaultValue: false,
        value: false,
        type: "boolean",
        explicitSet: false,
        valueSet: [true, false],
        pdfVersion: 1.7
      },
      PrintPageRange: {
        defaultValue: "",
        value: "",
        type: "array",
        explicitSet: false,
        valueSet: null,
        pdfVersion: 1.7
      },
      NumCopies: {
        defaultValue: 1,
        value: 1,
        type: "integer",
        explicitSet: false,
        valueSet: null,
        pdfVersion: 1.7
      }
    };
    var configurationKeys = Object.keys(configurationTemplate);
    var rangeArray = [];
    var i2 = 0;
    var j = 0;
    var k = 0;
    var isValid;
    var method;
    var value;
    function arrayContainsElement(array2, element2) {
      var iterator;
      var result = false;
      for (iterator = 0; iterator < array2.length; iterator += 1) {
        if (array2[iterator] === element2) {
          result = true;
        }
      }
      return result;
    }
    if (this.internal.viewerpreferences === void 0) {
      this.internal.viewerpreferences = {};
      this.internal.viewerpreferences.configuration = JSON.parse(JSON.stringify(configurationTemplate));
      this.internal.viewerpreferences.isSubscribed = false;
    }
    configuration = this.internal.viewerpreferences.configuration;
    if (options === "reset" || doReset === true) {
      var len = configurationKeys.length;
      for (k = 0; k < len; k += 1) {
        configuration[configurationKeys[k]].value = configuration[configurationKeys[k]].defaultValue;
        configuration[configurationKeys[k]].explicitSet = false;
      }
    }
    if (_typeof(options) === "object") {
      for (method in options) {
        value = options[method];
        if (arrayContainsElement(configurationKeys, method) && value !== void 0) {
          if (configuration[method].type === "boolean" && typeof value === "boolean") {
            configuration[method].value = value;
          } else if (configuration[method].type === "name" && arrayContainsElement(configuration[method].valueSet, value)) {
            configuration[method].value = value;
          } else if (configuration[method].type === "integer" && Number.isInteger(value)) {
            configuration[method].value = value;
          } else if (configuration[method].type === "array") {
            for (i2 = 0; i2 < value.length; i2 += 1) {
              isValid = true;
              if (value[i2].length === 1 && typeof value[i2][0] === "number") {
                rangeArray.push(String(value[i2] - 1));
              } else if (value[i2].length > 1) {
                for (j = 0; j < value[i2].length; j += 1) {
                  if (typeof value[i2][j] !== "number") {
                    isValid = false;
                  }
                }
                if (isValid === true) {
                  rangeArray.push([value[i2][0] - 1, value[i2][1] - 1].join(" "));
                }
              }
            }
            configuration[method].value = "[" + rangeArray.join(" ") + "]";
          } else {
            configuration[method].value = configuration[method].defaultValue;
          }
          configuration[method].explicitSet = true;
        }
      }
    }
    if (this.internal.viewerpreferences.isSubscribed === false) {
      this.internal.events.subscribe("putCatalog", function() {
        var pdfDict = [];
        var vPref;
        for (vPref in configuration) {
          if (configuration[vPref].explicitSet === true) {
            if (configuration[vPref].type === "name") {
              pdfDict.push("/" + vPref + " /" + configuration[vPref].value);
            } else {
              pdfDict.push("/" + vPref + " " + configuration[vPref].value);
            }
          }
        }
        if (pdfDict.length !== 0) {
          this.internal.write("/ViewerPreferences\n<<\n" + pdfDict.join("\n") + "\n>>");
        }
      });
      this.internal.viewerpreferences.isSubscribed = true;
    }
    this.internal.viewerpreferences.configuration = configuration;
    return this;
  };
})(jsPDF.API);
(function(jsPDFAPI2) {
  var postPutResources = function postPutResources2() {
    var xmpmeta_beginning = '<x:xmpmeta xmlns:x="adobe:ns:meta/">';
    var rdf_beginning = '<rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"><rdf:Description rdf:about="" xmlns:jspdf="' + this.internal.__metadata__.namespaceuri + '"><jspdf:metadata>';
    var rdf_ending = "</jspdf:metadata></rdf:Description></rdf:RDF>";
    var xmpmeta_ending = "</x:xmpmeta>";
    var utf8_xmpmeta_beginning = unescape(encodeURIComponent(xmpmeta_beginning));
    var utf8_rdf_beginning = unescape(encodeURIComponent(rdf_beginning));
    var utf8_metadata = unescape(encodeURIComponent(this.internal.__metadata__.metadata));
    var utf8_rdf_ending = unescape(encodeURIComponent(rdf_ending));
    var utf8_xmpmeta_ending = unescape(encodeURIComponent(xmpmeta_ending));
    var total_len = utf8_rdf_beginning.length + utf8_metadata.length + utf8_rdf_ending.length + utf8_xmpmeta_beginning.length + utf8_xmpmeta_ending.length;
    this.internal.__metadata__.metadata_object_number = this.internal.newObject();
    this.internal.write("<< /Type /Metadata /Subtype /XML /Length " + total_len + " >>");
    this.internal.write("stream");
    this.internal.write(utf8_xmpmeta_beginning + utf8_rdf_beginning + utf8_metadata + utf8_rdf_ending + utf8_xmpmeta_ending);
    this.internal.write("endstream");
    this.internal.write("endobj");
  };
  var putCatalog = function putCatalog2() {
    if (this.internal.__metadata__.metadata_object_number) {
      this.internal.write("/Metadata " + this.internal.__metadata__.metadata_object_number + " 0 R");
    }
  };
  jsPDFAPI2.addMetadata = function(metadata, namespaceuri) {
    if (typeof this.internal.__metadata__ === "undefined") {
      this.internal.__metadata__ = {
        metadata,
        namespaceuri: namespaceuri || "http://jspdf.default.namespaceuri/"
      };
      this.internal.events.subscribe("putCatalog", putCatalog);
      this.internal.events.subscribe("postPutResources", postPutResources);
    }
    return this;
  };
})(jsPDF.API);
(function(jsPDF2) {
  var jsPDFAPI2 = jsPDF2.API;
  var pdfEscape16 = jsPDFAPI2.pdfEscape16 = function(text4, font) {
    var widths = font.metadata.Unicode.widths;
    var padz = ["", "0", "00", "000", "0000"];
    var ar = [""];
    for (var i2 = 0, l2 = text4.length, t2; i2 < l2; ++i2) {
      t2 = font.metadata.characterToGlyph(text4.charCodeAt(i2));
      font.metadata.glyIdsUsed.push(t2);
      font.metadata.toUnicode[t2] = text4.charCodeAt(i2);
      if (widths.indexOf(t2) == -1) {
        widths.push(t2);
        widths.push([parseInt(font.metadata.widthOfGlyph(t2), 10)]);
      }
      if (t2 == "0") {
        return ar.join("");
      } else {
        t2 = t2.toString(16);
        ar.push(padz[4 - t2.length], t2);
      }
    }
    return ar.join("");
  };
  var toUnicodeCmap = function toUnicodeCmap2(map3) {
    var code, codes, range, unicode, unicodeMap, _i, _len;
    unicodeMap = "/CIDInit /ProcSet findresource begin\n12 dict begin\nbegincmap\n/CIDSystemInfo <<\n  /Registry (Adobe)\n  /Ordering (UCS)\n  /Supplement 0\n>> def\n/CMapName /Adobe-Identity-UCS def\n/CMapType 2 def\n1 begincodespacerange\n<0000><ffff>\nendcodespacerange";
    codes = Object.keys(map3).sort(function(a2, b) {
      return a2 - b;
    });
    range = [];
    for (_i = 0, _len = codes.length; _i < _len; _i++) {
      code = codes[_i];
      if (range.length >= 100) {
        unicodeMap += "\n" + range.length + " beginbfchar\n" + range.join("\n") + "\nendbfchar";
        range = [];
      }
      if (map3[code] !== void 0 && map3[code] !== null && typeof map3[code].toString === "function") {
        unicode = ("0000" + map3[code].toString(16)).slice(-4);
        code = ("0000" + (+code).toString(16)).slice(-4);
        range.push("<" + code + "><" + unicode + ">");
      }
    }
    if (range.length) {
      unicodeMap += "\n" + range.length + " beginbfchar\n" + range.join("\n") + "\nendbfchar\n";
    }
    unicodeMap += "endcmap\nCMapName currentdict /CMap defineresource pop\nend\nend";
    return unicodeMap;
  };
  var identityHFunction = function identityHFunction2(options) {
    var font = options.font;
    var out = options.out;
    var newObject = options.newObject;
    var putStream = options.putStream;
    if (font.metadata instanceof jsPDF2.API.TTFFont && font.encoding === "Identity-H") {
      var widths = font.metadata.Unicode.widths;
      var data2 = font.metadata.subset.encode(font.metadata.glyIdsUsed, 1);
      var pdfOutput = data2;
      var pdfOutput2 = "";
      for (var i2 = 0; i2 < pdfOutput.length; i2++) {
        pdfOutput2 += String.fromCharCode(pdfOutput[i2]);
      }
      var fontTable = newObject();
      putStream({
        data: pdfOutput2,
        addLength1: true,
        objectId: fontTable
      });
      out("endobj");
      var cmap = newObject();
      var cmapData = toUnicodeCmap(font.metadata.toUnicode);
      putStream({
        data: cmapData,
        addLength1: true,
        objectId: cmap
      });
      out("endobj");
      var fontDescriptor = newObject();
      out("<<");
      out("/Type /FontDescriptor");
      out("/FontName /" + toPDFName(font.fontName));
      out("/FontFile2 " + fontTable + " 0 R");
      out("/FontBBox " + jsPDF2.API.PDFObject.convert(font.metadata.bbox));
      out("/Flags " + font.metadata.flags);
      out("/StemV " + font.metadata.stemV);
      out("/ItalicAngle " + font.metadata.italicAngle);
      out("/Ascent " + font.metadata.ascender);
      out("/Descent " + font.metadata.decender);
      out("/CapHeight " + font.metadata.capHeight);
      out(">>");
      out("endobj");
      var DescendantFont = newObject();
      out("<<");
      out("/Type /Font");
      out("/BaseFont /" + toPDFName(font.fontName));
      out("/FontDescriptor " + fontDescriptor + " 0 R");
      out("/W " + jsPDF2.API.PDFObject.convert(widths));
      out("/CIDToGIDMap /Identity");
      out("/DW 1000");
      out("/Subtype /CIDFontType2");
      out("/CIDSystemInfo");
      out("<<");
      out("/Supplement 0");
      out("/Registry (Adobe)");
      out("/Ordering (" + font.encoding + ")");
      out(">>");
      out(">>");
      out("endobj");
      font.objectNumber = newObject();
      out("<<");
      out("/Type /Font");
      out("/Subtype /Type0");
      out("/ToUnicode " + cmap + " 0 R");
      out("/BaseFont /" + toPDFName(font.fontName));
      out("/Encoding /" + font.encoding);
      out("/DescendantFonts [" + DescendantFont + " 0 R]");
      out(">>");
      out("endobj");
      font.isAlreadyPutted = true;
    }
  };
  jsPDFAPI2.events.push(["putFont", function(args) {
    identityHFunction(args);
  }]);
  var winAnsiEncodingFunction = function winAnsiEncodingFunction2(options) {
    var font = options.font;
    var out = options.out;
    var newObject = options.newObject;
    var putStream = options.putStream;
    if (font.metadata instanceof jsPDF2.API.TTFFont && font.encoding === "WinAnsiEncoding") {
      var data2 = font.metadata.rawData;
      var pdfOutput = data2;
      var pdfOutput2 = "";
      for (var i2 = 0; i2 < pdfOutput.length; i2++) {
        pdfOutput2 += String.fromCharCode(pdfOutput[i2]);
      }
      var fontTable = newObject();
      putStream({
        data: pdfOutput2,
        addLength1: true,
        objectId: fontTable
      });
      out("endobj");
      var cmap = newObject();
      var cmapData = toUnicodeCmap(font.metadata.toUnicode);
      putStream({
        data: cmapData,
        addLength1: true,
        objectId: cmap
      });
      out("endobj");
      var fontDescriptor = newObject();
      out("<<");
      out("/Descent " + font.metadata.decender);
      out("/CapHeight " + font.metadata.capHeight);
      out("/StemV " + font.metadata.stemV);
      out("/Type /FontDescriptor");
      out("/FontFile2 " + fontTable + " 0 R");
      out("/Flags 96");
      out("/FontBBox " + jsPDF2.API.PDFObject.convert(font.metadata.bbox));
      out("/FontName /" + toPDFName(font.fontName));
      out("/ItalicAngle " + font.metadata.italicAngle);
      out("/Ascent " + font.metadata.ascender);
      out(">>");
      out("endobj");
      font.objectNumber = newObject();
      for (var j = 0; j < font.metadata.hmtx.widths.length; j++) {
        font.metadata.hmtx.widths[j] = parseInt(font.metadata.hmtx.widths[j] * (1e3 / font.metadata.head.unitsPerEm));
      }
      out("<</Subtype/TrueType/Type/Font/ToUnicode " + cmap + " 0 R/BaseFont/" + toPDFName(font.fontName) + "/FontDescriptor " + fontDescriptor + " 0 R/Encoding/" + font.encoding + " /FirstChar 29 /LastChar 255 /Widths " + jsPDF2.API.PDFObject.convert(font.metadata.hmtx.widths) + ">>");
      out("endobj");
      font.isAlreadyPutted = true;
    }
  };
  jsPDFAPI2.events.push(["putFont", function(args) {
    winAnsiEncodingFunction(args);
  }]);
  var utf8TextFunction = function utf8TextFunction2(args) {
    var text4 = args.text || "";
    var x2 = args.x;
    var y3 = args.y;
    var options = args.options || {};
    var mutex = args.mutex || {};
    var pdfEscape3 = mutex.pdfEscape;
    var activeFontKey = mutex.activeFontKey;
    var fonts = mutex.fonts;
    var key = activeFontKey;
    var str = "", s2 = 0, cmapConfirm;
    var strText = "";
    var encoding = fonts[key].encoding;
    if (fonts[key].encoding !== "Identity-H") {
      return {
        text: text4,
        x: x2,
        y: y3,
        options,
        mutex
      };
    }
    strText = text4;
    key = activeFontKey;
    if (Array.isArray(text4)) {
      strText = text4[0];
    }
    for (s2 = 0; s2 < strText.length; s2 += 1) {
      if (fonts[key].metadata.hasOwnProperty("cmap")) {
        cmapConfirm = fonts[key].metadata.cmap.unicode.codeMap[strText[s2].charCodeAt(0)];
      }
      if (!cmapConfirm) {
        if (strText[s2].charCodeAt(0) < 256 && fonts[key].metadata.hasOwnProperty("Unicode")) {
          str += strText[s2];
        } else {
          str += "";
        }
      } else {
        str += strText[s2];
      }
    }
    var result = "";
    if (parseInt(key.slice(1)) < 14 || encoding === "WinAnsiEncoding") {
      result = pdfEscape3(str, key).split("").map(function(cv) {
        return cv.charCodeAt(0).toString(16);
      }).join("");
    } else if (encoding === "Identity-H") {
      result = pdfEscape16(str, fonts[key]);
    }
    mutex.isHex = true;
    return {
      text: result,
      x: x2,
      y: y3,
      options,
      mutex
    };
  };
  var utf8EscapeFunction = function utf8EscapeFunction2(parms) {
    var text4 = parms.text || "", x2 = parms.x, y3 = parms.y, options = parms.options, mutex = parms.mutex;
    var tmpText = [];
    var args = {
      text: text4,
      x: x2,
      y: y3,
      options,
      mutex
    };
    if (Array.isArray(text4)) {
      var i2 = 0;
      for (i2 = 0; i2 < text4.length; i2 += 1) {
        if (Array.isArray(text4[i2])) {
          if (text4[i2].length === 3) {
            tmpText.push([utf8TextFunction(Object.assign({}, args, {
              text: text4[i2][0]
            })).text, text4[i2][1], text4[i2][2]]);
          } else {
            tmpText.push(utf8TextFunction(Object.assign({}, args, {
              text: text4[i2]
            })).text);
          }
        } else {
          tmpText.push(utf8TextFunction(Object.assign({}, args, {
            text: text4[i2]
          })).text);
        }
      }
      parms.text = tmpText;
    } else {
      parms.text = utf8TextFunction(Object.assign({}, args, {
        text: text4
      })).text;
    }
  };
  jsPDFAPI2.events.push(["postProcessText", utf8EscapeFunction]);
})(jsPDF);
(function(jsPDFAPI2) {
  var _initializeVFS = function _initializeVFS2() {
    if (typeof this.internal.vFS === "undefined") {
      this.internal.vFS = {};
    }
    return true;
  };
  jsPDFAPI2.existsFileInVFS = function(filename) {
    _initializeVFS.call(this);
    return typeof this.internal.vFS[filename] !== "undefined";
  };
  jsPDFAPI2.addFileToVFS = function(filename, filecontent) {
    _initializeVFS.call(this);
    this.internal.vFS[filename] = filecontent;
    return this;
  };
  jsPDFAPI2.getFileFromVFS = function(filename) {
    _initializeVFS.call(this);
    if (typeof this.internal.vFS[filename] !== "undefined") {
      return this.internal.vFS[filename];
    }
    return null;
  };
})(jsPDF.API);
(function(jsPDF2) {
  var bidiUnicodeTypes = ["BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "S", "B", "S", "WS", "B", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "B", "B", "B", "S", "WS", "N", "N", "ET", "ET", "ET", "N", "N", "N", "N", "N", "ES", "CS", "ES", "CS", "CS", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "CS", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "BN", "BN", "BN", "BN", "BN", "BN", "B", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "CS", "N", "ET", "ET", "ET", "ET", "N", "N", "N", "N", "L", "N", "N", "BN", "N", "N", "ET", "ET", "EN", "EN", "N", "L", "N", "N", "N", "EN", "L", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "L", "L", "L", "L", "L", "L", "L", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "L", "N", "N", "N", "N", "N", "ET", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "R", "NSM", "R", "NSM", "NSM", "R", "NSM", "NSM", "R", "NSM", "N", "N", "N", "N", "N", "N", "N", "N", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "N", "N", "N", "N", "N", "R", "R", "R", "R", "R", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "AN", "AN", "AN", "AN", "AN", "AN", "N", "N", "AL", "ET", "ET", "AL", "CS", "AL", "N", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "N", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "ET", "AN", "AN", "AL", "AL", "AL", "NSM", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AN", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "NSM", "NSM", "N", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "N", "AL", "AL", "NSM", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "N", "N", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "R", "R", "N", "N", "N", "N", "R", "N", "N", "N", "N", "N", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "BN", "BN", "BN", "L", "R", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "WS", "B", "LRE", "RLE", "PDF", "LRO", "RLO", "CS", "ET", "ET", "ET", "ET", "ET", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "CS", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "WS", "BN", "BN", "BN", "BN", "BN", "N", "LRI", "RLI", "FSI", "PDI", "BN", "BN", "BN", "BN", "BN", "BN", "EN", "L", "N", "N", "EN", "EN", "EN", "EN", "EN", "EN", "ES", "ES", "N", "N", "N", "L", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "ES", "ES", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "R", "NSM", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "ES", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "N", "R", "R", "R", "R", "R", "N", "R", "N", "R", "R", "N", "R", "R", "N", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "CS", "N", "CS", "N", "N", "CS", "N", "N", "N", "N", "N", "N", "N", "N", "N", "ET", "N", "N", "ES", "ES", "N", "N", "N", "N", "N", "ET", "ET", "N", "N", "N", "N", "N", "AL", "AL", "AL", "AL", "AL", "N", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "N", "N", "BN", "N", "N", "N", "ET", "ET", "ET", "N", "N", "N", "N", "N", "ES", "CS", "ES", "CS", "CS", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "CS", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "L", "L", "L", "L", "L", "L", "N", "N", "L", "L", "L", "L", "L", "L", "N", "N", "L", "L", "L", "L", "L", "L", "N", "N", "L", "L", "L", "N", "N", "N", "ET", "ET", "N", "N", "N", "ET", "ET", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N"];
  jsPDF2.__bidiEngine__ = jsPDF2.prototype.__bidiEngine__ = function(options) {
    var _UNICODE_TYPES = _bidiUnicodeTypes;
    var _STATE_TABLE_LTR = [[0, 3, 0, 1, 0, 0, 0], [0, 3, 0, 1, 2, 2, 0], [0, 3, 0, 17, 2, 0, 1], [0, 3, 5, 5, 4, 1, 0], [0, 3, 21, 21, 4, 0, 1], [0, 3, 5, 5, 4, 2, 0]];
    var _STATE_TABLE_RTL = [[2, 0, 1, 1, 0, 1, 0], [2, 0, 1, 1, 0, 2, 0], [2, 0, 2, 1, 3, 2, 0], [2, 0, 2, 33, 3, 1, 1]];
    var _TYPE_NAMES_MAP = {
      L: 0,
      R: 1,
      EN: 2,
      AN: 3,
      N: 4,
      B: 5,
      S: 6
    };
    var _UNICODE_RANGES_MAP = {
      0: 0,
      5: 1,
      6: 2,
      7: 3,
      32: 4,
      251: 5,
      254: 6,
      255: 7
    };
    var _SWAP_TABLE = ["(", ")", "(", "<", ">", "<", "[", "]", "[", "{", "}", "{", "\xAB", "\xBB", "\xAB", "\u2039", "\u203A", "\u2039", "\u2045", "\u2046", "\u2045", "\u207D", "\u207E", "\u207D", "\u208D", "\u208E", "\u208D", "\u2264", "\u2265", "\u2264", "\u2329", "\u232A", "\u2329", "\uFE59", "\uFE5A", "\uFE59", "\uFE5B", "\uFE5C", "\uFE5B", "\uFE5D", "\uFE5E", "\uFE5D", "\uFE64", "\uFE65", "\uFE64"];
    var _LTR_RANGES_REG_EXPR = new RegExp(/^([1-4|9]|1[0-9]|2[0-9]|3[0168]|4[04589]|5[012]|7[78]|159|16[0-9]|17[0-2]|21[569]|22[03489]|250)$/);
    var _lastArabic = false, _hasUbatB, _hasUbatS, DIR_LTR = 0, DIR_RTL = 1, _isInVisual, _isInRtl, _isOutVisual, _isOutRtl, _isSymmetricSwapping, _dir = DIR_LTR;
    this.__bidiEngine__ = {};
    var _init = function _init2(text4, sourceToTargetMap) {
      if (sourceToTargetMap) {
        for (var i2 = 0; i2 < text4.length; i2++) {
          sourceToTargetMap[i2] = i2;
        }
      }
      if (_isInRtl === void 0) {
        _isInRtl = _isContextualDirRtl(text4);
      }
      if (_isOutRtl === void 0) {
        _isOutRtl = _isContextualDirRtl(text4);
      }
    };
    var _getCharType = function _getCharType2(ch) {
      var charCode = ch.charCodeAt(), range = charCode >> 8, rangeIdx = _UNICODE_RANGES_MAP[range];
      if (rangeIdx !== void 0) {
        return _UNICODE_TYPES[rangeIdx * 256 + (charCode & 255)];
      } else if (range === 252 || range === 253) {
        return "AL";
      } else if (_LTR_RANGES_REG_EXPR.test(range)) {
        return "L";
      } else if (range === 8) {
        return "R";
      }
      return "N";
    };
    var _isContextualDirRtl = function _isContextualDirRtl2(text4) {
      for (var i2 = 0, charType; i2 < text4.length; i2++) {
        charType = _getCharType(text4.charAt(i2));
        if (charType === "L") {
          return false;
        } else if (charType === "R") {
          return true;
        }
      }
      return false;
    };
    var _resolveCharType = function _resolveCharType2(chars, types, resolvedTypes, index3) {
      var cType = types[index3], wType, nType, i2, len;
      switch (cType) {
        case "L":
        case "R":
          _lastArabic = false;
          break;
        case "N":
        case "AN":
          break;
        case "EN":
          if (_lastArabic) {
            cType = "AN";
          }
          break;
        case "AL":
          _lastArabic = true;
          cType = "R";
          break;
        case "WS":
          cType = "N";
          break;
        case "CS":
          if (index3 < 1 || index3 + 1 >= types.length || (wType = resolvedTypes[index3 - 1]) !== "EN" && wType !== "AN" || (nType = types[index3 + 1]) !== "EN" && nType !== "AN") {
            cType = "N";
          } else if (_lastArabic) {
            nType = "AN";
          }
          cType = nType === wType ? nType : "N";
          break;
        case "ES":
          wType = index3 > 0 ? resolvedTypes[index3 - 1] : "B";
          cType = wType === "EN" && index3 + 1 < types.length && types[index3 + 1] === "EN" ? "EN" : "N";
          break;
        case "ET":
          if (index3 > 0 && resolvedTypes[index3 - 1] === "EN") {
            cType = "EN";
            break;
          } else if (_lastArabic) {
            cType = "N";
            break;
          }
          i2 = index3 + 1;
          len = types.length;
          while (i2 < len && types[i2] === "ET") {
            i2++;
          }
          if (i2 < len && types[i2] === "EN") {
            cType = "EN";
          } else {
            cType = "N";
          }
          break;
        case "NSM":
          if (_isInVisual && !_isInRtl) {
            len = types.length;
            i2 = index3 + 1;
            while (i2 < len && types[i2] === "NSM") {
              i2++;
            }
            if (i2 < len) {
              var c3 = chars[index3];
              var rtlCandidate = c3 >= 1425 && c3 <= 2303 || c3 === 64286;
              wType = types[i2];
              if (rtlCandidate && (wType === "R" || wType === "AL")) {
                cType = "R";
                break;
              }
            }
          }
          if (index3 < 1 || (wType = types[index3 - 1]) === "B") {
            cType = "N";
          } else {
            cType = resolvedTypes[index3 - 1];
          }
          break;
        case "B":
          _lastArabic = false;
          _hasUbatB = true;
          cType = _dir;
          break;
        case "S":
          _hasUbatS = true;
          cType = "N";
          break;
        case "LRE":
        case "RLE":
        case "LRO":
        case "RLO":
        case "PDF":
          _lastArabic = false;
          break;
        case "BN":
          cType = "N";
          break;
      }
      return cType;
    };
    var _handleUbatS = function _handleUbatS2(types, levels, length2) {
      for (var i2 = 0; i2 < length2; i2++) {
        if (types[i2] === "S") {
          levels[i2] = _dir;
          for (var j = i2 - 1; j >= 0; j--) {
            if (types[j] === "WS") {
              levels[j] = _dir;
            } else {
              break;
            }
          }
        }
      }
    };
    var _invertString = function _invertString2(text4, sourceToTargetMap, levels) {
      var charArray = text4.split("");
      if (levels) {
        _computeLevels(charArray, levels, {
          hiLevel: _dir
        });
      }
      charArray.reverse();
      sourceToTargetMap && sourceToTargetMap.reverse();
      return charArray.join("");
    };
    var _computeLevels = function _computeLevels2(chars, levels, params) {
      var action, condition, i2, index3, newLevel, prevState, condPos = -1, len = chars.length, newState = 0, resolvedTypes = [], stateTable = _dir ? _STATE_TABLE_RTL : _STATE_TABLE_LTR, types = [];
      _lastArabic = false;
      _hasUbatB = false;
      _hasUbatS = false;
      for (i2 = 0; i2 < len; i2++) {
        types[i2] = _getCharType(chars[i2]);
      }
      for (index3 = 0; index3 < len; index3++) {
        prevState = newState;
        resolvedTypes[index3] = _resolveCharType(chars, types, resolvedTypes, index3);
        newState = stateTable[prevState][_TYPE_NAMES_MAP[resolvedTypes[index3]]];
        action = newState & 240;
        newState &= 15;
        levels[index3] = newLevel = stateTable[newState][5];
        if (action > 0) {
          if (action === 16) {
            for (i2 = condPos; i2 < index3; i2++) {
              levels[i2] = 1;
            }
            condPos = -1;
          } else {
            condPos = -1;
          }
        }
        condition = stateTable[newState][6];
        if (condition) {
          if (condPos === -1) {
            condPos = index3;
          }
        } else {
          if (condPos > -1) {
            for (i2 = condPos; i2 < index3; i2++) {
              levels[i2] = newLevel;
            }
            condPos = -1;
          }
        }
        if (types[index3] === "B") {
          levels[index3] = 0;
        }
        params.hiLevel |= newLevel;
      }
      if (_hasUbatS) {
        _handleUbatS(types, levels, len);
      }
    };
    var _invertByLevel = function _invertByLevel2(level, charArray, sourceToTargetMap, levels, params) {
      if (params.hiLevel < level) {
        return;
      }
      if (level === 1 && _dir === DIR_RTL && !_hasUbatB) {
        charArray.reverse();
        sourceToTargetMap && sourceToTargetMap.reverse();
        return;
      }
      var ch, high, end, low, len = charArray.length, start = 0;
      while (start < len) {
        if (levels[start] >= level) {
          end = start + 1;
          while (end < len && levels[end] >= level) {
            end++;
          }
          for (low = start, high = end - 1; low < high; low++, high--) {
            ch = charArray[low];
            charArray[low] = charArray[high];
            charArray[high] = ch;
            if (sourceToTargetMap) {
              ch = sourceToTargetMap[low];
              sourceToTargetMap[low] = sourceToTargetMap[high];
              sourceToTargetMap[high] = ch;
            }
          }
          start = end;
        }
        start++;
      }
    };
    var _symmetricSwap = function _symmetricSwap2(charArray, levels, params) {
      if (params.hiLevel !== 0 && _isSymmetricSwapping) {
        for (var i2 = 0, index3; i2 < charArray.length; i2++) {
          if (levels[i2] === 1) {
            index3 = _SWAP_TABLE.indexOf(charArray[i2]);
            if (index3 >= 0) {
              charArray[i2] = _SWAP_TABLE[index3 + 1];
            }
          }
        }
      }
    };
    var _reorder = function _reorder2(text4, sourceToTargetMap, levels) {
      var charArray = text4.split(""), params = {
        hiLevel: _dir
      };
      if (!levels) {
        levels = [];
      }
      _computeLevels(charArray, levels, params);
      _symmetricSwap(charArray, levels, params);
      _invertByLevel(DIR_RTL + 1, charArray, sourceToTargetMap, levels, params);
      _invertByLevel(DIR_RTL, charArray, sourceToTargetMap, levels, params);
      return charArray.join("");
    };
    this.__bidiEngine__.doBidiReorder = function(text4, sourceToTargetMap, levels) {
      _init(text4, sourceToTargetMap);
      if (!_isInVisual && _isOutVisual && !_isOutRtl) {
        _dir = _isInRtl ? DIR_RTL : DIR_LTR;
        text4 = _reorder(text4, sourceToTargetMap, levels);
      } else if (_isInVisual && _isOutVisual && _isInRtl ^ _isOutRtl) {
        _dir = _isInRtl ? DIR_RTL : DIR_LTR;
        text4 = _invertString(text4, sourceToTargetMap, levels);
      } else if (!_isInVisual && _isOutVisual && _isOutRtl) {
        _dir = _isInRtl ? DIR_RTL : DIR_LTR;
        text4 = _reorder(text4, sourceToTargetMap, levels);
        text4 = _invertString(text4, sourceToTargetMap);
      } else if (_isInVisual && !_isInRtl && !_isOutVisual && !_isOutRtl) {
        _dir = DIR_LTR;
        text4 = _reorder(text4, sourceToTargetMap, levels);
      } else if (_isInVisual && !_isOutVisual && _isInRtl ^ _isOutRtl) {
        text4 = _invertString(text4, sourceToTargetMap);
        if (_isInRtl) {
          _dir = DIR_LTR;
          text4 = _reorder(text4, sourceToTargetMap, levels);
        } else {
          _dir = DIR_RTL;
          text4 = _reorder(text4, sourceToTargetMap, levels);
          text4 = _invertString(text4, sourceToTargetMap);
        }
      } else if (_isInVisual && _isInRtl && !_isOutVisual && _isOutRtl) {
        _dir = DIR_RTL;
        text4 = _reorder(text4, sourceToTargetMap, levels);
        text4 = _invertString(text4, sourceToTargetMap);
      } else if (!_isInVisual && !_isOutVisual && _isInRtl ^ _isOutRtl) {
        var isSymmetricSwappingOrig = _isSymmetricSwapping;
        if (_isInRtl) {
          _dir = DIR_RTL;
          text4 = _reorder(text4, sourceToTargetMap, levels);
          _dir = DIR_LTR;
          _isSymmetricSwapping = false;
          text4 = _reorder(text4, sourceToTargetMap, levels);
          _isSymmetricSwapping = isSymmetricSwappingOrig;
        } else {
          _dir = DIR_LTR;
          text4 = _reorder(text4, sourceToTargetMap, levels);
          text4 = _invertString(text4, sourceToTargetMap);
          _dir = DIR_RTL;
          _isSymmetricSwapping = false;
          text4 = _reorder(text4, sourceToTargetMap, levels);
          _isSymmetricSwapping = isSymmetricSwappingOrig;
          text4 = _invertString(text4, sourceToTargetMap);
        }
      }
      return text4;
    };
    this.__bidiEngine__.setOptions = function(options2) {
      if (options2) {
        _isInVisual = options2.isInputVisual;
        _isOutVisual = options2.isOutputVisual;
        _isInRtl = options2.isInputRtl;
        _isOutRtl = options2.isOutputRtl;
        _isSymmetricSwapping = options2.isSymmetricSwapping;
      }
    };
    this.__bidiEngine__.setOptions(options);
    return this.__bidiEngine__;
  };
  var _bidiUnicodeTypes = bidiUnicodeTypes;
  var bidiEngine = new jsPDF2.__bidiEngine__({
    isInputVisual: true
  });
  var bidiEngineFunction = function bidiEngineFunction2(args) {
    var text4 = args.text;
    var x2 = args.x;
    var y3 = args.y;
    var options = args.options || {};
    var mutex = args.mutex || {};
    var lang = options.lang;
    var tmpText = [];
    options.isInputVisual = typeof options.isInputVisual === "boolean" ? options.isInputVisual : true;
    bidiEngine.setOptions(options);
    if (Object.prototype.toString.call(text4) === "[object Array]") {
      var i2 = 0;
      tmpText = [];
      for (i2 = 0; i2 < text4.length; i2 += 1) {
        if (Object.prototype.toString.call(text4[i2]) === "[object Array]") {
          tmpText.push([bidiEngine.doBidiReorder(text4[i2][0]), text4[i2][1], text4[i2][2]]);
        } else {
          tmpText.push([bidiEngine.doBidiReorder(text4[i2])]);
        }
      }
      args.text = tmpText;
    } else {
      args.text = bidiEngine.doBidiReorder(text4);
    }
    bidiEngine.setOptions({
      isInputVisual: true
    });
  };
  jsPDF2.API.events.push(["postProcessText", bidiEngineFunction]);
})(jsPDF);
jsPDF.API.TTFFont = function() {
  TTFFont.open = function(file) {
    return new TTFFont(file);
  };
  function TTFFont(rawData) {
    var data2;
    this.rawData = rawData;
    data2 = this.contents = new Data(rawData);
    this.contents.pos = 4;
    if (data2.readString(4) === "ttcf") {
      throw new Error("TTCF not supported.");
    } else {
      data2.pos = 0;
      this.parse();
      this.subset = new Subset(this);
      this.registerTTF();
    }
  }
  TTFFont.prototype.parse = function() {
    this.directory = new Directory(this.contents);
    this.head = new HeadTable(this);
    this.name = new NameTable(this);
    this.cmap = new CmapTable(this);
    this.toUnicode = {};
    this.hhea = new HheaTable(this);
    this.maxp = new MaxpTable(this);
    this.hmtx = new HmtxTable(this);
    this.post = new PostTable(this);
    this.os2 = new OS2Table(this);
    this.loca = new LocaTable(this);
    this.glyf = new GlyfTable(this);
    this.ascender = this.os2.exists && this.os2.ascender || this.hhea.ascender;
    this.decender = this.os2.exists && this.os2.decender || this.hhea.decender;
    this.lineGap = this.os2.exists && this.os2.lineGap || this.hhea.lineGap;
    return this.bbox = [this.head.xMin, this.head.yMin, this.head.xMax, this.head.yMax];
  };
  TTFFont.prototype.registerTTF = function() {
    var e2, hi, low, raw, _ref;
    this.scaleFactor = 1e3 / this.head.unitsPerEm;
    this.bbox = function() {
      var _i, _len, _ref2, _results;
      _ref2 = this.bbox;
      _results = [];
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        e2 = _ref2[_i];
        _results.push(Math.round(e2 * this.scaleFactor));
      }
      return _results;
    }.call(this);
    this.stemV = 0;
    if (this.post.exists) {
      raw = this.post.italic_angle;
      hi = raw >> 16;
      low = raw & 255;
      if ((hi & 32768) !== 0) {
        hi = -((hi ^ 65535) + 1);
      }
      this.italicAngle = +("" + hi + "." + low);
    } else {
      this.italicAngle = 0;
    }
    this.ascender = Math.round(this.ascender * this.scaleFactor);
    this.decender = Math.round(this.decender * this.scaleFactor);
    this.lineGap = Math.round(this.lineGap * this.scaleFactor);
    this.capHeight = this.os2.exists && this.os2.capHeight || this.ascender;
    this.xHeight = this.os2.exists && this.os2.xHeight || 0;
    this.familyClass = (this.os2.exists && this.os2.familyClass || 0) >> 8;
    this.isSerif = (_ref = this.familyClass) === 1 || _ref === 2 || _ref === 3 || _ref === 4 || _ref === 5 || _ref === 7;
    this.isScript = this.familyClass === 10;
    this.flags = 0;
    if (this.post.isFixedPitch) {
      this.flags |= 1 << 0;
    }
    if (this.isSerif) {
      this.flags |= 1 << 1;
    }
    if (this.isScript) {
      this.flags |= 1 << 3;
    }
    if (this.italicAngle !== 0) {
      this.flags |= 1 << 6;
    }
    this.flags |= 1 << 5;
    if (!this.cmap.unicode) {
      throw new Error("No unicode cmap for font");
    }
  };
  TTFFont.prototype.characterToGlyph = function(character) {
    var _ref;
    return ((_ref = this.cmap.unicode) != null ? _ref.codeMap[character] : void 0) || 0;
  };
  TTFFont.prototype.widthOfGlyph = function(glyph) {
    var scale3;
    scale3 = 1e3 / this.head.unitsPerEm;
    return this.hmtx.forGlyph(glyph).advance * scale3;
  };
  TTFFont.prototype.widthOfString = function(string3, size2, charSpace) {
    var charCode, i2, scale3, width2, _ref;
    string3 = "" + string3;
    width2 = 0;
    for (i2 = 0, _ref = string3.length; 0 <= _ref ? i2 < _ref : i2 > _ref; i2 = 0 <= _ref ? ++i2 : --i2) {
      charCode = string3.charCodeAt(i2);
      width2 += this.widthOfGlyph(this.characterToGlyph(charCode)) + charSpace * (1e3 / size2) || 0;
    }
    scale3 = size2 / 1e3;
    return width2 * scale3;
  };
  TTFFont.prototype.lineHeight = function(size2, includeGap) {
    var gap;
    if (includeGap == null) {
      includeGap = false;
    }
    gap = includeGap ? this.lineGap : 0;
    return (this.ascender + gap - this.decender) / 1e3 * size2;
  };
  return TTFFont;
}();
var Data = function() {
  function Data2(data2) {
    this.data = data2 != null ? data2 : [];
    this.pos = 0;
    this.length = this.data.length;
  }
  Data2.prototype.readByte = function() {
    return this.data[this.pos++];
  };
  Data2.prototype.writeByte = function(byte) {
    return this.data[this.pos++] = byte;
  };
  Data2.prototype.readUInt32 = function() {
    var b1, b2, b3, b4;
    b1 = this.readByte() * 16777216;
    b2 = this.readByte() << 16;
    b3 = this.readByte() << 8;
    b4 = this.readByte();
    return b1 + b2 + b3 + b4;
  };
  Data2.prototype.writeUInt32 = function(val) {
    this.writeByte(val >>> 24 & 255);
    this.writeByte(val >> 16 & 255);
    this.writeByte(val >> 8 & 255);
    return this.writeByte(val & 255);
  };
  Data2.prototype.readInt32 = function() {
    var int;
    int = this.readUInt32();
    if (int >= 2147483648) {
      return int - 4294967296;
    } else {
      return int;
    }
  };
  Data2.prototype.writeInt32 = function(val) {
    if (val < 0) {
      val += 4294967296;
    }
    return this.writeUInt32(val);
  };
  Data2.prototype.readUInt16 = function() {
    var b1, b2;
    b1 = this.readByte() << 8;
    b2 = this.readByte();
    return b1 | b2;
  };
  Data2.prototype.writeUInt16 = function(val) {
    this.writeByte(val >> 8 & 255);
    return this.writeByte(val & 255);
  };
  Data2.prototype.readInt16 = function() {
    var int;
    int = this.readUInt16();
    if (int >= 32768) {
      return int - 65536;
    } else {
      return int;
    }
  };
  Data2.prototype.writeInt16 = function(val) {
    if (val < 0) {
      val += 65536;
    }
    return this.writeUInt16(val);
  };
  Data2.prototype.readString = function(length2) {
    var i2, ret;
    ret = [];
    for (i2 = 0; 0 <= length2 ? i2 < length2 : i2 > length2; i2 = 0 <= length2 ? ++i2 : --i2) {
      ret[i2] = String.fromCharCode(this.readByte());
    }
    return ret.join("");
  };
  Data2.prototype.writeString = function(val) {
    var i2, _ref, _results;
    _results = [];
    for (i2 = 0, _ref = val.length; 0 <= _ref ? i2 < _ref : i2 > _ref; i2 = 0 <= _ref ? ++i2 : --i2) {
      _results.push(this.writeByte(val.charCodeAt(i2)));
    }
    return _results;
  };
  Data2.prototype.readShort = function() {
    return this.readInt16();
  };
  Data2.prototype.writeShort = function(val) {
    return this.writeInt16(val);
  };
  Data2.prototype.readLongLong = function() {
    var b1, b2, b3, b4, b5, b6, b7, b8;
    b1 = this.readByte();
    b2 = this.readByte();
    b3 = this.readByte();
    b4 = this.readByte();
    b5 = this.readByte();
    b6 = this.readByte();
    b7 = this.readByte();
    b8 = this.readByte();
    if (b1 & 128) {
      return ((b1 ^ 255) * 72057594037927940 + (b2 ^ 255) * 281474976710656 + (b3 ^ 255) * 1099511627776 + (b4 ^ 255) * 4294967296 + (b5 ^ 255) * 16777216 + (b6 ^ 255) * 65536 + (b7 ^ 255) * 256 + (b8 ^ 255) + 1) * -1;
    }
    return b1 * 72057594037927940 + b2 * 281474976710656 + b3 * 1099511627776 + b4 * 4294967296 + b5 * 16777216 + b6 * 65536 + b7 * 256 + b8;
  };
  Data2.prototype.writeLongLong = function(val) {
    var high, low;
    high = Math.floor(val / 4294967296);
    low = val & 4294967295;
    this.writeByte(high >> 24 & 255);
    this.writeByte(high >> 16 & 255);
    this.writeByte(high >> 8 & 255);
    this.writeByte(high & 255);
    this.writeByte(low >> 24 & 255);
    this.writeByte(low >> 16 & 255);
    this.writeByte(low >> 8 & 255);
    return this.writeByte(low & 255);
  };
  Data2.prototype.readInt = function() {
    return this.readInt32();
  };
  Data2.prototype.writeInt = function(val) {
    return this.writeInt32(val);
  };
  Data2.prototype.read = function(bytes) {
    var buf, i2;
    buf = [];
    for (i2 = 0; 0 <= bytes ? i2 < bytes : i2 > bytes; i2 = 0 <= bytes ? ++i2 : --i2) {
      buf.push(this.readByte());
    }
    return buf;
  };
  Data2.prototype.write = function(bytes) {
    var byte, i2, _len, _results;
    _results = [];
    for (i2 = 0, _len = bytes.length; i2 < _len; i2++) {
      byte = bytes[i2];
      _results.push(this.writeByte(byte));
    }
    return _results;
  };
  return Data2;
}();
var Directory = function() {
  var checksum;
  function Directory2(data2) {
    var entry, i2, _ref;
    this.scalarType = data2.readInt();
    this.tableCount = data2.readShort();
    this.searchRange = data2.readShort();
    this.entrySelector = data2.readShort();
    this.rangeShift = data2.readShort();
    this.tables = {};
    for (i2 = 0, _ref = this.tableCount; 0 <= _ref ? i2 < _ref : i2 > _ref; i2 = 0 <= _ref ? ++i2 : --i2) {
      entry = {
        tag: data2.readString(4),
        checksum: data2.readInt(),
        offset: data2.readInt(),
        length: data2.readInt()
      };
      this.tables[entry.tag] = entry;
    }
  }
  Directory2.prototype.encode = function(tables) {
    var adjustment, directory, directoryLength, entrySelector, headOffset, log2, offset, rangeShift, searchRange, sum, table, tableCount, tableData, tag;
    tableCount = Object.keys(tables).length;
    log2 = Math.log(2);
    searchRange = Math.floor(Math.log(tableCount) / log2) * 16;
    entrySelector = Math.floor(searchRange / log2);
    rangeShift = tableCount * 16 - searchRange;
    directory = new Data();
    directory.writeInt(this.scalarType);
    directory.writeShort(tableCount);
    directory.writeShort(searchRange);
    directory.writeShort(entrySelector);
    directory.writeShort(rangeShift);
    directoryLength = tableCount * 16;
    offset = directory.pos + directoryLength;
    headOffset = null;
    tableData = [];
    for (tag in tables) {
      table = tables[tag];
      directory.writeString(tag);
      directory.writeInt(checksum(table));
      directory.writeInt(offset);
      directory.writeInt(table.length);
      tableData = tableData.concat(table);
      if (tag === "head") {
        headOffset = offset;
      }
      offset += table.length;
      while (offset % 4) {
        tableData.push(0);
        offset++;
      }
    }
    directory.write(tableData);
    sum = checksum(directory.data);
    adjustment = 2981146554 - sum;
    directory.pos = headOffset + 8;
    directory.writeUInt32(adjustment);
    return directory.data;
  };
  checksum = function checksum2(data2) {
    var i2, sum, tmp, _ref;
    data2 = __slice.call(data2);
    while (data2.length % 4) {
      data2.push(0);
    }
    tmp = new Data(data2);
    sum = 0;
    for (i2 = 0, _ref = data2.length; i2 < _ref; i2 = i2 += 4) {
      sum += tmp.readUInt32();
    }
    return sum & 4294967295;
  };
  return Directory2;
}();
var Table;
var __hasProp = {}.hasOwnProperty;
var __extends = function __extends2(child, parent) {
  for (var key in parent) {
    if (__hasProp.call(parent, key))
      child[key] = parent[key];
  }
  function ctor() {
    this.constructor = child;
  }
  ctor.prototype = parent.prototype;
  child.prototype = new ctor();
  child.__super__ = parent.prototype;
  return child;
};
Table = function() {
  function Table2(file) {
    var info;
    this.file = file;
    info = this.file.directory.tables[this.tag];
    this.exists = !!info;
    if (info) {
      this.offset = info.offset, this.length = info.length;
      this.parse(this.file.contents);
    }
  }
  Table2.prototype.parse = function() {
  };
  Table2.prototype.encode = function() {
  };
  Table2.prototype.raw = function() {
    if (!this.exists) {
      return null;
    }
    this.file.contents.pos = this.offset;
    return this.file.contents.read(this.length);
  };
  return Table2;
}();
var HeadTable = function(_super) {
  __extends(HeadTable2, _super);
  function HeadTable2() {
    return HeadTable2.__super__.constructor.apply(this, arguments);
  }
  HeadTable2.prototype.tag = "head";
  HeadTable2.prototype.parse = function(data2) {
    data2.pos = this.offset;
    this.version = data2.readInt();
    this.revision = data2.readInt();
    this.checkSumAdjustment = data2.readInt();
    this.magicNumber = data2.readInt();
    this.flags = data2.readShort();
    this.unitsPerEm = data2.readShort();
    this.created = data2.readLongLong();
    this.modified = data2.readLongLong();
    this.xMin = data2.readShort();
    this.yMin = data2.readShort();
    this.xMax = data2.readShort();
    this.yMax = data2.readShort();
    this.macStyle = data2.readShort();
    this.lowestRecPPEM = data2.readShort();
    this.fontDirectionHint = data2.readShort();
    this.indexToLocFormat = data2.readShort();
    return this.glyphDataFormat = data2.readShort();
  };
  HeadTable2.prototype.encode = function(indexToLocFormat) {
    var table;
    table = new Data();
    table.writeInt(this.version);
    table.writeInt(this.revision);
    table.writeInt(this.checkSumAdjustment);
    table.writeInt(this.magicNumber);
    table.writeShort(this.flags);
    table.writeShort(this.unitsPerEm);
    table.writeLongLong(this.created);
    table.writeLongLong(this.modified);
    table.writeShort(this.xMin);
    table.writeShort(this.yMin);
    table.writeShort(this.xMax);
    table.writeShort(this.yMax);
    table.writeShort(this.macStyle);
    table.writeShort(this.lowestRecPPEM);
    table.writeShort(this.fontDirectionHint);
    table.writeShort(indexToLocFormat);
    table.writeShort(this.glyphDataFormat);
    return table.data;
  };
  return HeadTable2;
}(Table);
var CmapEntry = function() {
  function CmapEntry2(data2, offset) {
    var code, count, endCode, glyphId, glyphIds, i2, idDelta, idRangeOffset, index3, saveOffset, segCount, segCountX2, start, startCode, tail, _j, _k, _len;
    this.platformID = data2.readUInt16();
    this.encodingID = data2.readShort();
    this.offset = offset + data2.readInt();
    saveOffset = data2.pos;
    data2.pos = this.offset;
    this.format = data2.readUInt16();
    this.length = data2.readUInt16();
    this.language = data2.readUInt16();
    this.isUnicode = this.platformID === 3 && this.encodingID === 1 && this.format === 4 || this.platformID === 0 && this.format === 4;
    this.codeMap = {};
    switch (this.format) {
      case 0:
        for (i2 = 0; i2 < 256; ++i2) {
          this.codeMap[i2] = data2.readByte();
        }
        break;
      case 4:
        segCountX2 = data2.readUInt16();
        segCount = segCountX2 / 2;
        data2.pos += 6;
        endCode = function() {
          var _j2, _results;
          _results = [];
          for (i2 = _j2 = 0; 0 <= segCount ? _j2 < segCount : _j2 > segCount; i2 = 0 <= segCount ? ++_j2 : --_j2) {
            _results.push(data2.readUInt16());
          }
          return _results;
        }();
        data2.pos += 2;
        startCode = function() {
          var _j2, _results;
          _results = [];
          for (i2 = _j2 = 0; 0 <= segCount ? _j2 < segCount : _j2 > segCount; i2 = 0 <= segCount ? ++_j2 : --_j2) {
            _results.push(data2.readUInt16());
          }
          return _results;
        }();
        idDelta = function() {
          var _j2, _results;
          _results = [];
          for (i2 = _j2 = 0; 0 <= segCount ? _j2 < segCount : _j2 > segCount; i2 = 0 <= segCount ? ++_j2 : --_j2) {
            _results.push(data2.readUInt16());
          }
          return _results;
        }();
        idRangeOffset = function() {
          var _j2, _results;
          _results = [];
          for (i2 = _j2 = 0; 0 <= segCount ? _j2 < segCount : _j2 > segCount; i2 = 0 <= segCount ? ++_j2 : --_j2) {
            _results.push(data2.readUInt16());
          }
          return _results;
        }();
        count = (this.length - data2.pos + this.offset) / 2;
        glyphIds = function() {
          var _j2, _results;
          _results = [];
          for (i2 = _j2 = 0; 0 <= count ? _j2 < count : _j2 > count; i2 = 0 <= count ? ++_j2 : --_j2) {
            _results.push(data2.readUInt16());
          }
          return _results;
        }();
        for (i2 = _j = 0, _len = endCode.length; _j < _len; i2 = ++_j) {
          tail = endCode[i2];
          start = startCode[i2];
          for (code = _k = start; start <= tail ? _k <= tail : _k >= tail; code = start <= tail ? ++_k : --_k) {
            if (idRangeOffset[i2] === 0) {
              glyphId = code + idDelta[i2];
            } else {
              index3 = idRangeOffset[i2] / 2 + (code - start) - (segCount - i2);
              glyphId = glyphIds[index3] || 0;
              if (glyphId !== 0) {
                glyphId += idDelta[i2];
              }
            }
            this.codeMap[code] = glyphId & 65535;
          }
        }
    }
    data2.pos = saveOffset;
  }
  CmapEntry2.encode = function(charmap, encoding) {
    var charMap, code, codeMap, codes, delta, deltas, diff, endCode, endCodes, entrySelector, glyphIDs, i2, id, indexes, last, map3, nextID, offset, old, rangeOffsets, rangeShift, searchRange, segCount, segCountX2, startCode, startCodes, startGlyph, subtable, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _len5, _len6, _len7, _m, _n, _name, _o, _p, _q;
    subtable = new Data();
    codes = Object.keys(charmap).sort(function(a2, b) {
      return a2 - b;
    });
    switch (encoding) {
      case "macroman":
        id = 0;
        indexes = function() {
          var _results = [];
          for (i2 = 0; i2 < 256; ++i2) {
            _results.push(0);
          }
          return _results;
        }();
        map3 = {
          0: 0
        };
        codeMap = {};
        for (_i = 0, _len = codes.length; _i < _len; _i++) {
          code = codes[_i];
          if (map3[_name = charmap[code]] == null) {
            map3[_name] = ++id;
          }
          codeMap[code] = {
            old: charmap[code],
            new: map3[charmap[code]]
          };
          indexes[code] = map3[charmap[code]];
        }
        subtable.writeUInt16(1);
        subtable.writeUInt16(0);
        subtable.writeUInt32(12);
        subtable.writeUInt16(0);
        subtable.writeUInt16(262);
        subtable.writeUInt16(0);
        subtable.write(indexes);
        return {
          charMap: codeMap,
          subtable: subtable.data,
          maxGlyphID: id + 1
        };
      case "unicode":
        startCodes = [];
        endCodes = [];
        nextID = 0;
        map3 = {};
        charMap = {};
        last = diff = null;
        for (_j = 0, _len1 = codes.length; _j < _len1; _j++) {
          code = codes[_j];
          old = charmap[code];
          if (map3[old] == null) {
            map3[old] = ++nextID;
          }
          charMap[code] = {
            old,
            new: map3[old]
          };
          delta = map3[old] - code;
          if (last == null || delta !== diff) {
            if (last) {
              endCodes.push(last);
            }
            startCodes.push(code);
            diff = delta;
          }
          last = code;
        }
        if (last) {
          endCodes.push(last);
        }
        endCodes.push(65535);
        startCodes.push(65535);
        segCount = startCodes.length;
        segCountX2 = segCount * 2;
        searchRange = 2 * Math.pow(Math.log(segCount) / Math.LN2, 2);
        entrySelector = Math.log(searchRange / 2) / Math.LN2;
        rangeShift = 2 * segCount - searchRange;
        deltas = [];
        rangeOffsets = [];
        glyphIDs = [];
        for (i2 = _k = 0, _len2 = startCodes.length; _k < _len2; i2 = ++_k) {
          startCode = startCodes[i2];
          endCode = endCodes[i2];
          if (startCode === 65535) {
            deltas.push(0);
            rangeOffsets.push(0);
            break;
          }
          startGlyph = charMap[startCode]["new"];
          if (startCode - startGlyph >= 32768) {
            deltas.push(0);
            rangeOffsets.push(2 * (glyphIDs.length + segCount - i2));
            for (code = _l = startCode; startCode <= endCode ? _l <= endCode : _l >= endCode; code = startCode <= endCode ? ++_l : --_l) {
              glyphIDs.push(charMap[code]["new"]);
            }
          } else {
            deltas.push(startGlyph - startCode);
            rangeOffsets.push(0);
          }
        }
        subtable.writeUInt16(3);
        subtable.writeUInt16(1);
        subtable.writeUInt32(12);
        subtable.writeUInt16(4);
        subtable.writeUInt16(16 + segCount * 8 + glyphIDs.length * 2);
        subtable.writeUInt16(0);
        subtable.writeUInt16(segCountX2);
        subtable.writeUInt16(searchRange);
        subtable.writeUInt16(entrySelector);
        subtable.writeUInt16(rangeShift);
        for (_m = 0, _len3 = endCodes.length; _m < _len3; _m++) {
          code = endCodes[_m];
          subtable.writeUInt16(code);
        }
        subtable.writeUInt16(0);
        for (_n = 0, _len4 = startCodes.length; _n < _len4; _n++) {
          code = startCodes[_n];
          subtable.writeUInt16(code);
        }
        for (_o = 0, _len5 = deltas.length; _o < _len5; _o++) {
          delta = deltas[_o];
          subtable.writeUInt16(delta);
        }
        for (_p = 0, _len6 = rangeOffsets.length; _p < _len6; _p++) {
          offset = rangeOffsets[_p];
          subtable.writeUInt16(offset);
        }
        for (_q = 0, _len7 = glyphIDs.length; _q < _len7; _q++) {
          id = glyphIDs[_q];
          subtable.writeUInt16(id);
        }
        return {
          charMap,
          subtable: subtable.data,
          maxGlyphID: nextID + 1
        };
    }
  };
  return CmapEntry2;
}();
var CmapTable = function(_super) {
  __extends(CmapTable2, _super);
  function CmapTable2() {
    return CmapTable2.__super__.constructor.apply(this, arguments);
  }
  CmapTable2.prototype.tag = "cmap";
  CmapTable2.prototype.parse = function(data2) {
    var entry, i2, tableCount;
    data2.pos = this.offset;
    this.version = data2.readUInt16();
    tableCount = data2.readUInt16();
    this.tables = [];
    this.unicode = null;
    for (i2 = 0; 0 <= tableCount ? i2 < tableCount : i2 > tableCount; i2 = 0 <= tableCount ? ++i2 : --i2) {
      entry = new CmapEntry(data2, this.offset);
      this.tables.push(entry);
      if (entry.isUnicode) {
        if (this.unicode == null) {
          this.unicode = entry;
        }
      }
    }
    return true;
  };
  CmapTable2.encode = function(charmap, encoding) {
    var result, table;
    if (encoding == null) {
      encoding = "macroman";
    }
    result = CmapEntry.encode(charmap, encoding);
    table = new Data();
    table.writeUInt16(0);
    table.writeUInt16(1);
    result.table = table.data.concat(result.subtable);
    return result;
  };
  return CmapTable2;
}(Table);
var HheaTable = function(_super) {
  __extends(HheaTable2, _super);
  function HheaTable2() {
    return HheaTable2.__super__.constructor.apply(this, arguments);
  }
  HheaTable2.prototype.tag = "hhea";
  HheaTable2.prototype.parse = function(data2) {
    data2.pos = this.offset;
    this.version = data2.readInt();
    this.ascender = data2.readShort();
    this.decender = data2.readShort();
    this.lineGap = data2.readShort();
    this.advanceWidthMax = data2.readShort();
    this.minLeftSideBearing = data2.readShort();
    this.minRightSideBearing = data2.readShort();
    this.xMaxExtent = data2.readShort();
    this.caretSlopeRise = data2.readShort();
    this.caretSlopeRun = data2.readShort();
    this.caretOffset = data2.readShort();
    data2.pos += 4 * 2;
    this.metricDataFormat = data2.readShort();
    return this.numberOfMetrics = data2.readUInt16();
  };
  return HheaTable2;
}(Table);
var OS2Table = function(_super) {
  __extends(OS2Table2, _super);
  function OS2Table2() {
    return OS2Table2.__super__.constructor.apply(this, arguments);
  }
  OS2Table2.prototype.tag = "OS/2";
  OS2Table2.prototype.parse = function(data2) {
    data2.pos = this.offset;
    this.version = data2.readUInt16();
    this.averageCharWidth = data2.readShort();
    this.weightClass = data2.readUInt16();
    this.widthClass = data2.readUInt16();
    this.type = data2.readShort();
    this.ySubscriptXSize = data2.readShort();
    this.ySubscriptYSize = data2.readShort();
    this.ySubscriptXOffset = data2.readShort();
    this.ySubscriptYOffset = data2.readShort();
    this.ySuperscriptXSize = data2.readShort();
    this.ySuperscriptYSize = data2.readShort();
    this.ySuperscriptXOffset = data2.readShort();
    this.ySuperscriptYOffset = data2.readShort();
    this.yStrikeoutSize = data2.readShort();
    this.yStrikeoutPosition = data2.readShort();
    this.familyClass = data2.readShort();
    this.panose = function() {
      var i2, _results;
      _results = [];
      for (i2 = 0; i2 < 10; ++i2) {
        _results.push(data2.readByte());
      }
      return _results;
    }();
    this.charRange = function() {
      var i2, _results;
      _results = [];
      for (i2 = 0; i2 < 4; ++i2) {
        _results.push(data2.readInt());
      }
      return _results;
    }();
    this.vendorID = data2.readString(4);
    this.selection = data2.readShort();
    this.firstCharIndex = data2.readShort();
    this.lastCharIndex = data2.readShort();
    if (this.version > 0) {
      this.ascent = data2.readShort();
      this.descent = data2.readShort();
      this.lineGap = data2.readShort();
      this.winAscent = data2.readShort();
      this.winDescent = data2.readShort();
      this.codePageRange = function() {
        var i2, _results;
        _results = [];
        for (i2 = 0; i2 < 2; i2 = ++i2) {
          _results.push(data2.readInt());
        }
        return _results;
      }();
      if (this.version > 1) {
        this.xHeight = data2.readShort();
        this.capHeight = data2.readShort();
        this.defaultChar = data2.readShort();
        this.breakChar = data2.readShort();
        return this.maxContext = data2.readShort();
      }
    }
  };
  return OS2Table2;
}(Table);
var PostTable = function(_super) {
  __extends(PostTable2, _super);
  function PostTable2() {
    return PostTable2.__super__.constructor.apply(this, arguments);
  }
  PostTable2.prototype.tag = "post";
  PostTable2.prototype.parse = function(data2) {
    var length2, numberOfGlyphs, _results;
    data2.pos = this.offset;
    this.format = data2.readInt();
    this.italicAngle = data2.readInt();
    this.underlinePosition = data2.readShort();
    this.underlineThickness = data2.readShort();
    this.isFixedPitch = data2.readInt();
    this.minMemType42 = data2.readInt();
    this.maxMemType42 = data2.readInt();
    this.minMemType1 = data2.readInt();
    this.maxMemType1 = data2.readInt();
    switch (this.format) {
      case 65536:
        break;
      case 131072:
        numberOfGlyphs = data2.readUInt16();
        this.glyphNameIndex = [];
        var i2;
        for (i2 = 0; 0 <= numberOfGlyphs ? i2 < numberOfGlyphs : i2 > numberOfGlyphs; i2 = 0 <= numberOfGlyphs ? ++i2 : --i2) {
          this.glyphNameIndex.push(data2.readUInt16());
        }
        this.names = [];
        _results = [];
        while (data2.pos < this.offset + this.length) {
          length2 = data2.readByte();
          _results.push(this.names.push(data2.readString(length2)));
        }
        return _results;
      case 151552:
        numberOfGlyphs = data2.readUInt16();
        return this.offsets = data2.read(numberOfGlyphs);
      case 196608:
        break;
      case 262144:
        return this.map = function() {
          var _j, _ref, _results1;
          _results1 = [];
          for (i2 = _j = 0, _ref = this.file.maxp.numGlyphs; 0 <= _ref ? _j < _ref : _j > _ref; i2 = 0 <= _ref ? ++_j : --_j) {
            _results1.push(data2.readUInt32());
          }
          return _results1;
        }.call(this);
    }
  };
  return PostTable2;
}(Table);
var NameEntry = function() {
  function NameEntry2(raw, entry) {
    this.raw = raw;
    this.length = raw.length;
    this.platformID = entry.platformID;
    this.encodingID = entry.encodingID;
    this.languageID = entry.languageID;
  }
  return NameEntry2;
}();
var NameTable = function(_super) {
  __extends(NameTable2, _super);
  function NameTable2() {
    return NameTable2.__super__.constructor.apply(this, arguments);
  }
  NameTable2.prototype.tag = "name";
  NameTable2.prototype.parse = function(data2) {
    var count, entries, entry, i2, name, stringOffset, strings, text4, _j, _len, _name;
    data2.pos = this.offset;
    data2.readShort();
    count = data2.readShort();
    stringOffset = data2.readShort();
    entries = [];
    for (i2 = 0; 0 <= count ? i2 < count : i2 > count; i2 = 0 <= count ? ++i2 : --i2) {
      entries.push({
        platformID: data2.readShort(),
        encodingID: data2.readShort(),
        languageID: data2.readShort(),
        nameID: data2.readShort(),
        length: data2.readShort(),
        offset: this.offset + stringOffset + data2.readShort()
      });
    }
    strings = {};
    for (i2 = _j = 0, _len = entries.length; _j < _len; i2 = ++_j) {
      entry = entries[i2];
      data2.pos = entry.offset;
      text4 = data2.readString(entry.length);
      name = new NameEntry(text4, entry);
      if (strings[_name = entry.nameID] == null) {
        strings[_name] = [];
      }
      strings[entry.nameID].push(name);
    }
    this.strings = strings;
    this.copyright = strings[0];
    this.fontFamily = strings[1];
    this.fontSubfamily = strings[2];
    this.uniqueSubfamily = strings[3];
    this.fontName = strings[4];
    this.version = strings[5];
    try {
      this.postscriptName = strings[6][0].raw.replace(/[\x00-\x19\x80-\xff]/g, "");
    } catch (e2) {
      this.postscriptName = strings[4][0].raw.replace(/[\x00-\x19\x80-\xff]/g, "");
    }
    this.trademark = strings[7];
    this.manufacturer = strings[8];
    this.designer = strings[9];
    this.description = strings[10];
    this.vendorUrl = strings[11];
    this.designerUrl = strings[12];
    this.license = strings[13];
    this.licenseUrl = strings[14];
    this.preferredFamily = strings[15];
    this.preferredSubfamily = strings[17];
    this.compatibleFull = strings[18];
    return this.sampleText = strings[19];
  };
  return NameTable2;
}(Table);
var MaxpTable = function(_super) {
  __extends(MaxpTable2, _super);
  function MaxpTable2() {
    return MaxpTable2.__super__.constructor.apply(this, arguments);
  }
  MaxpTable2.prototype.tag = "maxp";
  MaxpTable2.prototype.parse = function(data2) {
    data2.pos = this.offset;
    this.version = data2.readInt();
    this.numGlyphs = data2.readUInt16();
    this.maxPoints = data2.readUInt16();
    this.maxContours = data2.readUInt16();
    this.maxCompositePoints = data2.readUInt16();
    this.maxComponentContours = data2.readUInt16();
    this.maxZones = data2.readUInt16();
    this.maxTwilightPoints = data2.readUInt16();
    this.maxStorage = data2.readUInt16();
    this.maxFunctionDefs = data2.readUInt16();
    this.maxInstructionDefs = data2.readUInt16();
    this.maxStackElements = data2.readUInt16();
    this.maxSizeOfInstructions = data2.readUInt16();
    this.maxComponentElements = data2.readUInt16();
    return this.maxComponentDepth = data2.readUInt16();
  };
  return MaxpTable2;
}(Table);
var HmtxTable = function(_super) {
  __extends(HmtxTable2, _super);
  function HmtxTable2() {
    return HmtxTable2.__super__.constructor.apply(this, arguments);
  }
  HmtxTable2.prototype.tag = "hmtx";
  HmtxTable2.prototype.parse = function(data2) {
    var i2, last, lsbCount, m3, _j, _ref, _results;
    data2.pos = this.offset;
    this.metrics = [];
    for (i2 = 0, _ref = this.file.hhea.numberOfMetrics; 0 <= _ref ? i2 < _ref : i2 > _ref; i2 = 0 <= _ref ? ++i2 : --i2) {
      this.metrics.push({
        advance: data2.readUInt16(),
        lsb: data2.readInt16()
      });
    }
    lsbCount = this.file.maxp.numGlyphs - this.file.hhea.numberOfMetrics;
    this.leftSideBearings = function() {
      var _j2, _results2;
      _results2 = [];
      for (i2 = _j2 = 0; 0 <= lsbCount ? _j2 < lsbCount : _j2 > lsbCount; i2 = 0 <= lsbCount ? ++_j2 : --_j2) {
        _results2.push(data2.readInt16());
      }
      return _results2;
    }();
    this.widths = function() {
      var _j2, _len, _ref1, _results2;
      _ref1 = this.metrics;
      _results2 = [];
      for (_j2 = 0, _len = _ref1.length; _j2 < _len; _j2++) {
        m3 = _ref1[_j2];
        _results2.push(m3.advance);
      }
      return _results2;
    }.call(this);
    last = this.widths[this.widths.length - 1];
    _results = [];
    for (i2 = _j = 0; 0 <= lsbCount ? _j < lsbCount : _j > lsbCount; i2 = 0 <= lsbCount ? ++_j : --_j) {
      _results.push(this.widths.push(last));
    }
    return _results;
  };
  HmtxTable2.prototype.forGlyph = function(id) {
    if (id in this.metrics) {
      return this.metrics[id];
    }
    return {
      advance: this.metrics[this.metrics.length - 1].advance,
      lsb: this.leftSideBearings[id - this.metrics.length]
    };
  };
  return HmtxTable2;
}(Table);
var __slice = [].slice;
var GlyfTable = function(_super) {
  __extends(GlyfTable2, _super);
  function GlyfTable2() {
    return GlyfTable2.__super__.constructor.apply(this, arguments);
  }
  GlyfTable2.prototype.tag = "glyf";
  GlyfTable2.prototype.parse = function() {
    return this.cache = {};
  };
  GlyfTable2.prototype.glyphFor = function(id) {
    var data2, index3, length2, loca, numberOfContours, raw, xMax, xMin, yMax, yMin;
    if (id in this.cache) {
      return this.cache[id];
    }
    loca = this.file.loca;
    data2 = this.file.contents;
    index3 = loca.indexOf(id);
    length2 = loca.lengthOf(id);
    if (length2 === 0) {
      return this.cache[id] = null;
    }
    data2.pos = this.offset + index3;
    raw = new Data(data2.read(length2));
    numberOfContours = raw.readShort();
    xMin = raw.readShort();
    yMin = raw.readShort();
    xMax = raw.readShort();
    yMax = raw.readShort();
    if (numberOfContours === -1) {
      this.cache[id] = new CompoundGlyph(raw, xMin, yMin, xMax, yMax);
    } else {
      this.cache[id] = new SimpleGlyph(raw, numberOfContours, xMin, yMin, xMax, yMax);
    }
    return this.cache[id];
  };
  GlyfTable2.prototype.encode = function(glyphs, mapping, old2new) {
    var glyph, id, offsets, table, _i, _len;
    table = [];
    offsets = [];
    for (_i = 0, _len = mapping.length; _i < _len; _i++) {
      id = mapping[_i];
      glyph = glyphs[id];
      offsets.push(table.length);
      if (glyph) {
        table = table.concat(glyph.encode(old2new));
      }
    }
    offsets.push(table.length);
    return {
      table,
      offsets
    };
  };
  return GlyfTable2;
}(Table);
var SimpleGlyph = function() {
  function SimpleGlyph2(raw, numberOfContours, xMin, yMin, xMax, yMax) {
    this.raw = raw;
    this.numberOfContours = numberOfContours;
    this.xMin = xMin;
    this.yMin = yMin;
    this.xMax = xMax;
    this.yMax = yMax;
    this.compound = false;
  }
  SimpleGlyph2.prototype.encode = function() {
    return this.raw.data;
  };
  return SimpleGlyph2;
}();
var CompoundGlyph = function() {
  var ARG_1_AND_2_ARE_WORDS, MORE_COMPONENTS, WE_HAVE_AN_X_AND_Y_SCALE, WE_HAVE_A_SCALE, WE_HAVE_A_TWO_BY_TWO;
  ARG_1_AND_2_ARE_WORDS = 1;
  WE_HAVE_A_SCALE = 8;
  MORE_COMPONENTS = 32;
  WE_HAVE_AN_X_AND_Y_SCALE = 64;
  WE_HAVE_A_TWO_BY_TWO = 128;
  function CompoundGlyph2(raw, xMin, yMin, xMax, yMax) {
    var data2, flags;
    this.raw = raw;
    this.xMin = xMin;
    this.yMin = yMin;
    this.xMax = xMax;
    this.yMax = yMax;
    this.compound = true;
    this.glyphIDs = [];
    this.glyphOffsets = [];
    data2 = this.raw;
    while (true) {
      flags = data2.readShort();
      this.glyphOffsets.push(data2.pos);
      this.glyphIDs.push(data2.readUInt16());
      if (!(flags & MORE_COMPONENTS)) {
        break;
      }
      if (flags & ARG_1_AND_2_ARE_WORDS) {
        data2.pos += 4;
      } else {
        data2.pos += 2;
      }
      if (flags & WE_HAVE_A_TWO_BY_TWO) {
        data2.pos += 8;
      } else if (flags & WE_HAVE_AN_X_AND_Y_SCALE) {
        data2.pos += 4;
      } else if (flags & WE_HAVE_A_SCALE) {
        data2.pos += 2;
      }
    }
  }
  CompoundGlyph2.prototype.encode = function() {
    var i2, result, _len, _ref;
    result = new Data(__slice.call(this.raw.data));
    _ref = this.glyphIDs;
    for (i2 = 0, _len = _ref.length; i2 < _len; ++i2) {
      result.pos = this.glyphOffsets[i2];
    }
    return result.data;
  };
  return CompoundGlyph2;
}();
var LocaTable = function(_super) {
  __extends(LocaTable2, _super);
  function LocaTable2() {
    return LocaTable2.__super__.constructor.apply(this, arguments);
  }
  LocaTable2.prototype.tag = "loca";
  LocaTable2.prototype.parse = function(data2) {
    var format, i2;
    data2.pos = this.offset;
    format = this.file.head.indexToLocFormat;
    if (format === 0) {
      return this.offsets = function() {
        var _ref, _results;
        _results = [];
        for (i2 = 0, _ref = this.length; i2 < _ref; i2 += 2) {
          _results.push(data2.readUInt16() * 2);
        }
        return _results;
      }.call(this);
    } else {
      return this.offsets = function() {
        var _ref, _results;
        _results = [];
        for (i2 = 0, _ref = this.length; i2 < _ref; i2 += 4) {
          _results.push(data2.readUInt32());
        }
        return _results;
      }.call(this);
    }
  };
  LocaTable2.prototype.indexOf = function(id) {
    return this.offsets[id];
  };
  LocaTable2.prototype.lengthOf = function(id) {
    return this.offsets[id + 1] - this.offsets[id];
  };
  LocaTable2.prototype.encode = function(offsets, activeGlyphs) {
    var LocaTable3 = new Uint32Array(this.offsets.length);
    var glyfPtr = 0;
    var listGlyf = 0;
    for (var k = 0; k < LocaTable3.length; ++k) {
      LocaTable3[k] = glyfPtr;
      if (listGlyf < activeGlyphs.length && activeGlyphs[listGlyf] == k) {
        ++listGlyf;
        LocaTable3[k] = glyfPtr;
        var start = this.offsets[k];
        var len = this.offsets[k + 1] - start;
        if (len > 0) {
          glyfPtr += len;
        }
      }
    }
    var newLocaTable = new Array(LocaTable3.length * 4);
    for (var j = 0; j < LocaTable3.length; ++j) {
      newLocaTable[4 * j + 3] = LocaTable3[j] & 255;
      newLocaTable[4 * j + 2] = (LocaTable3[j] & 65280) >> 8;
      newLocaTable[4 * j + 1] = (LocaTable3[j] & 16711680) >> 16;
      newLocaTable[4 * j] = (LocaTable3[j] & 4278190080) >> 24;
    }
    return newLocaTable;
  };
  return LocaTable2;
}(Table);
var invert = function invert2(object) {
  var key, ret, val;
  ret = {};
  for (key in object) {
    val = object[key];
    ret[val] = key;
  }
  return ret;
};
var Subset = function() {
  function Subset2(font) {
    this.font = font;
    this.subset = {};
    this.unicodes = {};
    this.next = 33;
  }
  Subset2.prototype.generateCmap = function() {
    var mapping, roman, unicode, unicodeCmap, _ref;
    unicodeCmap = this.font.cmap.tables[0].codeMap;
    mapping = {};
    _ref = this.subset;
    for (roman in _ref) {
      unicode = _ref[roman];
      mapping[roman] = unicodeCmap[unicode];
    }
    return mapping;
  };
  Subset2.prototype.glyphsFor = function(glyphIDs) {
    var additionalIDs, glyph, glyphs, id, _i, _len, _ref;
    glyphs = {};
    for (_i = 0, _len = glyphIDs.length; _i < _len; _i++) {
      id = glyphIDs[_i];
      glyphs[id] = this.font.glyf.glyphFor(id);
    }
    additionalIDs = [];
    for (id in glyphs) {
      glyph = glyphs[id];
      if (glyph != null ? glyph.compound : void 0) {
        additionalIDs.push.apply(additionalIDs, glyph.glyphIDs);
      }
    }
    if (additionalIDs.length > 0) {
      _ref = this.glyphsFor(additionalIDs);
      for (id in _ref) {
        glyph = _ref[id];
        glyphs[id] = glyph;
      }
    }
    return glyphs;
  };
  Subset2.prototype.encode = function(glyID, indexToLocFormat) {
    var cmap, code, glyf, glyphs, id, ids, loca, new2old, newIDs, nextGlyphID, old2new, oldID, oldIDs, tables, _ref;
    cmap = CmapTable.encode(this.generateCmap(), "unicode");
    glyphs = this.glyphsFor(glyID);
    old2new = {
      0: 0
    };
    _ref = cmap.charMap;
    for (code in _ref) {
      ids = _ref[code];
      old2new[ids.old] = ids["new"];
    }
    nextGlyphID = cmap.maxGlyphID;
    for (oldID in glyphs) {
      if (!(oldID in old2new)) {
        old2new[oldID] = nextGlyphID++;
      }
    }
    new2old = invert(old2new);
    newIDs = Object.keys(new2old).sort(function(a2, b) {
      return a2 - b;
    });
    oldIDs = function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = newIDs.length; _i < _len; _i++) {
        id = newIDs[_i];
        _results.push(new2old[id]);
      }
      return _results;
    }();
    glyf = this.font.glyf.encode(glyphs, oldIDs, old2new);
    loca = this.font.loca.encode(glyf.offsets, oldIDs);
    tables = {
      cmap: this.font.cmap.raw(),
      glyf: glyf.table,
      loca,
      hmtx: this.font.hmtx.raw(),
      hhea: this.font.hhea.raw(),
      maxp: this.font.maxp.raw(),
      post: this.font.post.raw(),
      name: this.font.name.raw(),
      head: this.font.head.encode(indexToLocFormat)
    };
    if (this.font.os2.exists) {
      tables["OS/2"] = this.font.os2.raw();
    }
    return this.font.directory.encode(tables);
  };
  return Subset2;
}();
jsPDF.API.PDFObject = function() {
  var pad2;
  function PDFObject() {
  }
  pad2 = function pad3(str, length2) {
    return (Array(length2 + 1).join("0") + str).slice(-length2);
  };
  PDFObject.convert = function(object) {
    var e2, items, key, out, val;
    if (Array.isArray(object)) {
      items = function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = object.length; _i < _len; _i++) {
          e2 = object[_i];
          _results.push(PDFObject.convert(e2));
        }
        return _results;
      }().join(" ");
      return "[" + items + "]";
    } else if (typeof object === "string") {
      return "/" + object;
    } else if (object != null ? object.isString : void 0) {
      return "(" + object + ")";
    } else if (object instanceof Date) {
      return "(D:" + pad2(object.getUTCFullYear(), 4) + pad2(object.getUTCMonth(), 2) + pad2(object.getUTCDate(), 2) + pad2(object.getUTCHours(), 2) + pad2(object.getUTCMinutes(), 2) + pad2(object.getUTCSeconds(), 2) + "Z)";
    } else if ({}.toString.call(object) === "[object Object]") {
      out = ["<<"];
      for (key in object) {
        val = object[key];
        out.push("/" + key + " " + PDFObject.convert(val));
      }
      out.push(">>");
      return out.join("\n");
    } else {
      return "" + object;
    }
  };
  return PDFObject;
}();
var jspdf_default = jsPDF;

// ../simple-mind-map/src/plugins/ExportPDF.js
var ExportPDF = class {
  //  构造函数
  constructor(opt) {
    this.mindMap = opt.mindMap;
  }
  //  导出为pdf
  async pdf(name, img) {
    return new Promise((resolve, reject) => {
      const image = new Image();
      image.onload = () => {
        const imageWidth = image.width;
        const imageHeight = image.height;
        const pdf = new jspdf_default({
          unit: "px",
          format: [imageWidth, imageHeight],
          compress: true,
          hotfixes: ["px_scaling"],
          orientation: imageWidth > imageHeight ? "landscape" : "portrait"
        });
        pdf.addImage(img, "PNG", 0, 0, imageWidth, imageHeight);
        pdf.save(name);
        resolve();
      };
      image.onerror = (e2) => {
        reject(e2);
      };
      image.src = img;
    });
  }
};
ExportPDF.instanceName = "doExportPDF";
var ExportPDF_default = ExportPDF;

// ../simple-mind-map/src/utils/simulateCSSBackgroundInCanvas.js
var getNumberValueFromStr = (value) => {
  let arr = String(value).split(/\s+/);
  return arr.map((item) => {
    if (/^[\d.]+/.test(item)) {
      let res = /^([\d.]+)(.*)$/.exec(item);
      return [Number(res[1]), res[2]];
    } else {
      return item;
    }
  });
};
var zoomWidth = (ratio, height2) => {
  return ratio * height2;
};
var zoomHeight = (ratio, width2) => {
  return width2 / ratio;
};
var keyWordToPercentageMap = {
  left: 0,
  top: 0,
  center: 50,
  bottom: 100,
  right: 100
};
var handleBackgroundSize = ({
  backgroundSize,
  drawOpt,
  imageRatio,
  canvasWidth,
  canvasHeight,
  canvasRatio
}) => {
  if (backgroundSize) {
    let backgroundSizeValueArr = getNumberValueFromStr(backgroundSize);
    if (backgroundSizeValueArr[0] === "auto" && backgroundSizeValueArr[1] === "auto") {
      return;
    }
    if (backgroundSizeValueArr[0] === "cover") {
      if (imageRatio > canvasRatio) {
        drawOpt.height = canvasHeight;
        drawOpt.width = zoomWidth(imageRatio, canvasHeight);
      } else {
        drawOpt.width = canvasWidth;
        drawOpt.height = zoomHeight(imageRatio, canvasWidth);
      }
      return;
    }
    if (backgroundSizeValueArr[0] === "contain") {
      if (imageRatio > canvasRatio) {
        drawOpt.width = canvasWidth;
        drawOpt.height = zoomHeight(imageRatio, canvasWidth);
      } else {
        drawOpt.height = canvasHeight;
        drawOpt.width = zoomWidth(imageRatio, canvasHeight);
      }
      return;
    }
    let newNumberWidth = -1;
    if (backgroundSizeValueArr[0]) {
      if (Array.isArray(backgroundSizeValueArr[0])) {
        if (backgroundSizeValueArr[0][1] === "%") {
          drawOpt.width = backgroundSizeValueArr[0][0] / 100 * canvasWidth;
          newNumberWidth = drawOpt.width;
        } else {
          drawOpt.width = backgroundSizeValueArr[0][0];
          newNumberWidth = backgroundSizeValueArr[0][0];
        }
      } else if (backgroundSizeValueArr[0] === "auto") {
        if (backgroundSizeValueArr[1]) {
          if (backgroundSizeValueArr[1][1] === "%") {
            drawOpt.width = zoomWidth(
              imageRatio,
              backgroundSizeValueArr[1][0] / 100 * canvasHeight
            );
          } else {
            drawOpt.width = zoomWidth(imageRatio, backgroundSizeValueArr[1][0]);
          }
        }
      }
    }
    if (backgroundSizeValueArr[1] && Array.isArray(backgroundSizeValueArr[1])) {
      if (backgroundSizeValueArr[1][1] === "%") {
        drawOpt.height = backgroundSizeValueArr[1][0] / 100 * canvasHeight;
      } else {
        drawOpt.height = backgroundSizeValueArr[1][0];
      }
    } else if (newNumberWidth !== -1) {
      drawOpt.height = zoomHeight(imageRatio, newNumberWidth);
    }
  }
};
var handleBackgroundPosition = ({
  backgroundPosition,
  drawOpt,
  imgWidth,
  imgHeight,
  canvasWidth,
  canvasHeight
}) => {
  if (backgroundPosition) {
    let backgroundPositionValueArr = getNumberValueFromStr(backgroundPosition);
    backgroundPositionValueArr = backgroundPositionValueArr.map((item) => {
      if (typeof item === "string") {
        return keyWordToPercentageMap[item] !== void 0 ? [keyWordToPercentageMap[item], "%"] : item;
      }
      return item;
    });
    if (Array.isArray(backgroundPositionValueArr[0])) {
      if (backgroundPositionValueArr.length === 1) {
        backgroundPositionValueArr.push([50, "%"]);
      }
      if (backgroundPositionValueArr[0][1] === "%") {
        let canvasX = backgroundPositionValueArr[0][0] / 100 * canvasWidth;
        let imgX = backgroundPositionValueArr[0][0] / 100 * imgWidth;
        drawOpt.x = canvasX - imgX;
      } else {
        drawOpt.x = backgroundPositionValueArr[0][0];
      }
      if (backgroundPositionValueArr[1][1] === "%") {
        let canvasY = backgroundPositionValueArr[1][0] / 100 * canvasHeight;
        let imgY = backgroundPositionValueArr[1][0] / 100 * imgHeight;
        drawOpt.y = canvasY - imgY;
      } else {
        drawOpt.y = backgroundPositionValueArr[1][0];
      }
    }
  }
};
var handleBackgroundRepeat = ({
  ctx,
  image,
  backgroundRepeat,
  drawOpt,
  imgWidth,
  imgHeight,
  canvasWidth,
  canvasHeight
}) => {
  if (backgroundRepeat) {
    let ox = drawOpt.x;
    let oy = drawOpt.y;
    let oxRepeatNum = Math.ceil(ox / imgWidth);
    let oyRepeatNum = Math.ceil(oy / imgHeight);
    let oxRepeatX = ox - oxRepeatNum * imgWidth;
    let oxRepeatY = oy - oyRepeatNum * imgHeight;
    let backgroundRepeatValueArr = getNumberValueFromStr(backgroundRepeat);
    if (backgroundRepeatValueArr[0] === "no-repeat" || imgWidth >= canvasWidth && imgHeight >= canvasHeight) {
      return;
    }
    if (backgroundRepeatValueArr[0] === "repeat-x") {
      if (canvasWidth > imgWidth) {
        let x2 = oxRepeatX;
        while (x2 < canvasWidth) {
          drawImage(ctx, image, {
            ...drawOpt,
            x: x2
          });
          x2 += imgWidth;
        }
        return true;
      }
    }
    if (backgroundRepeatValueArr[0] === "repeat-y") {
      if (canvasHeight > imgHeight) {
        let y3 = oxRepeatY;
        while (y3 < canvasHeight) {
          drawImage(ctx, image, {
            ...drawOpt,
            y: y3
          });
          y3 += imgHeight;
        }
        return true;
      }
    }
    if (backgroundRepeatValueArr[0] === "repeat") {
      let x2 = oxRepeatX;
      while (x2 < canvasWidth) {
        if (canvasHeight > imgHeight) {
          let y3 = oxRepeatY;
          while (y3 < canvasHeight) {
            drawImage(ctx, image, {
              ...drawOpt,
              x: x2,
              y: y3
            });
            y3 += imgHeight;
          }
        }
        x2 += imgWidth;
      }
      return true;
    }
  }
};
var drawImage = (ctx, image, drawOpt) => {
  ctx.drawImage(
    image,
    drawOpt.sx,
    drawOpt.sy,
    drawOpt.swidth,
    drawOpt.sheight,
    drawOpt.x,
    drawOpt.y,
    drawOpt.width,
    drawOpt.height
  );
};
var drawBackgroundImageToCanvas = (ctx, width2, height2, img, { backgroundSize, backgroundPosition, backgroundRepeat }, callback = () => {
}) => {
  let canvasRatio = width2 / height2;
  let image = new Image();
  image.src = img;
  image.onload = () => {
    let imgWidth = image.width;
    let imgHeight = image.height;
    let imageRatio = imgWidth / imgHeight;
    let drawOpt = {
      sx: 0,
      sy: 0,
      swidth: imgWidth,
      sheight: imgHeight,
      x: 0,
      y: 0,
      width: imgWidth,
      height: imgHeight
    };
    handleBackgroundSize({
      backgroundSize,
      drawOpt,
      imageRatio,
      canvasWidth: width2,
      canvasHeight: height2,
      canvasRatio
    });
    handleBackgroundPosition({
      backgroundPosition,
      drawOpt,
      imgWidth: drawOpt.width,
      imgHeight: drawOpt.height,
      imageRatio,
      canvasWidth: width2,
      canvasHeight: height2,
      canvasRatio
    });
    let notNeedDraw = handleBackgroundRepeat({
      ctx,
      image,
      backgroundRepeat,
      drawOpt,
      imgWidth: drawOpt.width,
      imgHeight: drawOpt.height,
      imageRatio,
      canvasWidth: width2,
      canvasHeight: height2,
      canvasRatio
    });
    if (!notNeedDraw) {
      drawImage(ctx, image, drawOpt);
    }
    callback();
  };
  image.onerror = (e2) => {
    callback(e2);
  };
};
var simulateCSSBackgroundInCanvas_default = drawBackgroundImageToCanvas;

// ../simple-mind-map/src/parse/toMarkdown.js
var el = null;
var getText = (str) => {
  if (!el) {
    el = document.createElement("div");
  }
  el.innerHTML = str;
  return el.textContent;
};
var getTitleMark = (level) => {
  return new Array(level).fill("#").join("");
};
var getIndentMark = (level) => {
  return new Array(level - 6).fill("   ").join("") + "*";
};
var transformToMarkdown = (root2) => {
  let content3 = "";
  walk(
    root2,
    null,
    (node3, parent, isRoot, layerIndex) => {
      let level = layerIndex + 1;
      let text4 = node3.data.richText ? getText(node3.data.text) : node3.data.text;
      if (level <= 6) {
        content3 += getTitleMark(level);
      } else {
        content3 += getIndentMark(level);
      }
      content3 += " " + text4;
      let generalization = node3.data.generalization;
      if (generalization && generalization.text) {
        let generalizationText = generalization.richText ? getText(generalization.text) : generalization.text;
        content3 += `[${generalizationText}]`;
      }
      content3 += "\n\n";
      if (node3.data.note) {
        content3 += node3.data.note + "\n\n";
      }
    },
    () => {
    },
    true
  );
  return content3;
};

// ../simple-mind-map/src/plugins/Export.js
var Export = class {
  //  构造函数
  constructor(opt) {
    this.mindMap = opt.mindMap;
  }
  //  导出
  async export(type, isDownload = true, name = "\u601D\u7EF4\u5BFC\u56FE", ...args) {
    if (this[type]) {
      const result = await this[type](name, ...args);
      if (isDownload && type !== "pdf") {
        downloadFile(result, name + "." + type);
      }
      return result;
    } else {
      return null;
    }
  }
  // 创建图片url转换任务
  createTransformImgTaskList(svg2, tagName, propName, getUrlFn) {
    const imageList = svg2.find(tagName);
    return imageList.map(async (item) => {
      const imgUlr = getUrlFn(item);
      if (/^data:/.test(imgUlr) || imgUlr === "none") {
        return;
      }
      const imgData = await imgToDataUrl(imgUlr);
      item.attr(propName, imgData);
    });
  }
  //  获取svg数据
  async getSvgData() {
    let { exportPaddingX, exportPaddingY, errorHandler, resetCss } = this.mindMap.opt;
    let { svg: svg2, svgHTML } = this.mindMap.getSvgData({
      paddingX: exportPaddingX,
      paddingY: exportPaddingY
    });
    const task1 = this.createTransformImgTaskList(
      svg2,
      "image",
      "href",
      (item) => {
        return item.attr("href") || item.attr("xlink:href");
      }
    );
    const task2 = this.createTransformImgTaskList(svg2, "img", "src", (item) => {
      return item.attr("src");
    });
    const taskList = [...task1, ...task2];
    try {
      await Promise.all(taskList);
    } catch (error) {
      errorHandler(ERROR_TYPES.EXPORT_LOAD_IMAGE_ERROR, error);
    }
    let isAddResetCss;
    if (this.mindMap.richText) {
      const foreignObjectList = svg2.find("foreignObject");
      if (foreignObjectList.length > 0) {
        foreignObjectList[0].add(SVG(`<style>${resetCss}</style>`));
        isAddResetCss = true;
      }
    }
    if (taskList.length > 0 || isAddResetCss) {
      svgHTML = svg2.svg();
    }
    return {
      node: svg2,
      str: svgHTML
    };
  }
  //   svg转png
  svgToPng(svgSrc, transparent) {
    return new Promise((resolve, reject) => {
      const img = new Image();
      img.setAttribute("crossOrigin", "anonymous");
      img.onload = async () => {
        try {
          const canvas = document.createElement("canvas");
          const dpr = Math.max(
            window.devicePixelRatio,
            this.mindMap.opt.minExportImgCanvasScale
          );
          let imgWidth = img.width;
          let imgHeight = img.height;
          const maxSize = 16384 / dpr;
          const maxArea = maxSize * maxSize;
          if (imgWidth * imgHeight > maxArea) {
            let newWidth = null;
            let newHeight = null;
            if (imgWidth > maxSize) {
              newWidth = maxArea / imgHeight;
            } else if (imgHeight > maxSize) {
              newHeight = maxArea / imgWidth;
            }
            const res = resizeImgSize(imgWidth, imgHeight, newWidth, newHeight);
            imgWidth = res[0];
            imgHeight = res[1];
          }
          canvas.width = imgWidth * dpr;
          canvas.height = imgHeight * dpr;
          canvas.style.width = imgWidth + "px";
          canvas.style.height = imgHeight + "px";
          const ctx = canvas.getContext("2d");
          ctx.scale(dpr, dpr);
          if (!transparent) {
            await this.drawBackgroundToCanvas(ctx, imgWidth, imgHeight);
          }
          ctx.drawImage(img, 0, 0, imgWidth, imgHeight);
          resolve(canvas.toDataURL());
        } catch (error) {
          reject(error);
        }
      };
      img.onerror = (e2) => {
        reject(e2);
      };
      img.src = svgSrc;
    });
  }
  //  在canvas上绘制思维导图背景
  drawBackgroundToCanvas(ctx, width2, height2) {
    return new Promise((resolve, reject) => {
      const {
        backgroundColor = "#fff",
        backgroundImage,
        backgroundRepeat = "no-repeat",
        backgroundPosition = "center center",
        backgroundSize = "cover"
      } = this.mindMap.themeConfig;
      ctx.save();
      ctx.rect(0, 0, width2, height2);
      ctx.fillStyle = backgroundColor;
      ctx.fill();
      ctx.restore();
      if (backgroundImage && backgroundImage !== "none") {
        ctx.save();
        simulateCSSBackgroundInCanvas_default(
          ctx,
          width2,
          height2,
          backgroundImage,
          {
            backgroundRepeat,
            backgroundPosition,
            backgroundSize
          },
          (err) => {
            if (err) {
              reject(err);
            } else {
              resolve();
            }
            ctx.restore();
          }
        );
      } else {
        resolve();
      }
    });
  }
  //  在svg上绘制思维导图背景
  drawBackgroundToSvg(svg2) {
    return new Promise(async (resolve) => {
      const {
        backgroundColor = "#fff",
        backgroundImage,
        backgroundRepeat = "repeat"
      } = this.mindMap.themeConfig;
      svg2.css("background-color", backgroundColor);
      if (backgroundImage && backgroundImage !== "none") {
        const imgDataUrl = await imgToDataUrl(backgroundImage);
        svg2.css("background-image", `url(${imgDataUrl})`);
        svg2.css("background-repeat", backgroundRepeat);
        resolve();
      } else {
        resolve();
      }
    });
  }
  //  导出为png
  /**
   * 方法1.把svg的图片都转化成data:url格式，再转换
   * 方法2.把svg的图片提取出来再挨个绘制到canvas里，最后一起转换
   */
  async png(name, transparent = false) {
    const { str } = await this.getSvgData();
    const svgUrl = await this.fixSvgStrAndToBlob(str);
    const res = await this.svgToPng(svgUrl, transparent);
    return res;
  }
  //  导出为pdf
  async pdf(name, transparent = false) {
    if (!this.mindMap.doExportPDF) {
      throw new Error("\u8BF7\u6CE8\u518CExportPDF\u63D2\u4EF6");
    }
    const img = await this.png(name, transparent);
    await this.mindMap.doExportPDF.pdf(name, img);
  }
  // 导出为xmind
  async xmind(name) {
    if (!this.mindMap.doExportXMind) {
      throw new Error("\u8BF7\u6CE8\u518CExportXMind\u63D2\u4EF6");
    }
    const data2 = this.mindMap.getData();
    const blob = await this.mindMap.doExportXMind.xmind(data2, name);
    const res = await readBlob(blob);
    return res;
  }
  //  导出为svg
  async svg(name) {
    const { node: node3 } = await this.getSvgData();
    node3.first().before(SVG(`<title>${name}</title>`));
    await this.drawBackgroundToSvg(node3);
    const str = node3.svg();
    const res = await this.fixSvgStrAndToBlob(str);
    return res;
  }
  // 修复svg字符串，并且转换为blob数据
  async fixSvgStrAndToBlob(str) {
    str = removeHTMLEntities(str);
    str = handleSelfCloseTags(str);
    const blob = new Blob([str], {
      type: "image/svg+xml"
    });
    const res = await readBlob(blob);
    return res;
  }
  //  导出为json
  async json(name, withConfig = true) {
    const data2 = this.mindMap.getData(withConfig);
    const str = JSON.stringify(data2);
    const blob = new Blob([str]);
    const res = await readBlob(blob);
    return res;
  }
  //  专有文件，其实就是json文件
  async smm(name, withConfig) {
    const res = await this.json(name, withConfig);
    return res;
  }
  // markdown文件
  async md() {
    const data2 = this.mindMap.getData();
    const content3 = transformToMarkdown(data2);
    const blob = new Blob([content3]);
    const res = await readBlob(blob);
    return res;
  }
};
Export.instanceName = "doExport";
var Export_default = Export;

// ../simple-mind-map/src/plugins/Drag.js
var Drag = class extends Base_default {
  //  构造函数
  constructor({ mindMap }) {
    super(mindMap.renderer);
    this.mindMap = mindMap;
    this.reset();
    this.bindEvent();
  }
  //  复位
  reset() {
    this.isDragging = false;
    this.mousedownNode = null;
    this.beingDragNodeList = [];
    this.nodeList = [];
    this.overlapNode = null;
    this.prevNode = null;
    this.nextNode = null;
    this.drawTransform = null;
    this.clone = null;
    this.placeholder = null;
    this.offsetX = 0;
    this.offsetY = 0;
    this.isMousedown = false;
    this.mouseDownX = 0;
    this.mouseDownY = 0;
    this.mouseMoveX = 0;
    this.mouseMoveY = 0;
    this.checkDragOffset = 10;
    this.minOffset = 10;
  }
  //  绑定事件
  bindEvent() {
    this.onNodeMousedown = this.onNodeMousedown.bind(this);
    this.onMousemove = this.onMousemove.bind(this);
    this.onMouseup = this.onMouseup.bind(this);
    this.checkOverlapNode = throttle(this.checkOverlapNode, 300, this);
    this.mindMap.on("node_mousedown", this.onNodeMousedown);
    this.mindMap.on("mousemove", this.onMousemove);
    this.mindMap.on("node_mouseup", this.onMouseup);
    this.mindMap.on("mouseup", this.onMouseup);
  }
  // 解绑事件
  unBindEvent() {
    this.mindMap.off("node_mousedown", this.onNodeMousedown);
    this.mindMap.off("mousemove", this.onMousemove);
    this.mindMap.off("node_mouseup", this.onMouseup);
    this.mindMap.off("mouseup", this.onMouseup);
  }
  // 节点鼠标按下事件
  onNodeMousedown(node3, e2) {
    if (this.mindMap.opt.readonly || e2.which !== 1 || node3.isGeneralization || node3.isRoot) {
      return;
    }
    e2.preventDefault();
    this.isMousedown = true;
    this.mousedownNode = node3;
    const { x: x2, y: y3 } = this.mindMap.toPos(e2.clientX, e2.clientY);
    this.mouseDownX = x2;
    this.mouseDownY = y3;
  }
  // 鼠标移动事件
  onMousemove(e2) {
    if (this.mindMap.opt.readonly || !this.isMousedown) {
      return;
    }
    e2.preventDefault();
    const { x: x2, y: y3 } = this.mindMap.toPos(e2.clientX, e2.clientY);
    this.mouseMoveX = x2;
    this.mouseMoveY = y3;
    if (!this.isDragging && Math.abs(x2 - this.mouseDownX) <= this.checkDragOffset && Math.abs(y3 - this.mouseDownY) <= this.checkDragOffset) {
      return;
    }
    this.mindMap.emit("node_dragging", this.mousedownNode);
    this.handleStartMove();
    this.onMove(x2, y3, e2);
  }
  //  鼠标松开事件
  onMouseup(e2) {
    if (!this.isMousedown) {
      return;
    }
    this.isMousedown = false;
    this.beingDragNodeList.forEach((node3) => {
      node3.setOpacity(1);
      node3.showChildren();
      node3.endDrag();
    });
    this.removeCloneNode();
    let overlapNodeUid = this.overlapNode ? this.overlapNode.getData("uid") : "";
    let prevNodeUid = this.prevNode ? this.prevNode.getData("uid") : "";
    let nextNodeUid = this.nextNode ? this.nextNode.getData("uid") : "";
    if (this.overlapNode) {
      this.mindMap.execCommand("SET_NODE_ACTIVE", this.overlapNode, false);
      this.mindMap.execCommand(
        "MOVE_NODE_TO",
        this.beingDragNodeList,
        this.overlapNode
      );
    } else if (this.prevNode) {
      this.mindMap.execCommand("SET_NODE_ACTIVE", this.prevNode, false);
      this.mindMap.execCommand(
        "INSERT_AFTER",
        this.beingDragNodeList,
        this.prevNode
      );
    } else if (this.nextNode) {
      this.mindMap.execCommand("SET_NODE_ACTIVE", this.nextNode, false);
      this.mindMap.execCommand(
        "INSERT_BEFORE",
        this.beingDragNodeList,
        this.nextNode
      );
    } else if (this.clone && this.mindMap.opt.enableFreeDrag && this.beingDragNodeList.length === 1) {
      let { x: x2, y: y3 } = this.mindMap.toPos(
        e2.clientX - this.offsetX,
        e2.clientY - this.offsetY
      );
      let { scaleX, scaleY, translateX, translateY } = this.drawTransform;
      x2 = (x2 - translateX) / scaleX;
      y3 = (y3 - translateY) / scaleY;
      this.mousedownNode.left = x2;
      this.mousedownNode.top = y3;
      this.mousedownNode.customLeft = x2;
      this.mousedownNode.customTop = y3;
      this.mindMap.execCommand(
        "SET_NODE_CUSTOM_POSITION",
        this.mousedownNode,
        x2,
        y3
      );
      this.mindMap.render();
    }
    if (this.isDragging) {
      this.mindMap.emit("node_dragend", {
        overlapNodeUid,
        prevNodeUid,
        nextNodeUid
      });
    }
    this.reset();
  }
  //  拖动中
  onMove(x2, y3, e2) {
    if (!this.isMousedown) {
      return;
    }
    let { scaleX, scaleY, translateX, translateY } = this.drawTransform;
    let cloneNodeLeft = x2 - this.offsetX;
    let cloneNodeTop = y3 - this.offsetY;
    x2 = (cloneNodeLeft - translateX) / scaleX;
    y3 = (cloneNodeTop - translateY) / scaleY;
    let t2 = this.clone.transform();
    this.clone.translate(x2 - t2.translateX, y3 - t2.translateY);
    this.checkOverlapNode();
    if (this.mindMap.opt.autoMoveWhenMouseInEdgeOnDrag && this.mindMap.select) {
      this.drawTransform = this.mindMap.draw.transform();
      this.mindMap.select.clearAutoMoveTimer();
      this.mindMap.select.onMove(e2.clientX, e2.clientY);
    }
  }
  // 开始拖拽时初始化一些数据
  handleStartMove() {
    if (!this.isDragging) {
      this.isDragging = true;
      let node3 = this.mousedownNode;
      this.drawTransform = this.mindMap.draw.transform();
      let { scaleX, scaleY, translateX, translateY } = this.drawTransform;
      this.offsetX = this.mouseDownX - (node3.left * scaleX + translateX);
      this.offsetY = this.mouseDownY - (node3.top * scaleY + translateY);
      if (node3.getData("isActive")) {
        this.beingDragNodeList = getTopAncestorsFomNodeList(
          // 过滤掉根节点和概要节点
          this.mindMap.renderer.activeNodeList.filter((item) => {
            return !item.isRoot && !item.isGeneralization;
          })
        );
      } else {
        this.beingDragNodeList = [node3];
      }
      this.nodeTreeToList();
      this.createCloneNode();
      this.mindMap.execCommand("CLEAR_ACTIVE_NODE");
    }
  }
  // 节点由树转换成数组，从子节点到根节点
  nodeTreeToList() {
    const list2 = [];
    bfsWalk(this.mindMap.renderer.root, (node3) => {
      if (this.checkIsInBeingDragNodeList(node3)) {
        return;
      }
      if (!list2[node3.layerIndex]) {
        list2[node3.layerIndex] = [];
      }
      list2[node3.layerIndex].push(node3);
    });
    this.nodeList = list2.reduceRight((res, cur) => {
      return [...res, ...cur];
    }, []);
  }
  //  创建克隆节点
  createCloneNode() {
    if (!this.clone) {
      const {
        dragMultiNodeRectConfig,
        dragPlaceholderRectFill,
        dragOpacityConfig
      } = this.mindMap.opt;
      const {
        width: rectWidth,
        height: rectHeight,
        fill: rectFill
      } = dragMultiNodeRectConfig;
      const node3 = this.beingDragNodeList[0];
      const lineColor = node3.style.merge("lineColor", true);
      if (this.beingDragNodeList.length > 1) {
        this.clone = this.mindMap.otherDraw.rect().size(rectWidth, rectHeight).radius(rectHeight / 2).fill({
          color: rectFill || lineColor
        });
        this.offsetX = rectWidth / 2;
        this.offsetY = rectHeight / 2;
      } else {
        this.clone = node3.group.clone();
        const expandEl = this.clone.findOne(".smm-expand-btn");
        if (expandEl) {
          expandEl.remove();
        }
        this.mindMap.otherDraw.add(this.clone);
      }
      this.clone.opacity(dragOpacityConfig.cloneNodeOpacity);
      this.clone.css("z-index", 99999);
      this.placeholder = this.mindMap.otherDraw.rect().fill({
        color: dragPlaceholderRectFill || lineColor
      });
      this.beingDragNodeList.forEach((node4) => {
        node4.setOpacity(dragOpacityConfig.beingDragNodeOpacity);
        node4.hideChildren();
        node4.startDrag();
      });
    }
  }
  //  移除克隆节点
  removeCloneNode() {
    if (!this.clone) {
      return;
    }
    this.clone.remove();
    this.placeholder.remove();
  }
  //  检测重叠节点
  checkOverlapNode() {
    if (!this.drawTransform || !this.placeholder) {
      return;
    }
    this.overlapNode = null;
    this.prevNode = null;
    this.nextNode = null;
    this.placeholder.size(0, 0);
    this.nodeList.forEach((node3) => {
      if (node3.getData("isActive")) {
        this.mindMap.execCommand("SET_NODE_ACTIVE", node3, false);
      }
      if (this.overlapNode || this.prevNode && this.nextNode) {
        return;
      }
      switch (this.mindMap.opt.layout) {
        case "logicalStructure":
          this.handleLogicalStructure(node3);
          break;
        case "mindMap":
          this.handleMindMap(node3);
          break;
        case "organizationStructure":
          this.handleOrganizationStructure(node3);
          break;
        case "catalogOrganization":
          this.handleCatalogOrganization(node3);
          break;
        case "timeline":
          this.handleTimeLine(node3);
          break;
        case "timeline2":
          this.handleTimeLine2(node3);
          break;
        case "verticalTimeline":
          this.handleLogicalStructure(node3);
          break;
        case "fishbone":
          this.handleFishbone(node3);
          break;
        default:
          this.handleLogicalStructure(node3);
      }
    });
    if (this.overlapNode) {
      this.mindMap.execCommand("SET_NODE_ACTIVE", this.overlapNode, true);
    }
  }
  // 垂直方向比较
  // isReverse：是否反向
  handleVerticalCheck(node3, checkList, isReverse = false) {
    let x2 = this.mouseMoveX;
    let y3 = this.mouseMoveY;
    let nodeRect = this.getNodeRect(node3);
    if (isReverse) {
      checkList = checkList.reverse();
    }
    let oneFourthHeight = nodeRect.height / 4;
    let { prevBrotherOffset, nextBrotherOffset } = this.getNodeDistanceToSiblingNode(checkList, node3, nodeRect, "v");
    if (nodeRect.left <= x2 && nodeRect.right >= x2) {
      if (!this.overlapNode && !this.prevNode && !this.nextNode && !node3.isRoot) {
        let checkIsPrevNode = nextBrotherOffset > 0 ? y3 > nodeRect.bottom && y3 <= nodeRect.bottom + nextBrotherOffset : y3 >= nodeRect.bottom - oneFourthHeight && y3 <= nodeRect.bottom;
        let checkIsNextNode = prevBrotherOffset > 0 ? y3 < nodeRect.top && y3 >= nodeRect.top - prevBrotherOffset : y3 >= nodeRect.top && y3 <= nodeRect.top + oneFourthHeight;
        if (checkIsPrevNode) {
          if (isReverse) {
            this.nextNode = node3;
          } else {
            this.prevNode = node3;
          }
          let size2 = this.formatPlaceholderSize(nextBrotherOffset);
          this.setPlaceholderRect(
            node3.width,
            size2,
            nodeRect.originLeft,
            nodeRect.originBottom
          );
        } else if (checkIsNextNode) {
          if (isReverse) {
            this.prevNode = node3;
          } else {
            this.nextNode = node3;
          }
          let size2 = this.formatPlaceholderSize(prevBrotherOffset);
          this.setPlaceholderRect(
            node3.width,
            size2,
            nodeRect.originLeft,
            nodeRect.originTop - size2
          );
        }
      }
      this.checkIsOverlap({
        node: node3,
        dir: "v",
        prevBrotherOffset,
        nextBrotherOffset,
        size: oneFourthHeight,
        pos: y3,
        nodeRect
      });
    }
  }
  // 水平方向比较
  handleHorizontalCheck(node3, checkList) {
    let x2 = this.mouseMoveX;
    let y3 = this.mouseMoveY;
    let nodeRect = this.getNodeRect(node3);
    let oneFourthWidth = nodeRect.width / 4;
    let { prevBrotherOffset, nextBrotherOffset } = this.getNodeDistanceToSiblingNode(checkList, node3, nodeRect, "h");
    if (nodeRect.top <= y3 && nodeRect.bottom >= y3) {
      if (!this.overlapNode && !this.prevNode && !this.nextNode && !node3.isRoot) {
        let checkIsPrevNode = nextBrotherOffset > 0 ? x2 < nodeRect.right + nextBrotherOffset && x2 >= nodeRect.right : x2 <= nodeRect.right && x2 >= nodeRect.right - oneFourthWidth;
        let checkIsNextNode = prevBrotherOffset > 0 ? x2 > nodeRect.left - prevBrotherOffset && x2 <= nodeRect.left : x2 <= nodeRect.left + oneFourthWidth && x2 >= nodeRect.left;
        if (checkIsPrevNode) {
          this.prevNode = node3;
          let size2 = this.formatPlaceholderSize(nextBrotherOffset);
          this.setPlaceholderRect(
            size2,
            node3.height,
            nodeRect.originRight,
            nodeRect.originTop
          );
        } else if (checkIsNextNode) {
          this.nextNode = node3;
          let size2 = this.formatPlaceholderSize(prevBrotherOffset);
          this.setPlaceholderRect(
            size2,
            node3.height,
            nodeRect.originLeft - size2,
            nodeRect.originTop
          );
        }
      }
      this.checkIsOverlap({
        node: node3,
        dir: "h",
        prevBrotherOffset,
        nextBrotherOffset,
        size: oneFourthWidth,
        pos: x2,
        nodeRect
      });
    }
  }
  // 获取节点距前一个和后一个节点的距离
  getNodeDistanceToSiblingNode(checkList, node3, nodeRect, dir) {
    let dir1 = dir === "v" ? "top" : "left";
    let dir2 = dir === "v" ? "bottom" : "right";
    let index3 = getNodeIndexInNodeList(node3, checkList);
    let prevBrother = null;
    let nextBrother = null;
    if (index3 !== -1) {
      if (index3 - 1 >= 0) {
        prevBrother = checkList[index3 - 1];
      }
      if (index3 + 1 <= checkList.length - 1) {
        nextBrother = checkList[index3 + 1];
      }
    }
    let prevBrotherOffset = 0;
    if (prevBrother) {
      let prevNodeRect = this.getNodeRect(prevBrother);
      prevBrotherOffset = nodeRect[dir1] - prevNodeRect[dir2];
      prevBrotherOffset = prevBrotherOffset >= this.minOffset ? prevBrotherOffset / 2 : 0;
    } else {
      prevBrotherOffset = this.minOffset;
    }
    let nextBrotherOffset = 0;
    if (nextBrother) {
      let nextNodeRect = this.getNodeRect(nextBrother);
      nextBrotherOffset = nextNodeRect[dir1] - nodeRect[dir2];
      nextBrotherOffset = nextBrotherOffset >= this.minOffset ? nextBrotherOffset / 2 : 0;
    } else {
      nextBrotherOffset = this.minOffset;
    }
    return {
      prevBrotherOffset,
      nextBrotherOffset
    };
  }
  // 处理提示元素的大小
  formatPlaceholderSize(size2) {
    const { nodeDragPlaceholderMaxSize } = this.mindMap.opt;
    return size2 > 0 ? Math.min(size2, nodeDragPlaceholderMaxSize) : 5;
  }
  // 设置提示元素的大小和位置
  setPlaceholderRect(w, h2, x2, y3) {
    this.placeholder.size(w, h2).move(x2, y3);
  }
  // 检测是否重叠
  checkIsOverlap({
    node: node3,
    dir,
    prevBrotherOffset,
    nextBrotherOffset,
    size: size2,
    pos,
    nodeRect
  }) {
    let dir1 = dir === "v" ? "top" : "left";
    let dir2 = dir === "v" ? "bottom" : "right";
    if (!this.overlapNode && !this.prevNode && !this.nextNode) {
      if (nodeRect[dir1] + (prevBrotherOffset > 0 ? 0 : size2) <= pos && nodeRect[dir2] - (nextBrotherOffset > 0 ? 0 : size2) >= pos) {
        this.overlapNode = node3;
      }
    }
  }
  // 处理逻辑结构图
  handleLogicalStructure(node3) {
    const checkList = this.commonGetNodeCheckList(node3);
    this.handleVerticalCheck(node3, checkList);
  }
  // 处理思维导图
  handleMindMap(node3) {
    const checkList = node3.parent ? node3.parent.children.filter((item) => {
      let sameDir = true;
      if (node3.layerIndex === 1) {
        sameDir = item.dir === node3.dir;
      }
      return sameDir && !this.checkIsInBeingDragNodeList(item);
    }) : [];
    this.handleVerticalCheck(node3, checkList);
  }
  // 处理组织结构图
  handleOrganizationStructure(node3) {
    const checkList = this.commonGetNodeCheckList(node3);
    this.handleHorizontalCheck(node3, checkList);
  }
  // 处理目录组织图
  handleCatalogOrganization(node3) {
    const checkList = this.commonGetNodeCheckList(node3);
    if (node3.layerIndex === 1) {
      this.handleHorizontalCheck(node3, checkList);
    } else {
      this.handleVerticalCheck(node3, checkList);
    }
  }
  // 处理时间轴
  handleTimeLine(node3) {
    let checkList = this.commonGetNodeCheckList(node3);
    if (node3.layerIndex === 1) {
      this.handleHorizontalCheck(node3, checkList);
    } else {
      this.handleVerticalCheck(node3, checkList);
    }
  }
  // 处理时间轴2
  handleTimeLine2(node3) {
    let checkList = this.commonGetNodeCheckList(node3);
    if (node3.layerIndex === 1) {
      this.handleHorizontalCheck(node3, checkList);
    } else {
      if (node3.dir === "top" && node3.layerIndex === 2) {
        this.handleVerticalCheck(node3, checkList, true);
      } else {
        this.handleVerticalCheck(node3, checkList);
      }
    }
  }
  // 处理鱼骨图
  handleFishbone(node3) {
    let checkList = node3.parent ? node3.parent.children.filter((item) => {
      return item.layerIndex > 1 && !this.checkIsInBeingDragNodeList(item);
    }) : [];
    if (node3.layerIndex === 1) {
      this.handleHorizontalCheck(node3, checkList);
    } else {
      if (node3.dir === "top" && node3.layerIndex === 2) {
        this.handleVerticalCheck(node3, checkList, true);
      } else {
        this.handleVerticalCheck(node3, checkList);
      }
    }
  }
  // 获取节点的兄弟节点列表通用方法
  commonGetNodeCheckList(node3) {
    return node3.parent ? [...node3.parent.children].filter((item) => {
      return !this.checkIsInBeingDragNodeList(item);
    }) : [];
  }
  // 计算节点的位置尺寸信息
  getNodeRect(node3) {
    let { scaleX, scaleY, translateX, translateY } = this.drawTransform;
    let { left, top, width: width2, height: height2 } = node3;
    let originLeft = left;
    let originTop = top;
    let originBottom = top + height2;
    let originRight = left + width2;
    let right = (left + width2) * scaleX + translateX;
    let bottom = (top + height2) * scaleY + translateY;
    left = left * scaleX + translateX;
    top = top * scaleY + translateY;
    return {
      width: width2,
      height: height2,
      left,
      top,
      right,
      bottom,
      originLeft,
      originTop,
      originBottom,
      originRight
    };
  }
  // 检查某个节点是否在被拖拽节点内
  checkIsInBeingDragNodeList(node3) {
    return !!this.beingDragNodeList.find((item) => {
      return item.uid === node3.uid || item.isAncestor(node3);
    });
  }
  // 插件被移除前做的事情
  beforePluginRemove() {
    this.unBindEvent();
  }
  // 插件被卸载前做的事情
  beforePluginDestroy() {
    this.unBindEvent();
  }
};
Drag.instanceName = "drag";
var Drag_default = Drag;

// ../simple-mind-map/src/plugins/Select.js
var Select = class {
  //  构造函数
  constructor({ mindMap }) {
    this.mindMap = mindMap;
    this.rect = null;
    this.isMousedown = false;
    this.mouseDownX = 0;
    this.mouseDownY = 0;
    this.mouseMoveX = 0;
    this.mouseMoveY = 0;
    this.isSelecting = false;
    this.cacheActiveList = [];
    this.bindEvent();
  }
  //  绑定事件
  bindEvent() {
    this.onMousedown = this.onMousedown.bind(this);
    this.onMousemove = this.onMousemove.bind(this);
    this.onMouseup = this.onMouseup.bind(this);
    this.checkInNodes = throttle(this.checkInNodes, 300, this);
    this.mindMap.on("mousedown", this.onMousedown);
    this.mindMap.on("mousemove", this.onMousemove);
    this.mindMap.on("mouseup", this.onMouseup);
    this.mindMap.on("node_mouseup", this.onMouseup);
  }
  // 解绑事件
  unBindEvent() {
    this.mindMap.off("mousedown", this.onMousedown);
    this.mindMap.off("mousemove", this.onMousemove);
    this.mindMap.off("mouseup", this.onMouseup);
    this.mindMap.off("node_mouseup", this.onMouseup);
  }
  // 鼠标按下
  onMousedown(e2) {
    if (this.mindMap.opt.readonly) {
      return;
    }
    let { useLeftKeySelectionRightKeyDrag } = this.mindMap.opt;
    if (!e2.ctrlKey && (useLeftKeySelectionRightKeyDrag ? e2.which !== 1 : e2.which !== 3)) {
      return;
    }
    e2.preventDefault();
    this.isMousedown = true;
    this.cacheActiveList = [...this.mindMap.renderer.activeNodeList];
    let { x: x2, y: y3 } = this.mindMap.toPos(e2.clientX, e2.clientY);
    this.mouseDownX = x2;
    this.mouseDownY = y3;
    this.createRect(x2, y3);
  }
  // 鼠标移动
  onMousemove(e2) {
    if (this.mindMap.opt.readonly) {
      return;
    }
    if (!this.isMousedown) {
      return;
    }
    let { x: x2, y: y3 } = this.mindMap.toPos(e2.clientX, e2.clientY);
    this.mouseMoveX = x2;
    this.mouseMoveY = y3;
    if (Math.abs(x2 - this.mouseDownX) <= 10 && Math.abs(y3 - this.mouseDownY) <= 10) {
      return;
    }
    this.clearAutoMoveTimer();
    this.onMove(
      e2.clientX,
      e2.clientY,
      () => {
        this.isSelecting = true;
        this.rect.plot([
          [this.mouseDownX, this.mouseDownY],
          [this.mouseMoveX, this.mouseDownY],
          [this.mouseMoveX, this.mouseMoveY],
          [this.mouseDownX, this.mouseMoveY]
        ]);
        this.checkInNodes();
      },
      (dir, step) => {
        switch (dir) {
          case "left":
            this.mouseDownX += step;
            break;
          case "top":
            this.mouseDownY += step;
            break;
          case "right":
            this.mouseDownX -= step;
            break;
          case "bottom":
            this.mouseDownY -= step;
            break;
          default:
            break;
        }
      }
    );
  }
  // 结束框选
  onMouseup() {
    if (this.mindMap.opt.readonly) {
      return;
    }
    if (!this.isMousedown) {
      return;
    }
    this.checkTriggerNodeActiveEvent();
    clearTimeout(this.autoMoveTimer);
    this.isMousedown = false;
    this.cacheActiveList = [];
    if (this.rect)
      this.rect.remove();
    this.rect = null;
    setTimeout(() => {
      this.isSelecting = false;
    }, 0);
  }
  // 如果激活节点改变了，那么触发事件
  checkTriggerNodeActiveEvent() {
    let isNumChange = this.cacheActiveList.length !== this.mindMap.renderer.activeNodeList.length;
    let isNodeChange = false;
    if (!isNumChange) {
      for (let i2 = 0; i2 < this.cacheActiveList.length; i2++) {
        let cur = this.cacheActiveList[i2];
        if (!this.mindMap.renderer.activeNodeList.find((item) => {
          return item.getData("uid") === cur.getData("uid");
        })) {
          isNodeChange = true;
          break;
        }
      }
    }
    if (isNumChange || isNodeChange) {
      this.mindMap.renderer.emitNodeActiveEvent();
    }
  }
  //  鼠标移动事件
  onMove(x2, y3, callback = () => {
  }, handle = () => {
  }) {
    callback();
    let step = this.mindMap.opt.selectTranslateStep;
    let limit = this.mindMap.opt.selectTranslateLimit;
    let count = 0;
    if (x2 <= this.mindMap.elRect.left + limit) {
      handle("left", step);
      this.mindMap.view.translateX(step);
      count++;
    }
    if (x2 >= this.mindMap.elRect.right - limit) {
      handle("right", step);
      this.mindMap.view.translateX(-step);
      count++;
    }
    if (y3 <= this.mindMap.elRect.top + limit) {
      handle("top", step);
      this.mindMap.view.translateY(step);
      count++;
    }
    if (y3 >= this.mindMap.elRect.bottom - limit) {
      handle("bottom", step);
      this.mindMap.view.translateY(-step);
      count++;
    }
    if (count > 0) {
      this.startAutoMove(x2, y3, callback, handle);
    }
  }
  //  开启自动移动
  startAutoMove(x2, y3, callback, handle) {
    this.autoMoveTimer = setTimeout(() => {
      this.onMove(x2, y3, callback, handle);
    }, 20);
  }
  // 清除自动移动定时器
  clearAutoMoveTimer() {
    clearTimeout(this.autoMoveTimer);
  }
  //  创建矩形
  createRect(x2, y3) {
    if (this.rect)
      this.rect.remove();
    this.rect = this.mindMap.svg.polygon().stroke({
      color: "#0984e3"
    }).fill({
      color: "rgba(9,132,227,0.3)"
    }).plot([[x2, y3]]);
  }
  //  检测在选区里的节点
  checkInNodes() {
    let { scaleX, scaleY, translateX, translateY } = this.mindMap.draw.transform();
    let minx = Math.min(this.mouseDownX, this.mouseMoveX);
    let miny = Math.min(this.mouseDownY, this.mouseMoveY);
    let maxx = Math.max(this.mouseDownX, this.mouseMoveX);
    let maxy = Math.max(this.mouseDownY, this.mouseMoveY);
    bfsWalk(this.mindMap.renderer.root, (node3) => {
      let { left, top, width: width2, height: height2 } = node3;
      let right = (left + width2) * scaleX + translateX;
      let bottom = (top + height2) * scaleY + translateY;
      left = left * scaleX + translateX;
      top = top * scaleY + translateY;
      if (checkTwoRectIsOverlap(minx, maxx, miny, maxy, left, right, top, bottom)) {
        if (node3.getData("isActive")) {
          return;
        }
        this.mindMap.renderer.addNodeToActiveList(node3);
      } else if (node3.getData("isActive")) {
        if (!node3.getData("isActive")) {
          return;
        }
        this.mindMap.renderer.removeNodeFromActiveList(node3);
      }
    });
  }
  // 是否存在选区
  hasSelectRange() {
    return this.isSelecting;
  }
  // 插件被移除前做的事情
  beforePluginRemove() {
    this.unBindEvent();
  }
  // 插件被卸载前做的事情
  beforePluginDestroy() {
    this.unBindEvent();
  }
};
Select.instanceName = "select";
var Select_default = Select;

// ../simple-mind-map/src/plugins/associativeLine/associativeLineUtils.js
var getAssociativeLineTargetIndex = (node3, toNode3) => {
  return node3.getData("associativeLineTargets").findIndex((item) => {
    return item === toNode3.getData("uid");
  });
};
var computeCubicBezierPathPoints = (x1, y1, x2, y22) => {
  let cx1 = x1 + (x2 - x1) / 2;
  let cy1 = y1;
  let cx2 = cx1;
  let cy2 = y22;
  if (Math.abs(x1 - x2) <= 5) {
    cx1 = x1 + (y22 - y1) / 2;
    cx2 = cx1;
  }
  return [
    {
      x: cx1,
      y: cy1
    },
    {
      x: cx2,
      y: cy2
    }
  ];
};
var joinCubicBezierPath = (startPoint, endPoint, point1, point22) => {
  return `M ${startPoint.x},${startPoint.y} C ${point1.x},${point1.y} ${point22.x},${point22.y} ${endPoint.x},${endPoint.y}`;
};
var getNodeRect = (node3) => {
  let { left, top, width: width2, height: height2 } = node3;
  return {
    right: left + width2,
    bottom: top + height2,
    left,
    top
  };
};
var cubicBezierPath = (x1, y1, x2, y22) => {
  let points = computeCubicBezierPathPoints(x1, y1, x2, y22);
  return joinCubicBezierPath(
    { x: x1, y: y1 },
    { x: x2, y: y22 },
    points[0],
    points[1]
  );
};
var calcPoint = (node3, e2) => {
  const { left, top, translateLeft, translateTop, width: width2, height: height2 } = node3;
  const clientX = e2.clientX;
  const clientY = e2.clientY;
  const centerX = translateLeft + width2 / 2;
  const centerY = translateTop + height2 / 2;
  const translateCenterX = left + width2 / 2;
  const translateCenterY = top + height2 / 2;
  const theta = Math.atan(height2 / width2);
  const deltaX = clientX - centerX;
  const deltaY = centerY - clientY;
  const direction = Math.atan2(deltaY, deltaX);
  let x2 = left + width2;
  let y3 = top + height2;
  if (direction < theta && direction >= -theta) {
    const range2 = direction * (width2 / 2);
    if (direction < theta && direction >= 0) {
      y3 = translateCenterY - range2;
    } else if (direction >= -theta && direction < 0) {
      y3 = translateCenterY - range2;
    }
    return {
      x: x2,
      y: y3,
      dir: "right",
      range: range2
    };
  } else if (direction >= theta && direction < Math.PI - theta) {
    y3 = top;
    let range2 = 0;
    if (direction < Math.PI / 2 - theta && direction >= theta) {
      const side = height2 / 2 / direction;
      range2 = -side;
      x2 = translateCenterX + side;
    } else if (direction >= Math.PI / 2 - theta && direction < Math.PI - theta) {
      const tanValue2 = (centerX - clientX) / (centerY - clientY);
      const side = height2 / 2 * tanValue2;
      range2 = side;
      x2 = translateCenterX - side;
    }
    return {
      x: x2,
      y: y3,
      dir: "top",
      range: range2
    };
  } else if (direction < -theta && direction >= theta - Math.PI) {
    let range2 = 0;
    if (direction >= theta - Math.PI / 2 && direction < -theta) {
      const side = height2 / 2 / direction;
      range2 = side;
      x2 = translateCenterX - side;
    } else if (direction < theta - Math.PI / 2 && direction >= theta - Math.PI) {
      const tanValue2 = (centerX - clientX) / (centerY - clientY);
      const side = height2 / 2 * tanValue2;
      range2 = -side;
      x2 = translateCenterX + side;
    }
    return {
      x: x2,
      y: y3,
      dir: "bottom",
      range: range2
    };
  }
  x2 = left;
  const tanValue = (centerY - clientY) / (centerX - clientX);
  const range = tanValue * (width2 / 2);
  if (direction >= -Math.PI && direction < theta - Math.PI) {
    y3 = translateCenterY - range;
  } else if (direction < Math.PI && direction >= Math.PI - theta) {
    y3 = translateCenterY - range;
  }
  return {
    x: x2,
    y: y3,
    dir: "left",
    range
  };
};
var getNodePoint = (node3, dir = "right", range = 0, e2 = null) => {
  let { left, top, width: width2, height: height2 } = node3;
  if (e2) {
    return calcPoint(node3, e2);
  }
  switch (dir) {
    case "left":
      return {
        x: left,
        y: top + height2 / 2 - range
      };
    case "right":
      return {
        x: left + width2,
        y: top + height2 / 2 - range
      };
    case "top":
      return {
        x: left + width2 / 2 - range,
        y: top
      };
    case "bottom":
      return {
        x: left + width2 / 2 - range,
        y: top + height2
      };
    default:
      break;
  }
};
var computeNodePoints = (fromNode, toNode3) => {
  let fromRect = getNodeRect(fromNode);
  let fromCx = (fromRect.right + fromRect.left) / 2;
  let fromCy = (fromRect.bottom + fromRect.top) / 2;
  let toRect = getNodeRect(toNode3);
  let toCx = (toRect.right + toRect.left) / 2;
  let toCy = (toRect.bottom + toRect.top) / 2;
  let offsetX = toCx - fromCx;
  let offsetY = toCy - fromCy;
  if (offsetX === 0 && offsetY === 0)
    return [];
  let fromDir = "";
  let toDir = "";
  if (offsetX <= 0 && offsetX <= offsetY && offsetX <= -offsetY) {
    fromDir = "left";
    toDir = "right";
  } else if (offsetX > 0 && offsetX >= -offsetY && offsetX >= offsetY) {
    fromDir = "right";
    toDir = "left";
  } else if (offsetY <= 0 && offsetY < offsetX && offsetY < -offsetX) {
    fromDir = "top";
    toDir = "bottom";
  } else if (offsetY > 0 && -offsetY < offsetX && offsetY > offsetX) {
    fromDir = "right";
    toDir = "right";
  }
  return [getNodePoint(fromNode, fromDir), getNodePoint(toNode3, toDir)];
};
var getNodeLinePath = (startPoint, endPoint, node3, toNode3) => {
  let targetIndex = getAssociativeLineTargetIndex(node3, toNode3);
  let controlPoints = [];
  let associativeLineTargetControlOffsets = node3.getData("associativeLineTargetControlOffsets");
  if (associativeLineTargetControlOffsets && associativeLineTargetControlOffsets[targetIndex]) {
    let offsets = associativeLineTargetControlOffsets[targetIndex];
    controlPoints = [
      {
        x: startPoint.x + offsets[0].x,
        y: startPoint.y + offsets[0].y
      },
      {
        x: endPoint.x + offsets[1].x,
        y: endPoint.y + offsets[1].y
      }
    ];
  } else {
    controlPoints = computeCubicBezierPathPoints(
      startPoint.x,
      startPoint.y,
      endPoint.x,
      endPoint.y
    );
  }
  return {
    path: joinCubicBezierPath(
      startPoint,
      endPoint,
      controlPoints[0],
      controlPoints[1]
    ),
    controlPoints
  };
};
var getDefaultControlPointOffsets = (startPoint, endPoint) => {
  let controlPoints = computeCubicBezierPathPoints(
    startPoint.x,
    startPoint.y,
    endPoint.x,
    endPoint.y
  );
  return [
    {
      x: controlPoints[0].x - startPoint.x,
      y: controlPoints[0].y - startPoint.y
    },
    {
      x: controlPoints[1].x - endPoint.x,
      y: controlPoints[1].y - endPoint.y
    }
  ];
};

// ../simple-mind-map/src/plugins/associativeLine/associativeLineControls.js
function createControlNodes() {
  let { associativeLineActiveColor } = this.mindMap.themeConfig;
  this.controlLine1 = this.associativeLineDraw.line().stroke({ color: associativeLineActiveColor, width: 2 });
  this.controlLine2 = this.associativeLineDraw.line().stroke({ color: associativeLineActiveColor, width: 2 });
  this.controlPoint1 = this.createOneControlNode("controlPoint1");
  this.controlPoint2 = this.createOneControlNode("controlPoint2");
}
function createOneControlNode(pointKey) {
  let { associativeLineActiveColor } = this.mindMap.themeConfig;
  return this.associativeLineDraw.circle(this.controlPointDiameter).stroke({ color: associativeLineActiveColor }).fill({ color: "#fff" }).click((e2) => {
    e2.stopPropagation();
  }).mousedown((e2) => {
    this.onControlPointMousedown(e2, pointKey);
  });
}
function onControlPointMousedown(e2, pointKey) {
  e2.stopPropagation();
  this.isControlPointMousedown = true;
  this.mousedownControlPointKey = pointKey;
}
function onControlPointMousemove(e2) {
  if (!this.isControlPointMousedown || !this.mousedownControlPointKey || !this[this.mousedownControlPointKey])
    return;
  e2.stopPropagation();
  e2.preventDefault();
  let radius = this.controlPointDiameter / 2;
  let { x: x2, y: y3 } = this.getTransformedEventPos(e2);
  this.controlPointMousemoveState.pos = {
    x: x2,
    y: y3
  };
  this[this.mousedownControlPointKey].x(x2 - radius).y(y3 - radius);
  let [, , , node3, toNode3] = this.activeLine;
  let targetIndex = getAssociativeLineTargetIndex(node3, toNode3);
  let { associativeLinePoint, associativeLineTargetControlOffsets } = node3.getData();
  associativeLinePoint = associativeLinePoint || [];
  const nodePos = this.getNodePos(node3);
  const toNodePos = this.getNodePos(toNode3);
  let [startPoint, endPoint] = this.updateAllLinesPos(
    node3,
    toNode3,
    associativeLinePoint[targetIndex]
  );
  this.controlPointMousemoveState.startPoint = startPoint;
  this.controlPointMousemoveState.endPoint = endPoint;
  this.controlPointMousemoveState.targetIndex = targetIndex;
  let offsets = [];
  if (!associativeLineTargetControlOffsets) {
    offsets = getDefaultControlPointOffsets(startPoint, endPoint);
  } else {
    offsets = associativeLineTargetControlOffsets[targetIndex];
  }
  let point1 = null;
  let point22 = null;
  const { x: clientX, y: clientY } = this.mindMap.toPos(e2.clientX, e2.clientY);
  const _e = {
    clientX,
    clientY
  };
  if (this.mousedownControlPointKey === "controlPoint1") {
    startPoint = getNodePoint(nodePos, "", 0, _e);
    point1 = {
      x: x2,
      y: y3
    };
    point22 = {
      x: endPoint.x + offsets[1].x,
      y: endPoint.y + offsets[1].y
    };
    if (startPoint) {
      this.controlPointMousemoveState.startPoint = startPoint;
      this.controlLine1.plot(startPoint.x, startPoint.y, point1.x, point1.y);
    }
  } else {
    endPoint = getNodePoint(toNodePos, "", 0, _e);
    point1 = {
      x: startPoint.x + offsets[0].x,
      y: startPoint.y + offsets[0].y
    };
    point22 = {
      x: x2,
      y: y3
    };
    if (endPoint) {
      this.controlPointMousemoveState.endPoint = endPoint;
      this.controlLine2.plot(endPoint.x, endPoint.y, point22.x, point22.y);
    }
  }
  this.updataAassociativeLine(
    startPoint,
    endPoint,
    point1,
    point22,
    this.activeLine
  );
}
function updataAassociativeLine(startPoint, endPoint, point1, point22, activeLine) {
  const [path2, clickPath, text4] = activeLine;
  const pathStr = joinCubicBezierPath(startPoint, endPoint, point1, point22);
  path2.plot(pathStr);
  clickPath.plot(pathStr);
  this.updateTextPos(path2, text4);
  this.updateTextEditBoxPos(text4);
}
function onControlPointMouseup(e2) {
  if (!this.isControlPointMousedown)
    return;
  e2.stopPropagation();
  e2.preventDefault();
  let { pos, startPoint, endPoint, targetIndex } = this.controlPointMousemoveState;
  let [, , , node3] = this.activeLine;
  let offsetList = [];
  let { associativeLinePoint, associativeLineTargetControlOffsets } = node3.getData();
  if (!associativeLinePoint) {
    associativeLinePoint = [];
  }
  associativeLinePoint[targetIndex] = associativeLinePoint[targetIndex] || {
    startPoint,
    endPoint
  };
  if (!associativeLineTargetControlOffsets) {
    offsetList[targetIndex] = getDefaultControlPointOffsets(
      startPoint,
      endPoint
    );
  } else {
    offsetList = associativeLineTargetControlOffsets;
  }
  let offset1 = null;
  let offset2 = null;
  if (this.mousedownControlPointKey === "controlPoint1") {
    offset1 = {
      x: pos.x - startPoint.x,
      y: pos.y - startPoint.y
    };
    offset2 = offsetList[targetIndex][1];
    associativeLinePoint[targetIndex].startPoint = startPoint;
  } else {
    offset1 = offsetList[targetIndex][0];
    offset2 = {
      x: pos.x - endPoint.x,
      y: pos.y - endPoint.y
    };
    associativeLinePoint[targetIndex].endPoint = endPoint;
  }
  offsetList[targetIndex] = [offset1, offset2];
  this.mindMap.execCommand("SET_NODE_DATA", node3, {
    associativeLineTargetControlOffsets: offsetList,
    associativeLinePoint
  });
  setTimeout(() => {
    this.resetControlPoint();
  }, 0);
}
function resetControlPoint() {
  this.isControlPointMousedown = false;
  this.mousedownControlPointKey = "";
  this.controlPointMousemoveState = {
    pos: null,
    startPoint: null,
    endPoint: null,
    targetIndex: ""
  };
}
function renderControls(startPoint, endPoint, point1, point22) {
  if (!this.controlLine1) {
    this.createControlNodes();
  }
  let radius = this.controlPointDiameter / 2;
  this.controlLine1.plot(startPoint.x, startPoint.y, point1.x, point1.y);
  this.controlLine2.plot(endPoint.x, endPoint.y, point22.x, point22.y);
  this.controlPoint1.x(point1.x - radius).y(point1.y - radius);
  this.controlPoint2.x(point22.x - radius).y(point22.y - radius);
}
function removeControls() {
  if (!this.controlLine1)
    return;
  [
    this.controlLine1,
    this.controlLine2,
    this.controlPoint1,
    this.controlPoint2
  ].forEach((item) => {
    item.remove();
  });
  this.controlLine1 = null;
  this.controlLine2 = null;
  this.controlPoint1 = null;
  this.controlPoint2 = null;
}
function hideControls() {
  if (!this.controlLine1)
    return;
  [
    this.controlLine1,
    this.controlLine2,
    this.controlPoint1,
    this.controlPoint2
  ].forEach((item) => {
    item.hide();
  });
}
function showControls() {
  if (!this.controlLine1)
    return;
  [
    this.controlLine1,
    this.controlLine2,
    this.controlPoint1,
    this.controlPoint2
  ].forEach((item) => {
    item.show();
  });
}
var associativeLineControls_default = {
  createControlNodes,
  createOneControlNode,
  onControlPointMousedown,
  onControlPointMousemove,
  onControlPointMouseup,
  resetControlPoint,
  renderControls,
  removeControls,
  hideControls,
  showControls,
  updataAassociativeLine
};

// ../simple-mind-map/src/plugins/associativeLine/associativeLineText.js
function createText(data2) {
  let g = this.associativeLineDraw.group();
  const setActive = () => {
    if (!this.activeLine || this.activeLine[3] !== data2.node || this.activeLine[4] !== data2.toNode) {
      this.setActiveLine({
        ...data2,
        text: g
      });
    }
  };
  g.click((e2) => {
    e2.stopPropagation();
    setActive();
  });
  g.on("dblclick", (e2) => {
    e2.stopPropagation();
    setActive();
    if (!this.activeLine)
      return;
    this.showEditTextBox(g);
  });
  return g;
}
function showEditTextBox(g) {
  this.mindMap.emit("before_show_text_edit");
  this.mindMap.keyCommand.addShortcut("Enter", () => {
    this.hideEditTextBox();
  });
  if (!this.textEditNode) {
    this.textEditNode = document.createElement("div");
    this.textEditNode.style.cssText = `position:fixed;box-sizing: border-box;background-color:#fff;box-shadow: 0 0 20px rgba(0,0,0,.5);padding: 3px 5px;margin-left: -5px;margin-top: -3px;outline: none; word-break: break-all;`;
    this.textEditNode.setAttribute("contenteditable", true);
    this.textEditNode.addEventListener("keyup", (e2) => {
      e2.stopPropagation();
    });
    this.textEditNode.addEventListener("click", (e2) => {
      e2.stopPropagation();
    });
    const targetNode = this.mindMap.opt.customInnerElsAppendTo || document.body;
    targetNode.appendChild(this.textEditNode);
  }
  let {
    associativeLineTextFontSize,
    associativeLineTextFontFamily,
    associativeLineTextLineHeight
  } = this.mindMap.themeConfig;
  let { defaultAssociativeLineText, nodeTextEditZIndex } = this.mindMap.opt;
  let scale3 = this.mindMap.view.scale;
  let [, , , node3, toNode3] = this.activeLine;
  let text4 = this.getText(node3, toNode3);
  let textLines = (text4 || defaultAssociativeLineText).split(/\n/gim);
  this.textEditNode.style.fontFamily = associativeLineTextFontFamily;
  this.textEditNode.style.fontSize = associativeLineTextFontSize * scale3 + "px";
  this.textEditNode.style.lineHeight = textLines.length > 1 ? associativeLineTextLineHeight : "normal";
  this.textEditNode.style.zIndex = nodeTextEditZIndex;
  this.textEditNode.innerHTML = textLines.join("<br>");
  this.textEditNode.style.display = "block";
  this.updateTextEditBoxPos(g);
  this.showTextEdit = true;
  if (text4 === "" || text4 === defaultAssociativeLineText) {
    selectAllInput(this.textEditNode);
  } else {
    focusInput(this.textEditNode);
  }
}
function onScale() {
  this.hideEditTextBox();
}
function updateTextEditBoxPos(g) {
  let rect = g.node.getBoundingClientRect();
  if (this.textEditNode) {
    this.textEditNode.style.minWidth = `${rect.width + 10}px`;
    this.textEditNode.style.minHeight = `${rect.height + 6}px`;
    this.textEditNode.style.left = `${rect.left}px`;
    this.textEditNode.style.top = `${rect.top}px`;
  }
}
function hideEditTextBox() {
  if (!this.showTextEdit) {
    return;
  }
  let [path2, , text4, node3, toNode3] = this.activeLine;
  let str = getStrWithBrFromHtml(this.textEditNode.innerHTML);
  let isDefaultText = str === this.mindMap.opt.defaultAssociativeLineText;
  str = isDefaultText ? "" : str;
  this.mindMap.execCommand("SET_NODE_DATA", node3, {
    associativeLineText: {
      ...node3.getData("associativeLineText") || {},
      [toNode3.getData("uid")]: str
    }
  });
  this.textEditNode.style.display = "none";
  this.textEditNode.innerHTML = "";
  this.showTextEdit = false;
  this.renderText(str, path2, text4);
  this.mindMap.emit("hide_text_edit");
}
function getText2(node3, toNode3) {
  let obj = node3.getData("associativeLineText");
  if (!obj) {
    return "";
  }
  return obj[toNode3.getData("uid")] || "";
}
function renderText(str, path2, text4) {
  if (!str)
    return;
  let { associativeLineTextFontSize, associativeLineTextLineHeight } = this.mindMap.themeConfig;
  text4.clear();
  let textArr = str.split(/\n/gim);
  textArr.forEach((item, index3) => {
    let node3 = new Text2().text(item);
    node3.y(associativeLineTextFontSize * associativeLineTextLineHeight * index3);
    this.styleText(node3);
    text4.add(node3);
  });
  updateTextPos(path2, text4);
}
function styleText(node3) {
  let {
    associativeLineTextColor,
    associativeLineTextFontSize,
    associativeLineTextFontFamily
  } = this.mindMap.themeConfig;
  node3.fill({
    color: associativeLineTextColor
  }).css({
    "font-family": associativeLineTextFontFamily,
    "font-size": associativeLineTextFontSize
  });
}
function updateTextPos(path2, text4) {
  let pathLength = path2.length();
  let centerPoint = path2.pointAt(pathLength / 2);
  let { width: textWidth, height: textHeight } = text4.bbox();
  text4.x(centerPoint.x - textWidth / 2);
  text4.y(centerPoint.y - textHeight / 2);
}
var associativeLineText_default = {
  getText: getText2,
  createText,
  styleText,
  onScale,
  showEditTextBox,
  hideEditTextBox,
  updateTextEditBoxPos,
  renderText,
  updateTextPos
};

// ../simple-mind-map/src/plugins/AssociativeLine.js
var AssociativeLine = class {
  constructor(opt = {}) {
    this.mindMap = opt.mindMap;
    this.associativeLineDraw = this.mindMap.associativeLineDraw;
    this.lineList = [];
    this.activeLine = null;
    this.isCreatingLine = false;
    this.creatingStartNode = null;
    this.creatingLine = null;
    this.overlapNode = null;
    this.isNodeDragging = false;
    this.markerPath = null;
    this.marker = this.createMarker();
    this.controlLine1 = null;
    this.controlLine2 = null;
    this.controlPoint1 = null;
    this.controlPoint2 = null;
    this.controlPointDiameter = 10;
    this.isControlPointMousedown = false;
    this.mousedownControlPointKey = "";
    this.controlPointMousemoveState = {
      pos: null,
      startPoint: null,
      endPoint: null,
      targetIndex: ""
    };
    this.checkOverlapNode = throttle(this.checkOverlapNode, 100, this);
    Object.keys(associativeLineControls_default).forEach((item) => {
      this[item] = associativeLineControls_default[item].bind(this);
    });
    Object.keys(associativeLineText_default).forEach((item) => {
      this[item] = associativeLineText_default[item].bind(this);
    });
    this.bindEvent();
  }
  // 监听事件
  bindEvent() {
    this.renderAllLines = this.renderAllLines.bind(this);
    this.onDrawClick = this.onDrawClick.bind(this);
    this.onNodeClick = this.onNodeClick.bind(this);
    this.removeLine = this.removeLine.bind(this);
    this.addLine = this.addLine.bind(this);
    this.onMousemove = this.onMousemove.bind(this);
    this.onNodeDragging = this.onNodeDragging.bind(this);
    this.onNodeDragend = this.onNodeDragend.bind(this);
    this.onControlPointMouseup = this.onControlPointMouseup.bind(this);
    this.mindMap.on("node_tree_render_end", this.renderAllLines);
    this.mindMap.on("data_change", this.renderAllLines);
    this.mindMap.on("draw_click", this.onDrawClick);
    this.mindMap.on("node_click", this.onNodeClick);
    this.mindMap.keyCommand.addShortcut("Del|Backspace", this.removeLine);
    this.mindMap.command.add("ADD_ASSOCIATIVE_LINE", this.addLine);
    this.mindMap.on("mousemove", this.onMousemove);
    this.mindMap.on("node_dragging", this.onNodeDragging);
    this.mindMap.on("node_dragend", this.onNodeDragend);
    this.mindMap.on("mouseup", this.onControlPointMouseup);
    this.mindMap.on("scale", this.onScale);
  }
  // 解绑事件
  unBindEvent() {
    this.mindMap.off("node_tree_render_end", this.renderAllLines);
    this.mindMap.off("data_change", this.renderAllLines);
    this.mindMap.off("draw_click", this.onDrawClick);
    this.mindMap.off("node_click", this.onNodeClick);
    this.mindMap.keyCommand.removeShortcut("Del|Backspace", this.removeLine);
    this.mindMap.command.remove("ADD_ASSOCIATIVE_LINE", this.addLine);
    this.mindMap.off("mousemove", this.onMousemove);
    this.mindMap.off("node_dragging", this.onNodeDragging);
    this.mindMap.off("node_dragend", this.onNodeDragend);
    this.mindMap.off("mouseup", this.onControlPointMouseup);
    this.mindMap.off("scale", this.onScale);
  }
  // 画布点击事件
  onDrawClick() {
    if (this.isControlPointMousedown) {
      return;
    }
    this.clearActiveLine();
  }
  // 节点点击事件
  onNodeClick(node3) {
    if (this.isCreatingLine) {
      this.completeCreateLine(node3);
    } else {
      this.clearActiveLine();
    }
  }
  // 创建箭头
  createMarker() {
    return this.associativeLineDraw.marker(20, 20, (add) => {
      add.ref(12, 5);
      add.size(10, 10);
      add.attr("orient", "auto-start-reverse");
      this.markerPath = add.path("M0,0 L2,5 L0,10 L10,5 Z");
    });
  }
  // 判断关联线坐标是否变更，有变更则使用变化后的坐标，无则默认坐标
  updateAllLinesPos(node3, toNode3, associativeLinePoint) {
    associativeLinePoint = associativeLinePoint || {};
    let [startPoint, endPoint] = computeNodePoints(node3, toNode3);
    let nodeRange = 0;
    let nodeDir = "";
    let toNodeRange = 0;
    let toNodeDir = "";
    if (associativeLinePoint.startPoint) {
      nodeRange = associativeLinePoint.startPoint.range || 0;
      nodeDir = associativeLinePoint.startPoint.dir || "right";
      startPoint = getNodePoint(node3, nodeDir, nodeRange);
    }
    if (associativeLinePoint.endPoint) {
      toNodeRange = associativeLinePoint.endPoint.range || 0;
      toNodeDir = associativeLinePoint.endPoint.dir || "right";
      endPoint = getNodePoint(toNode3, toNodeDir, toNodeRange);
    }
    return [startPoint, endPoint];
  }
  // 渲染所有连线
  renderAllLines() {
    this.removeAllLines();
    this.removeControls();
    this.clearActiveLine();
    let tree = this.mindMap.renderer.root;
    if (!tree)
      return;
    let idToNode = /* @__PURE__ */ new Map();
    let nodeToIds = /* @__PURE__ */ new Map();
    walk(
      tree,
      null,
      (cur) => {
        if (!cur)
          return;
        let data2 = cur.getData();
        if (data2.associativeLineTargets && data2.associativeLineTargets.length > 0) {
          nodeToIds.set(cur, data2.associativeLineTargets);
        }
        if (data2.uid) {
          idToNode.set(data2.uid, cur);
        }
      },
      () => {
      },
      true,
      0
    );
    nodeToIds.forEach((ids, node3) => {
      ids.forEach((uid, index3) => {
        let toNode3 = idToNode.get(uid);
        if (!node3 || !toNode3)
          return;
        const associativeLinePoint = (node3.getData("associativeLinePoint") || [])[index3];
        const [startPoint, endPoint] = this.updateAllLinesPos(
          node3,
          toNode3,
          associativeLinePoint
        );
        this.drawLine(startPoint, endPoint, node3, toNode3);
      });
    });
  }
  // 绘制连接线
  drawLine(startPoint, endPoint, node3, toNode3) {
    let {
      associativeLineWidth,
      associativeLineColor,
      associativeLineActiveWidth,
      associativeLineActiveColor
    } = this.mindMap.themeConfig;
    this.markerPath.stroke({ color: associativeLineColor }).fill({ color: associativeLineColor });
    let { path: pathStr, controlPoints } = getNodeLinePath(
      startPoint,
      endPoint,
      node3,
      toNode3
    );
    let path2 = this.associativeLineDraw.path();
    path2.stroke({
      width: associativeLineWidth,
      color: associativeLineColor,
      dasharray: [6, 4]
    }).fill({ color: "none" });
    path2.plot(pathStr);
    path2.marker("end", this.marker);
    let clickPath = this.associativeLineDraw.path();
    clickPath.stroke({ width: associativeLineActiveWidth, color: "transparent" }).fill({ color: "none" });
    clickPath.plot(pathStr);
    let text4 = this.createText({
      path: path2,
      clickPath,
      node: node3,
      toNode: toNode3,
      startPoint,
      endPoint,
      controlPoints
    });
    clickPath.click((e2) => {
      e2.stopPropagation();
      this.setActiveLine({
        path: path2,
        clickPath,
        text: text4,
        node: node3,
        toNode: toNode3,
        startPoint,
        endPoint,
        controlPoints
      });
    });
    clickPath.dblclick(() => {
      if (!this.activeLine)
        return;
      this.showEditTextBox(text4);
    });
    this.renderText(this.getText(node3, toNode3), path2, text4);
    this.lineList.push([path2, clickPath, text4, node3, toNode3]);
  }
  // 激活某根关联线
  setActiveLine({
    path: path2,
    clickPath,
    text: text4,
    node: node3,
    toNode: toNode3,
    startPoint,
    endPoint,
    controlPoints
  }) {
    let { associativeLineActiveColor } = this.mindMap.themeConfig;
    this.mindMap.execCommand("CLEAR_ACTIVE_NODE");
    this.clearActiveLine();
    this.activeLine = [path2, clickPath, text4, node3, toNode3];
    clickPath.stroke({ color: associativeLineActiveColor });
    if (!this.getText(node3, toNode3)) {
      this.renderText(this.mindMap.opt.defaultAssociativeLineText, path2, text4);
    }
    this.renderControls(
      startPoint,
      endPoint,
      controlPoints[0],
      controlPoints[1]
    );
    this.mindMap.emit("associative_line_click", path2, clickPath, node3, toNode3);
    this.front();
  }
  // 移除所有连接线
  removeAllLines() {
    this.lineList.forEach((line) => {
      line[0].remove();
      line[1].remove();
      line[2].remove();
    });
    this.lineList = [];
  }
  // 从当前激活节点开始创建连接线
  createLineFromActiveNode() {
    if (this.mindMap.renderer.activeNodeList.length <= 0)
      return;
    let node3 = this.mindMap.renderer.activeNodeList[0];
    this.createLine(node3);
  }
  // 创建连接线
  createLine(fromNode) {
    let { associativeLineWidth, associativeLineColor } = this.mindMap.themeConfig;
    if (this.isCreatingLine || !fromNode)
      return;
    this.front();
    this.isCreatingLine = true;
    this.creatingStartNode = fromNode;
    this.creatingLine = this.associativeLineDraw.path();
    this.creatingLine.stroke({
      width: associativeLineWidth,
      color: associativeLineColor,
      dasharray: [6, 4]
    }).fill({ color: "none" });
    this.creatingLine.marker("end", this.marker);
  }
  // 鼠标移动事件
  onMousemove(e2) {
    this.onControlPointMousemove(e2);
    this.updateCreatingLine(e2);
  }
  // 更新创建过程中的连接线
  updateCreatingLine(e2) {
    if (!this.isCreatingLine)
      return;
    let { x: x2, y: y3 } = this.getTransformedEventPos(e2);
    let startPoint = getNodePoint(this.creatingStartNode);
    let offsetX = x2 > startPoint.x ? -10 : 10;
    let pathStr = cubicBezierPath(startPoint.x, startPoint.y, x2 + offsetX, y3);
    this.creatingLine.plot(pathStr);
    this.checkOverlapNode(x2, y3);
  }
  // 获取转换后的鼠标事件对象的坐标
  getTransformedEventPos(e2) {
    let { x: x2, y: y3 } = this.mindMap.toPos(e2.clientX, e2.clientY);
    let { scaleX, scaleY, translateX, translateY } = this.mindMap.draw.transform();
    return {
      x: (x2 - translateX) / scaleX,
      y: (y3 - translateY) / scaleY
    };
  }
  // 计算节点偏移位置
  getNodePos(node3) {
    const { scaleX, scaleY, translateX, translateY } = this.mindMap.draw.transform();
    const { left, top, width: width2, height: height2 } = node3;
    let translateLeft = left * scaleX + translateX;
    let translateTop = top * scaleY + translateY;
    return {
      left,
      top,
      translateLeft,
      translateTop,
      width: width2,
      height: height2
    };
  }
  // 检测当前移动到的目标节点
  checkOverlapNode(x2, y3) {
    this.overlapNode = null;
    bfsWalk(this.mindMap.renderer.root, (node3) => {
      if (node3.getData("isActive")) {
        this.mindMap.execCommand("SET_NODE_ACTIVE", node3, false);
      }
      if (node3.uid === this.creatingStartNode.uid || this.overlapNode) {
        return;
      }
      let { left, top, width: width2, height: height2 } = node3;
      let right = left + width2;
      let bottom = top + height2;
      if (x2 >= left && x2 <= right && y3 >= top && y3 <= bottom) {
        this.overlapNode = node3;
      }
    });
    if (this.overlapNode && !this.overlapNode.getData("isActive")) {
      this.mindMap.execCommand("SET_NODE_ACTIVE", this.overlapNode, true);
    }
  }
  // 完成创建连接线
  completeCreateLine(node3) {
    if (this.creatingStartNode.uid === node3.uid)
      return;
    this.addLine(this.creatingStartNode, node3);
    if (this.overlapNode && this.overlapNode.getData("isActive")) {
      this.mindMap.execCommand("SET_NODE_ACTIVE", this.overlapNode, false);
    }
    this.isCreatingLine = false;
    this.creatingStartNode = null;
    this.creatingLine.remove();
    this.creatingLine = null;
    this.overlapNode = null;
    this.back();
  }
  // 添加连接线
  addLine(fromNode, toNode3) {
    if (!fromNode || !toNode3)
      return;
    let uid = toNode3.getData("uid");
    if (!uid) {
      uid = v4_default();
      this.mindMap.execCommand("SET_NODE_DATA", toNode3, {
        uid
      });
    }
    let list2 = fromNode.getData("associativeLineTargets") || [];
    const sameLine = list2.some((item) => item === uid);
    if (sameLine) {
      return;
    }
    list2.push(uid);
    let [startPoint, endPoint] = computeNodePoints(fromNode, toNode3);
    let controlPoints = computeCubicBezierPathPoints(
      startPoint.x,
      startPoint.y,
      endPoint.x,
      endPoint.y
    );
    let offsetList = fromNode.getData("associativeLineTargetControlOffsets") || [];
    offsetList[list2.length - 1] = [
      {
        x: controlPoints[0].x - startPoint.x,
        y: controlPoints[0].y - startPoint.y
      },
      {
        x: controlPoints[1].x - endPoint.x,
        y: controlPoints[1].y - endPoint.y
      }
    ];
    let associativeLinePoint = fromNode.getData("associativeLinePoint") || [];
    associativeLinePoint[list2.length - 1] = { startPoint, endPoint };
    this.mindMap.execCommand("SET_NODE_DATA", fromNode, {
      associativeLineTargets: list2,
      associativeLineTargetControlOffsets: offsetList,
      associativeLinePoint
    });
  }
  // 删除连接线
  removeLine() {
    if (!this.activeLine)
      return;
    let [, , , node3, toNode3] = this.activeLine;
    this.removeControls();
    let {
      associativeLineTargets,
      associativeLinePoint,
      associativeLineTargetControlOffsets,
      associativeLineText
    } = node3.getData();
    associativeLinePoint = associativeLinePoint || [];
    let targetIndex = getAssociativeLineTargetIndex(node3, toNode3);
    let newAssociativeLineText = {};
    if (associativeLineText) {
      Object.keys(associativeLineText).forEach((item) => {
        if (item !== toNode3.getData("uid")) {
          newAssociativeLineText[item] = associativeLineText[item];
        }
      });
    }
    this.mindMap.execCommand("SET_NODE_DATA", node3, {
      // 目标
      associativeLineTargets: associativeLineTargets.filter((_2, index3) => {
        return index3 !== targetIndex;
      }),
      // 连接线坐标
      associativeLinePoint: associativeLinePoint.filter((_2, index3) => {
        return index3 !== targetIndex;
      }),
      // 偏移量
      associativeLineTargetControlOffsets: associativeLineTargetControlOffsets ? associativeLineTargetControlOffsets.filter((_2, index3) => {
        return index3 !== targetIndex;
      }) : [],
      // 文本
      associativeLineText: newAssociativeLineText
    });
  }
  // 清除激活的线
  clearActiveLine() {
    if (this.activeLine) {
      let [, clickPath, text4, node3, toNode3] = this.activeLine;
      clickPath.stroke({
        color: "transparent"
      });
      this.hideEditTextBox();
      if (!this.getText(node3, toNode3)) {
        text4.clear();
      }
      this.activeLine = null;
      this.removeControls();
      this.back();
    }
  }
  // 处理节点正在拖拽事件
  onNodeDragging() {
    if (this.isNodeDragging)
      return;
    this.isNodeDragging = true;
    this.lineList.forEach((line) => {
      line[0].hide();
      line[1].hide();
      line[2].hide();
    });
    this.hideControls();
  }
  // 处理节点拖拽完成事件
  onNodeDragend() {
    if (!this.isNodeDragging)
      return;
    this.lineList.forEach((line) => {
      line[0].show();
      line[1].show();
      line[2].show();
    });
    this.showControls();
    this.isNodeDragging = false;
  }
  // 关联线顶层显示
  front() {
    if (this.mindMap.opt.associativeLineIsAlwaysAboveNode)
      return;
    this.associativeLineDraw.front();
  }
  // 关联线回到原有层级
  back() {
    if (this.mindMap.opt.associativeLineIsAlwaysAboveNode)
      return;
    this.associativeLineDraw.back();
    this.associativeLineDraw.forward();
  }
  // 插件被移除前做的事情
  beforePluginRemove() {
    this.unBindEvent();
  }
  // 插件被卸载前做的事情
  beforePluginDestroy() {
    this.unBindEvent();
  }
};
AssociativeLine.instanceName = "associativeLine";
var AssociativeLine_default = AssociativeLine;

// ../simple-mind-map/src/plugins/RichText.js
var import_quill = __toESM(require_quill());
var import_quill_delta = __toESM(require_delta());
var extended = false;
var fontFamilyList = [
  "\u5B8B\u4F53, SimSun, Songti SC",
  "\u5FAE\u8F6F\u96C5\u9ED1, Microsoft YaHei",
  "\u6977\u4F53, \u6977\u4F53_GB2312, SimKai, STKaiti",
  "\u9ED1\u4F53, SimHei, Heiti SC",
  "\u96B6\u4E66, SimLi",
  "andale mono",
  "arial, helvetica, sans-serif",
  "arial black, avant garde",
  "comic sans ms",
  "impact, chicago",
  "times new roman",
  "sans-serif",
  "serif"
];
var fontSizeList = new Array(100).fill(0).map((_2, index3) => {
  return index3 + "px";
});
var RichText = class {
  constructor({ mindMap, pluginOpt }) {
    this.mindMap = mindMap;
    this.pluginOpt = pluginOpt;
    this.textEditNode = null;
    this.showTextEdit = false;
    this.quill = null;
    this.range = null;
    this.lastRange = null;
    this.pasteUseRange = null;
    this.node = null;
    this.isInserting = false;
    this.styleEl = null;
    this.cacheEditingText = "";
    this.lostStyle = false;
    this.isCompositing = false;
    this.initOpt();
    this.extendQuill();
    this.appendCss();
    this.bindEvent();
    if (this.mindMap.opt.data) {
      this.mindMap.opt.data = this.handleSetData(this.mindMap.opt.data);
    }
  }
  // 绑定事件
  bindEvent() {
    this.onCompositionStart = this.onCompositionStart.bind(this);
    this.onCompositionEnd = this.onCompositionEnd.bind(this);
    window.addEventListener("compositionstart", this.onCompositionStart);
    window.addEventListener("compositionend", this.onCompositionEnd);
  }
  // 解绑事件
  unbindEvent() {
    window.removeEventListener("compositionstart", this.onCompositionStart);
    window.removeEventListener("compositionend", this.onCompositionEnd);
  }
  // 插入样式
  appendCss() {
    let cssText = `
      .ql-editor {
        overflow: hidden;
        padding: 0;
        height: auto;
        line-height: normal;
        -webkit-user-select: text;
      }
      
      .ql-container {
        height: auto;
        font-size: inherit;
      }

      .ql-container.ql-snow {
        border: none;
      }

      .smm-richtext-node-wrap {
        word-break: break-all;
      }

      .smm-richtext-node-wrap p {
        font-family: auto;
        
      }

      .smm-richtext-node-edit-wrap p {
        font-family: auto;
      }
    `;
    this.styleEl = document.createElement("style");
    this.styleEl.type = "text/css";
    this.styleEl.innerHTML = cssText;
    document.head.appendChild(this.styleEl);
  }
  // 处理选项参数
  initOpt() {
    if (this.pluginOpt.fontFamilyList && Array.isArray(this.pluginOpt.fontFamilyList)) {
      fontFamilyList = this.pluginOpt.fontFamilyList;
    }
    if (this.pluginOpt.fontSizeList && Array.isArray(this.pluginOpt.fontSizeList)) {
      fontSizeList = this.pluginOpt.fontSizeList;
    }
  }
  // 扩展quill编辑器
  extendQuill() {
    if (extended) {
      return;
    }
    extended = true;
    const FontAttributor = import_quill.default.import("attributors/class/font");
    FontAttributor.whitelist = fontFamilyList;
    import_quill.default.register(FontAttributor, true);
    const FontStyle = import_quill.default.import("attributors/style/font");
    FontStyle.whitelist = fontFamilyList;
    import_quill.default.register(FontStyle, true);
    const SizeAttributor = import_quill.default.import("attributors/class/size");
    SizeAttributor.whitelist = fontSizeList;
    import_quill.default.register(SizeAttributor, true);
    const SizeStyle = import_quill.default.import("attributors/style/size");
    SizeStyle.whitelist = fontSizeList;
    import_quill.default.register(SizeStyle, true);
  }
  // 显示文本编辑控件
  showEditText({ node: node3, rect, isInserting, isFromKeyDown, isFromScale }) {
    if (this.showTextEdit) {
      return;
    }
    const {
      richTextEditFakeInPlace,
      customInnerElsAppendTo,
      nodeTextEditZIndex,
      textAutoWrapWidth,
      selectTextOnEnterEditText
    } = this.mindMap.opt;
    this.node = node3;
    this.isInserting = isInserting;
    if (!rect)
      rect = node3._textData.node.node.getBoundingClientRect();
    if (!isFromScale) {
      this.mindMap.emit("before_show_text_edit");
    }
    this.mindMap.renderer.textEdit.registerTmpShortcut();
    let g = node3._textData.node;
    let originWidth = g.attr("data-width");
    let originHeight = g.attr("data-height");
    let scaleX = rect.width / originWidth;
    let scaleY = rect.height / originHeight;
    let paddingX = 6;
    let paddingY = 4;
    if (richTextEditFakeInPlace) {
      let paddingValue = node3.getPaddingVale();
      paddingX = paddingValue.paddingX;
      paddingY = paddingValue.paddingY;
    }
    if (!this.textEditNode) {
      this.textEditNode = document.createElement("div");
      this.textEditNode.classList.add("smm-richtext-node-edit-wrap");
      this.textEditNode.style.cssText = `
        position:fixed; 
        box-sizing: border-box; 
        box-shadow: 0 0 20px rgba(0,0,0,.5);
        outline: none; 
        word-break: 
        break-all;padding: ${paddingY}px ${paddingX}px;
      `;
      this.textEditNode.addEventListener("click", (e2) => {
        e2.stopPropagation();
      });
      this.textEditNode.addEventListener("mousedown", (e2) => {
        e2.stopPropagation();
      });
      this.textEditNode.addEventListener("keydown", (e2) => {
        if (this.mindMap.renderer.textEdit.checkIsAutoEnterTextEditKey(e2)) {
          e2.stopPropagation();
        }
      });
      const targetNode = customInnerElsAppendTo || document.body;
      targetNode.appendChild(this.textEditNode);
    }
    let bgColor = node3.style.merge("fillColor");
    let color = node3.style.merge("color");
    this.textEditNode.style.marginLeft = `-${paddingX * scaleX}px`;
    this.textEditNode.style.marginTop = `-${paddingY * scaleY}px`;
    this.textEditNode.style.zIndex = nodeTextEditZIndex;
    this.textEditNode.style.backgroundColor = bgColor === "transparent" ? isWhite(color) ? getVisibleColorFromTheme(this.mindMap.themeConfig) : "#fff" : bgColor;
    this.textEditNode.style.minWidth = originWidth + paddingX * 2 + "px";
    this.textEditNode.style.minHeight = originHeight + "px";
    this.textEditNode.style.left = rect.left + "px";
    this.textEditNode.style.top = rect.top + "px";
    this.textEditNode.style.display = "block";
    this.textEditNode.style.maxWidth = textAutoWrapWidth + paddingX * 2 + "px";
    this.textEditNode.style.transform = `scale(${scaleX}, ${scaleY})`;
    this.textEditNode.style.transformOrigin = "left top";
    if (richTextEditFakeInPlace) {
      this.textEditNode.style.borderRadius = (node3.style.merge("borderRadius") || 5) + "px";
      if (node3.style.merge("shape") == "roundedRectangle") {
        this.textEditNode.style.borderRadius = (node3.height || 50) + "px";
      }
    }
    const nodeText = node3.getData("text");
    const isEmptyText = isUndef(nodeText);
    const noneEmptyNoneRichText = !node3.getData("richText") && !isEmptyText;
    if (isEmptyText) {
      this.lostStyle = true;
    }
    if (noneEmptyNoneRichText) {
      let text4 = String(nodeText).split(/\n/gim).join("<br>");
      let html2 = `<p>${text4}</p>`;
      this.textEditNode.innerHTML = this.cacheEditingText || html2;
    } else {
      this.textEditNode.innerHTML = this.cacheEditingText || nodeText;
    }
    this.initQuillEditor();
    document.querySelector(".ql-editor").style.minHeight = originHeight + "px";
    this.showTextEdit = true;
    this.focus(
      isInserting || selectTextOnEnterEditText && !isFromKeyDown ? 0 : null
    );
    if (noneEmptyNoneRichText) {
      this.setTextStyleIfNotRichText(node3);
    }
    this.cacheEditingText = "";
  }
  // 如果是非富文本的情况，需要手动应用文本样式
  setTextStyleIfNotRichText(node3) {
    let style = {
      font: node3.style.merge("fontFamily"),
      color: node3.style.merge("color"),
      italic: node3.style.merge("fontStyle") === "italic",
      bold: node3.style.merge("fontWeight") === "bold",
      size: node3.style.merge("fontSize") + "px",
      underline: node3.style.merge("textDecoration") === "underline",
      strike: node3.style.merge("textDecoration") === "line-through"
    };
    this.pureFormatAllText(style);
  }
  // 获取当前正在编辑的内容
  getEditText() {
    let html2 = this.quill.container.firstChild.innerHTML;
    return html2.replace(/<p><br><\/p>$/, "");
  }
  // 隐藏文本编辑控件，即完成编辑
  hideEditText(nodes) {
    if (!this.showTextEdit) {
      return;
    }
    let html2 = this.getEditText();
    let list2 = nodes && nodes.length > 0 ? nodes : this.mindMap.renderer.activeNodeList;
    list2.forEach((node3) => {
      this.mindMap.execCommand("SET_NODE_TEXT", node3, html2, true);
      if (node3.isGeneralization) {
        node3.generalizationBelongNode.updateGeneralization();
      }
      this.mindMap.render();
    });
    this.mindMap.emit("hide_text_edit", this.textEditNode, list2);
    this.textEditNode.style.display = "none";
    this.showTextEdit = false;
    this.mindMap.emit("rich_text_selection_change", false);
    this.node = null;
    this.isInserting = false;
  }
  // 初始化Quill富文本编辑器
  initQuillEditor() {
    this.quill = new import_quill.default(this.textEditNode, {
      modules: {
        toolbar: false,
        keyboard: {
          bindings: {
            enter: {
              key: 13,
              handler: function() {
              }
            },
            tab: {
              key: 9,
              handler: function() {
              }
            }
          }
        }
      },
      theme: "snow"
    });
    this.quill.on("selection-change", (range) => {
      if (this.isInserting)
        return;
      this.lastRange = this.range;
      this.range = null;
      if (range) {
        this.pasteUseRange = range;
        let bounds = this.quill.getBounds(range.index, range.length);
        let rect = this.textEditNode.getBoundingClientRect();
        let rectInfo = {
          left: bounds.left + rect.left,
          top: bounds.top + rect.top,
          right: bounds.right + rect.left,
          bottom: bounds.bottom + rect.top,
          width: bounds.width
        };
        let formatInfo = this.quill.getFormat(range.index, range.length);
        let hasRange = false;
        if (range.length == 0) {
          hasRange = false;
        } else {
          this.range = range;
          hasRange = true;
        }
        this.mindMap.emit(
          "rich_text_selection_change",
          hasRange,
          rectInfo,
          formatInfo
        );
      } else {
        this.mindMap.emit("rich_text_selection_change", false, null, null);
      }
    });
    this.quill.on("text-change", () => {
      let contents = this.quill.getContents();
      let len = contents.ops.length;
      if (len <= 0 || len === 1 && contents.ops[0].insert === "\n") {
        this.lostStyle = true;
        this.syncFormatToNodeConfig(null, true);
      } else if (this.lostStyle && !this.isCompositing) {
        this.setTextStyleIfNotRichText(this.node);
        this.lostStyle = false;
      }
    });
    this.quill.clipboard.addMatcher(Node.TEXT_NODE, (node3) => {
      let style = this.getPasteTextStyle();
      return new import_quill_delta.default().insert(node3.data, style);
    });
    this.quill.clipboard.addMatcher(Node.ELEMENT_NODE, (node3, delta) => {
      let ops = [];
      let style = this.getPasteTextStyle();
      delta.ops.forEach((op2) => {
        if (op2.insert && typeof op2.insert === "string" && op2.insert !== "\n") {
          ops.push({
            attributes: { ...style },
            insert: op2.insert
          });
        }
      });
      delta.ops = ops;
      return delta;
    });
  }
  // 获取粘贴的文本的样式
  getPasteTextStyle() {
    if (this.pasteUseRange) {
      return this.quill.getFormat(
        this.pasteUseRange.index,
        this.pasteUseRange.length
      );
    }
    return {};
  }
  // 正则输入中文
  onCompositionStart() {
    if (!this.showTextEdit) {
      return;
    }
    this.isCompositing = true;
  }
  // 中文输入结束
  onCompositionEnd() {
    if (!this.showTextEdit) {
      return;
    }
    this.isCompositing = false;
    if (!this.lostStyle) {
      return;
    }
    this.setTextStyleIfNotRichText(this.node);
  }
  // 选中全部
  selectAll() {
    this.quill.setSelection(0, this.quill.getLength());
  }
  // 聚焦
  focus(start) {
    let len = this.quill.getLength();
    this.quill.setSelection(typeof start === "number" ? start : len, len);
  }
  // 格式化当前选中的文本
  formatText(config = {}, clear2 = false) {
    if (!this.range && !this.lastRange)
      return;
    this.syncFormatToNodeConfig(config, clear2);
    let rangeLost = !this.range;
    let range = rangeLost ? this.lastRange : this.range;
    clear2 ? this.quill.removeFormat(range.index, range.length) : this.quill.formatText(range.index, range.length, config);
    if (rangeLost) {
      this.quill.setSelection(this.lastRange.index, this.lastRange.length);
    }
  }
  // 清除当前选中文本的样式
  removeFormat() {
    this.formatText({}, true);
  }
  // 格式化指定范围的文本
  formatRangeText(range, config = {}) {
    if (!range)
      return;
    this.syncFormatToNodeConfig(config);
    this.quill.formatText(range.index, range.length, config);
  }
  // 格式化所有文本
  formatAllText(config = {}) {
    this.syncFormatToNodeConfig(config);
    this.pureFormatAllText(config);
  }
  // 纯粹的格式化所有文本
  pureFormatAllText(config = {}) {
    this.quill.formatText(0, this.quill.getLength(), config);
  }
  // 同步格式化到节点样式配置
  syncFormatToNodeConfig(config, clear2) {
    if (!this.node)
      return;
    if (clear2) {
      ;
      [
        "fontFamily",
        "fontSize",
        "fontWeight",
        "fontStyle",
        "textDecoration",
        "color"
      ].forEach((prop) => {
        delete this.node.nodeData.data[prop];
      });
    } else {
      let data2 = this.richTextStyleToNormalStyle(config);
      this.mindMap.execCommand("SET_NODE_DATA", this.node, data2);
    }
  }
  // 将普通节点样式对象转换成富文本样式对象
  normalStyleToRichTextStyle(style) {
    let config = {};
    Object.keys(style).forEach((prop) => {
      let value = style[prop];
      switch (prop) {
        case "fontFamily":
          config.font = value;
          break;
        case "fontSize":
          config.size = value + "px";
          break;
        case "fontWeight":
          config.bold = value === "bold";
          break;
        case "fontStyle":
          config.italic = value === "italic";
          break;
        case "textDecoration":
          config.underline = value === "underline";
          config.strike = value === "line-through";
          break;
        case "color":
          config.color = value;
          break;
        default:
          break;
      }
    });
    return config;
  }
  // 将富文本样式对象转换成普通节点样式对象
  richTextStyleToNormalStyle(config) {
    let data2 = {};
    Object.keys(config).forEach((prop) => {
      let value = config[prop];
      switch (prop) {
        case "font":
          data2.fontFamily = value;
          break;
        case "size":
          data2.fontSize = parseFloat(value);
          break;
        case "bold":
          data2.fontWeight = value ? "bold" : "normal";
          break;
        case "italic":
          data2.fontStyle = value ? "italic" : "normal";
          break;
        case "underline":
          data2.textDecoration = value ? "underline" : "none";
          break;
        case "strike":
          data2.textDecoration = value ? "line-through" : "none";
          break;
        case "color":
          data2.color = value;
          break;
        default:
          break;
      }
    });
    return data2;
  }
  // 给未激活的节点设置富文本样式
  setNotActiveNodeStyle(node3, style) {
    const config = this.normalStyleToRichTextStyle(style);
    if (Object.keys(config).length > 0) {
      this.showEditText({ node: node3 });
      this.formatAllText(config);
      this.hideEditText([node3]);
    }
  }
  // 处理导出为图片
  async handleExportPng(node3) {
    let el2 = document.createElement("div");
    el2.style.position = "absolute";
    el2.style.left = "-9999999px";
    el2.appendChild(node3);
    this.mindMap.el.appendChild(el2);
    let walk2 = (root2) => {
      root2.style.margin = 0;
      root2.style.padding = 0;
      if (root2.hasChildNodes()) {
        Array.from(root2.children).forEach((item) => {
          walk2(item);
        });
      }
    };
    walk2(node3);
    const res = await domtoimage.toPng(el2);
    this.mindMap.el.removeChild(el2);
    return res;
  }
  // 将所有节点转换成非富文本节点
  transformAllNodesToNormalNode() {
    walk(
      this.mindMap.renderer.renderTree,
      null,
      (node3) => {
        if (node3.data.richText) {
          node3.data.richText = false;
          node3.data.text = getTextFromHtml(node3.data.text);
        }
      },
      null,
      true,
      0,
      0
    );
    this.mindMap.command.clearHistory();
    this.mindMap.command.addHistory();
    this.mindMap.render(null, CONSTANTS.TRANSFORM_TO_NORMAL_NODE);
  }
  // 处理导入数据
  handleSetData(data2) {
    let walk2 = (root2) => {
      if (root2.data && !root2.data.richText) {
        root2.data.richText = true;
        root2.data.resetRichText = true;
      }
      if (root2.children && root2.children.length > 0) {
        Array.from(root2.children).forEach((item) => {
          walk2(item);
        });
      }
    };
    walk2(data2);
    return data2;
  }
  // 插件被移除前做的事情
  beforePluginRemove() {
    this.transformAllNodesToNormalNode();
    document.head.removeChild(this.styleEl);
    this.unbindEvent();
  }
  // 插件被卸载前做的事情
  beforePluginDestroy() {
    document.head.removeChild(this.styleEl);
    this.unbindEvent();
  }
};
RichText.instanceName = "richText";
var RichText_default = RichText;

// ../simple-mind-map/src/plugins/NodeImgAdjust.js
var NodeImgAdjust = class {
  //  构造函数
  constructor({ mindMap }) {
    this.mindMap = mindMap;
    this.resizeBtnSize = 26;
    this.handleEl = null;
    this.isShowHandleEl = false;
    this.node = null;
    this.img = null;
    this.rect = null;
    this.isMousedown = false;
    this.currentImgWidth = 0;
    this.currentImgHeight = 0;
    this.isAdjusted = false;
    this.bindEvent();
  }
  // 监听事件
  bindEvent() {
    this.onNodeImgMouseleave = this.onNodeImgMouseleave.bind(this);
    this.onNodeImgMousemove = this.onNodeImgMousemove.bind(this);
    this.onMousemove = this.onMousemove.bind(this);
    this.onMouseup = this.onMouseup.bind(this);
    this.onRenderEnd = this.onRenderEnd.bind(this);
    this.mindMap.on("node_img_mouseleave", this.onNodeImgMouseleave);
    this.mindMap.on("node_img_mousemove", this.onNodeImgMousemove);
    this.mindMap.on("mousemove", this.onMousemove);
    this.mindMap.on("mouseup", this.onMouseup);
    this.mindMap.on("node_mouseup", this.onMouseup);
    this.mindMap.on("node_tree_render_end", this.onRenderEnd);
  }
  // 解绑事件
  unBindEvent() {
    this.mindMap.off("node_img_mouseleave", this.onNodeImgMouseleave);
    this.mindMap.off("node_img_mousemove", this.onNodeImgMousemove);
    this.mindMap.off("mousemove", this.onMousemove);
    this.mindMap.off("mouseup", this.onMouseup);
    this.mindMap.off("node_mouseup", this.onMouseup);
    this.mindMap.off("node_tree_render_end", this.onRenderEnd);
  }
  // 节点图片鼠标移动事件
  onNodeImgMousemove(node3, img) {
    if (this.isMousedown || this.isAdjusted || this.mindMap.opt.readonly)
      return;
    if (this.node && this.node.uid === node3.uid && this.isShowHandleEl)
      return;
    this.node = node3;
    this.img = img;
    this.rect = this.img.rbox();
    this.showHandleEl();
  }
  // 节点图片鼠标移出事件
  onNodeImgMouseleave() {
    if (this.isMousedown)
      return;
    this.hideHandleEl();
  }
  // 隐藏节点实际的图片
  hideNodeImage() {
    if (!this.img)
      return;
    this.img.hide();
  }
  // 显示节点实际的图片
  showNodeImage() {
    if (!this.img)
      return;
    this.img.show();
  }
  // 显示自定义元素
  showHandleEl() {
    if (!this.handleEl) {
      this.createResizeBtnEl();
    }
    this.setHandleElRect();
    this.handleEl.style.display = "block";
    this.isShowHandleEl = true;
  }
  // 隐藏自定义元素
  hideHandleEl() {
    if (!this.isShowHandleEl)
      return;
    this.isShowHandleEl = false;
    this.handleEl.style.display = "none";
    this.handleEl.style.backgroundImage = ``;
    this.handleEl.style.width = 0;
    this.handleEl.style.height = 0;
    this.handleEl.style.left = 0;
    this.handleEl.style.top = 0;
  }
  // 设置自定义元素尺寸位置信息
  setHandleElRect() {
    let { width: width2, height: height2, x: x2, y: y3 } = this.rect;
    this.handleEl.style.left = `${x2}px`;
    this.handleEl.style.top = `${y3}px`;
    this.currentImgWidth = width2;
    this.currentImgHeight = height2;
    this.updateHandleElSize();
  }
  // 更新自定义元素宽高
  updateHandleElSize() {
    this.handleEl.style.width = `${this.currentImgWidth}px`;
    this.handleEl.style.height = `${this.currentImgHeight}px`;
  }
  // 创建调整按钮元素
  createResizeBtnEl() {
    this.handleEl = document.createElement("div");
    this.handleEl.style.cssText = `
      pointer-events: none;
      position: fixed;
	    display:none;
      background-size: cover;
    `;
    this.handleEl.className = "node-img-handle";
    const btnEl = document.createElement("div");
    btnEl.innerHTML = btns_default.imgAdjust;
    btnEl.style.cssText = `
      position: absolute;
      right: 0;
      bottom: 0;
      pointer-events: auto;
      background-color: rgba(0, 0, 0, 0.3);
      width: ${this.resizeBtnSize}px;
      height: ${this.resizeBtnSize}px;
      display: flex;
      justify-content: center;
      align-items: center;
      cursor: nwse-resize;
    `;
    btnEl.className = "node-image-resize";
    btnEl.addEventListener("mouseenter", () => {
      this.showHandleEl();
    });
    btnEl.addEventListener("mouseleave", () => {
      if (this.isMousedown)
        return;
      this.hideHandleEl();
    });
    btnEl.addEventListener("mousedown", (e2) => {
      e2.stopPropagation();
      this.onMousedown(e2);
    });
    btnEl.addEventListener("mouseup", (e2) => {
      setTimeout(() => {
        this.hideHandleEl();
        this.isAdjusted = false;
      }, 0);
    });
    btnEl.addEventListener("click", (e2) => {
      e2.stopPropagation();
    });
    this.handleEl.appendChild(btnEl);
    const btnRemove = document.createElement("div");
    this.handleEl.prepend(btnRemove);
    btnRemove.className = "node-image-remove";
    btnRemove.innerHTML = btns_default.remove;
    btnRemove.style.cssText = `
      position: absolute;
      right: 0;top:0;color:#fff;
      pointer-events: auto;
      background-color: rgba(0, 0, 0, 0.3);
      width: ${this.resizeBtnSize}px;
      height: ${this.resizeBtnSize}px;
      display: flex;
      justify-content: center;
      align-items: center;
      cursor: pointer;
    `;
    btnRemove.addEventListener("mouseenter", (e2) => {
      this.showHandleEl();
    });
    btnRemove.addEventListener("mouseleave", (e2) => {
      if (this.isMousedown)
        return;
      this.hideHandleEl();
    });
    btnRemove.addEventListener("click", (e2) => {
      this.mindMap.execCommand("SET_NODE_IMAGE", this.node, { url: null });
    });
    const targetNode = this.mindMap.opt.customInnerElsAppendTo || document.body;
    targetNode.appendChild(this.handleEl);
  }
  // 鼠标按钮按下事件
  onMousedown() {
    this.isMousedown = true;
    this.hideNodeImage();
    this.handleEl.style.backgroundImage = `url(${this.node.getData("image")})`;
  }
  // 鼠标移动
  onMousemove(e2) {
    if (!this.isMousedown)
      return;
    e2.preventDefault();
    let { width: imageOriginWidth, height: imageOriginHeight } = this.node.getData("imageSize");
    let newWidth = e2.clientX - this.rect.x;
    let newHeight = e2.clientY - this.rect.y;
    if (newWidth <= 0 || newHeight <= 0)
      return;
    let [actWidth, actHeight] = resizeImgSizeByOriginRatio(
      imageOriginWidth,
      imageOriginHeight,
      newWidth,
      newHeight
    );
    this.currentImgWidth = actWidth;
    this.currentImgHeight = actHeight;
    this.updateHandleElSize();
  }
  // 鼠标松开
  onMouseup() {
    if (!this.isMousedown)
      return;
    this.showNodeImage();
    this.hideHandleEl();
    let { image, imageTitle } = this.node.getData();
    let { scaleX, scaleY } = this.mindMap.draw.transform();
    this.mindMap.execCommand("SET_NODE_IMAGE", this.node, {
      url: image,
      title: imageTitle,
      width: this.currentImgWidth / scaleX,
      height: this.currentImgHeight / scaleY,
      custom: true
      // 代表自定义了图片大小
    });
    this.isAdjusted = true;
    this.isMousedown = false;
  }
  // 渲染完成事件
  onRenderEnd() {
    if (!this.isAdjusted) {
      this.hideHandleEl();
      return;
    }
    this.isAdjusted = false;
  }
  // 插件被移除前做的事情
  beforePluginRemove() {
    this.unBindEvent();
  }
  // 插件被卸载前做的事情
  beforePluginDestroy() {
    this.unBindEvent();
  }
};
NodeImgAdjust.instanceName = "nodeImgAdjust";
var NodeImgAdjust_default = NodeImgAdjust;

// ../simple-mind-map/src/plugins/TouchEvent.js
var TouchEvent = class {
  //  构造函数
  constructor({ mindMap }) {
    this.mindMap = mindMap;
    this.touchesNum = 0;
    this.singleTouchstartEvent = null;
    this.clickNum = 0;
    this.touchStartScaleView = null;
    this.bindEvent();
  }
  // 绑定事件
  bindEvent() {
    this.onTouchstart = this.onTouchstart.bind(this);
    this.onTouchmove = this.onTouchmove.bind(this);
    this.onTouchcancel = this.onTouchcancel.bind(this);
    this.onTouchend = this.onTouchend.bind(this);
    window.addEventListener("touchstart", this.onTouchstart);
    window.addEventListener("touchmove", this.onTouchmove);
    window.addEventListener("touchcancel", this.onTouchcancel);
    window.addEventListener("touchend", this.onTouchend);
  }
  // 解绑事件
  unBindEvent() {
    window.removeEventListener("touchstart", this.onTouchstart);
    window.removeEventListener("touchmove", this.onTouchmove);
    window.removeEventListener("touchcancel", this.onTouchcancel);
    window.removeEventListener("touchend", this.onTouchend);
  }
  // 手指按下事件
  onTouchstart(e2) {
    this.touchesNum = e2.touches.length;
    this.touchStartScaleView = null;
    if (this.touchesNum === 1) {
      let touch = e2.touches[0];
      this.singleTouchstartEvent = touch;
      this.dispatchMouseEvent("mousedown", touch.target, touch);
    }
  }
  // 手指移动事件
  onTouchmove(e2) {
    let len = e2.touches.length;
    if (len === 1) {
      let touch = e2.touches[0];
      this.dispatchMouseEvent("mousemove", touch.target, touch);
    } else if (len === 2) {
      if (this.mindMap.opt.disableTouchZoom)
        return;
      let touch1 = e2.touches[0];
      let touch2 = e2.touches[1];
      let ox = touch1.clientX - touch2.clientX;
      let oy = touch1.clientY - touch2.clientY;
      let distance = Math.sqrt(Math.pow(ox, 2) + Math.pow(oy, 2));
      let { x: touch1ClientX, y: touch1ClientY } = this.mindMap.toPos(
        touch1.clientX,
        touch1.clientY
      );
      let { x: touch2ClientX, y: touch2ClientY } = this.mindMap.toPos(
        touch2.clientX,
        touch2.clientY
      );
      let cx2 = (touch1ClientX + touch2ClientX) / 2;
      let cy2 = (touch1ClientY + touch2ClientY) / 2;
      const view = this.mindMap.view;
      if (!this.touchStartScaleView) {
        this.touchStartScaleView = {
          distance,
          scale: view.scale,
          x: view.x,
          y: view.y,
          cx: cx2,
          cy: cy2
        };
        return;
      }
      const viewBefore = this.touchStartScaleView;
      let scale3 = viewBefore.scale * (distance / viewBefore.distance);
      if (Math.abs(distance - viewBefore.distance) <= 10) {
        scale3 = viewBefore.scale;
      }
      const ratio = 1 - scale3 / viewBefore.scale;
      view.scale = scale3 < 0.1 ? 0.1 : scale3;
      view.x = viewBefore.x + (cx2 - viewBefore.x) * ratio + (cx2 - viewBefore.cx) * scale3;
      view.y = viewBefore.y + (cy2 - viewBefore.y) * ratio + (cy2 - viewBefore.cy) * scale3;
      view.transform();
      this.mindMap.emit("scale", scale3);
    }
  }
  // 手指取消事件
  onTouchcancel(e2) {
  }
  // 手指松开事件
  onTouchend(e2) {
    this.dispatchMouseEvent("mouseup", e2.target);
    if (this.touchesNum === 1) {
      this.clickNum++;
      setTimeout(() => {
        this.clickNum = 0;
      }, 300);
      let ev = this.singleTouchstartEvent;
      if (this.clickNum > 1) {
        this.clickNum = 0;
        this.dispatchMouseEvent("dblclick", ev.target, ev);
      } else {
      }
    }
    this.touchesNum = 0;
    this.singleTouchstartEvent = null;
    this.touchStartScaleView = null;
  }
  // 发送鼠标事件
  dispatchMouseEvent(eventName, target, e2) {
    let opt = {};
    if (e2) {
      opt = {
        screenX: e2.screenX,
        screenY: e2.screenY,
        clientX: e2.clientX,
        clientY: e2.clientY,
        which: 1
      };
    }
    let event = new MouseEvent(eventName, {
      view: window,
      bubbles: true,
      cancelable: true,
      ...opt
    });
    target.dispatchEvent(event);
  }
  // 插件被移除前做的事情
  beforePluginRemove() {
    this.unBindEvent();
  }
  // 插件被卸载前做的事情
  beforePluginDestroy() {
    this.unBindEvent();
  }
};
TouchEvent.instanceName = "touchEvent";
var TouchEvent_default = TouchEvent;

// ../simple-mind-map/src/plugins/Search.js
var Search = class {
  //  构造函数
  constructor({ mindMap }) {
    this.mindMap = mindMap;
    this.isSearching = false;
    this.searchText = "";
    this.matchNodeList = [];
    this.currentIndex = -1;
    this.notResetSearchText = false;
    this.isJumpNext = false;
    this.bindEvent();
  }
  bindEvent() {
    this.onDataChange = this.onDataChange.bind(this);
    this.mindMap.on("data_change", this.onDataChange);
  }
  unBindEvent() {
    this.mindMap.off("data_change", this.onDataChange);
  }
  // 节点数据改变了，需要重新搜索
  onDataChange() {
    if (this.isJumpNext) {
      this.isJumpNext = false;
      this.search(this.searchText);
      return;
    }
    if (this.notResetSearchText) {
      this.notResetSearchText = false;
      return;
    }
    this.searchText = "";
  }
  // 搜索
  search(text4, callback = () => {
  }) {
    if (isUndef(text4))
      return this.endSearch();
    text4 = String(text4);
    this.isSearching = true;
    if (this.searchText === text4) {
      this.searchNext(callback);
    } else {
      this.searchText = text4;
      this.doSearch();
      this.searchNext(callback);
    }
    this.emitEvent();
  }
  // 结束搜索
  endSearch() {
    if (!this.isSearching)
      return;
    this.searchText = "";
    this.matchNodeList = [];
    this.currentIndex = -1;
    this.notResetSearchText = false;
    this.isSearching = false;
    if (this.mindMap.opt.readonly) {
      this.mindMap.renderer.closeHighlightNode();
    }
    this.emitEvent();
  }
  // 搜索匹配的节点
  doSearch() {
    this.matchNodeList = [];
    this.currentIndex = -1;
    bfsWalk(this.mindMap.renderer.root, (node3) => {
      let { richText, text: text4 } = node3.getData();
      if (richText) {
        text4 = getTextFromHtml(text4);
      }
      if (text4.includes(this.searchText)) {
        this.matchNodeList.push(node3);
      }
    });
  }
  // 搜索下一个，定位到下一个匹配节点
  searchNext(callback) {
    if (!this.isSearching || this.matchNodeList.length <= 0)
      return;
    if (this.currentIndex < this.matchNodeList.length - 1) {
      this.currentIndex++;
    } else {
      this.currentIndex = 0;
    }
    let currentNode = this.matchNodeList[this.currentIndex];
    this.notResetSearchText = true;
    this.mindMap.execCommand("GO_TARGET_NODE", currentNode, () => {
      this.notResetSearchText = false;
      callback();
      if (this.mindMap.opt.readonly) {
        this.mindMap.renderer.highlightNode(currentNode);
      }
    });
  }
  // 替换当前节点
  replace(replaceText, jumpNext = false) {
    if (replaceText === null || replaceText === void 0 || !this.isSearching || this.matchNodeList.length <= 0)
      return;
    this.isJumpNext = jumpNext;
    replaceText = String(replaceText);
    let currentNode = this.matchNodeList[this.currentIndex];
    if (!currentNode)
      return;
    let text4 = this.getReplacedText(currentNode, this.searchText, replaceText);
    this.notResetSearchText = true;
    currentNode.setText(text4, currentNode.getData("richText"), true);
    this.matchNodeList = this.matchNodeList.filter((node3) => {
      return currentNode !== node3;
    });
    if (this.currentIndex > this.matchNodeList.length - 1) {
      this.currentIndex = -1;
    } else {
      this.currentIndex--;
    }
    this.emitEvent();
  }
  // 替换所有
  replaceAll(replaceText) {
    if (replaceText === null || replaceText === void 0 || !this.isSearching || this.matchNodeList.length <= 0)
      return;
    replaceText = String(replaceText);
    this.matchNodeList.forEach((node3) => {
      let text4 = this.getReplacedText(node3, this.searchText, replaceText);
      this.mindMap.renderer.setNodeDataRender(
        node3,
        {
          text: text4,
          resetRichText: !!node3.getData("richText")
        },
        true
      );
    });
    this.mindMap.render();
    this.mindMap.command.addHistory();
    this.endSearch();
  }
  // 获取某个节点替换后的文本
  getReplacedText(node3, searchText, replaceText) {
    let { richText, text: text4 } = node3.getData();
    if (richText) {
      return replaceHtmlText(text4, searchText, replaceText);
    } else {
      return text4.replaceAll(searchText, replaceText);
    }
  }
  // 发送事件
  emitEvent() {
    this.mindMap.emit("search_info_change", {
      currentIndex: this.currentIndex,
      total: this.matchNodeList.length
    });
  }
  // 插件被移除前做的事情
  beforePluginRemove() {
    this.unBindEvent();
  }
  // 插件被卸载前做的事情
  beforePluginDestroy() {
    this.unBindEvent();
  }
};
Search.instanceName = "search";
var Search_default = Search;

// ../simple-mind-map/src/plugins/Painter.js
var Painter = class {
  constructor({ mindMap }) {
    this.mindMap = mindMap;
    this.isInPainter = false;
    this.painterNode = null;
    this.bindEvent();
  }
  bindEvent() {
    this.painterOneNode = this.painterOneNode.bind(this);
    this.onEndPainter = this.onEndPainter.bind(this);
    this.mindMap.on("node_click", this.painterOneNode);
    this.mindMap.on("draw_click", this.onEndPainter);
  }
  unBindEvent() {
    this.mindMap.off("node_click", this.painterOneNode);
    this.mindMap.off("draw_click", this.onEndPainter);
  }
  // 开始格式刷
  startPainter() {
    if (this.mindMap.opt.readonly)
      return;
    let activeNodeList = this.mindMap.renderer.activeNodeList;
    if (activeNodeList.length <= 0)
      return;
    this.painterNode = activeNodeList[0];
    this.isInPainter = true;
    this.mindMap.emit("painter_start");
  }
  // 结束格式刷
  endPainter() {
    this.painterNode = null;
    this.isInPainter = false;
  }
  onEndPainter() {
    if (!this.isInPainter)
      return;
    this.endPainter();
    this.mindMap.emit("painter_end");
  }
  // 格式刷某个节点
  painterOneNode(node3) {
    if (!node3 || !this.isInPainter || !this.painterNode || !node3 || node3.uid === this.painterNode.uid)
      return;
    const style = {};
    const painterNodeData = this.painterNode.getData();
    Object.keys(painterNodeData).forEach((key) => {
      if (checkIsNodeStyleDataKey(key)) {
        style[key] = painterNodeData[key];
      }
    });
    node3.setStyles(style);
    if (painterNodeData.activeStyle) {
      node3.setStyles(painterNodeData.activeStyle, true);
    }
  }
  // 插件被移除前做的事情
  beforePluginRemove() {
    this.unBindEvent();
  }
  // 插件被卸载前做的事情
  beforePluginDestroy() {
    this.unBindEvent();
  }
};
Painter.instanceName = "painter";
var Painter_default = Painter;

// ../simple-mind-map/src/plugins/Scrollbar.js
var Scrollbar = class {
  //  构造函数
  constructor(opt) {
    this.mindMap = opt.mindMap;
    this.scrollbarWrapSize = {
      width: 0,
      // 水平滚动条的容器宽度
      height: 0
      // 垂直滚动条的容器高度
    };
    this.chartHeight = 0;
    this.chartWidth = 0;
    this.reset();
    this.bindEvent();
  }
  // 复位数据
  reset() {
    this.currentScrollType = "";
    this.isMousedown = false;
    this.mousedownPos = {
      x: 0,
      y: 0
    };
    this.mousedownScrollbarPos = 0;
  }
  // 绑定事件
  bindEvent() {
    this.onMousemove = this.onMousemove.bind(this);
    this.onMouseup = this.onMouseup.bind(this);
    this.updateScrollbar = this.updateScrollbar.bind(this);
    this.updateScrollbar = throttle(this.updateScrollbar, 16, this);
    this.mindMap.on("mousemove", this.onMousemove);
    this.mindMap.on("mouseup", this.onMouseup);
    this.mindMap.on("node_tree_render_end", this.updateScrollbar);
    this.mindMap.on("view_data_change", this.updateScrollbar);
  }
  // 解绑事件
  unBindEvent() {
    this.mindMap.off("mousemove", this.onMousemove);
    this.mindMap.off("mouseup", this.onMouseup);
    this.mindMap.off("node_tree_render_end", this.updateScrollbar);
    this.mindMap.off("view_data_change", this.updateScrollbar);
  }
  // 渲染后、数据改变需要更新滚动条
  updateScrollbar() {
    if (this.isMousedown)
      return;
    const res = this.calculationScrollbar();
    this.emitEvent(res);
  }
  // 发送滚动条改变事件
  emitEvent(data2) {
    this.mindMap.emit("scrollbar_change", data2);
  }
  // 设置滚动条容器的大小，指滚动条容器的大小，对于水平滚动条，即宽度，对于垂直滚动条，即高度
  setScrollBarWrapSize(width2, height2) {
    this.scrollbarWrapSize.width = width2;
    this.scrollbarWrapSize.height = height2;
  }
  // 计算滚动条大小和位置
  calculationScrollbar() {
    const rect = this.mindMap.draw.rbox();
    const elRect = this.mindMap.elRect;
    rect.x -= elRect.left;
    rect.y -= elRect.top;
    const canvasHeight = this.mindMap.height;
    const paddingY = canvasHeight / 2;
    const chartHeight = rect.height + paddingY * 2;
    this.chartHeight = chartHeight;
    const chartTop = rect.y - paddingY;
    const height2 = Math.min(canvasHeight / chartHeight * 100, 100);
    let top = -chartTop / chartHeight * 100;
    if (top < 0) {
      top = 0;
    }
    if (top > 100 - height2) {
      top = 100 - height2;
    }
    const canvasWidth = this.mindMap.width;
    const paddingX = canvasWidth / 2;
    const chartWidth = rect.width + paddingX * 2;
    this.chartWidth = chartWidth;
    const chartLeft = rect.x - paddingX;
    const width2 = Math.min(canvasWidth / chartWidth * 100, 100);
    let left = -chartLeft / chartWidth * 100;
    if (left < 0) {
      left = 0;
    }
    if (left > 100 - width2) {
      left = 100 - width2;
    }
    const res = {
      // 垂直滚动条
      vertical: {
        top,
        height: height2
      },
      // 水平滚动条
      horizontal: {
        left,
        width: width2
      }
    };
    return res;
  }
  // 滚动条鼠标按下事件处理函数
  onMousedown(e2, type) {
    e2.preventDefault();
    e2.stopPropagation();
    this.currentScrollType = type;
    this.isMousedown = true;
    this.mousedownPos = {
      x: e2.clientX,
      y: e2.clientY
    };
    const styles2 = window.getComputedStyle(e2.target);
    if (type === CONSTANTS.SCROLL_BAR_DIR.VERTICAL) {
      this.mousedownScrollbarPos = Number.parseFloat(styles2.top);
    } else {
      this.mousedownScrollbarPos = Number.parseFloat(styles2.left);
    }
  }
  // 鼠标移动事件处理函数
  onMousemove(e2) {
    if (!this.isMousedown) {
      return;
    }
    e2.preventDefault();
    e2.stopPropagation();
    if (this.currentScrollType === CONSTANTS.SCROLL_BAR_DIR.VERTICAL) {
      const oy = e2.clientY - this.mousedownPos.y + this.mousedownScrollbarPos;
      this.updateMindMapView(CONSTANTS.SCROLL_BAR_DIR.VERTICAL, oy);
    } else {
      const ox = e2.clientX - this.mousedownPos.x + this.mousedownScrollbarPos;
      this.updateMindMapView(CONSTANTS.SCROLL_BAR_DIR.HORIZONTAL, ox);
    }
  }
  // 鼠标松开事件处理函数
  onMouseup() {
    this.isMousedown = false;
    this.reset();
  }
  // 更新视图
  updateMindMapView(type, offset) {
    const scrollbarData = this.calculationScrollbar();
    const t2 = this.mindMap.draw.transform();
    const drawRect = this.mindMap.draw.rbox();
    const rootRect = this.mindMap.renderer.root.group.rbox();
    const rootCenterOffset = this.mindMap.renderer.layout.getRootCenterOffset(
      rootRect.width,
      rootRect.height
    );
    if (type === CONSTANTS.SCROLL_BAR_DIR.VERTICAL) {
      let oy = offset;
      if (oy <= 0) {
        oy = 0;
      }
      const max2 = (100 - scrollbarData.vertical.height) / 100 * this.scrollbarWrapSize.height;
      if (oy >= max2) {
        oy = max2;
      }
      const oyPercentage = oy / this.scrollbarWrapSize.height * 100;
      const oyPx = -oyPercentage / 100 * this.chartHeight;
      const yOffset = rootRect.y - drawRect.y;
      const paddingY = this.mindMap.height / 2;
      const chartTop = oyPx + yOffset - paddingY * t2.scaleY + paddingY - rootCenterOffset.y * t2.scaleY;
      this.mindMap.view.translateYTo(chartTop);
      this.emitEvent({
        horizontal: scrollbarData.horizontal,
        vertical: {
          top: oyPercentage,
          height: scrollbarData.vertical.height
        }
      });
    } else {
      let ox = offset;
      if (ox <= 0) {
        ox = 0;
      }
      const max2 = (100 - scrollbarData.horizontal.width) / 100 * this.scrollbarWrapSize.width;
      if (ox >= max2) {
        ox = max2;
      }
      const oxPercentage = ox / this.scrollbarWrapSize.width * 100;
      const oxPx = -oxPercentage / 100 * this.chartWidth;
      const xOffset = rootRect.x - drawRect.x;
      const paddingX = this.mindMap.width / 2;
      const chartLeft = oxPx + xOffset - paddingX * t2.scaleX + paddingX - rootCenterOffset.x * t2.scaleX;
      this.mindMap.view.translateXTo(chartLeft);
      this.emitEvent({
        vertical: scrollbarData.vertical,
        horizontal: {
          left: oxPercentage,
          width: scrollbarData.horizontal.width
        }
      });
    }
  }
  // 滚动条的点击事件
  onClick(e2, type) {
    let offset = 0;
    if (type === CONSTANTS.SCROLL_BAR_DIR.VERTICAL) {
      offset = e2.clientY - e2.currentTarget.getBoundingClientRect().top;
    } else {
      offset = e2.clientX - e2.currentTarget.getBoundingClientRect().left;
    }
    this.updateMindMapView(type, offset);
  }
  // 插件被移除前做的事情
  beforePluginRemove() {
    this.unBindEvent();
  }
  // 插件被卸载前做的事情
  beforePluginDestroy() {
    this.unBindEvent();
  }
};
Scrollbar.instanceName = "scrollbar";
var Scrollbar_default = Scrollbar;

// ../simple-mind-map/node_modules/katex/dist/katex.mjs
var SourceLocation = class {
  // The + prefix indicates that these fields aren't writeable
  // Lexer holding the input string.
  // Start offset, zero-based inclusive.
  // End offset, zero-based exclusive.
  constructor(lexer, start, end) {
    this.lexer = void 0;
    this.start = void 0;
    this.end = void 0;
    this.lexer = lexer;
    this.start = start;
    this.end = end;
  }
  /**
   * Merges two `SourceLocation`s from location providers, given they are
   * provided in order of appearance.
   * - Returns the first one's location if only the first is provided.
   * - Returns a merged range of the first and the last if both are provided
   *   and their lexers match.
   * - Otherwise, returns null.
   */
  static range(first, second) {
    if (!second) {
      return first && first.loc;
    } else if (!first || !first.loc || !second.loc || first.loc.lexer !== second.loc.lexer) {
      return null;
    } else {
      return new SourceLocation(first.loc.lexer, first.loc.start, second.loc.end);
    }
  }
};
var Token = class {
  // don't expand the token
  // used in \noexpand
  constructor(text4, loc) {
    this.text = void 0;
    this.loc = void 0;
    this.noexpand = void 0;
    this.treatAsRelax = void 0;
    this.text = text4;
    this.loc = loc;
  }
  /**
   * Given a pair of tokens (this and endToken), compute a `Token` encompassing
   * the whole input range enclosed by these two.
   */
  range(endToken, text4) {
    return new Token(text4, SourceLocation.range(this, endToken));
  }
};
var ParseError = class {
  // Error start position based on passed-in Token or ParseNode.
  // Length of affected text based on passed-in Token or ParseNode.
  // The underlying error message without any context added.
  constructor(message, token) {
    this.name = void 0;
    this.position = void 0;
    this.length = void 0;
    this.rawMessage = void 0;
    var error = "KaTeX parse error: " + message;
    var start;
    var end;
    var loc = token && token.loc;
    if (loc && loc.start <= loc.end) {
      var input = loc.lexer.input;
      start = loc.start;
      end = loc.end;
      if (start === input.length) {
        error += " at end of input: ";
      } else {
        error += " at position " + (start + 1) + ": ";
      }
      var underlined = input.slice(start, end).replace(/[^]/g, "$&\u0332");
      var left;
      if (start > 15) {
        left = "\u2026" + input.slice(start - 15, start);
      } else {
        left = input.slice(0, start);
      }
      var right;
      if (end + 15 < input.length) {
        right = input.slice(end, end + 15) + "\u2026";
      } else {
        right = input.slice(end);
      }
      error += left + underlined + right;
    }
    var self2 = new Error(error);
    self2.name = "ParseError";
    self2.__proto__ = ParseError.prototype;
    self2.position = start;
    if (start != null && end != null) {
      self2.length = end - start;
    }
    self2.rawMessage = message;
    return self2;
  }
};
ParseError.prototype.__proto__ = Error.prototype;
var contains = function contains2(list2, elem) {
  return list2.indexOf(elem) !== -1;
};
var deflt = function deflt2(setting, defaultIfUndefined) {
  return setting === void 0 ? defaultIfUndefined : setting;
};
var uppercase = /([A-Z])/g;
var hyphenate = function hyphenate2(str) {
  return str.replace(uppercase, "-$1").toLowerCase();
};
var ESCAPE_LOOKUP = {
  "&": "&amp;",
  ">": "&gt;",
  "<": "&lt;",
  '"': "&quot;",
  "'": "&#x27;"
};
var ESCAPE_REGEX = /[&><"']/g;
function escape(text4) {
  return String(text4).replace(ESCAPE_REGEX, (match) => ESCAPE_LOOKUP[match]);
}
var getBaseElem = function getBaseElem2(group) {
  if (group.type === "ordgroup") {
    if (group.body.length === 1) {
      return getBaseElem2(group.body[0]);
    } else {
      return group;
    }
  } else if (group.type === "color") {
    if (group.body.length === 1) {
      return getBaseElem2(group.body[0]);
    } else {
      return group;
    }
  } else if (group.type === "font") {
    return getBaseElem2(group.body);
  } else {
    return group;
  }
};
var isCharacterBox = function isCharacterBox2(group) {
  var baseElem = getBaseElem(group);
  return baseElem.type === "mathord" || baseElem.type === "textord" || baseElem.type === "atom";
};
var assert = function assert2(value) {
  if (!value) {
    throw new Error("Expected non-null, but got " + String(value));
  }
  return value;
};
var protocolFromUrl = function protocolFromUrl2(url) {
  var protocol = /^\s*([^\\/#]*?)(?::|&#0*58|&#x0*3a)/i.exec(url);
  return protocol != null ? protocol[1] : "_relative";
};
var utils = {
  contains,
  deflt,
  escape,
  hyphenate,
  getBaseElem,
  isCharacterBox,
  protocolFromUrl
};
var SETTINGS_SCHEMA = {
  displayMode: {
    type: "boolean",
    description: "Render math in display mode, which puts the math in display style (so \\int and \\sum are large, for example), and centers the math on the page on its own line.",
    cli: "-d, --display-mode"
  },
  output: {
    type: {
      enum: ["htmlAndMathml", "html", "mathml"]
    },
    description: "Determines the markup language of the output.",
    cli: "-F, --format <type>"
  },
  leqno: {
    type: "boolean",
    description: "Render display math in leqno style (left-justified tags)."
  },
  fleqn: {
    type: "boolean",
    description: "Render display math flush left."
  },
  throwOnError: {
    type: "boolean",
    default: true,
    cli: "-t, --no-throw-on-error",
    cliDescription: "Render errors (in the color given by --error-color) instead of throwing a ParseError exception when encountering an error."
  },
  errorColor: {
    type: "string",
    default: "#cc0000",
    cli: "-c, --error-color <color>",
    cliDescription: "A color string given in the format 'rgb' or 'rrggbb' (no #). This option determines the color of errors rendered by the -t option.",
    cliProcessor: (color) => "#" + color
  },
  macros: {
    type: "object",
    cli: "-m, --macro <def>",
    cliDescription: "Define custom macro of the form '\\foo:expansion' (use multiple -m arguments for multiple macros).",
    cliDefault: [],
    cliProcessor: (def, defs) => {
      defs.push(def);
      return defs;
    }
  },
  minRuleThickness: {
    type: "number",
    description: "Specifies a minimum thickness, in ems, for fraction lines, `\\sqrt` top lines, `{array}` vertical lines, `\\hline`, `\\hdashline`, `\\underline`, `\\overline`, and the borders of `\\fbox`, `\\boxed`, and `\\fcolorbox`.",
    processor: (t2) => Math.max(0, t2),
    cli: "--min-rule-thickness <size>",
    cliProcessor: parseFloat
  },
  colorIsTextColor: {
    type: "boolean",
    description: "Makes \\color behave like LaTeX's 2-argument \\textcolor, instead of LaTeX's one-argument \\color mode change.",
    cli: "-b, --color-is-text-color"
  },
  strict: {
    type: [{
      enum: ["warn", "ignore", "error"]
    }, "boolean", "function"],
    description: "Turn on strict / LaTeX faithfulness mode, which throws an error if the input uses features that are not supported by LaTeX.",
    cli: "-S, --strict",
    cliDefault: false
  },
  trust: {
    type: ["boolean", "function"],
    description: "Trust the input, enabling all HTML features such as \\url.",
    cli: "-T, --trust"
  },
  maxSize: {
    type: "number",
    default: Infinity,
    description: "If non-zero, all user-specified sizes, e.g. in \\rule{500em}{500em}, will be capped to maxSize ems. Otherwise, elements and spaces can be arbitrarily large",
    processor: (s2) => Math.max(0, s2),
    cli: "-s, --max-size <n>",
    cliProcessor: parseInt
  },
  maxExpand: {
    type: "number",
    default: 1e3,
    description: "Limit the number of macro expansions to the specified number, to prevent e.g. infinite macro loops. If set to Infinity, the macro expander will try to fully expand as in LaTeX.",
    processor: (n2) => Math.max(0, n2),
    cli: "-e, --max-expand <n>",
    cliProcessor: (n2) => n2 === "Infinity" ? Infinity : parseInt(n2)
  },
  globalGroup: {
    type: "boolean",
    cli: false
  }
};
function getDefaultValue(schema) {
  if (schema.default) {
    return schema.default;
  }
  var type = schema.type;
  var defaultType = Array.isArray(type) ? type[0] : type;
  if (typeof defaultType !== "string") {
    return defaultType.enum[0];
  }
  switch (defaultType) {
    case "boolean":
      return false;
    case "string":
      return "";
    case "number":
      return 0;
    case "object":
      return {};
  }
}
var Settings = class {
  constructor(options) {
    this.displayMode = void 0;
    this.output = void 0;
    this.leqno = void 0;
    this.fleqn = void 0;
    this.throwOnError = void 0;
    this.errorColor = void 0;
    this.macros = void 0;
    this.minRuleThickness = void 0;
    this.colorIsTextColor = void 0;
    this.strict = void 0;
    this.trust = void 0;
    this.maxSize = void 0;
    this.maxExpand = void 0;
    this.globalGroup = void 0;
    options = options || {};
    for (var prop in SETTINGS_SCHEMA) {
      if (SETTINGS_SCHEMA.hasOwnProperty(prop)) {
        var schema = SETTINGS_SCHEMA[prop];
        this[prop] = options[prop] !== void 0 ? schema.processor ? schema.processor(options[prop]) : options[prop] : getDefaultValue(schema);
      }
    }
  }
  /**
   * Report nonstrict (non-LaTeX-compatible) input.
   * Can safely not be called if `this.strict` is false in JavaScript.
   */
  reportNonstrict(errorCode, errorMsg, token) {
    var strict = this.strict;
    if (typeof strict === "function") {
      strict = strict(errorCode, errorMsg, token);
    }
    if (!strict || strict === "ignore") {
      return;
    } else if (strict === true || strict === "error") {
      throw new ParseError("LaTeX-incompatible input and strict mode is set to 'error': " + (errorMsg + " [" + errorCode + "]"), token);
    } else if (strict === "warn") {
      typeof console !== "undefined" && console.warn("LaTeX-incompatible input and strict mode is set to 'warn': " + (errorMsg + " [" + errorCode + "]"));
    } else {
      typeof console !== "undefined" && console.warn("LaTeX-incompatible input and strict mode is set to " + ("unrecognized '" + strict + "': " + errorMsg + " [" + errorCode + "]"));
    }
  }
  /**
   * Check whether to apply strict (LaTeX-adhering) behavior for unusual
   * input (like `\\`).  Unlike `nonstrict`, will not throw an error;
   * instead, "error" translates to a return value of `true`, while "ignore"
   * translates to a return value of `false`.  May still print a warning:
   * "warn" prints a warning and returns `false`.
   * This is for the second category of `errorCode`s listed in the README.
   */
  useStrictBehavior(errorCode, errorMsg, token) {
    var strict = this.strict;
    if (typeof strict === "function") {
      try {
        strict = strict(errorCode, errorMsg, token);
      } catch (error) {
        strict = "error";
      }
    }
    if (!strict || strict === "ignore") {
      return false;
    } else if (strict === true || strict === "error") {
      return true;
    } else if (strict === "warn") {
      typeof console !== "undefined" && console.warn("LaTeX-incompatible input and strict mode is set to 'warn': " + (errorMsg + " [" + errorCode + "]"));
      return false;
    } else {
      typeof console !== "undefined" && console.warn("LaTeX-incompatible input and strict mode is set to " + ("unrecognized '" + strict + "': " + errorMsg + " [" + errorCode + "]"));
      return false;
    }
  }
  /**
   * Check whether to test potentially dangerous input, and return
   * `true` (trusted) or `false` (untrusted).  The sole argument `context`
   * should be an object with `command` field specifying the relevant LaTeX
   * command (as a string starting with `\`), and any other arguments, etc.
   * If `context` has a `url` field, a `protocol` field will automatically
   * get added by this function (changing the specified object).
   */
  isTrusted(context) {
    if (context.url && !context.protocol) {
      context.protocol = utils.protocolFromUrl(context.url);
    }
    var trust = typeof this.trust === "function" ? this.trust(context) : this.trust;
    return Boolean(trust);
  }
};
var Style3 = class {
  constructor(id, size2, cramped) {
    this.id = void 0;
    this.size = void 0;
    this.cramped = void 0;
    this.id = id;
    this.size = size2;
    this.cramped = cramped;
  }
  /**
   * Get the style of a superscript given a base in the current style.
   */
  sup() {
    return styles[sup[this.id]];
  }
  /**
   * Get the style of a subscript given a base in the current style.
   */
  sub() {
    return styles[sub[this.id]];
  }
  /**
   * Get the style of a fraction numerator given the fraction in the current
   * style.
   */
  fracNum() {
    return styles[fracNum[this.id]];
  }
  /**
   * Get the style of a fraction denominator given the fraction in the current
   * style.
   */
  fracDen() {
    return styles[fracDen[this.id]];
  }
  /**
   * Get the cramped version of a style (in particular, cramping a cramped style
   * doesn't change the style).
   */
  cramp() {
    return styles[cramp[this.id]];
  }
  /**
   * Get a text or display version of this style.
   */
  text() {
    return styles[text$1[this.id]];
  }
  /**
   * Return true if this style is tightly spaced (scriptstyle/scriptscriptstyle)
   */
  isTight() {
    return this.size >= 2;
  }
};
var D = 0;
var Dc = 1;
var T2 = 2;
var Tc = 3;
var S = 4;
var Sc = 5;
var SS = 6;
var SSc = 7;
var styles = [new Style3(D, 0, false), new Style3(Dc, 0, true), new Style3(T2, 1, false), new Style3(Tc, 1, true), new Style3(S, 2, false), new Style3(Sc, 2, true), new Style3(SS, 3, false), new Style3(SSc, 3, true)];
var sup = [S, Sc, S, Sc, SS, SSc, SS, SSc];
var sub = [Sc, Sc, Sc, Sc, SSc, SSc, SSc, SSc];
var fracNum = [T2, Tc, S, Sc, SS, SSc, SS, SSc];
var fracDen = [Tc, Tc, Sc, Sc, SSc, SSc, SSc, SSc];
var cramp = [Dc, Dc, Tc, Tc, Sc, Sc, SSc, SSc];
var text$1 = [D, Dc, T2, Tc, T2, Tc, T2, Tc];
var Style$1 = {
  DISPLAY: styles[D],
  TEXT: styles[T2],
  SCRIPT: styles[S],
  SCRIPTSCRIPT: styles[SS]
};
var scriptData = [{
  // Latin characters beyond the Latin-1 characters we have metrics for.
  // Needed for Czech, Hungarian and Turkish text, for example.
  name: "latin",
  blocks: [
    [256, 591],
    // Latin Extended-A and Latin Extended-B
    [768, 879]
    // Combining Diacritical marks
  ]
}, {
  // The Cyrillic script used by Russian and related languages.
  // A Cyrillic subset used to be supported as explicitly defined
  // symbols in symbols.js
  name: "cyrillic",
  blocks: [[1024, 1279]]
}, {
  // Armenian
  name: "armenian",
  blocks: [[1328, 1423]]
}, {
  // The Brahmic scripts of South and Southeast Asia
  // Devanagari (0900–097F)
  // Bengali (0980–09FF)
  // Gurmukhi (0A00–0A7F)
  // Gujarati (0A80–0AFF)
  // Oriya (0B00–0B7F)
  // Tamil (0B80–0BFF)
  // Telugu (0C00–0C7F)
  // Kannada (0C80–0CFF)
  // Malayalam (0D00–0D7F)
  // Sinhala (0D80–0DFF)
  // Thai (0E00–0E7F)
  // Lao (0E80–0EFF)
  // Tibetan (0F00–0FFF)
  // Myanmar (1000–109F)
  name: "brahmic",
  blocks: [[2304, 4255]]
}, {
  name: "georgian",
  blocks: [[4256, 4351]]
}, {
  // Chinese and Japanese.
  // The "k" in cjk is for Korean, but we've separated Korean out
  name: "cjk",
  blocks: [
    [12288, 12543],
    // CJK symbols and punctuation, Hiragana, Katakana
    [19968, 40879],
    // CJK ideograms
    [65280, 65376]
    // Fullwidth punctuation
    // TODO: add halfwidth Katakana and Romanji glyphs
  ]
}, {
  // Korean
  name: "hangul",
  blocks: [[44032, 55215]]
}];
function scriptFromCodepoint(codepoint) {
  for (var i2 = 0; i2 < scriptData.length; i2++) {
    var script = scriptData[i2];
    for (var _i = 0; _i < script.blocks.length; _i++) {
      var block = script.blocks[_i];
      if (codepoint >= block[0] && codepoint <= block[1]) {
        return script.name;
      }
    }
  }
  return null;
}
var allBlocks = [];
scriptData.forEach((s2) => s2.blocks.forEach((b) => allBlocks.push(...b)));
function supportedCodepoint(codepoint) {
  for (var i2 = 0; i2 < allBlocks.length; i2 += 2) {
    if (codepoint >= allBlocks[i2] && codepoint <= allBlocks[i2 + 1]) {
      return true;
    }
  }
  return false;
}
var hLinePad = 80;
var sqrtMain = function sqrtMain2(extraVinculum, hLinePad2) {
  return "M95," + (622 + extraVinculum + hLinePad2) + "\nc-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14\nc0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54\nc44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10\ns173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429\nc69,-144,104.5,-217.7,106.5,-221\nl" + extraVinculum / 2.075 + " -" + extraVinculum + "\nc5.3,-9.3,12,-14,20,-14\nH400000v" + (40 + extraVinculum) + "H845.2724\ns-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7\nc-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z\nM" + (834 + extraVinculum) + " " + hLinePad2 + "h400000v" + (40 + extraVinculum) + "h-400000z";
};
var sqrtSize1 = function sqrtSize12(extraVinculum, hLinePad2) {
  return "M263," + (601 + extraVinculum + hLinePad2) + "c0.7,0,18,39.7,52,119\nc34,79.3,68.167,158.7,102.5,238c34.3,79.3,51.8,119.3,52.5,120\nc340,-704.7,510.7,-1060.3,512,-1067\nl" + extraVinculum / 2.084 + " -" + extraVinculum + "\nc4.7,-7.3,11,-11,19,-11\nH40000v" + (40 + extraVinculum) + "H1012.3\ns-271.3,567,-271.3,567c-38.7,80.7,-84,175,-136,283c-52,108,-89.167,185.3,-111.5,232\nc-22.3,46.7,-33.8,70.3,-34.5,71c-4.7,4.7,-12.3,7,-23,7s-12,-1,-12,-1\ns-109,-253,-109,-253c-72.7,-168,-109.3,-252,-110,-252c-10.7,8,-22,16.7,-34,26\nc-22,17.3,-33.3,26,-34,26s-26,-26,-26,-26s76,-59,76,-59s76,-60,76,-60z\nM" + (1001 + extraVinculum) + " " + hLinePad2 + "h400000v" + (40 + extraVinculum) + "h-400000z";
};
var sqrtSize2 = function sqrtSize22(extraVinculum, hLinePad2) {
  return "M983 " + (10 + extraVinculum + hLinePad2) + "\nl" + extraVinculum / 3.13 + " -" + extraVinculum + "\nc4,-6.7,10,-10,18,-10 H400000v" + (40 + extraVinculum) + "\nH1013.1s-83.4,268,-264.1,840c-180.7,572,-277,876.3,-289,913c-4.7,4.7,-12.7,7,-24,7\ns-12,0,-12,0c-1.3,-3.3,-3.7,-11.7,-7,-25c-35.3,-125.3,-106.7,-373.3,-214,-744\nc-10,12,-21,25,-33,39s-32,39,-32,39c-6,-5.3,-15,-14,-27,-26s25,-30,25,-30\nc26.7,-32.7,52,-63,76,-91s52,-60,52,-60s208,722,208,722\nc56,-175.3,126.3,-397.3,211,-666c84.7,-268.7,153.8,-488.2,207.5,-658.5\nc53.7,-170.3,84.5,-266.8,92.5,-289.5z\nM" + (1001 + extraVinculum) + " " + hLinePad2 + "h400000v" + (40 + extraVinculum) + "h-400000z";
};
var sqrtSize3 = function sqrtSize32(extraVinculum, hLinePad2) {
  return "M424," + (2398 + extraVinculum + hLinePad2) + "\nc-1.3,-0.7,-38.5,-172,-111.5,-514c-73,-342,-109.8,-513.3,-110.5,-514\nc0,-2,-10.7,14.3,-32,49c-4.7,7.3,-9.8,15.7,-15.5,25c-5.7,9.3,-9.8,16,-12.5,20\ns-5,7,-5,7c-4,-3.3,-8.3,-7.7,-13,-13s-13,-13,-13,-13s76,-122,76,-122s77,-121,77,-121\ns209,968,209,968c0,-2,84.7,-361.7,254,-1079c169.3,-717.3,254.7,-1077.7,256,-1081\nl" + extraVinculum / 4.223 + " -" + extraVinculum + "c4,-6.7,10,-10,18,-10 H400000\nv" + (40 + extraVinculum) + "H1014.6\ns-87.3,378.7,-272.6,1166c-185.3,787.3,-279.3,1182.3,-282,1185\nc-2,6,-10,9,-24,9\nc-8,0,-12,-0.7,-12,-2z M" + (1001 + extraVinculum) + " " + hLinePad2 + "\nh400000v" + (40 + extraVinculum) + "h-400000z";
};
var sqrtSize4 = function sqrtSize42(extraVinculum, hLinePad2) {
  return "M473," + (2713 + extraVinculum + hLinePad2) + "\nc339.3,-1799.3,509.3,-2700,510,-2702 l" + extraVinculum / 5.298 + " -" + extraVinculum + "\nc3.3,-7.3,9.3,-11,18,-11 H400000v" + (40 + extraVinculum) + "H1017.7\ns-90.5,478,-276.2,1466c-185.7,988,-279.5,1483,-281.5,1485c-2,6,-10,9,-24,9\nc-8,0,-12,-0.7,-12,-2c0,-1.3,-5.3,-32,-16,-92c-50.7,-293.3,-119.7,-693.3,-207,-1200\nc0,-1.3,-5.3,8.7,-16,30c-10.7,21.3,-21.3,42.7,-32,64s-16,33,-16,33s-26,-26,-26,-26\ns76,-153,76,-153s77,-151,77,-151c0.7,0.7,35.7,202,105,604c67.3,400.7,102,602.7,104,\n606zM" + (1001 + extraVinculum) + " " + hLinePad2 + "h400000v" + (40 + extraVinculum) + "H1017.7z";
};
var phasePath = function phasePath2(y3) {
  var x2 = y3 / 2;
  return "M400000 " + y3 + " H0 L" + x2 + " 0 l65 45 L145 " + (y3 - 80) + " H400000z";
};
var sqrtTall = function sqrtTall2(extraVinculum, hLinePad2, viewBoxHeight) {
  var vertSegment = viewBoxHeight - 54 - hLinePad2 - extraVinculum;
  return "M702 " + (extraVinculum + hLinePad2) + "H400000" + (40 + extraVinculum) + "\nH742v" + vertSegment + "l-4 4-4 4c-.667.7 -2 1.5-4 2.5s-4.167 1.833-6.5 2.5-5.5 1-9.5 1\nh-12l-28-84c-16.667-52-96.667 -294.333-240-727l-212 -643 -85 170\nc-4-3.333-8.333-7.667-13 -13l-13-13l77-155 77-156c66 199.333 139 419.667\n219 661 l218 661zM702 " + hLinePad2 + "H400000v" + (40 + extraVinculum) + "H742z";
};
var sqrtPath = function sqrtPath2(size2, extraVinculum, viewBoxHeight) {
  extraVinculum = 1e3 * extraVinculum;
  var path2 = "";
  switch (size2) {
    case "sqrtMain":
      path2 = sqrtMain(extraVinculum, hLinePad);
      break;
    case "sqrtSize1":
      path2 = sqrtSize1(extraVinculum, hLinePad);
      break;
    case "sqrtSize2":
      path2 = sqrtSize2(extraVinculum, hLinePad);
      break;
    case "sqrtSize3":
      path2 = sqrtSize3(extraVinculum, hLinePad);
      break;
    case "sqrtSize4":
      path2 = sqrtSize4(extraVinculum, hLinePad);
      break;
    case "sqrtTall":
      path2 = sqrtTall(extraVinculum, hLinePad, viewBoxHeight);
  }
  return path2;
};
var innerPath = function innerPath2(name, height2) {
  switch (name) {
    case "\u239C":
      return "M291 0 H417 V" + height2 + " H291z M291 0 H417 V" + height2 + " H291z";
    case "\u2223":
      return "M145 0 H188 V" + height2 + " H145z M145 0 H188 V" + height2 + " H145z";
    case "\u2225":
      return "M145 0 H188 V" + height2 + " H145z M145 0 H188 V" + height2 + " H145z" + ("M367 0 H410 V" + height2 + " H367z M367 0 H410 V" + height2 + " H367z");
    case "\u239F":
      return "M457 0 H583 V" + height2 + " H457z M457 0 H583 V" + height2 + " H457z";
    case "\u23A2":
      return "M319 0 H403 V" + height2 + " H319z M319 0 H403 V" + height2 + " H319z";
    case "\u23A5":
      return "M263 0 H347 V" + height2 + " H263z M263 0 H347 V" + height2 + " H263z";
    case "\u23AA":
      return "M384 0 H504 V" + height2 + " H384z M384 0 H504 V" + height2 + " H384z";
    case "\u23D0":
      return "M312 0 H355 V" + height2 + " H312z M312 0 H355 V" + height2 + " H312z";
    case "\u2016":
      return "M257 0 H300 V" + height2 + " H257z M257 0 H300 V" + height2 + " H257z" + ("M478 0 H521 V" + height2 + " H478z M478 0 H521 V" + height2 + " H478z");
    default:
      return "";
  }
};
var path = {
  // The doubleleftarrow geometry is from glyph U+21D0 in the font KaTeX Main
  doubleleftarrow: "M262 157\nl10-10c34-36 62.7-77 86-123 3.3-8 5-13.3 5-16 0-5.3-6.7-8-20-8-7.3\n 0-12.2.5-14.5 1.5-2.3 1-4.8 4.5-7.5 10.5-49.3 97.3-121.7 169.3-217 216-28\n 14-57.3 25-88 33-6.7 2-11 3.8-13 5.5-2 1.7-3 4.2-3 7.5s1 5.8 3 7.5\nc2 1.7 6.3 3.5 13 5.5 68 17.3 128.2 47.8 180.5 91.5 52.3 43.7 93.8 96.2 124.5\n 157.5 9.3 8 15.3 12.3 18 13h6c12-.7 18-4 18-10 0-2-1.7-7-5-15-23.3-46-52-87\n-86-123l-10-10h399738v-40H218c328 0 0 0 0 0l-10-8c-26.7-20-65.7-43-117-69 2.7\n-2 6-3.7 10-5 36.7-16 72.3-37.3 107-64l10-8h399782v-40z\nm8 0v40h399730v-40zm0 194v40h399730v-40z",
  // doublerightarrow is from glyph U+21D2 in font KaTeX Main
  doublerightarrow: "M399738 392l\n-10 10c-34 36-62.7 77-86 123-3.3 8-5 13.3-5 16 0 5.3 6.7 8 20 8 7.3 0 12.2-.5\n 14.5-1.5 2.3-1 4.8-4.5 7.5-10.5 49.3-97.3 121.7-169.3 217-216 28-14 57.3-25 88\n-33 6.7-2 11-3.8 13-5.5 2-1.7 3-4.2 3-7.5s-1-5.8-3-7.5c-2-1.7-6.3-3.5-13-5.5-68\n-17.3-128.2-47.8-180.5-91.5-52.3-43.7-93.8-96.2-124.5-157.5-9.3-8-15.3-12.3-18\n-13h-6c-12 .7-18 4-18 10 0 2 1.7 7 5 15 23.3 46 52 87 86 123l10 10H0v40h399782\nc-328 0 0 0 0 0l10 8c26.7 20 65.7 43 117 69-2.7 2-6 3.7-10 5-36.7 16-72.3 37.3\n-107 64l-10 8H0v40zM0 157v40h399730v-40zm0 194v40h399730v-40z",
  // leftarrow is from glyph U+2190 in font KaTeX Main
  leftarrow: "M400000 241H110l3-3c68.7-52.7 113.7-120\n 135-202 4-14.7 6-23 6-25 0-7.3-7-11-21-11-8 0-13.2.8-15.5 2.5-2.3 1.7-4.2 5.8\n-5.5 12.5-1.3 4.7-2.7 10.3-4 17-12 48.7-34.8 92-68.5 130S65.3 228.3 18 247\nc-10 4-16 7.7-18 11 0 8.7 6 14.3 18 17 47.3 18.7 87.8 47 121.5 85S196 441.3 208\n 490c.7 2 1.3 5 2 9s1.2 6.7 1.5 8c.3 1.3 1 3.3 2 6s2.2 4.5 3.5 5.5c1.3 1 3.3\n 1.8 6 2.5s6 1 10 1c14 0 21-3.7 21-11 0-2-2-10.3-6-25-20-79.3-65-146.7-135-202\n l-3-3h399890zM100 241v40h399900v-40z",
  // overbrace is from glyphs U+23A9/23A8/23A7 in font KaTeX_Size4-Regular
  leftbrace: "M6 548l-6-6v-35l6-11c56-104 135.3-181.3 238-232 57.3-28.7 117\n-45 179-50h399577v120H403c-43.3 7-81 15-113 26-100.7 33-179.7 91-237 174-2.7\n 5-6 9-10 13-.7 1-7.3 1-20 1H6z",
  leftbraceunder: "M0 6l6-6h17c12.688 0 19.313.3 20 1 4 4 7.313 8.3 10 13\n 35.313 51.3 80.813 93.8 136.5 127.5 55.688 33.7 117.188 55.8 184.5 66.5.688\n 0 2 .3 4 1 18.688 2.7 76 4.3 172 5h399450v120H429l-6-1c-124.688-8-235-61.7\n-331-161C60.687 138.7 32.312 99.3 7 54L0 41V6z",
  // overgroup is from the MnSymbol package (public domain)
  leftgroup: "M400000 80\nH435C64 80 168.3 229.4 21 260c-5.9 1.2-18 0-18 0-2 0-3-1-3-3v-38C76 61 257 0\n 435 0h399565z",
  leftgroupunder: "M400000 262\nH435C64 262 168.3 112.6 21 82c-5.9-1.2-18 0-18 0-2 0-3 1-3 3v38c76 158 257 219\n 435 219h399565z",
  // Harpoons are from glyph U+21BD in font KaTeX Main
  leftharpoon: "M0 267c.7 5.3 3 10 7 14h399993v-40H93c3.3\n-3.3 10.2-9.5 20.5-18.5s17.8-15.8 22.5-20.5c50.7-52 88-110.3 112-175 4-11.3 5\n-18.3 3-21-1.3-4-7.3-6-18-6-8 0-13 .7-15 2s-4.7 6.7-8 16c-42 98.7-107.3 174.7\n-196 228-6.7 4.7-10.7 8-12 10-1.3 2-2 5.7-2 11zm100-26v40h399900v-40z",
  leftharpoonplus: "M0 267c.7 5.3 3 10 7 14h399993v-40H93c3.3-3.3 10.2-9.5\n 20.5-18.5s17.8-15.8 22.5-20.5c50.7-52 88-110.3 112-175 4-11.3 5-18.3 3-21-1.3\n-4-7.3-6-18-6-8 0-13 .7-15 2s-4.7 6.7-8 16c-42 98.7-107.3 174.7-196 228-6.7 4.7\n-10.7 8-12 10-1.3 2-2 5.7-2 11zm100-26v40h399900v-40zM0 435v40h400000v-40z\nm0 0v40h400000v-40z",
  leftharpoondown: "M7 241c-4 4-6.333 8.667-7 14 0 5.333.667 9 2 11s5.333\n 5.333 12 10c90.667 54 156 130 196 228 3.333 10.667 6.333 16.333 9 17 2 .667 5\n 1 9 1h5c10.667 0 16.667-2 18-6 2-2.667 1-9.667-3-21-32-87.333-82.667-157.667\n-152-211l-3-3h399907v-40zM93 281 H400000 v-40L7 241z",
  leftharpoondownplus: "M7 435c-4 4-6.3 8.7-7 14 0 5.3.7 9 2 11s5.3 5.3 12\n 10c90.7 54 156 130 196 228 3.3 10.7 6.3 16.3 9 17 2 .7 5 1 9 1h5c10.7 0 16.7\n-2 18-6 2-2.7 1-9.7-3-21-32-87.3-82.7-157.7-152-211l-3-3h399907v-40H7zm93 0\nv40h399900v-40zM0 241v40h399900v-40zm0 0v40h399900v-40z",
  // hook is from glyph U+21A9 in font KaTeX Main
  lefthook: "M400000 281 H103s-33-11.2-61-33.5S0 197.3 0 164s14.2-61.2 42.5\n-83.5C70.8 58.2 104 47 142 47 c16.7 0 25 6.7 25 20 0 12-8.7 18.7-26 20-40 3.3\n-68.7 15.7-86 37-10 12-15 25.3-15 40 0 22.7 9.8 40.7 29.5 54 19.7 13.3 43.5 21\n 71.5 23h399859zM103 281v-40h399897v40z",
  leftlinesegment: "M40 281 V428 H0 V94 H40 V241 H400000 v40z\nM40 281 V428 H0 V94 H40 V241 H400000 v40z",
  leftmapsto: "M40 281 V448H0V74H40V241H400000v40z\nM40 281 V448H0V74H40V241H400000v40z",
  // tofrom is from glyph U+21C4 in font KaTeX AMS Regular
  leftToFrom: "M0 147h400000v40H0zm0 214c68 40 115.7 95.7 143 167h22c15.3 0 23\n-.3 23-1 0-1.3-5.3-13.7-16-37-18-35.3-41.3-69-70-101l-7-8h399905v-40H95l7-8\nc28.7-32 52-65.7 70-101 10.7-23.3 16-35.7 16-37 0-.7-7.7-1-23-1h-22C115.7 265.3\n 68 321 0 361zm0-174v-40h399900v40zm100 154v40h399900v-40z",
  longequal: "M0 50 h400000 v40H0z m0 194h40000v40H0z\nM0 50 h400000 v40H0z m0 194h40000v40H0z",
  midbrace: "M200428 334\nc-100.7-8.3-195.3-44-280-108-55.3-42-101.7-93-139-153l-9-14c-2.7 4-5.7 8.7-9 14\n-53.3 86.7-123.7 153-211 199-66.7 36-137.3 56.3-212 62H0V214h199568c178.3-11.7\n 311.7-78.3 403-201 6-8 9.7-12 11-12 .7-.7 6.7-1 18-1s17.3.3 18 1c1.3 0 5 4 11\n 12 44.7 59.3 101.3 106.3 170 141s145.3 54.3 229 60h199572v120z",
  midbraceunder: "M199572 214\nc100.7 8.3 195.3 44 280 108 55.3 42 101.7 93 139 153l9 14c2.7-4 5.7-8.7 9-14\n 53.3-86.7 123.7-153 211-199 66.7-36 137.3-56.3 212-62h199568v120H200432c-178.3\n 11.7-311.7 78.3-403 201-6 8-9.7 12-11 12-.7.7-6.7 1-18 1s-17.3-.3-18-1c-1.3 0\n-5-4-11-12-44.7-59.3-101.3-106.3-170-141s-145.3-54.3-229-60H0V214z",
  oiintSize1: "M512.6 71.6c272.6 0 320.3 106.8 320.3 178.2 0 70.8-47.7 177.6\n-320.3 177.6S193.1 320.6 193.1 249.8c0-71.4 46.9-178.2 319.5-178.2z\nm368.1 178.2c0-86.4-60.9-215.4-368.1-215.4-306.4 0-367.3 129-367.3 215.4 0 85.8\n60.9 214.8 367.3 214.8 307.2 0 368.1-129 368.1-214.8z",
  oiintSize2: "M757.8 100.1c384.7 0 451.1 137.6 451.1 230 0 91.3-66.4 228.8\n-451.1 228.8-386.3 0-452.7-137.5-452.7-228.8 0-92.4 66.4-230 452.7-230z\nm502.4 230c0-111.2-82.4-277.2-502.4-277.2s-504 166-504 277.2\nc0 110 84 276 504 276s502.4-166 502.4-276z",
  oiiintSize1: "M681.4 71.6c408.9 0 480.5 106.8 480.5 178.2 0 70.8-71.6 177.6\n-480.5 177.6S202.1 320.6 202.1 249.8c0-71.4 70.5-178.2 479.3-178.2z\nm525.8 178.2c0-86.4-86.8-215.4-525.7-215.4-437.9 0-524.7 129-524.7 215.4 0\n85.8 86.8 214.8 524.7 214.8 438.9 0 525.7-129 525.7-214.8z",
  oiiintSize2: "M1021.2 53c603.6 0 707.8 165.8 707.8 277.2 0 110-104.2 275.8\n-707.8 275.8-606 0-710.2-165.8-710.2-275.8C311 218.8 415.2 53 1021.2 53z\nm770.4 277.1c0-131.2-126.4-327.6-770.5-327.6S248.4 198.9 248.4 330.1\nc0 130 128.8 326.4 772.7 326.4s770.5-196.4 770.5-326.4z",
  rightarrow: "M0 241v40h399891c-47.3 35.3-84 78-110 128\n-16.7 32-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20\n 11 8 0 13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7\n 39-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85\n-40.5-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5\n-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67\n 151.7 139 205zm0 0v40h399900v-40z",
  rightbrace: "M400000 542l\n-6 6h-17c-12.7 0-19.3-.3-20-1-4-4-7.3-8.3-10-13-35.3-51.3-80.8-93.8-136.5-127.5\ns-117.2-55.8-184.5-66.5c-.7 0-2-.3-4-1-18.7-2.7-76-4.3-172-5H0V214h399571l6 1\nc124.7 8 235 61.7 331 161 31.3 33.3 59.7 72.7 85 118l7 13v35z",
  rightbraceunder: "M399994 0l6 6v35l-6 11c-56 104-135.3 181.3-238 232-57.3\n 28.7-117 45-179 50H-300V214h399897c43.3-7 81-15 113-26 100.7-33 179.7-91 237\n-174 2.7-5 6-9 10-13 .7-1 7.3-1 20-1h17z",
  rightgroup: "M0 80h399565c371 0 266.7 149.4 414 180 5.9 1.2 18 0 18 0 2 0\n 3-1 3-3v-38c-76-158-257-219-435-219H0z",
  rightgroupunder: "M0 262h399565c371 0 266.7-149.4 414-180 5.9-1.2 18 0 18\n 0 2 0 3 1 3 3v38c-76 158-257 219-435 219H0z",
  rightharpoon: "M0 241v40h399993c4.7-4.7 7-9.3 7-14 0-9.3\n-3.7-15.3-11-18-92.7-56.7-159-133.7-199-231-3.3-9.3-6-14.7-8-16-2-1.3-7-2-15-2\n-10.7 0-16.7 2-18 6-2 2.7-1 9.7 3 21 15.3 42 36.7 81.8 64 119.5 27.3 37.7 58\n 69.2 92 94.5zm0 0v40h399900v-40z",
  rightharpoonplus: "M0 241v40h399993c4.7-4.7 7-9.3 7-14 0-9.3-3.7-15.3-11\n-18-92.7-56.7-159-133.7-199-231-3.3-9.3-6-14.7-8-16-2-1.3-7-2-15-2-10.7 0-16.7\n 2-18 6-2 2.7-1 9.7 3 21 15.3 42 36.7 81.8 64 119.5 27.3 37.7 58 69.2 92 94.5z\nm0 0v40h399900v-40z m100 194v40h399900v-40zm0 0v40h399900v-40z",
  rightharpoondown: "M399747 511c0 7.3 6.7 11 20 11 8 0 13-.8 15-2.5s4.7-6.8\n 8-15.5c40-94 99.3-166.3 178-217 13.3-8 20.3-12.3 21-13 5.3-3.3 8.5-5.8 9.5\n-7.5 1-1.7 1.5-5.2 1.5-10.5s-2.3-10.3-7-15H0v40h399908c-34 25.3-64.7 57-92 95\n-27.3 38-48.7 77.7-64 119-3.3 8.7-5 14-5 16zM0 241v40h399900v-40z",
  rightharpoondownplus: "M399747 705c0 7.3 6.7 11 20 11 8 0 13-.8\n 15-2.5s4.7-6.8 8-15.5c40-94 99.3-166.3 178-217 13.3-8 20.3-12.3 21-13 5.3-3.3\n 8.5-5.8 9.5-7.5 1-1.7 1.5-5.2 1.5-10.5s-2.3-10.3-7-15H0v40h399908c-34 25.3\n-64.7 57-92 95-27.3 38-48.7 77.7-64 119-3.3 8.7-5 14-5 16zM0 435v40h399900v-40z\nm0-194v40h400000v-40zm0 0v40h400000v-40z",
  righthook: "M399859 241c-764 0 0 0 0 0 40-3.3 68.7-15.7 86-37 10-12 15-25.3\n 15-40 0-22.7-9.8-40.7-29.5-54-19.7-13.3-43.5-21-71.5-23-17.3-1.3-26-8-26-20 0\n-13.3 8.7-20 26-20 38 0 71 11.2 99 33.5 0 0 7 5.6 21 16.7 14 11.2 21 33.5 21\n 66.8s-14 61.2-42 83.5c-28 22.3-61 33.5-99 33.5L0 241z M0 281v-40h399859v40z",
  rightlinesegment: "M399960 241 V94 h40 V428 h-40 V281 H0 v-40z\nM399960 241 V94 h40 V428 h-40 V281 H0 v-40z",
  rightToFrom: "M400000 167c-70.7-42-118-97.7-142-167h-23c-15.3 0-23 .3-23\n 1 0 1.3 5.3 13.7 16 37 18 35.3 41.3 69 70 101l7 8H0v40h399905l-7 8c-28.7 32\n-52 65.7-70 101-10.7 23.3-16 35.7-16 37 0 .7 7.7 1 23 1h23c24-69.3 71.3-125 142\n-167z M100 147v40h399900v-40zM0 341v40h399900v-40z",
  // twoheadleftarrow is from glyph U+219E in font KaTeX AMS Regular
  twoheadleftarrow: "M0 167c68 40\n 115.7 95.7 143 167h22c15.3 0 23-.3 23-1 0-1.3-5.3-13.7-16-37-18-35.3-41.3-69\n-70-101l-7-8h125l9 7c50.7 39.3 85 86 103 140h46c0-4.7-6.3-18.7-19-42-18-35.3\n-40-67.3-66-96l-9-9h399716v-40H284l9-9c26-28.7 48-60.7 66-96 12.7-23.333 19\n-37.333 19-42h-46c-18 54-52.3 100.7-103 140l-9 7H95l7-8c28.7-32 52-65.7 70-101\n 10.7-23.333 16-35.7 16-37 0-.7-7.7-1-23-1h-22C115.7 71.3 68 127 0 167z",
  twoheadrightarrow: "M400000 167\nc-68-40-115.7-95.7-143-167h-22c-15.3 0-23 .3-23 1 0 1.3 5.3 13.7 16 37 18 35.3\n 41.3 69 70 101l7 8h-125l-9-7c-50.7-39.3-85-86-103-140h-46c0 4.7 6.3 18.7 19 42\n 18 35.3 40 67.3 66 96l9 9H0v40h399716l-9 9c-26 28.7-48 60.7-66 96-12.7 23.333\n-19 37.333-19 42h46c18-54 52.3-100.7 103-140l9-7h125l-7 8c-28.7 32-52 65.7-70\n 101-10.7 23.333-16 35.7-16 37 0 .7 7.7 1 23 1h22c27.3-71.3 75-127 143-167z",
  // tilde1 is a modified version of a glyph from the MnSymbol package
  tilde1: "M200 55.538c-77 0-168 73.953-177 73.953-3 0-7\n-2.175-9-5.437L2 97c-1-2-2-4-2-6 0-4 2-7 5-9l20-12C116 12 171 0 207 0c86 0\n 114 68 191 68 78 0 168-68 177-68 4 0 7 2 9 5l12 19c1 2.175 2 4.35 2 6.525 0\n 4.35-2 7.613-5 9.788l-19 13.05c-92 63.077-116.937 75.308-183 76.128\n-68.267.847-113-73.952-191-73.952z",
  // ditto tilde2, tilde3, & tilde4
  tilde2: "M344 55.266c-142 0-300.638 81.316-311.5 86.418\n-8.01 3.762-22.5 10.91-23.5 5.562L1 120c-1-2-1-3-1-4 0-5 3-9 8-10l18.4-9C160.9\n 31.9 283 0 358 0c148 0 188 122 331 122s314-97 326-97c4 0 8 2 10 7l7 21.114\nc1 2.14 1 3.21 1 4.28 0 5.347-3 9.626-7 10.696l-22.3 12.622C852.6 158.372 751\n 181.476 676 181.476c-149 0-189-126.21-332-126.21z",
  tilde3: "M786 59C457 59 32 175.242 13 175.242c-6 0-10-3.457\n-11-10.37L.15 138c-1-7 3-12 10-13l19.2-6.4C378.4 40.7 634.3 0 804.3 0c337 0\n 411.8 157 746.8 157 328 0 754-112 773-112 5 0 10 3 11 9l1 14.075c1 8.066-.697\n 16.595-6.697 17.492l-21.052 7.31c-367.9 98.146-609.15 122.696-778.15 122.696\n -338 0-409-156.573-744-156.573z",
  tilde4: "M786 58C457 58 32 177.487 13 177.487c-6 0-10-3.345\n-11-10.035L.15 143c-1-7 3-12 10-13l22-6.7C381.2 35 637.15 0 807.15 0c337 0 409\n 177 744 177 328 0 754-127 773-127 5 0 10 3 11 9l1 14.794c1 7.805-3 13.38-9\n 14.495l-20.7 5.574c-366.85 99.79-607.3 139.372-776.3 139.372-338 0-409\n -175.236-744-175.236z",
  // vec is from glyph U+20D7 in font KaTeX Main
  vec: "M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5\n3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11\n10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63\n-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1\n-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59\nH213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359\nc-16-25.333-24-45-24-59z",
  // widehat1 is a modified version of a glyph from the MnSymbol package
  widehat1: "M529 0h5l519 115c5 1 9 5 9 10 0 1-1 2-1 3l-4 22\nc-1 5-5 9-11 9h-2L532 67 19 159h-2c-5 0-9-4-11-9l-5-22c-1-6 2-12 8-13z",
  // ditto widehat2, widehat3, & widehat4
  widehat2: "M1181 0h2l1171 176c6 0 10 5 10 11l-2 23c-1 6-5 10\n-11 10h-1L1182 67 15 220h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z",
  widehat3: "M1181 0h2l1171 236c6 0 10 5 10 11l-2 23c-1 6-5 10\n-11 10h-1L1182 67 15 280h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z",
  widehat4: "M1181 0h2l1171 296c6 0 10 5 10 11l-2 23c-1 6-5 10\n-11 10h-1L1182 67 15 340h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z",
  // widecheck paths are all inverted versions of widehat
  widecheck1: "M529,159h5l519,-115c5,-1,9,-5,9,-10c0,-1,-1,-2,-1,-3l-4,-22c-1,\n-5,-5,-9,-11,-9h-2l-512,92l-513,-92h-2c-5,0,-9,4,-11,9l-5,22c-1,6,2,12,8,13z",
  widecheck2: "M1181,220h2l1171,-176c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,\n-11,-10h-1l-1168,153l-1167,-153h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z",
  widecheck3: "M1181,280h2l1171,-236c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,\n-11,-10h-1l-1168,213l-1167,-213h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z",
  widecheck4: "M1181,340h2l1171,-296c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,\n-11,-10h-1l-1168,273l-1167,-273h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z",
  // The next ten paths support reaction arrows from the mhchem package.
  // Arrows for \ce{<-->} are offset from xAxis by 0.22ex, per mhchem in LaTeX
  // baraboveleftarrow is mostly from glyph U+2190 in font KaTeX Main
  baraboveleftarrow: "M400000 620h-399890l3 -3c68.7 -52.7 113.7 -120 135 -202\nc4 -14.7 6 -23 6 -25c0 -7.3 -7 -11 -21 -11c-8 0 -13.2 0.8 -15.5 2.5\nc-2.3 1.7 -4.2 5.8 -5.5 12.5c-1.3 4.7 -2.7 10.3 -4 17c-12 48.7 -34.8 92 -68.5 130\ns-74.2 66.3 -121.5 85c-10 4 -16 7.7 -18 11c0 8.7 6 14.3 18 17c47.3 18.7 87.8 47\n121.5 85s56.5 81.3 68.5 130c0.7 2 1.3 5 2 9s1.2 6.7 1.5 8c0.3 1.3 1 3.3 2 6\ns2.2 4.5 3.5 5.5c1.3 1 3.3 1.8 6 2.5s6 1 10 1c14 0 21 -3.7 21 -11\nc0 -2 -2 -10.3 -6 -25c-20 -79.3 -65 -146.7 -135 -202l-3 -3h399890z\nM100 620v40h399900v-40z M0 241v40h399900v-40zM0 241v40h399900v-40z",
  // rightarrowabovebar is mostly from glyph U+2192, KaTeX Main
  rightarrowabovebar: "M0 241v40h399891c-47.3 35.3-84 78-110 128-16.7 32\n-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20 11 8 0\n13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7 39\n-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85-40.5\n-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5\n-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67\n151.7 139 205zm96 379h399894v40H0zm0 0h399904v40H0z",
  // The short left harpoon has 0.5em (i.e. 500 units) kern on the left end.
  // Ref from mhchem.sty: \rlap{\raisebox{-.22ex}{$\kern0.5em
  baraboveshortleftharpoon: "M507,435c-4,4,-6.3,8.7,-7,14c0,5.3,0.7,9,2,11\nc1.3,2,5.3,5.3,12,10c90.7,54,156,130,196,228c3.3,10.7,6.3,16.3,9,17\nc2,0.7,5,1,9,1c0,0,5,0,5,0c10.7,0,16.7,-2,18,-6c2,-2.7,1,-9.7,-3,-21\nc-32,-87.3,-82.7,-157.7,-152,-211c0,0,-3,-3,-3,-3l399351,0l0,-40\nc-398570,0,-399437,0,-399437,0z M593 435 v40 H399500 v-40z\nM0 281 v-40 H399908 v40z M0 281 v-40 H399908 v40z",
  rightharpoonaboveshortbar: "M0,241 l0,40c399126,0,399993,0,399993,0\nc4.7,-4.7,7,-9.3,7,-14c0,-9.3,-3.7,-15.3,-11,-18c-92.7,-56.7,-159,-133.7,-199,\n-231c-3.3,-9.3,-6,-14.7,-8,-16c-2,-1.3,-7,-2,-15,-2c-10.7,0,-16.7,2,-18,6\nc-2,2.7,-1,9.7,3,21c15.3,42,36.7,81.8,64,119.5c27.3,37.7,58,69.2,92,94.5z\nM0 241 v40 H399908 v-40z M0 475 v-40 H399500 v40z M0 475 v-40 H399500 v40z",
  shortbaraboveleftharpoon: "M7,435c-4,4,-6.3,8.7,-7,14c0,5.3,0.7,9,2,11\nc1.3,2,5.3,5.3,12,10c90.7,54,156,130,196,228c3.3,10.7,6.3,16.3,9,17c2,0.7,5,1,9,\n1c0,0,5,0,5,0c10.7,0,16.7,-2,18,-6c2,-2.7,1,-9.7,-3,-21c-32,-87.3,-82.7,-157.7,\n-152,-211c0,0,-3,-3,-3,-3l399907,0l0,-40c-399126,0,-399993,0,-399993,0z\nM93 435 v40 H400000 v-40z M500 241 v40 H400000 v-40z M500 241 v40 H400000 v-40z",
  shortrightharpoonabovebar: "M53,241l0,40c398570,0,399437,0,399437,0\nc4.7,-4.7,7,-9.3,7,-14c0,-9.3,-3.7,-15.3,-11,-18c-92.7,-56.7,-159,-133.7,-199,\n-231c-3.3,-9.3,-6,-14.7,-8,-16c-2,-1.3,-7,-2,-15,-2c-10.7,0,-16.7,2,-18,6\nc-2,2.7,-1,9.7,3,21c15.3,42,36.7,81.8,64,119.5c27.3,37.7,58,69.2,92,94.5z\nM500 241 v40 H399408 v-40z M500 435 v40 H400000 v-40z"
};
var tallDelim = function tallDelim2(label, midHeight) {
  switch (label) {
    case "lbrack":
      return "M403 1759 V84 H666 V0 H319 V1759 v" + midHeight + " v1759 h347 v-84\nH403z M403 1759 V0 H319 V1759 v" + midHeight + " v1759 h84z";
    case "rbrack":
      return "M347 1759 V0 H0 V84 H263 V1759 v" + midHeight + " v1759 H0 v84 H347z\nM347 1759 V0 H263 V1759 v" + midHeight + " v1759 h84z";
    case "vert":
      return "M145 15 v585 v" + midHeight + " v585 c2.667,10,9.667,15,21,15\nc10,0,16.667,-5,20,-15 v-585 v" + -midHeight + " v-585 c-2.667,-10,-9.667,-15,-21,-15\nc-10,0,-16.667,5,-20,15z M188 15 H145 v585 v" + midHeight + " v585 h43z";
    case "doublevert":
      return "M145 15 v585 v" + midHeight + " v585 c2.667,10,9.667,15,21,15\nc10,0,16.667,-5,20,-15 v-585 v" + -midHeight + " v-585 c-2.667,-10,-9.667,-15,-21,-15\nc-10,0,-16.667,5,-20,15z M188 15 H145 v585 v" + midHeight + " v585 h43z\nM367 15 v585 v" + midHeight + " v585 c2.667,10,9.667,15,21,15\nc10,0,16.667,-5,20,-15 v-585 v" + -midHeight + " v-585 c-2.667,-10,-9.667,-15,-21,-15\nc-10,0,-16.667,5,-20,15z M410 15 H367 v585 v" + midHeight + " v585 h43z";
    case "lfloor":
      return "M319 602 V0 H403 V602 v" + midHeight + " v1715 h263 v84 H319z\nMM319 602 V0 H403 V602 v" + midHeight + " v1715 H319z";
    case "rfloor":
      return "M319 602 V0 H403 V602 v" + midHeight + " v1799 H0 v-84 H319z\nMM319 602 V0 H403 V602 v" + midHeight + " v1715 H319z";
    case "lceil":
      return "M403 1759 V84 H666 V0 H319 V1759 v" + midHeight + " v602 h84z\nM403 1759 V0 H319 V1759 v" + midHeight + " v602 h84z";
    case "rceil":
      return "M347 1759 V0 H0 V84 H263 V1759 v" + midHeight + " v602 h84z\nM347 1759 V0 h-84 V1759 v" + midHeight + " v602 h84z";
    case "lparen":
      return "M863,9c0,-2,-2,-5,-6,-9c0,0,-17,0,-17,0c-12.7,0,-19.3,0.3,-20,1\nc-5.3,5.3,-10.3,11,-15,17c-242.7,294.7,-395.3,682,-458,1162c-21.3,163.3,-33.3,349,\n-36,557 l0," + (midHeight + 84) + "c0.2,6,0,26,0,60c2,159.3,10,310.7,24,454c53.3,528,210,\n949.7,470,1265c4.7,6,9.7,11.7,15,17c0.7,0.7,7,1,19,1c0,0,18,0,18,0c4,-4,6,-7,6,-9\nc0,-2.7,-3.3,-8.7,-10,-18c-135.3,-192.7,-235.5,-414.3,-300.5,-665c-65,-250.7,-102.5,\n-544.7,-112.5,-882c-2,-104,-3,-167,-3,-189\nl0,-" + (midHeight + 92) + "c0,-162.7,5.7,-314,17,-454c20.7,-272,63.7,-513,129,-723c65.3,\n-210,155.3,-396.3,270,-559c6.7,-9.3,10,-15.3,10,-18z";
    case "rparen":
      return "M76,0c-16.7,0,-25,3,-25,9c0,2,2,6.3,6,13c21.3,28.7,42.3,60.3,\n63,95c96.7,156.7,172.8,332.5,228.5,527.5c55.7,195,92.8,416.5,111.5,664.5\nc11.3,139.3,17,290.7,17,454c0,28,1.7,43,3.3,45l0," + (midHeight + 9) + "\nc-3,4,-3.3,16.7,-3.3,38c0,162,-5.7,313.7,-17,455c-18.7,248,-55.8,469.3,-111.5,664\nc-55.7,194.7,-131.8,370.3,-228.5,527c-20.7,34.7,-41.7,66.3,-63,95c-2,3.3,-4,7,-6,11\nc0,7.3,5.7,11,17,11c0,0,11,0,11,0c9.3,0,14.3,-0.3,15,-1c5.3,-5.3,10.3,-11,15,-17\nc242.7,-294.7,395.3,-681.7,458,-1161c21.3,-164.7,33.3,-350.7,36,-558\nl0,-" + (midHeight + 144) + "c-2,-159.3,-10,-310.7,-24,-454c-53.3,-528,-210,-949.7,\n-470,-1265c-4.7,-6,-9.7,-11.7,-15,-17c-0.7,-0.7,-6.7,-1,-18,-1z";
    default:
      throw new Error("Unknown stretchy delimiter.");
  }
};
var DocumentFragment = class {
  // HtmlDomNode
  // Never used; needed for satisfying interface.
  constructor(children) {
    this.children = void 0;
    this.classes = void 0;
    this.height = void 0;
    this.depth = void 0;
    this.maxFontSize = void 0;
    this.style = void 0;
    this.children = children;
    this.classes = [];
    this.height = 0;
    this.depth = 0;
    this.maxFontSize = 0;
    this.style = {};
  }
  hasClass(className) {
    return utils.contains(this.classes, className);
  }
  /** Convert the fragment into a node. */
  toNode() {
    var frag = document.createDocumentFragment();
    for (var i2 = 0; i2 < this.children.length; i2++) {
      frag.appendChild(this.children[i2].toNode());
    }
    return frag;
  }
  /** Convert the fragment into HTML markup. */
  toMarkup() {
    var markup = "";
    for (var i2 = 0; i2 < this.children.length; i2++) {
      markup += this.children[i2].toMarkup();
    }
    return markup;
  }
  /**
   * Converts the math node into a string, similar to innerText. Applies to
   * MathDomNode's only.
   */
  toText() {
    var toText = (child) => child.toText();
    return this.children.map(toText).join("");
  }
};
var fontMetricsData = {
  "AMS-Regular": {
    "32": [0, 0, 0, 0, 0.25],
    "65": [0, 0.68889, 0, 0, 0.72222],
    "66": [0, 0.68889, 0, 0, 0.66667],
    "67": [0, 0.68889, 0, 0, 0.72222],
    "68": [0, 0.68889, 0, 0, 0.72222],
    "69": [0, 0.68889, 0, 0, 0.66667],
    "70": [0, 0.68889, 0, 0, 0.61111],
    "71": [0, 0.68889, 0, 0, 0.77778],
    "72": [0, 0.68889, 0, 0, 0.77778],
    "73": [0, 0.68889, 0, 0, 0.38889],
    "74": [0.16667, 0.68889, 0, 0, 0.5],
    "75": [0, 0.68889, 0, 0, 0.77778],
    "76": [0, 0.68889, 0, 0, 0.66667],
    "77": [0, 0.68889, 0, 0, 0.94445],
    "78": [0, 0.68889, 0, 0, 0.72222],
    "79": [0.16667, 0.68889, 0, 0, 0.77778],
    "80": [0, 0.68889, 0, 0, 0.61111],
    "81": [0.16667, 0.68889, 0, 0, 0.77778],
    "82": [0, 0.68889, 0, 0, 0.72222],
    "83": [0, 0.68889, 0, 0, 0.55556],
    "84": [0, 0.68889, 0, 0, 0.66667],
    "85": [0, 0.68889, 0, 0, 0.72222],
    "86": [0, 0.68889, 0, 0, 0.72222],
    "87": [0, 0.68889, 0, 0, 1],
    "88": [0, 0.68889, 0, 0, 0.72222],
    "89": [0, 0.68889, 0, 0, 0.72222],
    "90": [0, 0.68889, 0, 0, 0.66667],
    "107": [0, 0.68889, 0, 0, 0.55556],
    "160": [0, 0, 0, 0, 0.25],
    "165": [0, 0.675, 0.025, 0, 0.75],
    "174": [0.15559, 0.69224, 0, 0, 0.94666],
    "240": [0, 0.68889, 0, 0, 0.55556],
    "295": [0, 0.68889, 0, 0, 0.54028],
    "710": [0, 0.825, 0, 0, 2.33334],
    "732": [0, 0.9, 0, 0, 2.33334],
    "770": [0, 0.825, 0, 0, 2.33334],
    "771": [0, 0.9, 0, 0, 2.33334],
    "989": [0.08167, 0.58167, 0, 0, 0.77778],
    "1008": [0, 0.43056, 0.04028, 0, 0.66667],
    "8245": [0, 0.54986, 0, 0, 0.275],
    "8463": [0, 0.68889, 0, 0, 0.54028],
    "8487": [0, 0.68889, 0, 0, 0.72222],
    "8498": [0, 0.68889, 0, 0, 0.55556],
    "8502": [0, 0.68889, 0, 0, 0.66667],
    "8503": [0, 0.68889, 0, 0, 0.44445],
    "8504": [0, 0.68889, 0, 0, 0.66667],
    "8513": [0, 0.68889, 0, 0, 0.63889],
    "8592": [-0.03598, 0.46402, 0, 0, 0.5],
    "8594": [-0.03598, 0.46402, 0, 0, 0.5],
    "8602": [-0.13313, 0.36687, 0, 0, 1],
    "8603": [-0.13313, 0.36687, 0, 0, 1],
    "8606": [0.01354, 0.52239, 0, 0, 1],
    "8608": [0.01354, 0.52239, 0, 0, 1],
    "8610": [0.01354, 0.52239, 0, 0, 1.11111],
    "8611": [0.01354, 0.52239, 0, 0, 1.11111],
    "8619": [0, 0.54986, 0, 0, 1],
    "8620": [0, 0.54986, 0, 0, 1],
    "8621": [-0.13313, 0.37788, 0, 0, 1.38889],
    "8622": [-0.13313, 0.36687, 0, 0, 1],
    "8624": [0, 0.69224, 0, 0, 0.5],
    "8625": [0, 0.69224, 0, 0, 0.5],
    "8630": [0, 0.43056, 0, 0, 1],
    "8631": [0, 0.43056, 0, 0, 1],
    "8634": [0.08198, 0.58198, 0, 0, 0.77778],
    "8635": [0.08198, 0.58198, 0, 0, 0.77778],
    "8638": [0.19444, 0.69224, 0, 0, 0.41667],
    "8639": [0.19444, 0.69224, 0, 0, 0.41667],
    "8642": [0.19444, 0.69224, 0, 0, 0.41667],
    "8643": [0.19444, 0.69224, 0, 0, 0.41667],
    "8644": [0.1808, 0.675, 0, 0, 1],
    "8646": [0.1808, 0.675, 0, 0, 1],
    "8647": [0.1808, 0.675, 0, 0, 1],
    "8648": [0.19444, 0.69224, 0, 0, 0.83334],
    "8649": [0.1808, 0.675, 0, 0, 1],
    "8650": [0.19444, 0.69224, 0, 0, 0.83334],
    "8651": [0.01354, 0.52239, 0, 0, 1],
    "8652": [0.01354, 0.52239, 0, 0, 1],
    "8653": [-0.13313, 0.36687, 0, 0, 1],
    "8654": [-0.13313, 0.36687, 0, 0, 1],
    "8655": [-0.13313, 0.36687, 0, 0, 1],
    "8666": [0.13667, 0.63667, 0, 0, 1],
    "8667": [0.13667, 0.63667, 0, 0, 1],
    "8669": [-0.13313, 0.37788, 0, 0, 1],
    "8672": [-0.064, 0.437, 0, 0, 1.334],
    "8674": [-0.064, 0.437, 0, 0, 1.334],
    "8705": [0, 0.825, 0, 0, 0.5],
    "8708": [0, 0.68889, 0, 0, 0.55556],
    "8709": [0.08167, 0.58167, 0, 0, 0.77778],
    "8717": [0, 0.43056, 0, 0, 0.42917],
    "8722": [-0.03598, 0.46402, 0, 0, 0.5],
    "8724": [0.08198, 0.69224, 0, 0, 0.77778],
    "8726": [0.08167, 0.58167, 0, 0, 0.77778],
    "8733": [0, 0.69224, 0, 0, 0.77778],
    "8736": [0, 0.69224, 0, 0, 0.72222],
    "8737": [0, 0.69224, 0, 0, 0.72222],
    "8738": [0.03517, 0.52239, 0, 0, 0.72222],
    "8739": [0.08167, 0.58167, 0, 0, 0.22222],
    "8740": [0.25142, 0.74111, 0, 0, 0.27778],
    "8741": [0.08167, 0.58167, 0, 0, 0.38889],
    "8742": [0.25142, 0.74111, 0, 0, 0.5],
    "8756": [0, 0.69224, 0, 0, 0.66667],
    "8757": [0, 0.69224, 0, 0, 0.66667],
    "8764": [-0.13313, 0.36687, 0, 0, 0.77778],
    "8765": [-0.13313, 0.37788, 0, 0, 0.77778],
    "8769": [-0.13313, 0.36687, 0, 0, 0.77778],
    "8770": [-0.03625, 0.46375, 0, 0, 0.77778],
    "8774": [0.30274, 0.79383, 0, 0, 0.77778],
    "8776": [-0.01688, 0.48312, 0, 0, 0.77778],
    "8778": [0.08167, 0.58167, 0, 0, 0.77778],
    "8782": [0.06062, 0.54986, 0, 0, 0.77778],
    "8783": [0.06062, 0.54986, 0, 0, 0.77778],
    "8785": [0.08198, 0.58198, 0, 0, 0.77778],
    "8786": [0.08198, 0.58198, 0, 0, 0.77778],
    "8787": [0.08198, 0.58198, 0, 0, 0.77778],
    "8790": [0, 0.69224, 0, 0, 0.77778],
    "8791": [0.22958, 0.72958, 0, 0, 0.77778],
    "8796": [0.08198, 0.91667, 0, 0, 0.77778],
    "8806": [0.25583, 0.75583, 0, 0, 0.77778],
    "8807": [0.25583, 0.75583, 0, 0, 0.77778],
    "8808": [0.25142, 0.75726, 0, 0, 0.77778],
    "8809": [0.25142, 0.75726, 0, 0, 0.77778],
    "8812": [0.25583, 0.75583, 0, 0, 0.5],
    "8814": [0.20576, 0.70576, 0, 0, 0.77778],
    "8815": [0.20576, 0.70576, 0, 0, 0.77778],
    "8816": [0.30274, 0.79383, 0, 0, 0.77778],
    "8817": [0.30274, 0.79383, 0, 0, 0.77778],
    "8818": [0.22958, 0.72958, 0, 0, 0.77778],
    "8819": [0.22958, 0.72958, 0, 0, 0.77778],
    "8822": [0.1808, 0.675, 0, 0, 0.77778],
    "8823": [0.1808, 0.675, 0, 0, 0.77778],
    "8828": [0.13667, 0.63667, 0, 0, 0.77778],
    "8829": [0.13667, 0.63667, 0, 0, 0.77778],
    "8830": [0.22958, 0.72958, 0, 0, 0.77778],
    "8831": [0.22958, 0.72958, 0, 0, 0.77778],
    "8832": [0.20576, 0.70576, 0, 0, 0.77778],
    "8833": [0.20576, 0.70576, 0, 0, 0.77778],
    "8840": [0.30274, 0.79383, 0, 0, 0.77778],
    "8841": [0.30274, 0.79383, 0, 0, 0.77778],
    "8842": [0.13597, 0.63597, 0, 0, 0.77778],
    "8843": [0.13597, 0.63597, 0, 0, 0.77778],
    "8847": [0.03517, 0.54986, 0, 0, 0.77778],
    "8848": [0.03517, 0.54986, 0, 0, 0.77778],
    "8858": [0.08198, 0.58198, 0, 0, 0.77778],
    "8859": [0.08198, 0.58198, 0, 0, 0.77778],
    "8861": [0.08198, 0.58198, 0, 0, 0.77778],
    "8862": [0, 0.675, 0, 0, 0.77778],
    "8863": [0, 0.675, 0, 0, 0.77778],
    "8864": [0, 0.675, 0, 0, 0.77778],
    "8865": [0, 0.675, 0, 0, 0.77778],
    "8872": [0, 0.69224, 0, 0, 0.61111],
    "8873": [0, 0.69224, 0, 0, 0.72222],
    "8874": [0, 0.69224, 0, 0, 0.88889],
    "8876": [0, 0.68889, 0, 0, 0.61111],
    "8877": [0, 0.68889, 0, 0, 0.61111],
    "8878": [0, 0.68889, 0, 0, 0.72222],
    "8879": [0, 0.68889, 0, 0, 0.72222],
    "8882": [0.03517, 0.54986, 0, 0, 0.77778],
    "8883": [0.03517, 0.54986, 0, 0, 0.77778],
    "8884": [0.13667, 0.63667, 0, 0, 0.77778],
    "8885": [0.13667, 0.63667, 0, 0, 0.77778],
    "8888": [0, 0.54986, 0, 0, 1.11111],
    "8890": [0.19444, 0.43056, 0, 0, 0.55556],
    "8891": [0.19444, 0.69224, 0, 0, 0.61111],
    "8892": [0.19444, 0.69224, 0, 0, 0.61111],
    "8901": [0, 0.54986, 0, 0, 0.27778],
    "8903": [0.08167, 0.58167, 0, 0, 0.77778],
    "8905": [0.08167, 0.58167, 0, 0, 0.77778],
    "8906": [0.08167, 0.58167, 0, 0, 0.77778],
    "8907": [0, 0.69224, 0, 0, 0.77778],
    "8908": [0, 0.69224, 0, 0, 0.77778],
    "8909": [-0.03598, 0.46402, 0, 0, 0.77778],
    "8910": [0, 0.54986, 0, 0, 0.76042],
    "8911": [0, 0.54986, 0, 0, 0.76042],
    "8912": [0.03517, 0.54986, 0, 0, 0.77778],
    "8913": [0.03517, 0.54986, 0, 0, 0.77778],
    "8914": [0, 0.54986, 0, 0, 0.66667],
    "8915": [0, 0.54986, 0, 0, 0.66667],
    "8916": [0, 0.69224, 0, 0, 0.66667],
    "8918": [0.0391, 0.5391, 0, 0, 0.77778],
    "8919": [0.0391, 0.5391, 0, 0, 0.77778],
    "8920": [0.03517, 0.54986, 0, 0, 1.33334],
    "8921": [0.03517, 0.54986, 0, 0, 1.33334],
    "8922": [0.38569, 0.88569, 0, 0, 0.77778],
    "8923": [0.38569, 0.88569, 0, 0, 0.77778],
    "8926": [0.13667, 0.63667, 0, 0, 0.77778],
    "8927": [0.13667, 0.63667, 0, 0, 0.77778],
    "8928": [0.30274, 0.79383, 0, 0, 0.77778],
    "8929": [0.30274, 0.79383, 0, 0, 0.77778],
    "8934": [0.23222, 0.74111, 0, 0, 0.77778],
    "8935": [0.23222, 0.74111, 0, 0, 0.77778],
    "8936": [0.23222, 0.74111, 0, 0, 0.77778],
    "8937": [0.23222, 0.74111, 0, 0, 0.77778],
    "8938": [0.20576, 0.70576, 0, 0, 0.77778],
    "8939": [0.20576, 0.70576, 0, 0, 0.77778],
    "8940": [0.30274, 0.79383, 0, 0, 0.77778],
    "8941": [0.30274, 0.79383, 0, 0, 0.77778],
    "8994": [0.19444, 0.69224, 0, 0, 0.77778],
    "8995": [0.19444, 0.69224, 0, 0, 0.77778],
    "9416": [0.15559, 0.69224, 0, 0, 0.90222],
    "9484": [0, 0.69224, 0, 0, 0.5],
    "9488": [0, 0.69224, 0, 0, 0.5],
    "9492": [0, 0.37788, 0, 0, 0.5],
    "9496": [0, 0.37788, 0, 0, 0.5],
    "9585": [0.19444, 0.68889, 0, 0, 0.88889],
    "9586": [0.19444, 0.74111, 0, 0, 0.88889],
    "9632": [0, 0.675, 0, 0, 0.77778],
    "9633": [0, 0.675, 0, 0, 0.77778],
    "9650": [0, 0.54986, 0, 0, 0.72222],
    "9651": [0, 0.54986, 0, 0, 0.72222],
    "9654": [0.03517, 0.54986, 0, 0, 0.77778],
    "9660": [0, 0.54986, 0, 0, 0.72222],
    "9661": [0, 0.54986, 0, 0, 0.72222],
    "9664": [0.03517, 0.54986, 0, 0, 0.77778],
    "9674": [0.11111, 0.69224, 0, 0, 0.66667],
    "9733": [0.19444, 0.69224, 0, 0, 0.94445],
    "10003": [0, 0.69224, 0, 0, 0.83334],
    "10016": [0, 0.69224, 0, 0, 0.83334],
    "10731": [0.11111, 0.69224, 0, 0, 0.66667],
    "10846": [0.19444, 0.75583, 0, 0, 0.61111],
    "10877": [0.13667, 0.63667, 0, 0, 0.77778],
    "10878": [0.13667, 0.63667, 0, 0, 0.77778],
    "10885": [0.25583, 0.75583, 0, 0, 0.77778],
    "10886": [0.25583, 0.75583, 0, 0, 0.77778],
    "10887": [0.13597, 0.63597, 0, 0, 0.77778],
    "10888": [0.13597, 0.63597, 0, 0, 0.77778],
    "10889": [0.26167, 0.75726, 0, 0, 0.77778],
    "10890": [0.26167, 0.75726, 0, 0, 0.77778],
    "10891": [0.48256, 0.98256, 0, 0, 0.77778],
    "10892": [0.48256, 0.98256, 0, 0, 0.77778],
    "10901": [0.13667, 0.63667, 0, 0, 0.77778],
    "10902": [0.13667, 0.63667, 0, 0, 0.77778],
    "10933": [0.25142, 0.75726, 0, 0, 0.77778],
    "10934": [0.25142, 0.75726, 0, 0, 0.77778],
    "10935": [0.26167, 0.75726, 0, 0, 0.77778],
    "10936": [0.26167, 0.75726, 0, 0, 0.77778],
    "10937": [0.26167, 0.75726, 0, 0, 0.77778],
    "10938": [0.26167, 0.75726, 0, 0, 0.77778],
    "10949": [0.25583, 0.75583, 0, 0, 0.77778],
    "10950": [0.25583, 0.75583, 0, 0, 0.77778],
    "10955": [0.28481, 0.79383, 0, 0, 0.77778],
    "10956": [0.28481, 0.79383, 0, 0, 0.77778],
    "57350": [0.08167, 0.58167, 0, 0, 0.22222],
    "57351": [0.08167, 0.58167, 0, 0, 0.38889],
    "57352": [0.08167, 0.58167, 0, 0, 0.77778],
    "57353": [0, 0.43056, 0.04028, 0, 0.66667],
    "57356": [0.25142, 0.75726, 0, 0, 0.77778],
    "57357": [0.25142, 0.75726, 0, 0, 0.77778],
    "57358": [0.41951, 0.91951, 0, 0, 0.77778],
    "57359": [0.30274, 0.79383, 0, 0, 0.77778],
    "57360": [0.30274, 0.79383, 0, 0, 0.77778],
    "57361": [0.41951, 0.91951, 0, 0, 0.77778],
    "57366": [0.25142, 0.75726, 0, 0, 0.77778],
    "57367": [0.25142, 0.75726, 0, 0, 0.77778],
    "57368": [0.25142, 0.75726, 0, 0, 0.77778],
    "57369": [0.25142, 0.75726, 0, 0, 0.77778],
    "57370": [0.13597, 0.63597, 0, 0, 0.77778],
    "57371": [0.13597, 0.63597, 0, 0, 0.77778]
  },
  "Caligraphic-Regular": {
    "32": [0, 0, 0, 0, 0.25],
    "65": [0, 0.68333, 0, 0.19445, 0.79847],
    "66": [0, 0.68333, 0.03041, 0.13889, 0.65681],
    "67": [0, 0.68333, 0.05834, 0.13889, 0.52653],
    "68": [0, 0.68333, 0.02778, 0.08334, 0.77139],
    "69": [0, 0.68333, 0.08944, 0.11111, 0.52778],
    "70": [0, 0.68333, 0.09931, 0.11111, 0.71875],
    "71": [0.09722, 0.68333, 0.0593, 0.11111, 0.59487],
    "72": [0, 0.68333, 965e-5, 0.11111, 0.84452],
    "73": [0, 0.68333, 0.07382, 0, 0.54452],
    "74": [0.09722, 0.68333, 0.18472, 0.16667, 0.67778],
    "75": [0, 0.68333, 0.01445, 0.05556, 0.76195],
    "76": [0, 0.68333, 0, 0.13889, 0.68972],
    "77": [0, 0.68333, 0, 0.13889, 1.2009],
    "78": [0, 0.68333, 0.14736, 0.08334, 0.82049],
    "79": [0, 0.68333, 0.02778, 0.11111, 0.79611],
    "80": [0, 0.68333, 0.08222, 0.08334, 0.69556],
    "81": [0.09722, 0.68333, 0, 0.11111, 0.81667],
    "82": [0, 0.68333, 0, 0.08334, 0.8475],
    "83": [0, 0.68333, 0.075, 0.13889, 0.60556],
    "84": [0, 0.68333, 0.25417, 0, 0.54464],
    "85": [0, 0.68333, 0.09931, 0.08334, 0.62583],
    "86": [0, 0.68333, 0.08222, 0, 0.61278],
    "87": [0, 0.68333, 0.08222, 0.08334, 0.98778],
    "88": [0, 0.68333, 0.14643, 0.13889, 0.7133],
    "89": [0.09722, 0.68333, 0.08222, 0.08334, 0.66834],
    "90": [0, 0.68333, 0.07944, 0.13889, 0.72473],
    "160": [0, 0, 0, 0, 0.25]
  },
  "Fraktur-Regular": {
    "32": [0, 0, 0, 0, 0.25],
    "33": [0, 0.69141, 0, 0, 0.29574],
    "34": [0, 0.69141, 0, 0, 0.21471],
    "38": [0, 0.69141, 0, 0, 0.73786],
    "39": [0, 0.69141, 0, 0, 0.21201],
    "40": [0.24982, 0.74947, 0, 0, 0.38865],
    "41": [0.24982, 0.74947, 0, 0, 0.38865],
    "42": [0, 0.62119, 0, 0, 0.27764],
    "43": [0.08319, 0.58283, 0, 0, 0.75623],
    "44": [0, 0.10803, 0, 0, 0.27764],
    "45": [0.08319, 0.58283, 0, 0, 0.75623],
    "46": [0, 0.10803, 0, 0, 0.27764],
    "47": [0.24982, 0.74947, 0, 0, 0.50181],
    "48": [0, 0.47534, 0, 0, 0.50181],
    "49": [0, 0.47534, 0, 0, 0.50181],
    "50": [0, 0.47534, 0, 0, 0.50181],
    "51": [0.18906, 0.47534, 0, 0, 0.50181],
    "52": [0.18906, 0.47534, 0, 0, 0.50181],
    "53": [0.18906, 0.47534, 0, 0, 0.50181],
    "54": [0, 0.69141, 0, 0, 0.50181],
    "55": [0.18906, 0.47534, 0, 0, 0.50181],
    "56": [0, 0.69141, 0, 0, 0.50181],
    "57": [0.18906, 0.47534, 0, 0, 0.50181],
    "58": [0, 0.47534, 0, 0, 0.21606],
    "59": [0.12604, 0.47534, 0, 0, 0.21606],
    "61": [-0.13099, 0.36866, 0, 0, 0.75623],
    "63": [0, 0.69141, 0, 0, 0.36245],
    "65": [0, 0.69141, 0, 0, 0.7176],
    "66": [0, 0.69141, 0, 0, 0.88397],
    "67": [0, 0.69141, 0, 0, 0.61254],
    "68": [0, 0.69141, 0, 0, 0.83158],
    "69": [0, 0.69141, 0, 0, 0.66278],
    "70": [0.12604, 0.69141, 0, 0, 0.61119],
    "71": [0, 0.69141, 0, 0, 0.78539],
    "72": [0.06302, 0.69141, 0, 0, 0.7203],
    "73": [0, 0.69141, 0, 0, 0.55448],
    "74": [0.12604, 0.69141, 0, 0, 0.55231],
    "75": [0, 0.69141, 0, 0, 0.66845],
    "76": [0, 0.69141, 0, 0, 0.66602],
    "77": [0, 0.69141, 0, 0, 1.04953],
    "78": [0, 0.69141, 0, 0, 0.83212],
    "79": [0, 0.69141, 0, 0, 0.82699],
    "80": [0.18906, 0.69141, 0, 0, 0.82753],
    "81": [0.03781, 0.69141, 0, 0, 0.82699],
    "82": [0, 0.69141, 0, 0, 0.82807],
    "83": [0, 0.69141, 0, 0, 0.82861],
    "84": [0, 0.69141, 0, 0, 0.66899],
    "85": [0, 0.69141, 0, 0, 0.64576],
    "86": [0, 0.69141, 0, 0, 0.83131],
    "87": [0, 0.69141, 0, 0, 1.04602],
    "88": [0, 0.69141, 0, 0, 0.71922],
    "89": [0.18906, 0.69141, 0, 0, 0.83293],
    "90": [0.12604, 0.69141, 0, 0, 0.60201],
    "91": [0.24982, 0.74947, 0, 0, 0.27764],
    "93": [0.24982, 0.74947, 0, 0, 0.27764],
    "94": [0, 0.69141, 0, 0, 0.49965],
    "97": [0, 0.47534, 0, 0, 0.50046],
    "98": [0, 0.69141, 0, 0, 0.51315],
    "99": [0, 0.47534, 0, 0, 0.38946],
    "100": [0, 0.62119, 0, 0, 0.49857],
    "101": [0, 0.47534, 0, 0, 0.40053],
    "102": [0.18906, 0.69141, 0, 0, 0.32626],
    "103": [0.18906, 0.47534, 0, 0, 0.5037],
    "104": [0.18906, 0.69141, 0, 0, 0.52126],
    "105": [0, 0.69141, 0, 0, 0.27899],
    "106": [0, 0.69141, 0, 0, 0.28088],
    "107": [0, 0.69141, 0, 0, 0.38946],
    "108": [0, 0.69141, 0, 0, 0.27953],
    "109": [0, 0.47534, 0, 0, 0.76676],
    "110": [0, 0.47534, 0, 0, 0.52666],
    "111": [0, 0.47534, 0, 0, 0.48885],
    "112": [0.18906, 0.52396, 0, 0, 0.50046],
    "113": [0.18906, 0.47534, 0, 0, 0.48912],
    "114": [0, 0.47534, 0, 0, 0.38919],
    "115": [0, 0.47534, 0, 0, 0.44266],
    "116": [0, 0.62119, 0, 0, 0.33301],
    "117": [0, 0.47534, 0, 0, 0.5172],
    "118": [0, 0.52396, 0, 0, 0.5118],
    "119": [0, 0.52396, 0, 0, 0.77351],
    "120": [0.18906, 0.47534, 0, 0, 0.38865],
    "121": [0.18906, 0.47534, 0, 0, 0.49884],
    "122": [0.18906, 0.47534, 0, 0, 0.39054],
    "160": [0, 0, 0, 0, 0.25],
    "8216": [0, 0.69141, 0, 0, 0.21471],
    "8217": [0, 0.69141, 0, 0, 0.21471],
    "58112": [0, 0.62119, 0, 0, 0.49749],
    "58113": [0, 0.62119, 0, 0, 0.4983],
    "58114": [0.18906, 0.69141, 0, 0, 0.33328],
    "58115": [0.18906, 0.69141, 0, 0, 0.32923],
    "58116": [0.18906, 0.47534, 0, 0, 0.50343],
    "58117": [0, 0.69141, 0, 0, 0.33301],
    "58118": [0, 0.62119, 0, 0, 0.33409],
    "58119": [0, 0.47534, 0, 0, 0.50073]
  },
  "Main-Bold": {
    "32": [0, 0, 0, 0, 0.25],
    "33": [0, 0.69444, 0, 0, 0.35],
    "34": [0, 0.69444, 0, 0, 0.60278],
    "35": [0.19444, 0.69444, 0, 0, 0.95833],
    "36": [0.05556, 0.75, 0, 0, 0.575],
    "37": [0.05556, 0.75, 0, 0, 0.95833],
    "38": [0, 0.69444, 0, 0, 0.89444],
    "39": [0, 0.69444, 0, 0, 0.31944],
    "40": [0.25, 0.75, 0, 0, 0.44722],
    "41": [0.25, 0.75, 0, 0, 0.44722],
    "42": [0, 0.75, 0, 0, 0.575],
    "43": [0.13333, 0.63333, 0, 0, 0.89444],
    "44": [0.19444, 0.15556, 0, 0, 0.31944],
    "45": [0, 0.44444, 0, 0, 0.38333],
    "46": [0, 0.15556, 0, 0, 0.31944],
    "47": [0.25, 0.75, 0, 0, 0.575],
    "48": [0, 0.64444, 0, 0, 0.575],
    "49": [0, 0.64444, 0, 0, 0.575],
    "50": [0, 0.64444, 0, 0, 0.575],
    "51": [0, 0.64444, 0, 0, 0.575],
    "52": [0, 0.64444, 0, 0, 0.575],
    "53": [0, 0.64444, 0, 0, 0.575],
    "54": [0, 0.64444, 0, 0, 0.575],
    "55": [0, 0.64444, 0, 0, 0.575],
    "56": [0, 0.64444, 0, 0, 0.575],
    "57": [0, 0.64444, 0, 0, 0.575],
    "58": [0, 0.44444, 0, 0, 0.31944],
    "59": [0.19444, 0.44444, 0, 0, 0.31944],
    "60": [0.08556, 0.58556, 0, 0, 0.89444],
    "61": [-0.10889, 0.39111, 0, 0, 0.89444],
    "62": [0.08556, 0.58556, 0, 0, 0.89444],
    "63": [0, 0.69444, 0, 0, 0.54305],
    "64": [0, 0.69444, 0, 0, 0.89444],
    "65": [0, 0.68611, 0, 0, 0.86944],
    "66": [0, 0.68611, 0, 0, 0.81805],
    "67": [0, 0.68611, 0, 0, 0.83055],
    "68": [0, 0.68611, 0, 0, 0.88194],
    "69": [0, 0.68611, 0, 0, 0.75555],
    "70": [0, 0.68611, 0, 0, 0.72361],
    "71": [0, 0.68611, 0, 0, 0.90416],
    "72": [0, 0.68611, 0, 0, 0.9],
    "73": [0, 0.68611, 0, 0, 0.43611],
    "74": [0, 0.68611, 0, 0, 0.59444],
    "75": [0, 0.68611, 0, 0, 0.90138],
    "76": [0, 0.68611, 0, 0, 0.69166],
    "77": [0, 0.68611, 0, 0, 1.09166],
    "78": [0, 0.68611, 0, 0, 0.9],
    "79": [0, 0.68611, 0, 0, 0.86388],
    "80": [0, 0.68611, 0, 0, 0.78611],
    "81": [0.19444, 0.68611, 0, 0, 0.86388],
    "82": [0, 0.68611, 0, 0, 0.8625],
    "83": [0, 0.68611, 0, 0, 0.63889],
    "84": [0, 0.68611, 0, 0, 0.8],
    "85": [0, 0.68611, 0, 0, 0.88472],
    "86": [0, 0.68611, 0.01597, 0, 0.86944],
    "87": [0, 0.68611, 0.01597, 0, 1.18888],
    "88": [0, 0.68611, 0, 0, 0.86944],
    "89": [0, 0.68611, 0.02875, 0, 0.86944],
    "90": [0, 0.68611, 0, 0, 0.70277],
    "91": [0.25, 0.75, 0, 0, 0.31944],
    "92": [0.25, 0.75, 0, 0, 0.575],
    "93": [0.25, 0.75, 0, 0, 0.31944],
    "94": [0, 0.69444, 0, 0, 0.575],
    "95": [0.31, 0.13444, 0.03194, 0, 0.575],
    "97": [0, 0.44444, 0, 0, 0.55902],
    "98": [0, 0.69444, 0, 0, 0.63889],
    "99": [0, 0.44444, 0, 0, 0.51111],
    "100": [0, 0.69444, 0, 0, 0.63889],
    "101": [0, 0.44444, 0, 0, 0.52708],
    "102": [0, 0.69444, 0.10903, 0, 0.35139],
    "103": [0.19444, 0.44444, 0.01597, 0, 0.575],
    "104": [0, 0.69444, 0, 0, 0.63889],
    "105": [0, 0.69444, 0, 0, 0.31944],
    "106": [0.19444, 0.69444, 0, 0, 0.35139],
    "107": [0, 0.69444, 0, 0, 0.60694],
    "108": [0, 0.69444, 0, 0, 0.31944],
    "109": [0, 0.44444, 0, 0, 0.95833],
    "110": [0, 0.44444, 0, 0, 0.63889],
    "111": [0, 0.44444, 0, 0, 0.575],
    "112": [0.19444, 0.44444, 0, 0, 0.63889],
    "113": [0.19444, 0.44444, 0, 0, 0.60694],
    "114": [0, 0.44444, 0, 0, 0.47361],
    "115": [0, 0.44444, 0, 0, 0.45361],
    "116": [0, 0.63492, 0, 0, 0.44722],
    "117": [0, 0.44444, 0, 0, 0.63889],
    "118": [0, 0.44444, 0.01597, 0, 0.60694],
    "119": [0, 0.44444, 0.01597, 0, 0.83055],
    "120": [0, 0.44444, 0, 0, 0.60694],
    "121": [0.19444, 0.44444, 0.01597, 0, 0.60694],
    "122": [0, 0.44444, 0, 0, 0.51111],
    "123": [0.25, 0.75, 0, 0, 0.575],
    "124": [0.25, 0.75, 0, 0, 0.31944],
    "125": [0.25, 0.75, 0, 0, 0.575],
    "126": [0.35, 0.34444, 0, 0, 0.575],
    "160": [0, 0, 0, 0, 0.25],
    "163": [0, 0.69444, 0, 0, 0.86853],
    "168": [0, 0.69444, 0, 0, 0.575],
    "172": [0, 0.44444, 0, 0, 0.76666],
    "176": [0, 0.69444, 0, 0, 0.86944],
    "177": [0.13333, 0.63333, 0, 0, 0.89444],
    "184": [0.17014, 0, 0, 0, 0.51111],
    "198": [0, 0.68611, 0, 0, 1.04166],
    "215": [0.13333, 0.63333, 0, 0, 0.89444],
    "216": [0.04861, 0.73472, 0, 0, 0.89444],
    "223": [0, 0.69444, 0, 0, 0.59722],
    "230": [0, 0.44444, 0, 0, 0.83055],
    "247": [0.13333, 0.63333, 0, 0, 0.89444],
    "248": [0.09722, 0.54167, 0, 0, 0.575],
    "305": [0, 0.44444, 0, 0, 0.31944],
    "338": [0, 0.68611, 0, 0, 1.16944],
    "339": [0, 0.44444, 0, 0, 0.89444],
    "567": [0.19444, 0.44444, 0, 0, 0.35139],
    "710": [0, 0.69444, 0, 0, 0.575],
    "711": [0, 0.63194, 0, 0, 0.575],
    "713": [0, 0.59611, 0, 0, 0.575],
    "714": [0, 0.69444, 0, 0, 0.575],
    "715": [0, 0.69444, 0, 0, 0.575],
    "728": [0, 0.69444, 0, 0, 0.575],
    "729": [0, 0.69444, 0, 0, 0.31944],
    "730": [0, 0.69444, 0, 0, 0.86944],
    "732": [0, 0.69444, 0, 0, 0.575],
    "733": [0, 0.69444, 0, 0, 0.575],
    "915": [0, 0.68611, 0, 0, 0.69166],
    "916": [0, 0.68611, 0, 0, 0.95833],
    "920": [0, 0.68611, 0, 0, 0.89444],
    "923": [0, 0.68611, 0, 0, 0.80555],
    "926": [0, 0.68611, 0, 0, 0.76666],
    "928": [0, 0.68611, 0, 0, 0.9],
    "931": [0, 0.68611, 0, 0, 0.83055],
    "933": [0, 0.68611, 0, 0, 0.89444],
    "934": [0, 0.68611, 0, 0, 0.83055],
    "936": [0, 0.68611, 0, 0, 0.89444],
    "937": [0, 0.68611, 0, 0, 0.83055],
    "8211": [0, 0.44444, 0.03194, 0, 0.575],
    "8212": [0, 0.44444, 0.03194, 0, 1.14999],
    "8216": [0, 0.69444, 0, 0, 0.31944],
    "8217": [0, 0.69444, 0, 0, 0.31944],
    "8220": [0, 0.69444, 0, 0, 0.60278],
    "8221": [0, 0.69444, 0, 0, 0.60278],
    "8224": [0.19444, 0.69444, 0, 0, 0.51111],
    "8225": [0.19444, 0.69444, 0, 0, 0.51111],
    "8242": [0, 0.55556, 0, 0, 0.34444],
    "8407": [0, 0.72444, 0.15486, 0, 0.575],
    "8463": [0, 0.69444, 0, 0, 0.66759],
    "8465": [0, 0.69444, 0, 0, 0.83055],
    "8467": [0, 0.69444, 0, 0, 0.47361],
    "8472": [0.19444, 0.44444, 0, 0, 0.74027],
    "8476": [0, 0.69444, 0, 0, 0.83055],
    "8501": [0, 0.69444, 0, 0, 0.70277],
    "8592": [-0.10889, 0.39111, 0, 0, 1.14999],
    "8593": [0.19444, 0.69444, 0, 0, 0.575],
    "8594": [-0.10889, 0.39111, 0, 0, 1.14999],
    "8595": [0.19444, 0.69444, 0, 0, 0.575],
    "8596": [-0.10889, 0.39111, 0, 0, 1.14999],
    "8597": [0.25, 0.75, 0, 0, 0.575],
    "8598": [0.19444, 0.69444, 0, 0, 1.14999],
    "8599": [0.19444, 0.69444, 0, 0, 1.14999],
    "8600": [0.19444, 0.69444, 0, 0, 1.14999],
    "8601": [0.19444, 0.69444, 0, 0, 1.14999],
    "8636": [-0.10889, 0.39111, 0, 0, 1.14999],
    "8637": [-0.10889, 0.39111, 0, 0, 1.14999],
    "8640": [-0.10889, 0.39111, 0, 0, 1.14999],
    "8641": [-0.10889, 0.39111, 0, 0, 1.14999],
    "8656": [-0.10889, 0.39111, 0, 0, 1.14999],
    "8657": [0.19444, 0.69444, 0, 0, 0.70277],
    "8658": [-0.10889, 0.39111, 0, 0, 1.14999],
    "8659": [0.19444, 0.69444, 0, 0, 0.70277],
    "8660": [-0.10889, 0.39111, 0, 0, 1.14999],
    "8661": [0.25, 0.75, 0, 0, 0.70277],
    "8704": [0, 0.69444, 0, 0, 0.63889],
    "8706": [0, 0.69444, 0.06389, 0, 0.62847],
    "8707": [0, 0.69444, 0, 0, 0.63889],
    "8709": [0.05556, 0.75, 0, 0, 0.575],
    "8711": [0, 0.68611, 0, 0, 0.95833],
    "8712": [0.08556, 0.58556, 0, 0, 0.76666],
    "8715": [0.08556, 0.58556, 0, 0, 0.76666],
    "8722": [0.13333, 0.63333, 0, 0, 0.89444],
    "8723": [0.13333, 0.63333, 0, 0, 0.89444],
    "8725": [0.25, 0.75, 0, 0, 0.575],
    "8726": [0.25, 0.75, 0, 0, 0.575],
    "8727": [-0.02778, 0.47222, 0, 0, 0.575],
    "8728": [-0.02639, 0.47361, 0, 0, 0.575],
    "8729": [-0.02639, 0.47361, 0, 0, 0.575],
    "8730": [0.18, 0.82, 0, 0, 0.95833],
    "8733": [0, 0.44444, 0, 0, 0.89444],
    "8734": [0, 0.44444, 0, 0, 1.14999],
    "8736": [0, 0.69224, 0, 0, 0.72222],
    "8739": [0.25, 0.75, 0, 0, 0.31944],
    "8741": [0.25, 0.75, 0, 0, 0.575],
    "8743": [0, 0.55556, 0, 0, 0.76666],
    "8744": [0, 0.55556, 0, 0, 0.76666],
    "8745": [0, 0.55556, 0, 0, 0.76666],
    "8746": [0, 0.55556, 0, 0, 0.76666],
    "8747": [0.19444, 0.69444, 0.12778, 0, 0.56875],
    "8764": [-0.10889, 0.39111, 0, 0, 0.89444],
    "8768": [0.19444, 0.69444, 0, 0, 0.31944],
    "8771": [222e-5, 0.50222, 0, 0, 0.89444],
    "8773": [0.027, 0.638, 0, 0, 0.894],
    "8776": [0.02444, 0.52444, 0, 0, 0.89444],
    "8781": [222e-5, 0.50222, 0, 0, 0.89444],
    "8801": [222e-5, 0.50222, 0, 0, 0.89444],
    "8804": [0.19667, 0.69667, 0, 0, 0.89444],
    "8805": [0.19667, 0.69667, 0, 0, 0.89444],
    "8810": [0.08556, 0.58556, 0, 0, 1.14999],
    "8811": [0.08556, 0.58556, 0, 0, 1.14999],
    "8826": [0.08556, 0.58556, 0, 0, 0.89444],
    "8827": [0.08556, 0.58556, 0, 0, 0.89444],
    "8834": [0.08556, 0.58556, 0, 0, 0.89444],
    "8835": [0.08556, 0.58556, 0, 0, 0.89444],
    "8838": [0.19667, 0.69667, 0, 0, 0.89444],
    "8839": [0.19667, 0.69667, 0, 0, 0.89444],
    "8846": [0, 0.55556, 0, 0, 0.76666],
    "8849": [0.19667, 0.69667, 0, 0, 0.89444],
    "8850": [0.19667, 0.69667, 0, 0, 0.89444],
    "8851": [0, 0.55556, 0, 0, 0.76666],
    "8852": [0, 0.55556, 0, 0, 0.76666],
    "8853": [0.13333, 0.63333, 0, 0, 0.89444],
    "8854": [0.13333, 0.63333, 0, 0, 0.89444],
    "8855": [0.13333, 0.63333, 0, 0, 0.89444],
    "8856": [0.13333, 0.63333, 0, 0, 0.89444],
    "8857": [0.13333, 0.63333, 0, 0, 0.89444],
    "8866": [0, 0.69444, 0, 0, 0.70277],
    "8867": [0, 0.69444, 0, 0, 0.70277],
    "8868": [0, 0.69444, 0, 0, 0.89444],
    "8869": [0, 0.69444, 0, 0, 0.89444],
    "8900": [-0.02639, 0.47361, 0, 0, 0.575],
    "8901": [-0.02639, 0.47361, 0, 0, 0.31944],
    "8902": [-0.02778, 0.47222, 0, 0, 0.575],
    "8968": [0.25, 0.75, 0, 0, 0.51111],
    "8969": [0.25, 0.75, 0, 0, 0.51111],
    "8970": [0.25, 0.75, 0, 0, 0.51111],
    "8971": [0.25, 0.75, 0, 0, 0.51111],
    "8994": [-0.13889, 0.36111, 0, 0, 1.14999],
    "8995": [-0.13889, 0.36111, 0, 0, 1.14999],
    "9651": [0.19444, 0.69444, 0, 0, 1.02222],
    "9657": [-0.02778, 0.47222, 0, 0, 0.575],
    "9661": [0.19444, 0.69444, 0, 0, 1.02222],
    "9667": [-0.02778, 0.47222, 0, 0, 0.575],
    "9711": [0.19444, 0.69444, 0, 0, 1.14999],
    "9824": [0.12963, 0.69444, 0, 0, 0.89444],
    "9825": [0.12963, 0.69444, 0, 0, 0.89444],
    "9826": [0.12963, 0.69444, 0, 0, 0.89444],
    "9827": [0.12963, 0.69444, 0, 0, 0.89444],
    "9837": [0, 0.75, 0, 0, 0.44722],
    "9838": [0.19444, 0.69444, 0, 0, 0.44722],
    "9839": [0.19444, 0.69444, 0, 0, 0.44722],
    "10216": [0.25, 0.75, 0, 0, 0.44722],
    "10217": [0.25, 0.75, 0, 0, 0.44722],
    "10815": [0, 0.68611, 0, 0, 0.9],
    "10927": [0.19667, 0.69667, 0, 0, 0.89444],
    "10928": [0.19667, 0.69667, 0, 0, 0.89444],
    "57376": [0.19444, 0.69444, 0, 0, 0]
  },
  "Main-BoldItalic": {
    "32": [0, 0, 0, 0, 0.25],
    "33": [0, 0.69444, 0.11417, 0, 0.38611],
    "34": [0, 0.69444, 0.07939, 0, 0.62055],
    "35": [0.19444, 0.69444, 0.06833, 0, 0.94444],
    "37": [0.05556, 0.75, 0.12861, 0, 0.94444],
    "38": [0, 0.69444, 0.08528, 0, 0.88555],
    "39": [0, 0.69444, 0.12945, 0, 0.35555],
    "40": [0.25, 0.75, 0.15806, 0, 0.47333],
    "41": [0.25, 0.75, 0.03306, 0, 0.47333],
    "42": [0, 0.75, 0.14333, 0, 0.59111],
    "43": [0.10333, 0.60333, 0.03306, 0, 0.88555],
    "44": [0.19444, 0.14722, 0, 0, 0.35555],
    "45": [0, 0.44444, 0.02611, 0, 0.41444],
    "46": [0, 0.14722, 0, 0, 0.35555],
    "47": [0.25, 0.75, 0.15806, 0, 0.59111],
    "48": [0, 0.64444, 0.13167, 0, 0.59111],
    "49": [0, 0.64444, 0.13167, 0, 0.59111],
    "50": [0, 0.64444, 0.13167, 0, 0.59111],
    "51": [0, 0.64444, 0.13167, 0, 0.59111],
    "52": [0.19444, 0.64444, 0.13167, 0, 0.59111],
    "53": [0, 0.64444, 0.13167, 0, 0.59111],
    "54": [0, 0.64444, 0.13167, 0, 0.59111],
    "55": [0.19444, 0.64444, 0.13167, 0, 0.59111],
    "56": [0, 0.64444, 0.13167, 0, 0.59111],
    "57": [0, 0.64444, 0.13167, 0, 0.59111],
    "58": [0, 0.44444, 0.06695, 0, 0.35555],
    "59": [0.19444, 0.44444, 0.06695, 0, 0.35555],
    "61": [-0.10889, 0.39111, 0.06833, 0, 0.88555],
    "63": [0, 0.69444, 0.11472, 0, 0.59111],
    "64": [0, 0.69444, 0.09208, 0, 0.88555],
    "65": [0, 0.68611, 0, 0, 0.86555],
    "66": [0, 0.68611, 0.0992, 0, 0.81666],
    "67": [0, 0.68611, 0.14208, 0, 0.82666],
    "68": [0, 0.68611, 0.09062, 0, 0.87555],
    "69": [0, 0.68611, 0.11431, 0, 0.75666],
    "70": [0, 0.68611, 0.12903, 0, 0.72722],
    "71": [0, 0.68611, 0.07347, 0, 0.89527],
    "72": [0, 0.68611, 0.17208, 0, 0.8961],
    "73": [0, 0.68611, 0.15681, 0, 0.47166],
    "74": [0, 0.68611, 0.145, 0, 0.61055],
    "75": [0, 0.68611, 0.14208, 0, 0.89499],
    "76": [0, 0.68611, 0, 0, 0.69777],
    "77": [0, 0.68611, 0.17208, 0, 1.07277],
    "78": [0, 0.68611, 0.17208, 0, 0.8961],
    "79": [0, 0.68611, 0.09062, 0, 0.85499],
    "80": [0, 0.68611, 0.0992, 0, 0.78721],
    "81": [0.19444, 0.68611, 0.09062, 0, 0.85499],
    "82": [0, 0.68611, 0.02559, 0, 0.85944],
    "83": [0, 0.68611, 0.11264, 0, 0.64999],
    "84": [0, 0.68611, 0.12903, 0, 0.7961],
    "85": [0, 0.68611, 0.17208, 0, 0.88083],
    "86": [0, 0.68611, 0.18625, 0, 0.86555],
    "87": [0, 0.68611, 0.18625, 0, 1.15999],
    "88": [0, 0.68611, 0.15681, 0, 0.86555],
    "89": [0, 0.68611, 0.19803, 0, 0.86555],
    "90": [0, 0.68611, 0.14208, 0, 0.70888],
    "91": [0.25, 0.75, 0.1875, 0, 0.35611],
    "93": [0.25, 0.75, 0.09972, 0, 0.35611],
    "94": [0, 0.69444, 0.06709, 0, 0.59111],
    "95": [0.31, 0.13444, 0.09811, 0, 0.59111],
    "97": [0, 0.44444, 0.09426, 0, 0.59111],
    "98": [0, 0.69444, 0.07861, 0, 0.53222],
    "99": [0, 0.44444, 0.05222, 0, 0.53222],
    "100": [0, 0.69444, 0.10861, 0, 0.59111],
    "101": [0, 0.44444, 0.085, 0, 0.53222],
    "102": [0.19444, 0.69444, 0.21778, 0, 0.4],
    "103": [0.19444, 0.44444, 0.105, 0, 0.53222],
    "104": [0, 0.69444, 0.09426, 0, 0.59111],
    "105": [0, 0.69326, 0.11387, 0, 0.35555],
    "106": [0.19444, 0.69326, 0.1672, 0, 0.35555],
    "107": [0, 0.69444, 0.11111, 0, 0.53222],
    "108": [0, 0.69444, 0.10861, 0, 0.29666],
    "109": [0, 0.44444, 0.09426, 0, 0.94444],
    "110": [0, 0.44444, 0.09426, 0, 0.64999],
    "111": [0, 0.44444, 0.07861, 0, 0.59111],
    "112": [0.19444, 0.44444, 0.07861, 0, 0.59111],
    "113": [0.19444, 0.44444, 0.105, 0, 0.53222],
    "114": [0, 0.44444, 0.11111, 0, 0.50167],
    "115": [0, 0.44444, 0.08167, 0, 0.48694],
    "116": [0, 0.63492, 0.09639, 0, 0.385],
    "117": [0, 0.44444, 0.09426, 0, 0.62055],
    "118": [0, 0.44444, 0.11111, 0, 0.53222],
    "119": [0, 0.44444, 0.11111, 0, 0.76777],
    "120": [0, 0.44444, 0.12583, 0, 0.56055],
    "121": [0.19444, 0.44444, 0.105, 0, 0.56166],
    "122": [0, 0.44444, 0.13889, 0, 0.49055],
    "126": [0.35, 0.34444, 0.11472, 0, 0.59111],
    "160": [0, 0, 0, 0, 0.25],
    "168": [0, 0.69444, 0.11473, 0, 0.59111],
    "176": [0, 0.69444, 0, 0, 0.94888],
    "184": [0.17014, 0, 0, 0, 0.53222],
    "198": [0, 0.68611, 0.11431, 0, 1.02277],
    "216": [0.04861, 0.73472, 0.09062, 0, 0.88555],
    "223": [0.19444, 0.69444, 0.09736, 0, 0.665],
    "230": [0, 0.44444, 0.085, 0, 0.82666],
    "248": [0.09722, 0.54167, 0.09458, 0, 0.59111],
    "305": [0, 0.44444, 0.09426, 0, 0.35555],
    "338": [0, 0.68611, 0.11431, 0, 1.14054],
    "339": [0, 0.44444, 0.085, 0, 0.82666],
    "567": [0.19444, 0.44444, 0.04611, 0, 0.385],
    "710": [0, 0.69444, 0.06709, 0, 0.59111],
    "711": [0, 0.63194, 0.08271, 0, 0.59111],
    "713": [0, 0.59444, 0.10444, 0, 0.59111],
    "714": [0, 0.69444, 0.08528, 0, 0.59111],
    "715": [0, 0.69444, 0, 0, 0.59111],
    "728": [0, 0.69444, 0.10333, 0, 0.59111],
    "729": [0, 0.69444, 0.12945, 0, 0.35555],
    "730": [0, 0.69444, 0, 0, 0.94888],
    "732": [0, 0.69444, 0.11472, 0, 0.59111],
    "733": [0, 0.69444, 0.11472, 0, 0.59111],
    "915": [0, 0.68611, 0.12903, 0, 0.69777],
    "916": [0, 0.68611, 0, 0, 0.94444],
    "920": [0, 0.68611, 0.09062, 0, 0.88555],
    "923": [0, 0.68611, 0, 0, 0.80666],
    "926": [0, 0.68611, 0.15092, 0, 0.76777],
    "928": [0, 0.68611, 0.17208, 0, 0.8961],
    "931": [0, 0.68611, 0.11431, 0, 0.82666],
    "933": [0, 0.68611, 0.10778, 0, 0.88555],
    "934": [0, 0.68611, 0.05632, 0, 0.82666],
    "936": [0, 0.68611, 0.10778, 0, 0.88555],
    "937": [0, 0.68611, 0.0992, 0, 0.82666],
    "8211": [0, 0.44444, 0.09811, 0, 0.59111],
    "8212": [0, 0.44444, 0.09811, 0, 1.18221],
    "8216": [0, 0.69444, 0.12945, 0, 0.35555],
    "8217": [0, 0.69444, 0.12945, 0, 0.35555],
    "8220": [0, 0.69444, 0.16772, 0, 0.62055],
    "8221": [0, 0.69444, 0.07939, 0, 0.62055]
  },
  "Main-Italic": {
    "32": [0, 0, 0, 0, 0.25],
    "33": [0, 0.69444, 0.12417, 0, 0.30667],
    "34": [0, 0.69444, 0.06961, 0, 0.51444],
    "35": [0.19444, 0.69444, 0.06616, 0, 0.81777],
    "37": [0.05556, 0.75, 0.13639, 0, 0.81777],
    "38": [0, 0.69444, 0.09694, 0, 0.76666],
    "39": [0, 0.69444, 0.12417, 0, 0.30667],
    "40": [0.25, 0.75, 0.16194, 0, 0.40889],
    "41": [0.25, 0.75, 0.03694, 0, 0.40889],
    "42": [0, 0.75, 0.14917, 0, 0.51111],
    "43": [0.05667, 0.56167, 0.03694, 0, 0.76666],
    "44": [0.19444, 0.10556, 0, 0, 0.30667],
    "45": [0, 0.43056, 0.02826, 0, 0.35778],
    "46": [0, 0.10556, 0, 0, 0.30667],
    "47": [0.25, 0.75, 0.16194, 0, 0.51111],
    "48": [0, 0.64444, 0.13556, 0, 0.51111],
    "49": [0, 0.64444, 0.13556, 0, 0.51111],
    "50": [0, 0.64444, 0.13556, 0, 0.51111],
    "51": [0, 0.64444, 0.13556, 0, 0.51111],
    "52": [0.19444, 0.64444, 0.13556, 0, 0.51111],
    "53": [0, 0.64444, 0.13556, 0, 0.51111],
    "54": [0, 0.64444, 0.13556, 0, 0.51111],
    "55": [0.19444, 0.64444, 0.13556, 0, 0.51111],
    "56": [0, 0.64444, 0.13556, 0, 0.51111],
    "57": [0, 0.64444, 0.13556, 0, 0.51111],
    "58": [0, 0.43056, 0.0582, 0, 0.30667],
    "59": [0.19444, 0.43056, 0.0582, 0, 0.30667],
    "61": [-0.13313, 0.36687, 0.06616, 0, 0.76666],
    "63": [0, 0.69444, 0.1225, 0, 0.51111],
    "64": [0, 0.69444, 0.09597, 0, 0.76666],
    "65": [0, 0.68333, 0, 0, 0.74333],
    "66": [0, 0.68333, 0.10257, 0, 0.70389],
    "67": [0, 0.68333, 0.14528, 0, 0.71555],
    "68": [0, 0.68333, 0.09403, 0, 0.755],
    "69": [0, 0.68333, 0.12028, 0, 0.67833],
    "70": [0, 0.68333, 0.13305, 0, 0.65277],
    "71": [0, 0.68333, 0.08722, 0, 0.77361],
    "72": [0, 0.68333, 0.16389, 0, 0.74333],
    "73": [0, 0.68333, 0.15806, 0, 0.38555],
    "74": [0, 0.68333, 0.14028, 0, 0.525],
    "75": [0, 0.68333, 0.14528, 0, 0.76888],
    "76": [0, 0.68333, 0, 0, 0.62722],
    "77": [0, 0.68333, 0.16389, 0, 0.89666],
    "78": [0, 0.68333, 0.16389, 0, 0.74333],
    "79": [0, 0.68333, 0.09403, 0, 0.76666],
    "80": [0, 0.68333, 0.10257, 0, 0.67833],
    "81": [0.19444, 0.68333, 0.09403, 0, 0.76666],
    "82": [0, 0.68333, 0.03868, 0, 0.72944],
    "83": [0, 0.68333, 0.11972, 0, 0.56222],
    "84": [0, 0.68333, 0.13305, 0, 0.71555],
    "85": [0, 0.68333, 0.16389, 0, 0.74333],
    "86": [0, 0.68333, 0.18361, 0, 0.74333],
    "87": [0, 0.68333, 0.18361, 0, 0.99888],
    "88": [0, 0.68333, 0.15806, 0, 0.74333],
    "89": [0, 0.68333, 0.19383, 0, 0.74333],
    "90": [0, 0.68333, 0.14528, 0, 0.61333],
    "91": [0.25, 0.75, 0.1875, 0, 0.30667],
    "93": [0.25, 0.75, 0.10528, 0, 0.30667],
    "94": [0, 0.69444, 0.06646, 0, 0.51111],
    "95": [0.31, 0.12056, 0.09208, 0, 0.51111],
    "97": [0, 0.43056, 0.07671, 0, 0.51111],
    "98": [0, 0.69444, 0.06312, 0, 0.46],
    "99": [0, 0.43056, 0.05653, 0, 0.46],
    "100": [0, 0.69444, 0.10333, 0, 0.51111],
    "101": [0, 0.43056, 0.07514, 0, 0.46],
    "102": [0.19444, 0.69444, 0.21194, 0, 0.30667],
    "103": [0.19444, 0.43056, 0.08847, 0, 0.46],
    "104": [0, 0.69444, 0.07671, 0, 0.51111],
    "105": [0, 0.65536, 0.1019, 0, 0.30667],
    "106": [0.19444, 0.65536, 0.14467, 0, 0.30667],
    "107": [0, 0.69444, 0.10764, 0, 0.46],
    "108": [0, 0.69444, 0.10333, 0, 0.25555],
    "109": [0, 0.43056, 0.07671, 0, 0.81777],
    "110": [0, 0.43056, 0.07671, 0, 0.56222],
    "111": [0, 0.43056, 0.06312, 0, 0.51111],
    "112": [0.19444, 0.43056, 0.06312, 0, 0.51111],
    "113": [0.19444, 0.43056, 0.08847, 0, 0.46],
    "114": [0, 0.43056, 0.10764, 0, 0.42166],
    "115": [0, 0.43056, 0.08208, 0, 0.40889],
    "116": [0, 0.61508, 0.09486, 0, 0.33222],
    "117": [0, 0.43056, 0.07671, 0, 0.53666],
    "118": [0, 0.43056, 0.10764, 0, 0.46],
    "119": [0, 0.43056, 0.10764, 0, 0.66444],
    "120": [0, 0.43056, 0.12042, 0, 0.46389],
    "121": [0.19444, 0.43056, 0.08847, 0, 0.48555],
    "122": [0, 0.43056, 0.12292, 0, 0.40889],
    "126": [0.35, 0.31786, 0.11585, 0, 0.51111],
    "160": [0, 0, 0, 0, 0.25],
    "168": [0, 0.66786, 0.10474, 0, 0.51111],
    "176": [0, 0.69444, 0, 0, 0.83129],
    "184": [0.17014, 0, 0, 0, 0.46],
    "198": [0, 0.68333, 0.12028, 0, 0.88277],
    "216": [0.04861, 0.73194, 0.09403, 0, 0.76666],
    "223": [0.19444, 0.69444, 0.10514, 0, 0.53666],
    "230": [0, 0.43056, 0.07514, 0, 0.71555],
    "248": [0.09722, 0.52778, 0.09194, 0, 0.51111],
    "338": [0, 0.68333, 0.12028, 0, 0.98499],
    "339": [0, 0.43056, 0.07514, 0, 0.71555],
    "710": [0, 0.69444, 0.06646, 0, 0.51111],
    "711": [0, 0.62847, 0.08295, 0, 0.51111],
    "713": [0, 0.56167, 0.10333, 0, 0.51111],
    "714": [0, 0.69444, 0.09694, 0, 0.51111],
    "715": [0, 0.69444, 0, 0, 0.51111],
    "728": [0, 0.69444, 0.10806, 0, 0.51111],
    "729": [0, 0.66786, 0.11752, 0, 0.30667],
    "730": [0, 0.69444, 0, 0, 0.83129],
    "732": [0, 0.66786, 0.11585, 0, 0.51111],
    "733": [0, 0.69444, 0.1225, 0, 0.51111],
    "915": [0, 0.68333, 0.13305, 0, 0.62722],
    "916": [0, 0.68333, 0, 0, 0.81777],
    "920": [0, 0.68333, 0.09403, 0, 0.76666],
    "923": [0, 0.68333, 0, 0, 0.69222],
    "926": [0, 0.68333, 0.15294, 0, 0.66444],
    "928": [0, 0.68333, 0.16389, 0, 0.74333],
    "931": [0, 0.68333, 0.12028, 0, 0.71555],
    "933": [0, 0.68333, 0.11111, 0, 0.76666],
    "934": [0, 0.68333, 0.05986, 0, 0.71555],
    "936": [0, 0.68333, 0.11111, 0, 0.76666],
    "937": [0, 0.68333, 0.10257, 0, 0.71555],
    "8211": [0, 0.43056, 0.09208, 0, 0.51111],
    "8212": [0, 0.43056, 0.09208, 0, 1.02222],
    "8216": [0, 0.69444, 0.12417, 0, 0.30667],
    "8217": [0, 0.69444, 0.12417, 0, 0.30667],
    "8220": [0, 0.69444, 0.1685, 0, 0.51444],
    "8221": [0, 0.69444, 0.06961, 0, 0.51444],
    "8463": [0, 0.68889, 0, 0, 0.54028]
  },
  "Main-Regular": {
    "32": [0, 0, 0, 0, 0.25],
    "33": [0, 0.69444, 0, 0, 0.27778],
    "34": [0, 0.69444, 0, 0, 0.5],
    "35": [0.19444, 0.69444, 0, 0, 0.83334],
    "36": [0.05556, 0.75, 0, 0, 0.5],
    "37": [0.05556, 0.75, 0, 0, 0.83334],
    "38": [0, 0.69444, 0, 0, 0.77778],
    "39": [0, 0.69444, 0, 0, 0.27778],
    "40": [0.25, 0.75, 0, 0, 0.38889],
    "41": [0.25, 0.75, 0, 0, 0.38889],
    "42": [0, 0.75, 0, 0, 0.5],
    "43": [0.08333, 0.58333, 0, 0, 0.77778],
    "44": [0.19444, 0.10556, 0, 0, 0.27778],
    "45": [0, 0.43056, 0, 0, 0.33333],
    "46": [0, 0.10556, 0, 0, 0.27778],
    "47": [0.25, 0.75, 0, 0, 0.5],
    "48": [0, 0.64444, 0, 0, 0.5],
    "49": [0, 0.64444, 0, 0, 0.5],
    "50": [0, 0.64444, 0, 0, 0.5],
    "51": [0, 0.64444, 0, 0, 0.5],
    "52": [0, 0.64444, 0, 0, 0.5],
    "53": [0, 0.64444, 0, 0, 0.5],
    "54": [0, 0.64444, 0, 0, 0.5],
    "55": [0, 0.64444, 0, 0, 0.5],
    "56": [0, 0.64444, 0, 0, 0.5],
    "57": [0, 0.64444, 0, 0, 0.5],
    "58": [0, 0.43056, 0, 0, 0.27778],
    "59": [0.19444, 0.43056, 0, 0, 0.27778],
    "60": [0.0391, 0.5391, 0, 0, 0.77778],
    "61": [-0.13313, 0.36687, 0, 0, 0.77778],
    "62": [0.0391, 0.5391, 0, 0, 0.77778],
    "63": [0, 0.69444, 0, 0, 0.47222],
    "64": [0, 0.69444, 0, 0, 0.77778],
    "65": [0, 0.68333, 0, 0, 0.75],
    "66": [0, 0.68333, 0, 0, 0.70834],
    "67": [0, 0.68333, 0, 0, 0.72222],
    "68": [0, 0.68333, 0, 0, 0.76389],
    "69": [0, 0.68333, 0, 0, 0.68056],
    "70": [0, 0.68333, 0, 0, 0.65278],
    "71": [0, 0.68333, 0, 0, 0.78472],
    "72": [0, 0.68333, 0, 0, 0.75],
    "73": [0, 0.68333, 0, 0, 0.36111],
    "74": [0, 0.68333, 0, 0, 0.51389],
    "75": [0, 0.68333, 0, 0, 0.77778],
    "76": [0, 0.68333, 0, 0, 0.625],
    "77": [0, 0.68333, 0, 0, 0.91667],
    "78": [0, 0.68333, 0, 0, 0.75],
    "79": [0, 0.68333, 0, 0, 0.77778],
    "80": [0, 0.68333, 0, 0, 0.68056],
    "81": [0.19444, 0.68333, 0, 0, 0.77778],
    "82": [0, 0.68333, 0, 0, 0.73611],
    "83": [0, 0.68333, 0, 0, 0.55556],
    "84": [0, 0.68333, 0, 0, 0.72222],
    "85": [0, 0.68333, 0, 0, 0.75],
    "86": [0, 0.68333, 0.01389, 0, 0.75],
    "87": [0, 0.68333, 0.01389, 0, 1.02778],
    "88": [0, 0.68333, 0, 0, 0.75],
    "89": [0, 0.68333, 0.025, 0, 0.75],
    "90": [0, 0.68333, 0, 0, 0.61111],
    "91": [0.25, 0.75, 0, 0, 0.27778],
    "92": [0.25, 0.75, 0, 0, 0.5],
    "93": [0.25, 0.75, 0, 0, 0.27778],
    "94": [0, 0.69444, 0, 0, 0.5],
    "95": [0.31, 0.12056, 0.02778, 0, 0.5],
    "97": [0, 0.43056, 0, 0, 0.5],
    "98": [0, 0.69444, 0, 0, 0.55556],
    "99": [0, 0.43056, 0, 0, 0.44445],
    "100": [0, 0.69444, 0, 0, 0.55556],
    "101": [0, 0.43056, 0, 0, 0.44445],
    "102": [0, 0.69444, 0.07778, 0, 0.30556],
    "103": [0.19444, 0.43056, 0.01389, 0, 0.5],
    "104": [0, 0.69444, 0, 0, 0.55556],
    "105": [0, 0.66786, 0, 0, 0.27778],
    "106": [0.19444, 0.66786, 0, 0, 0.30556],
    "107": [0, 0.69444, 0, 0, 0.52778],
    "108": [0, 0.69444, 0, 0, 0.27778],
    "109": [0, 0.43056, 0, 0, 0.83334],
    "110": [0, 0.43056, 0, 0, 0.55556],
    "111": [0, 0.43056, 0, 0, 0.5],
    "112": [0.19444, 0.43056, 0, 0, 0.55556],
    "113": [0.19444, 0.43056, 0, 0, 0.52778],
    "114": [0, 0.43056, 0, 0, 0.39167],
    "115": [0, 0.43056, 0, 0, 0.39445],
    "116": [0, 0.61508, 0, 0, 0.38889],
    "117": [0, 0.43056, 0, 0, 0.55556],
    "118": [0, 0.43056, 0.01389, 0, 0.52778],
    "119": [0, 0.43056, 0.01389, 0, 0.72222],
    "120": [0, 0.43056, 0, 0, 0.52778],
    "121": [0.19444, 0.43056, 0.01389, 0, 0.52778],
    "122": [0, 0.43056, 0, 0, 0.44445],
    "123": [0.25, 0.75, 0, 0, 0.5],
    "124": [0.25, 0.75, 0, 0, 0.27778],
    "125": [0.25, 0.75, 0, 0, 0.5],
    "126": [0.35, 0.31786, 0, 0, 0.5],
    "160": [0, 0, 0, 0, 0.25],
    "163": [0, 0.69444, 0, 0, 0.76909],
    "167": [0.19444, 0.69444, 0, 0, 0.44445],
    "168": [0, 0.66786, 0, 0, 0.5],
    "172": [0, 0.43056, 0, 0, 0.66667],
    "176": [0, 0.69444, 0, 0, 0.75],
    "177": [0.08333, 0.58333, 0, 0, 0.77778],
    "182": [0.19444, 0.69444, 0, 0, 0.61111],
    "184": [0.17014, 0, 0, 0, 0.44445],
    "198": [0, 0.68333, 0, 0, 0.90278],
    "215": [0.08333, 0.58333, 0, 0, 0.77778],
    "216": [0.04861, 0.73194, 0, 0, 0.77778],
    "223": [0, 0.69444, 0, 0, 0.5],
    "230": [0, 0.43056, 0, 0, 0.72222],
    "247": [0.08333, 0.58333, 0, 0, 0.77778],
    "248": [0.09722, 0.52778, 0, 0, 0.5],
    "305": [0, 0.43056, 0, 0, 0.27778],
    "338": [0, 0.68333, 0, 0, 1.01389],
    "339": [0, 0.43056, 0, 0, 0.77778],
    "567": [0.19444, 0.43056, 0, 0, 0.30556],
    "710": [0, 0.69444, 0, 0, 0.5],
    "711": [0, 0.62847, 0, 0, 0.5],
    "713": [0, 0.56778, 0, 0, 0.5],
    "714": [0, 0.69444, 0, 0, 0.5],
    "715": [0, 0.69444, 0, 0, 0.5],
    "728": [0, 0.69444, 0, 0, 0.5],
    "729": [0, 0.66786, 0, 0, 0.27778],
    "730": [0, 0.69444, 0, 0, 0.75],
    "732": [0, 0.66786, 0, 0, 0.5],
    "733": [0, 0.69444, 0, 0, 0.5],
    "915": [0, 0.68333, 0, 0, 0.625],
    "916": [0, 0.68333, 0, 0, 0.83334],
    "920": [0, 0.68333, 0, 0, 0.77778],
    "923": [0, 0.68333, 0, 0, 0.69445],
    "926": [0, 0.68333, 0, 0, 0.66667],
    "928": [0, 0.68333, 0, 0, 0.75],
    "931": [0, 0.68333, 0, 0, 0.72222],
    "933": [0, 0.68333, 0, 0, 0.77778],
    "934": [0, 0.68333, 0, 0, 0.72222],
    "936": [0, 0.68333, 0, 0, 0.77778],
    "937": [0, 0.68333, 0, 0, 0.72222],
    "8211": [0, 0.43056, 0.02778, 0, 0.5],
    "8212": [0, 0.43056, 0.02778, 0, 1],
    "8216": [0, 0.69444, 0, 0, 0.27778],
    "8217": [0, 0.69444, 0, 0, 0.27778],
    "8220": [0, 0.69444, 0, 0, 0.5],
    "8221": [0, 0.69444, 0, 0, 0.5],
    "8224": [0.19444, 0.69444, 0, 0, 0.44445],
    "8225": [0.19444, 0.69444, 0, 0, 0.44445],
    "8230": [0, 0.123, 0, 0, 1.172],
    "8242": [0, 0.55556, 0, 0, 0.275],
    "8407": [0, 0.71444, 0.15382, 0, 0.5],
    "8463": [0, 0.68889, 0, 0, 0.54028],
    "8465": [0, 0.69444, 0, 0, 0.72222],
    "8467": [0, 0.69444, 0, 0.11111, 0.41667],
    "8472": [0.19444, 0.43056, 0, 0.11111, 0.63646],
    "8476": [0, 0.69444, 0, 0, 0.72222],
    "8501": [0, 0.69444, 0, 0, 0.61111],
    "8592": [-0.13313, 0.36687, 0, 0, 1],
    "8593": [0.19444, 0.69444, 0, 0, 0.5],
    "8594": [-0.13313, 0.36687, 0, 0, 1],
    "8595": [0.19444, 0.69444, 0, 0, 0.5],
    "8596": [-0.13313, 0.36687, 0, 0, 1],
    "8597": [0.25, 0.75, 0, 0, 0.5],
    "8598": [0.19444, 0.69444, 0, 0, 1],
    "8599": [0.19444, 0.69444, 0, 0, 1],
    "8600": [0.19444, 0.69444, 0, 0, 1],
    "8601": [0.19444, 0.69444, 0, 0, 1],
    "8614": [0.011, 0.511, 0, 0, 1],
    "8617": [0.011, 0.511, 0, 0, 1.126],
    "8618": [0.011, 0.511, 0, 0, 1.126],
    "8636": [-0.13313, 0.36687, 0, 0, 1],
    "8637": [-0.13313, 0.36687, 0, 0, 1],
    "8640": [-0.13313, 0.36687, 0, 0, 1],
    "8641": [-0.13313, 0.36687, 0, 0, 1],
    "8652": [0.011, 0.671, 0, 0, 1],
    "8656": [-0.13313, 0.36687, 0, 0, 1],
    "8657": [0.19444, 0.69444, 0, 0, 0.61111],
    "8658": [-0.13313, 0.36687, 0, 0, 1],
    "8659": [0.19444, 0.69444, 0, 0, 0.61111],
    "8660": [-0.13313, 0.36687, 0, 0, 1],
    "8661": [0.25, 0.75, 0, 0, 0.61111],
    "8704": [0, 0.69444, 0, 0, 0.55556],
    "8706": [0, 0.69444, 0.05556, 0.08334, 0.5309],
    "8707": [0, 0.69444, 0, 0, 0.55556],
    "8709": [0.05556, 0.75, 0, 0, 0.5],
    "8711": [0, 0.68333, 0, 0, 0.83334],
    "8712": [0.0391, 0.5391, 0, 0, 0.66667],
    "8715": [0.0391, 0.5391, 0, 0, 0.66667],
    "8722": [0.08333, 0.58333, 0, 0, 0.77778],
    "8723": [0.08333, 0.58333, 0, 0, 0.77778],
    "8725": [0.25, 0.75, 0, 0, 0.5],
    "8726": [0.25, 0.75, 0, 0, 0.5],
    "8727": [-0.03472, 0.46528, 0, 0, 0.5],
    "8728": [-0.05555, 0.44445, 0, 0, 0.5],
    "8729": [-0.05555, 0.44445, 0, 0, 0.5],
    "8730": [0.2, 0.8, 0, 0, 0.83334],
    "8733": [0, 0.43056, 0, 0, 0.77778],
    "8734": [0, 0.43056, 0, 0, 1],
    "8736": [0, 0.69224, 0, 0, 0.72222],
    "8739": [0.25, 0.75, 0, 0, 0.27778],
    "8741": [0.25, 0.75, 0, 0, 0.5],
    "8743": [0, 0.55556, 0, 0, 0.66667],
    "8744": [0, 0.55556, 0, 0, 0.66667],
    "8745": [0, 0.55556, 0, 0, 0.66667],
    "8746": [0, 0.55556, 0, 0, 0.66667],
    "8747": [0.19444, 0.69444, 0.11111, 0, 0.41667],
    "8764": [-0.13313, 0.36687, 0, 0, 0.77778],
    "8768": [0.19444, 0.69444, 0, 0, 0.27778],
    "8771": [-0.03625, 0.46375, 0, 0, 0.77778],
    "8773": [-0.022, 0.589, 0, 0, 0.778],
    "8776": [-0.01688, 0.48312, 0, 0, 0.77778],
    "8781": [-0.03625, 0.46375, 0, 0, 0.77778],
    "8784": [-0.133, 0.673, 0, 0, 0.778],
    "8801": [-0.03625, 0.46375, 0, 0, 0.77778],
    "8804": [0.13597, 0.63597, 0, 0, 0.77778],
    "8805": [0.13597, 0.63597, 0, 0, 0.77778],
    "8810": [0.0391, 0.5391, 0, 0, 1],
    "8811": [0.0391, 0.5391, 0, 0, 1],
    "8826": [0.0391, 0.5391, 0, 0, 0.77778],
    "8827": [0.0391, 0.5391, 0, 0, 0.77778],
    "8834": [0.0391, 0.5391, 0, 0, 0.77778],
    "8835": [0.0391, 0.5391, 0, 0, 0.77778],
    "8838": [0.13597, 0.63597, 0, 0, 0.77778],
    "8839": [0.13597, 0.63597, 0, 0, 0.77778],
    "8846": [0, 0.55556, 0, 0, 0.66667],
    "8849": [0.13597, 0.63597, 0, 0, 0.77778],
    "8850": [0.13597, 0.63597, 0, 0, 0.77778],
    "8851": [0, 0.55556, 0, 0, 0.66667],
    "8852": [0, 0.55556, 0, 0, 0.66667],
    "8853": [0.08333, 0.58333, 0, 0, 0.77778],
    "8854": [0.08333, 0.58333, 0, 0, 0.77778],
    "8855": [0.08333, 0.58333, 0, 0, 0.77778],
    "8856": [0.08333, 0.58333, 0, 0, 0.77778],
    "8857": [0.08333, 0.58333, 0, 0, 0.77778],
    "8866": [0, 0.69444, 0, 0, 0.61111],
    "8867": [0, 0.69444, 0, 0, 0.61111],
    "8868": [0, 0.69444, 0, 0, 0.77778],
    "8869": [0, 0.69444, 0, 0, 0.77778],
    "8872": [0.249, 0.75, 0, 0, 0.867],
    "8900": [-0.05555, 0.44445, 0, 0, 0.5],
    "8901": [-0.05555, 0.44445, 0, 0, 0.27778],
    "8902": [-0.03472, 0.46528, 0, 0, 0.5],
    "8904": [5e-3, 0.505, 0, 0, 0.9],
    "8942": [0.03, 0.903, 0, 0, 0.278],
    "8943": [-0.19, 0.313, 0, 0, 1.172],
    "8945": [-0.1, 0.823, 0, 0, 1.282],
    "8968": [0.25, 0.75, 0, 0, 0.44445],
    "8969": [0.25, 0.75, 0, 0, 0.44445],
    "8970": [0.25, 0.75, 0, 0, 0.44445],
    "8971": [0.25, 0.75, 0, 0, 0.44445],
    "8994": [-0.14236, 0.35764, 0, 0, 1],
    "8995": [-0.14236, 0.35764, 0, 0, 1],
    "9136": [0.244, 0.744, 0, 0, 0.412],
    "9137": [0.244, 0.745, 0, 0, 0.412],
    "9651": [0.19444, 0.69444, 0, 0, 0.88889],
    "9657": [-0.03472, 0.46528, 0, 0, 0.5],
    "9661": [0.19444, 0.69444, 0, 0, 0.88889],
    "9667": [-0.03472, 0.46528, 0, 0, 0.5],
    "9711": [0.19444, 0.69444, 0, 0, 1],
    "9824": [0.12963, 0.69444, 0, 0, 0.77778],
    "9825": [0.12963, 0.69444, 0, 0, 0.77778],
    "9826": [0.12963, 0.69444, 0, 0, 0.77778],
    "9827": [0.12963, 0.69444, 0, 0, 0.77778],
    "9837": [0, 0.75, 0, 0, 0.38889],
    "9838": [0.19444, 0.69444, 0, 0, 0.38889],
    "9839": [0.19444, 0.69444, 0, 0, 0.38889],
    "10216": [0.25, 0.75, 0, 0, 0.38889],
    "10217": [0.25, 0.75, 0, 0, 0.38889],
    "10222": [0.244, 0.744, 0, 0, 0.412],
    "10223": [0.244, 0.745, 0, 0, 0.412],
    "10229": [0.011, 0.511, 0, 0, 1.609],
    "10230": [0.011, 0.511, 0, 0, 1.638],
    "10231": [0.011, 0.511, 0, 0, 1.859],
    "10232": [0.024, 0.525, 0, 0, 1.609],
    "10233": [0.024, 0.525, 0, 0, 1.638],
    "10234": [0.024, 0.525, 0, 0, 1.858],
    "10236": [0.011, 0.511, 0, 0, 1.638],
    "10815": [0, 0.68333, 0, 0, 0.75],
    "10927": [0.13597, 0.63597, 0, 0, 0.77778],
    "10928": [0.13597, 0.63597, 0, 0, 0.77778],
    "57376": [0.19444, 0.69444, 0, 0, 0]
  },
  "Math-BoldItalic": {
    "32": [0, 0, 0, 0, 0.25],
    "48": [0, 0.44444, 0, 0, 0.575],
    "49": [0, 0.44444, 0, 0, 0.575],
    "50": [0, 0.44444, 0, 0, 0.575],
    "51": [0.19444, 0.44444, 0, 0, 0.575],
    "52": [0.19444, 0.44444, 0, 0, 0.575],
    "53": [0.19444, 0.44444, 0, 0, 0.575],
    "54": [0, 0.64444, 0, 0, 0.575],
    "55": [0.19444, 0.44444, 0, 0, 0.575],
    "56": [0, 0.64444, 0, 0, 0.575],
    "57": [0.19444, 0.44444, 0, 0, 0.575],
    "65": [0, 0.68611, 0, 0, 0.86944],
    "66": [0, 0.68611, 0.04835, 0, 0.8664],
    "67": [0, 0.68611, 0.06979, 0, 0.81694],
    "68": [0, 0.68611, 0.03194, 0, 0.93812],
    "69": [0, 0.68611, 0.05451, 0, 0.81007],
    "70": [0, 0.68611, 0.15972, 0, 0.68889],
    "71": [0, 0.68611, 0, 0, 0.88673],
    "72": [0, 0.68611, 0.08229, 0, 0.98229],
    "73": [0, 0.68611, 0.07778, 0, 0.51111],
    "74": [0, 0.68611, 0.10069, 0, 0.63125],
    "75": [0, 0.68611, 0.06979, 0, 0.97118],
    "76": [0, 0.68611, 0, 0, 0.75555],
    "77": [0, 0.68611, 0.11424, 0, 1.14201],
    "78": [0, 0.68611, 0.11424, 0, 0.95034],
    "79": [0, 0.68611, 0.03194, 0, 0.83666],
    "80": [0, 0.68611, 0.15972, 0, 0.72309],
    "81": [0.19444, 0.68611, 0, 0, 0.86861],
    "82": [0, 0.68611, 421e-5, 0, 0.87235],
    "83": [0, 0.68611, 0.05382, 0, 0.69271],
    "84": [0, 0.68611, 0.15972, 0, 0.63663],
    "85": [0, 0.68611, 0.11424, 0, 0.80027],
    "86": [0, 0.68611, 0.25555, 0, 0.67778],
    "87": [0, 0.68611, 0.15972, 0, 1.09305],
    "88": [0, 0.68611, 0.07778, 0, 0.94722],
    "89": [0, 0.68611, 0.25555, 0, 0.67458],
    "90": [0, 0.68611, 0.06979, 0, 0.77257],
    "97": [0, 0.44444, 0, 0, 0.63287],
    "98": [0, 0.69444, 0, 0, 0.52083],
    "99": [0, 0.44444, 0, 0, 0.51342],
    "100": [0, 0.69444, 0, 0, 0.60972],
    "101": [0, 0.44444, 0, 0, 0.55361],
    "102": [0.19444, 0.69444, 0.11042, 0, 0.56806],
    "103": [0.19444, 0.44444, 0.03704, 0, 0.5449],
    "104": [0, 0.69444, 0, 0, 0.66759],
    "105": [0, 0.69326, 0, 0, 0.4048],
    "106": [0.19444, 0.69326, 0.0622, 0, 0.47083],
    "107": [0, 0.69444, 0.01852, 0, 0.6037],
    "108": [0, 0.69444, 88e-4, 0, 0.34815],
    "109": [0, 0.44444, 0, 0, 1.0324],
    "110": [0, 0.44444, 0, 0, 0.71296],
    "111": [0, 0.44444, 0, 0, 0.58472],
    "112": [0.19444, 0.44444, 0, 0, 0.60092],
    "113": [0.19444, 0.44444, 0.03704, 0, 0.54213],
    "114": [0, 0.44444, 0.03194, 0, 0.5287],
    "115": [0, 0.44444, 0, 0, 0.53125],
    "116": [0, 0.63492, 0, 0, 0.41528],
    "117": [0, 0.44444, 0, 0, 0.68102],
    "118": [0, 0.44444, 0.03704, 0, 0.56666],
    "119": [0, 0.44444, 0.02778, 0, 0.83148],
    "120": [0, 0.44444, 0, 0, 0.65903],
    "121": [0.19444, 0.44444, 0.03704, 0, 0.59028],
    "122": [0, 0.44444, 0.04213, 0, 0.55509],
    "160": [0, 0, 0, 0, 0.25],
    "915": [0, 0.68611, 0.15972, 0, 0.65694],
    "916": [0, 0.68611, 0, 0, 0.95833],
    "920": [0, 0.68611, 0.03194, 0, 0.86722],
    "923": [0, 0.68611, 0, 0, 0.80555],
    "926": [0, 0.68611, 0.07458, 0, 0.84125],
    "928": [0, 0.68611, 0.08229, 0, 0.98229],
    "931": [0, 0.68611, 0.05451, 0, 0.88507],
    "933": [0, 0.68611, 0.15972, 0, 0.67083],
    "934": [0, 0.68611, 0, 0, 0.76666],
    "936": [0, 0.68611, 0.11653, 0, 0.71402],
    "937": [0, 0.68611, 0.04835, 0, 0.8789],
    "945": [0, 0.44444, 0, 0, 0.76064],
    "946": [0.19444, 0.69444, 0.03403, 0, 0.65972],
    "947": [0.19444, 0.44444, 0.06389, 0, 0.59003],
    "948": [0, 0.69444, 0.03819, 0, 0.52222],
    "949": [0, 0.44444, 0, 0, 0.52882],
    "950": [0.19444, 0.69444, 0.06215, 0, 0.50833],
    "951": [0.19444, 0.44444, 0.03704, 0, 0.6],
    "952": [0, 0.69444, 0.03194, 0, 0.5618],
    "953": [0, 0.44444, 0, 0, 0.41204],
    "954": [0, 0.44444, 0, 0, 0.66759],
    "955": [0, 0.69444, 0, 0, 0.67083],
    "956": [0.19444, 0.44444, 0, 0, 0.70787],
    "957": [0, 0.44444, 0.06898, 0, 0.57685],
    "958": [0.19444, 0.69444, 0.03021, 0, 0.50833],
    "959": [0, 0.44444, 0, 0, 0.58472],
    "960": [0, 0.44444, 0.03704, 0, 0.68241],
    "961": [0.19444, 0.44444, 0, 0, 0.6118],
    "962": [0.09722, 0.44444, 0.07917, 0, 0.42361],
    "963": [0, 0.44444, 0.03704, 0, 0.68588],
    "964": [0, 0.44444, 0.13472, 0, 0.52083],
    "965": [0, 0.44444, 0.03704, 0, 0.63055],
    "966": [0.19444, 0.44444, 0, 0, 0.74722],
    "967": [0.19444, 0.44444, 0, 0, 0.71805],
    "968": [0.19444, 0.69444, 0.03704, 0, 0.75833],
    "969": [0, 0.44444, 0.03704, 0, 0.71782],
    "977": [0, 0.69444, 0, 0, 0.69155],
    "981": [0.19444, 0.69444, 0, 0, 0.7125],
    "982": [0, 0.44444, 0.03194, 0, 0.975],
    "1009": [0.19444, 0.44444, 0, 0, 0.6118],
    "1013": [0, 0.44444, 0, 0, 0.48333],
    "57649": [0, 0.44444, 0, 0, 0.39352],
    "57911": [0.19444, 0.44444, 0, 0, 0.43889]
  },
  "Math-Italic": {
    "32": [0, 0, 0, 0, 0.25],
    "48": [0, 0.43056, 0, 0, 0.5],
    "49": [0, 0.43056, 0, 0, 0.5],
    "50": [0, 0.43056, 0, 0, 0.5],
    "51": [0.19444, 0.43056, 0, 0, 0.5],
    "52": [0.19444, 0.43056, 0, 0, 0.5],
    "53": [0.19444, 0.43056, 0, 0, 0.5],
    "54": [0, 0.64444, 0, 0, 0.5],
    "55": [0.19444, 0.43056, 0, 0, 0.5],
    "56": [0, 0.64444, 0, 0, 0.5],
    "57": [0.19444, 0.43056, 0, 0, 0.5],
    "65": [0, 0.68333, 0, 0.13889, 0.75],
    "66": [0, 0.68333, 0.05017, 0.08334, 0.75851],
    "67": [0, 0.68333, 0.07153, 0.08334, 0.71472],
    "68": [0, 0.68333, 0.02778, 0.05556, 0.82792],
    "69": [0, 0.68333, 0.05764, 0.08334, 0.7382],
    "70": [0, 0.68333, 0.13889, 0.08334, 0.64306],
    "71": [0, 0.68333, 0, 0.08334, 0.78625],
    "72": [0, 0.68333, 0.08125, 0.05556, 0.83125],
    "73": [0, 0.68333, 0.07847, 0.11111, 0.43958],
    "74": [0, 0.68333, 0.09618, 0.16667, 0.55451],
    "75": [0, 0.68333, 0.07153, 0.05556, 0.84931],
    "76": [0, 0.68333, 0, 0.02778, 0.68056],
    "77": [0, 0.68333, 0.10903, 0.08334, 0.97014],
    "78": [0, 0.68333, 0.10903, 0.08334, 0.80347],
    "79": [0, 0.68333, 0.02778, 0.08334, 0.76278],
    "80": [0, 0.68333, 0.13889, 0.08334, 0.64201],
    "81": [0.19444, 0.68333, 0, 0.08334, 0.79056],
    "82": [0, 0.68333, 773e-5, 0.08334, 0.75929],
    "83": [0, 0.68333, 0.05764, 0.08334, 0.6132],
    "84": [0, 0.68333, 0.13889, 0.08334, 0.58438],
    "85": [0, 0.68333, 0.10903, 0.02778, 0.68278],
    "86": [0, 0.68333, 0.22222, 0, 0.58333],
    "87": [0, 0.68333, 0.13889, 0, 0.94445],
    "88": [0, 0.68333, 0.07847, 0.08334, 0.82847],
    "89": [0, 0.68333, 0.22222, 0, 0.58056],
    "90": [0, 0.68333, 0.07153, 0.08334, 0.68264],
    "97": [0, 0.43056, 0, 0, 0.52859],
    "98": [0, 0.69444, 0, 0, 0.42917],
    "99": [0, 0.43056, 0, 0.05556, 0.43276],
    "100": [0, 0.69444, 0, 0.16667, 0.52049],
    "101": [0, 0.43056, 0, 0.05556, 0.46563],
    "102": [0.19444, 0.69444, 0.10764, 0.16667, 0.48959],
    "103": [0.19444, 0.43056, 0.03588, 0.02778, 0.47697],
    "104": [0, 0.69444, 0, 0, 0.57616],
    "105": [0, 0.65952, 0, 0, 0.34451],
    "106": [0.19444, 0.65952, 0.05724, 0, 0.41181],
    "107": [0, 0.69444, 0.03148, 0, 0.5206],
    "108": [0, 0.69444, 0.01968, 0.08334, 0.29838],
    "109": [0, 0.43056, 0, 0, 0.87801],
    "110": [0, 0.43056, 0, 0, 0.60023],
    "111": [0, 0.43056, 0, 0.05556, 0.48472],
    "112": [0.19444, 0.43056, 0, 0.08334, 0.50313],
    "113": [0.19444, 0.43056, 0.03588, 0.08334, 0.44641],
    "114": [0, 0.43056, 0.02778, 0.05556, 0.45116],
    "115": [0, 0.43056, 0, 0.05556, 0.46875],
    "116": [0, 0.61508, 0, 0.08334, 0.36111],
    "117": [0, 0.43056, 0, 0.02778, 0.57246],
    "118": [0, 0.43056, 0.03588, 0.02778, 0.48472],
    "119": [0, 0.43056, 0.02691, 0.08334, 0.71592],
    "120": [0, 0.43056, 0, 0.02778, 0.57153],
    "121": [0.19444, 0.43056, 0.03588, 0.05556, 0.49028],
    "122": [0, 0.43056, 0.04398, 0.05556, 0.46505],
    "160": [0, 0, 0, 0, 0.25],
    "915": [0, 0.68333, 0.13889, 0.08334, 0.61528],
    "916": [0, 0.68333, 0, 0.16667, 0.83334],
    "920": [0, 0.68333, 0.02778, 0.08334, 0.76278],
    "923": [0, 0.68333, 0, 0.16667, 0.69445],
    "926": [0, 0.68333, 0.07569, 0.08334, 0.74236],
    "928": [0, 0.68333, 0.08125, 0.05556, 0.83125],
    "931": [0, 0.68333, 0.05764, 0.08334, 0.77986],
    "933": [0, 0.68333, 0.13889, 0.05556, 0.58333],
    "934": [0, 0.68333, 0, 0.08334, 0.66667],
    "936": [0, 0.68333, 0.11, 0.05556, 0.61222],
    "937": [0, 0.68333, 0.05017, 0.08334, 0.7724],
    "945": [0, 0.43056, 37e-4, 0.02778, 0.6397],
    "946": [0.19444, 0.69444, 0.05278, 0.08334, 0.56563],
    "947": [0.19444, 0.43056, 0.05556, 0, 0.51773],
    "948": [0, 0.69444, 0.03785, 0.05556, 0.44444],
    "949": [0, 0.43056, 0, 0.08334, 0.46632],
    "950": [0.19444, 0.69444, 0.07378, 0.08334, 0.4375],
    "951": [0.19444, 0.43056, 0.03588, 0.05556, 0.49653],
    "952": [0, 0.69444, 0.02778, 0.08334, 0.46944],
    "953": [0, 0.43056, 0, 0.05556, 0.35394],
    "954": [0, 0.43056, 0, 0, 0.57616],
    "955": [0, 0.69444, 0, 0, 0.58334],
    "956": [0.19444, 0.43056, 0, 0.02778, 0.60255],
    "957": [0, 0.43056, 0.06366, 0.02778, 0.49398],
    "958": [0.19444, 0.69444, 0.04601, 0.11111, 0.4375],
    "959": [0, 0.43056, 0, 0.05556, 0.48472],
    "960": [0, 0.43056, 0.03588, 0, 0.57003],
    "961": [0.19444, 0.43056, 0, 0.08334, 0.51702],
    "962": [0.09722, 0.43056, 0.07986, 0.08334, 0.36285],
    "963": [0, 0.43056, 0.03588, 0, 0.57141],
    "964": [0, 0.43056, 0.1132, 0.02778, 0.43715],
    "965": [0, 0.43056, 0.03588, 0.02778, 0.54028],
    "966": [0.19444, 0.43056, 0, 0.08334, 0.65417],
    "967": [0.19444, 0.43056, 0, 0.05556, 0.62569],
    "968": [0.19444, 0.69444, 0.03588, 0.11111, 0.65139],
    "969": [0, 0.43056, 0.03588, 0, 0.62245],
    "977": [0, 0.69444, 0, 0.08334, 0.59144],
    "981": [0.19444, 0.69444, 0, 0.08334, 0.59583],
    "982": [0, 0.43056, 0.02778, 0, 0.82813],
    "1009": [0.19444, 0.43056, 0, 0.08334, 0.51702],
    "1013": [0, 0.43056, 0, 0.05556, 0.4059],
    "57649": [0, 0.43056, 0, 0.02778, 0.32246],
    "57911": [0.19444, 0.43056, 0, 0.08334, 0.38403]
  },
  "SansSerif-Bold": {
    "32": [0, 0, 0, 0, 0.25],
    "33": [0, 0.69444, 0, 0, 0.36667],
    "34": [0, 0.69444, 0, 0, 0.55834],
    "35": [0.19444, 0.69444, 0, 0, 0.91667],
    "36": [0.05556, 0.75, 0, 0, 0.55],
    "37": [0.05556, 0.75, 0, 0, 1.02912],
    "38": [0, 0.69444, 0, 0, 0.83056],
    "39": [0, 0.69444, 0, 0, 0.30556],
    "40": [0.25, 0.75, 0, 0, 0.42778],
    "41": [0.25, 0.75, 0, 0, 0.42778],
    "42": [0, 0.75, 0, 0, 0.55],
    "43": [0.11667, 0.61667, 0, 0, 0.85556],
    "44": [0.10556, 0.13056, 0, 0, 0.30556],
    "45": [0, 0.45833, 0, 0, 0.36667],
    "46": [0, 0.13056, 0, 0, 0.30556],
    "47": [0.25, 0.75, 0, 0, 0.55],
    "48": [0, 0.69444, 0, 0, 0.55],
    "49": [0, 0.69444, 0, 0, 0.55],
    "50": [0, 0.69444, 0, 0, 0.55],
    "51": [0, 0.69444, 0, 0, 0.55],
    "52": [0, 0.69444, 0, 0, 0.55],
    "53": [0, 0.69444, 0, 0, 0.55],
    "54": [0, 0.69444, 0, 0, 0.55],
    "55": [0, 0.69444, 0, 0, 0.55],
    "56": [0, 0.69444, 0, 0, 0.55],
    "57": [0, 0.69444, 0, 0, 0.55],
    "58": [0, 0.45833, 0, 0, 0.30556],
    "59": [0.10556, 0.45833, 0, 0, 0.30556],
    "61": [-0.09375, 0.40625, 0, 0, 0.85556],
    "63": [0, 0.69444, 0, 0, 0.51945],
    "64": [0, 0.69444, 0, 0, 0.73334],
    "65": [0, 0.69444, 0, 0, 0.73334],
    "66": [0, 0.69444, 0, 0, 0.73334],
    "67": [0, 0.69444, 0, 0, 0.70278],
    "68": [0, 0.69444, 0, 0, 0.79445],
    "69": [0, 0.69444, 0, 0, 0.64167],
    "70": [0, 0.69444, 0, 0, 0.61111],
    "71": [0, 0.69444, 0, 0, 0.73334],
    "72": [0, 0.69444, 0, 0, 0.79445],
    "73": [0, 0.69444, 0, 0, 0.33056],
    "74": [0, 0.69444, 0, 0, 0.51945],
    "75": [0, 0.69444, 0, 0, 0.76389],
    "76": [0, 0.69444, 0, 0, 0.58056],
    "77": [0, 0.69444, 0, 0, 0.97778],
    "78": [0, 0.69444, 0, 0, 0.79445],
    "79": [0, 0.69444, 0, 0, 0.79445],
    "80": [0, 0.69444, 0, 0, 0.70278],
    "81": [0.10556, 0.69444, 0, 0, 0.79445],
    "82": [0, 0.69444, 0, 0, 0.70278],
    "83": [0, 0.69444, 0, 0, 0.61111],
    "84": [0, 0.69444, 0, 0, 0.73334],
    "85": [0, 0.69444, 0, 0, 0.76389],
    "86": [0, 0.69444, 0.01528, 0, 0.73334],
    "87": [0, 0.69444, 0.01528, 0, 1.03889],
    "88": [0, 0.69444, 0, 0, 0.73334],
    "89": [0, 0.69444, 0.0275, 0, 0.73334],
    "90": [0, 0.69444, 0, 0, 0.67223],
    "91": [0.25, 0.75, 0, 0, 0.34306],
    "93": [0.25, 0.75, 0, 0, 0.34306],
    "94": [0, 0.69444, 0, 0, 0.55],
    "95": [0.35, 0.10833, 0.03056, 0, 0.55],
    "97": [0, 0.45833, 0, 0, 0.525],
    "98": [0, 0.69444, 0, 0, 0.56111],
    "99": [0, 0.45833, 0, 0, 0.48889],
    "100": [0, 0.69444, 0, 0, 0.56111],
    "101": [0, 0.45833, 0, 0, 0.51111],
    "102": [0, 0.69444, 0.07639, 0, 0.33611],
    "103": [0.19444, 0.45833, 0.01528, 0, 0.55],
    "104": [0, 0.69444, 0, 0, 0.56111],
    "105": [0, 0.69444, 0, 0, 0.25556],
    "106": [0.19444, 0.69444, 0, 0, 0.28611],
    "107": [0, 0.69444, 0, 0, 0.53056],
    "108": [0, 0.69444, 0, 0, 0.25556],
    "109": [0, 0.45833, 0, 0, 0.86667],
    "110": [0, 0.45833, 0, 0, 0.56111],
    "111": [0, 0.45833, 0, 0, 0.55],
    "112": [0.19444, 0.45833, 0, 0, 0.56111],
    "113": [0.19444, 0.45833, 0, 0, 0.56111],
    "114": [0, 0.45833, 0.01528, 0, 0.37222],
    "115": [0, 0.45833, 0, 0, 0.42167],
    "116": [0, 0.58929, 0, 0, 0.40417],
    "117": [0, 0.45833, 0, 0, 0.56111],
    "118": [0, 0.45833, 0.01528, 0, 0.5],
    "119": [0, 0.45833, 0.01528, 0, 0.74445],
    "120": [0, 0.45833, 0, 0, 0.5],
    "121": [0.19444, 0.45833, 0.01528, 0, 0.5],
    "122": [0, 0.45833, 0, 0, 0.47639],
    "126": [0.35, 0.34444, 0, 0, 0.55],
    "160": [0, 0, 0, 0, 0.25],
    "168": [0, 0.69444, 0, 0, 0.55],
    "176": [0, 0.69444, 0, 0, 0.73334],
    "180": [0, 0.69444, 0, 0, 0.55],
    "184": [0.17014, 0, 0, 0, 0.48889],
    "305": [0, 0.45833, 0, 0, 0.25556],
    "567": [0.19444, 0.45833, 0, 0, 0.28611],
    "710": [0, 0.69444, 0, 0, 0.55],
    "711": [0, 0.63542, 0, 0, 0.55],
    "713": [0, 0.63778, 0, 0, 0.55],
    "728": [0, 0.69444, 0, 0, 0.55],
    "729": [0, 0.69444, 0, 0, 0.30556],
    "730": [0, 0.69444, 0, 0, 0.73334],
    "732": [0, 0.69444, 0, 0, 0.55],
    "733": [0, 0.69444, 0, 0, 0.55],
    "915": [0, 0.69444, 0, 0, 0.58056],
    "916": [0, 0.69444, 0, 0, 0.91667],
    "920": [0, 0.69444, 0, 0, 0.85556],
    "923": [0, 0.69444, 0, 0, 0.67223],
    "926": [0, 0.69444, 0, 0, 0.73334],
    "928": [0, 0.69444, 0, 0, 0.79445],
    "931": [0, 0.69444, 0, 0, 0.79445],
    "933": [0, 0.69444, 0, 0, 0.85556],
    "934": [0, 0.69444, 0, 0, 0.79445],
    "936": [0, 0.69444, 0, 0, 0.85556],
    "937": [0, 0.69444, 0, 0, 0.79445],
    "8211": [0, 0.45833, 0.03056, 0, 0.55],
    "8212": [0, 0.45833, 0.03056, 0, 1.10001],
    "8216": [0, 0.69444, 0, 0, 0.30556],
    "8217": [0, 0.69444, 0, 0, 0.30556],
    "8220": [0, 0.69444, 0, 0, 0.55834],
    "8221": [0, 0.69444, 0, 0, 0.55834]
  },
  "SansSerif-Italic": {
    "32": [0, 0, 0, 0, 0.25],
    "33": [0, 0.69444, 0.05733, 0, 0.31945],
    "34": [0, 0.69444, 316e-5, 0, 0.5],
    "35": [0.19444, 0.69444, 0.05087, 0, 0.83334],
    "36": [0.05556, 0.75, 0.11156, 0, 0.5],
    "37": [0.05556, 0.75, 0.03126, 0, 0.83334],
    "38": [0, 0.69444, 0.03058, 0, 0.75834],
    "39": [0, 0.69444, 0.07816, 0, 0.27778],
    "40": [0.25, 0.75, 0.13164, 0, 0.38889],
    "41": [0.25, 0.75, 0.02536, 0, 0.38889],
    "42": [0, 0.75, 0.11775, 0, 0.5],
    "43": [0.08333, 0.58333, 0.02536, 0, 0.77778],
    "44": [0.125, 0.08333, 0, 0, 0.27778],
    "45": [0, 0.44444, 0.01946, 0, 0.33333],
    "46": [0, 0.08333, 0, 0, 0.27778],
    "47": [0.25, 0.75, 0.13164, 0, 0.5],
    "48": [0, 0.65556, 0.11156, 0, 0.5],
    "49": [0, 0.65556, 0.11156, 0, 0.5],
    "50": [0, 0.65556, 0.11156, 0, 0.5],
    "51": [0, 0.65556, 0.11156, 0, 0.5],
    "52": [0, 0.65556, 0.11156, 0, 0.5],
    "53": [0, 0.65556, 0.11156, 0, 0.5],
    "54": [0, 0.65556, 0.11156, 0, 0.5],
    "55": [0, 0.65556, 0.11156, 0, 0.5],
    "56": [0, 0.65556, 0.11156, 0, 0.5],
    "57": [0, 0.65556, 0.11156, 0, 0.5],
    "58": [0, 0.44444, 0.02502, 0, 0.27778],
    "59": [0.125, 0.44444, 0.02502, 0, 0.27778],
    "61": [-0.13, 0.37, 0.05087, 0, 0.77778],
    "63": [0, 0.69444, 0.11809, 0, 0.47222],
    "64": [0, 0.69444, 0.07555, 0, 0.66667],
    "65": [0, 0.69444, 0, 0, 0.66667],
    "66": [0, 0.69444, 0.08293, 0, 0.66667],
    "67": [0, 0.69444, 0.11983, 0, 0.63889],
    "68": [0, 0.69444, 0.07555, 0, 0.72223],
    "69": [0, 0.69444, 0.11983, 0, 0.59722],
    "70": [0, 0.69444, 0.13372, 0, 0.56945],
    "71": [0, 0.69444, 0.11983, 0, 0.66667],
    "72": [0, 0.69444, 0.08094, 0, 0.70834],
    "73": [0, 0.69444, 0.13372, 0, 0.27778],
    "74": [0, 0.69444, 0.08094, 0, 0.47222],
    "75": [0, 0.69444, 0.11983, 0, 0.69445],
    "76": [0, 0.69444, 0, 0, 0.54167],
    "77": [0, 0.69444, 0.08094, 0, 0.875],
    "78": [0, 0.69444, 0.08094, 0, 0.70834],
    "79": [0, 0.69444, 0.07555, 0, 0.73611],
    "80": [0, 0.69444, 0.08293, 0, 0.63889],
    "81": [0.125, 0.69444, 0.07555, 0, 0.73611],
    "82": [0, 0.69444, 0.08293, 0, 0.64584],
    "83": [0, 0.69444, 0.09205, 0, 0.55556],
    "84": [0, 0.69444, 0.13372, 0, 0.68056],
    "85": [0, 0.69444, 0.08094, 0, 0.6875],
    "86": [0, 0.69444, 0.1615, 0, 0.66667],
    "87": [0, 0.69444, 0.1615, 0, 0.94445],
    "88": [0, 0.69444, 0.13372, 0, 0.66667],
    "89": [0, 0.69444, 0.17261, 0, 0.66667],
    "90": [0, 0.69444, 0.11983, 0, 0.61111],
    "91": [0.25, 0.75, 0.15942, 0, 0.28889],
    "93": [0.25, 0.75, 0.08719, 0, 0.28889],
    "94": [0, 0.69444, 0.0799, 0, 0.5],
    "95": [0.35, 0.09444, 0.08616, 0, 0.5],
    "97": [0, 0.44444, 981e-5, 0, 0.48056],
    "98": [0, 0.69444, 0.03057, 0, 0.51667],
    "99": [0, 0.44444, 0.08336, 0, 0.44445],
    "100": [0, 0.69444, 0.09483, 0, 0.51667],
    "101": [0, 0.44444, 0.06778, 0, 0.44445],
    "102": [0, 0.69444, 0.21705, 0, 0.30556],
    "103": [0.19444, 0.44444, 0.10836, 0, 0.5],
    "104": [0, 0.69444, 0.01778, 0, 0.51667],
    "105": [0, 0.67937, 0.09718, 0, 0.23889],
    "106": [0.19444, 0.67937, 0.09162, 0, 0.26667],
    "107": [0, 0.69444, 0.08336, 0, 0.48889],
    "108": [0, 0.69444, 0.09483, 0, 0.23889],
    "109": [0, 0.44444, 0.01778, 0, 0.79445],
    "110": [0, 0.44444, 0.01778, 0, 0.51667],
    "111": [0, 0.44444, 0.06613, 0, 0.5],
    "112": [0.19444, 0.44444, 0.0389, 0, 0.51667],
    "113": [0.19444, 0.44444, 0.04169, 0, 0.51667],
    "114": [0, 0.44444, 0.10836, 0, 0.34167],
    "115": [0, 0.44444, 0.0778, 0, 0.38333],
    "116": [0, 0.57143, 0.07225, 0, 0.36111],
    "117": [0, 0.44444, 0.04169, 0, 0.51667],
    "118": [0, 0.44444, 0.10836, 0, 0.46111],
    "119": [0, 0.44444, 0.10836, 0, 0.68334],
    "120": [0, 0.44444, 0.09169, 0, 0.46111],
    "121": [0.19444, 0.44444, 0.10836, 0, 0.46111],
    "122": [0, 0.44444, 0.08752, 0, 0.43472],
    "126": [0.35, 0.32659, 0.08826, 0, 0.5],
    "160": [0, 0, 0, 0, 0.25],
    "168": [0, 0.67937, 0.06385, 0, 0.5],
    "176": [0, 0.69444, 0, 0, 0.73752],
    "184": [0.17014, 0, 0, 0, 0.44445],
    "305": [0, 0.44444, 0.04169, 0, 0.23889],
    "567": [0.19444, 0.44444, 0.04169, 0, 0.26667],
    "710": [0, 0.69444, 0.0799, 0, 0.5],
    "711": [0, 0.63194, 0.08432, 0, 0.5],
    "713": [0, 0.60889, 0.08776, 0, 0.5],
    "714": [0, 0.69444, 0.09205, 0, 0.5],
    "715": [0, 0.69444, 0, 0, 0.5],
    "728": [0, 0.69444, 0.09483, 0, 0.5],
    "729": [0, 0.67937, 0.07774, 0, 0.27778],
    "730": [0, 0.69444, 0, 0, 0.73752],
    "732": [0, 0.67659, 0.08826, 0, 0.5],
    "733": [0, 0.69444, 0.09205, 0, 0.5],
    "915": [0, 0.69444, 0.13372, 0, 0.54167],
    "916": [0, 0.69444, 0, 0, 0.83334],
    "920": [0, 0.69444, 0.07555, 0, 0.77778],
    "923": [0, 0.69444, 0, 0, 0.61111],
    "926": [0, 0.69444, 0.12816, 0, 0.66667],
    "928": [0, 0.69444, 0.08094, 0, 0.70834],
    "931": [0, 0.69444, 0.11983, 0, 0.72222],
    "933": [0, 0.69444, 0.09031, 0, 0.77778],
    "934": [0, 0.69444, 0.04603, 0, 0.72222],
    "936": [0, 0.69444, 0.09031, 0, 0.77778],
    "937": [0, 0.69444, 0.08293, 0, 0.72222],
    "8211": [0, 0.44444, 0.08616, 0, 0.5],
    "8212": [0, 0.44444, 0.08616, 0, 1],
    "8216": [0, 0.69444, 0.07816, 0, 0.27778],
    "8217": [0, 0.69444, 0.07816, 0, 0.27778],
    "8220": [0, 0.69444, 0.14205, 0, 0.5],
    "8221": [0, 0.69444, 316e-5, 0, 0.5]
  },
  "SansSerif-Regular": {
    "32": [0, 0, 0, 0, 0.25],
    "33": [0, 0.69444, 0, 0, 0.31945],
    "34": [0, 0.69444, 0, 0, 0.5],
    "35": [0.19444, 0.69444, 0, 0, 0.83334],
    "36": [0.05556, 0.75, 0, 0, 0.5],
    "37": [0.05556, 0.75, 0, 0, 0.83334],
    "38": [0, 0.69444, 0, 0, 0.75834],
    "39": [0, 0.69444, 0, 0, 0.27778],
    "40": [0.25, 0.75, 0, 0, 0.38889],
    "41": [0.25, 0.75, 0, 0, 0.38889],
    "42": [0, 0.75, 0, 0, 0.5],
    "43": [0.08333, 0.58333, 0, 0, 0.77778],
    "44": [0.125, 0.08333, 0, 0, 0.27778],
    "45": [0, 0.44444, 0, 0, 0.33333],
    "46": [0, 0.08333, 0, 0, 0.27778],
    "47": [0.25, 0.75, 0, 0, 0.5],
    "48": [0, 0.65556, 0, 0, 0.5],
    "49": [0, 0.65556, 0, 0, 0.5],
    "50": [0, 0.65556, 0, 0, 0.5],
    "51": [0, 0.65556, 0, 0, 0.5],
    "52": [0, 0.65556, 0, 0, 0.5],
    "53": [0, 0.65556, 0, 0, 0.5],
    "54": [0, 0.65556, 0, 0, 0.5],
    "55": [0, 0.65556, 0, 0, 0.5],
    "56": [0, 0.65556, 0, 0, 0.5],
    "57": [0, 0.65556, 0, 0, 0.5],
    "58": [0, 0.44444, 0, 0, 0.27778],
    "59": [0.125, 0.44444, 0, 0, 0.27778],
    "61": [-0.13, 0.37, 0, 0, 0.77778],
    "63": [0, 0.69444, 0, 0, 0.47222],
    "64": [0, 0.69444, 0, 0, 0.66667],
    "65": [0, 0.69444, 0, 0, 0.66667],
    "66": [0, 0.69444, 0, 0, 0.66667],
    "67": [0, 0.69444, 0, 0, 0.63889],
    "68": [0, 0.69444, 0, 0, 0.72223],
    "69": [0, 0.69444, 0, 0, 0.59722],
    "70": [0, 0.69444, 0, 0, 0.56945],
    "71": [0, 0.69444, 0, 0, 0.66667],
    "72": [0, 0.69444, 0, 0, 0.70834],
    "73": [0, 0.69444, 0, 0, 0.27778],
    "74": [0, 0.69444, 0, 0, 0.47222],
    "75": [0, 0.69444, 0, 0, 0.69445],
    "76": [0, 0.69444, 0, 0, 0.54167],
    "77": [0, 0.69444, 0, 0, 0.875],
    "78": [0, 0.69444, 0, 0, 0.70834],
    "79": [0, 0.69444, 0, 0, 0.73611],
    "80": [0, 0.69444, 0, 0, 0.63889],
    "81": [0.125, 0.69444, 0, 0, 0.73611],
    "82": [0, 0.69444, 0, 0, 0.64584],
    "83": [0, 0.69444, 0, 0, 0.55556],
    "84": [0, 0.69444, 0, 0, 0.68056],
    "85": [0, 0.69444, 0, 0, 0.6875],
    "86": [0, 0.69444, 0.01389, 0, 0.66667],
    "87": [0, 0.69444, 0.01389, 0, 0.94445],
    "88": [0, 0.69444, 0, 0, 0.66667],
    "89": [0, 0.69444, 0.025, 0, 0.66667],
    "90": [0, 0.69444, 0, 0, 0.61111],
    "91": [0.25, 0.75, 0, 0, 0.28889],
    "93": [0.25, 0.75, 0, 0, 0.28889],
    "94": [0, 0.69444, 0, 0, 0.5],
    "95": [0.35, 0.09444, 0.02778, 0, 0.5],
    "97": [0, 0.44444, 0, 0, 0.48056],
    "98": [0, 0.69444, 0, 0, 0.51667],
    "99": [0, 0.44444, 0, 0, 0.44445],
    "100": [0, 0.69444, 0, 0, 0.51667],
    "101": [0, 0.44444, 0, 0, 0.44445],
    "102": [0, 0.69444, 0.06944, 0, 0.30556],
    "103": [0.19444, 0.44444, 0.01389, 0, 0.5],
    "104": [0, 0.69444, 0, 0, 0.51667],
    "105": [0, 0.67937, 0, 0, 0.23889],
    "106": [0.19444, 0.67937, 0, 0, 0.26667],
    "107": [0, 0.69444, 0, 0, 0.48889],
    "108": [0, 0.69444, 0, 0, 0.23889],
    "109": [0, 0.44444, 0, 0, 0.79445],
    "110": [0, 0.44444, 0, 0, 0.51667],
    "111": [0, 0.44444, 0, 0, 0.5],
    "112": [0.19444, 0.44444, 0, 0, 0.51667],
    "113": [0.19444, 0.44444, 0, 0, 0.51667],
    "114": [0, 0.44444, 0.01389, 0, 0.34167],
    "115": [0, 0.44444, 0, 0, 0.38333],
    "116": [0, 0.57143, 0, 0, 0.36111],
    "117": [0, 0.44444, 0, 0, 0.51667],
    "118": [0, 0.44444, 0.01389, 0, 0.46111],
    "119": [0, 0.44444, 0.01389, 0, 0.68334],
    "120": [0, 0.44444, 0, 0, 0.46111],
    "121": [0.19444, 0.44444, 0.01389, 0, 0.46111],
    "122": [0, 0.44444, 0, 0, 0.43472],
    "126": [0.35, 0.32659, 0, 0, 0.5],
    "160": [0, 0, 0, 0, 0.25],
    "168": [0, 0.67937, 0, 0, 0.5],
    "176": [0, 0.69444, 0, 0, 0.66667],
    "184": [0.17014, 0, 0, 0, 0.44445],
    "305": [0, 0.44444, 0, 0, 0.23889],
    "567": [0.19444, 0.44444, 0, 0, 0.26667],
    "710": [0, 0.69444, 0, 0, 0.5],
    "711": [0, 0.63194, 0, 0, 0.5],
    "713": [0, 0.60889, 0, 0, 0.5],
    "714": [0, 0.69444, 0, 0, 0.5],
    "715": [0, 0.69444, 0, 0, 0.5],
    "728": [0, 0.69444, 0, 0, 0.5],
    "729": [0, 0.67937, 0, 0, 0.27778],
    "730": [0, 0.69444, 0, 0, 0.66667],
    "732": [0, 0.67659, 0, 0, 0.5],
    "733": [0, 0.69444, 0, 0, 0.5],
    "915": [0, 0.69444, 0, 0, 0.54167],
    "916": [0, 0.69444, 0, 0, 0.83334],
    "920": [0, 0.69444, 0, 0, 0.77778],
    "923": [0, 0.69444, 0, 0, 0.61111],
    "926": [0, 0.69444, 0, 0, 0.66667],
    "928": [0, 0.69444, 0, 0, 0.70834],
    "931": [0, 0.69444, 0, 0, 0.72222],
    "933": [0, 0.69444, 0, 0, 0.77778],
    "934": [0, 0.69444, 0, 0, 0.72222],
    "936": [0, 0.69444, 0, 0, 0.77778],
    "937": [0, 0.69444, 0, 0, 0.72222],
    "8211": [0, 0.44444, 0.02778, 0, 0.5],
    "8212": [0, 0.44444, 0.02778, 0, 1],
    "8216": [0, 0.69444, 0, 0, 0.27778],
    "8217": [0, 0.69444, 0, 0, 0.27778],
    "8220": [0, 0.69444, 0, 0, 0.5],
    "8221": [0, 0.69444, 0, 0, 0.5]
  },
  "Script-Regular": {
    "32": [0, 0, 0, 0, 0.25],
    "65": [0, 0.7, 0.22925, 0, 0.80253],
    "66": [0, 0.7, 0.04087, 0, 0.90757],
    "67": [0, 0.7, 0.1689, 0, 0.66619],
    "68": [0, 0.7, 0.09371, 0, 0.77443],
    "69": [0, 0.7, 0.18583, 0, 0.56162],
    "70": [0, 0.7, 0.13634, 0, 0.89544],
    "71": [0, 0.7, 0.17322, 0, 0.60961],
    "72": [0, 0.7, 0.29694, 0, 0.96919],
    "73": [0, 0.7, 0.19189, 0, 0.80907],
    "74": [0.27778, 0.7, 0.19189, 0, 1.05159],
    "75": [0, 0.7, 0.31259, 0, 0.91364],
    "76": [0, 0.7, 0.19189, 0, 0.87373],
    "77": [0, 0.7, 0.15981, 0, 1.08031],
    "78": [0, 0.7, 0.3525, 0, 0.9015],
    "79": [0, 0.7, 0.08078, 0, 0.73787],
    "80": [0, 0.7, 0.08078, 0, 1.01262],
    "81": [0, 0.7, 0.03305, 0, 0.88282],
    "82": [0, 0.7, 0.06259, 0, 0.85],
    "83": [0, 0.7, 0.19189, 0, 0.86767],
    "84": [0, 0.7, 0.29087, 0, 0.74697],
    "85": [0, 0.7, 0.25815, 0, 0.79996],
    "86": [0, 0.7, 0.27523, 0, 0.62204],
    "87": [0, 0.7, 0.27523, 0, 0.80532],
    "88": [0, 0.7, 0.26006, 0, 0.94445],
    "89": [0, 0.7, 0.2939, 0, 0.70961],
    "90": [0, 0.7, 0.24037, 0, 0.8212],
    "160": [0, 0, 0, 0, 0.25]
  },
  "Size1-Regular": {
    "32": [0, 0, 0, 0, 0.25],
    "40": [0.35001, 0.85, 0, 0, 0.45834],
    "41": [0.35001, 0.85, 0, 0, 0.45834],
    "47": [0.35001, 0.85, 0, 0, 0.57778],
    "91": [0.35001, 0.85, 0, 0, 0.41667],
    "92": [0.35001, 0.85, 0, 0, 0.57778],
    "93": [0.35001, 0.85, 0, 0, 0.41667],
    "123": [0.35001, 0.85, 0, 0, 0.58334],
    "125": [0.35001, 0.85, 0, 0, 0.58334],
    "160": [0, 0, 0, 0, 0.25],
    "710": [0, 0.72222, 0, 0, 0.55556],
    "732": [0, 0.72222, 0, 0, 0.55556],
    "770": [0, 0.72222, 0, 0, 0.55556],
    "771": [0, 0.72222, 0, 0, 0.55556],
    "8214": [-99e-5, 0.601, 0, 0, 0.77778],
    "8593": [1e-5, 0.6, 0, 0, 0.66667],
    "8595": [1e-5, 0.6, 0, 0, 0.66667],
    "8657": [1e-5, 0.6, 0, 0, 0.77778],
    "8659": [1e-5, 0.6, 0, 0, 0.77778],
    "8719": [0.25001, 0.75, 0, 0, 0.94445],
    "8720": [0.25001, 0.75, 0, 0, 0.94445],
    "8721": [0.25001, 0.75, 0, 0, 1.05556],
    "8730": [0.35001, 0.85, 0, 0, 1],
    "8739": [-599e-5, 0.606, 0, 0, 0.33333],
    "8741": [-599e-5, 0.606, 0, 0, 0.55556],
    "8747": [0.30612, 0.805, 0.19445, 0, 0.47222],
    "8748": [0.306, 0.805, 0.19445, 0, 0.47222],
    "8749": [0.306, 0.805, 0.19445, 0, 0.47222],
    "8750": [0.30612, 0.805, 0.19445, 0, 0.47222],
    "8896": [0.25001, 0.75, 0, 0, 0.83334],
    "8897": [0.25001, 0.75, 0, 0, 0.83334],
    "8898": [0.25001, 0.75, 0, 0, 0.83334],
    "8899": [0.25001, 0.75, 0, 0, 0.83334],
    "8968": [0.35001, 0.85, 0, 0, 0.47222],
    "8969": [0.35001, 0.85, 0, 0, 0.47222],
    "8970": [0.35001, 0.85, 0, 0, 0.47222],
    "8971": [0.35001, 0.85, 0, 0, 0.47222],
    "9168": [-99e-5, 0.601, 0, 0, 0.66667],
    "10216": [0.35001, 0.85, 0, 0, 0.47222],
    "10217": [0.35001, 0.85, 0, 0, 0.47222],
    "10752": [0.25001, 0.75, 0, 0, 1.11111],
    "10753": [0.25001, 0.75, 0, 0, 1.11111],
    "10754": [0.25001, 0.75, 0, 0, 1.11111],
    "10756": [0.25001, 0.75, 0, 0, 0.83334],
    "10758": [0.25001, 0.75, 0, 0, 0.83334]
  },
  "Size2-Regular": {
    "32": [0, 0, 0, 0, 0.25],
    "40": [0.65002, 1.15, 0, 0, 0.59722],
    "41": [0.65002, 1.15, 0, 0, 0.59722],
    "47": [0.65002, 1.15, 0, 0, 0.81111],
    "91": [0.65002, 1.15, 0, 0, 0.47222],
    "92": [0.65002, 1.15, 0, 0, 0.81111],
    "93": [0.65002, 1.15, 0, 0, 0.47222],
    "123": [0.65002, 1.15, 0, 0, 0.66667],
    "125": [0.65002, 1.15, 0, 0, 0.66667],
    "160": [0, 0, 0, 0, 0.25],
    "710": [0, 0.75, 0, 0, 1],
    "732": [0, 0.75, 0, 0, 1],
    "770": [0, 0.75, 0, 0, 1],
    "771": [0, 0.75, 0, 0, 1],
    "8719": [0.55001, 1.05, 0, 0, 1.27778],
    "8720": [0.55001, 1.05, 0, 0, 1.27778],
    "8721": [0.55001, 1.05, 0, 0, 1.44445],
    "8730": [0.65002, 1.15, 0, 0, 1],
    "8747": [0.86225, 1.36, 0.44445, 0, 0.55556],
    "8748": [0.862, 1.36, 0.44445, 0, 0.55556],
    "8749": [0.862, 1.36, 0.44445, 0, 0.55556],
    "8750": [0.86225, 1.36, 0.44445, 0, 0.55556],
    "8896": [0.55001, 1.05, 0, 0, 1.11111],
    "8897": [0.55001, 1.05, 0, 0, 1.11111],
    "8898": [0.55001, 1.05, 0, 0, 1.11111],
    "8899": [0.55001, 1.05, 0, 0, 1.11111],
    "8968": [0.65002, 1.15, 0, 0, 0.52778],
    "8969": [0.65002, 1.15, 0, 0, 0.52778],
    "8970": [0.65002, 1.15, 0, 0, 0.52778],
    "8971": [0.65002, 1.15, 0, 0, 0.52778],
    "10216": [0.65002, 1.15, 0, 0, 0.61111],
    "10217": [0.65002, 1.15, 0, 0, 0.61111],
    "10752": [0.55001, 1.05, 0, 0, 1.51112],
    "10753": [0.55001, 1.05, 0, 0, 1.51112],
    "10754": [0.55001, 1.05, 0, 0, 1.51112],
    "10756": [0.55001, 1.05, 0, 0, 1.11111],
    "10758": [0.55001, 1.05, 0, 0, 1.11111]
  },
  "Size3-Regular": {
    "32": [0, 0, 0, 0, 0.25],
    "40": [0.95003, 1.45, 0, 0, 0.73611],
    "41": [0.95003, 1.45, 0, 0, 0.73611],
    "47": [0.95003, 1.45, 0, 0, 1.04445],
    "91": [0.95003, 1.45, 0, 0, 0.52778],
    "92": [0.95003, 1.45, 0, 0, 1.04445],
    "93": [0.95003, 1.45, 0, 0, 0.52778],
    "123": [0.95003, 1.45, 0, 0, 0.75],
    "125": [0.95003, 1.45, 0, 0, 0.75],
    "160": [0, 0, 0, 0, 0.25],
    "710": [0, 0.75, 0, 0, 1.44445],
    "732": [0, 0.75, 0, 0, 1.44445],
    "770": [0, 0.75, 0, 0, 1.44445],
    "771": [0, 0.75, 0, 0, 1.44445],
    "8730": [0.95003, 1.45, 0, 0, 1],
    "8968": [0.95003, 1.45, 0, 0, 0.58334],
    "8969": [0.95003, 1.45, 0, 0, 0.58334],
    "8970": [0.95003, 1.45, 0, 0, 0.58334],
    "8971": [0.95003, 1.45, 0, 0, 0.58334],
    "10216": [0.95003, 1.45, 0, 0, 0.75],
    "10217": [0.95003, 1.45, 0, 0, 0.75]
  },
  "Size4-Regular": {
    "32": [0, 0, 0, 0, 0.25],
    "40": [1.25003, 1.75, 0, 0, 0.79167],
    "41": [1.25003, 1.75, 0, 0, 0.79167],
    "47": [1.25003, 1.75, 0, 0, 1.27778],
    "91": [1.25003, 1.75, 0, 0, 0.58334],
    "92": [1.25003, 1.75, 0, 0, 1.27778],
    "93": [1.25003, 1.75, 0, 0, 0.58334],
    "123": [1.25003, 1.75, 0, 0, 0.80556],
    "125": [1.25003, 1.75, 0, 0, 0.80556],
    "160": [0, 0, 0, 0, 0.25],
    "710": [0, 0.825, 0, 0, 1.8889],
    "732": [0, 0.825, 0, 0, 1.8889],
    "770": [0, 0.825, 0, 0, 1.8889],
    "771": [0, 0.825, 0, 0, 1.8889],
    "8730": [1.25003, 1.75, 0, 0, 1],
    "8968": [1.25003, 1.75, 0, 0, 0.63889],
    "8969": [1.25003, 1.75, 0, 0, 0.63889],
    "8970": [1.25003, 1.75, 0, 0, 0.63889],
    "8971": [1.25003, 1.75, 0, 0, 0.63889],
    "9115": [0.64502, 1.155, 0, 0, 0.875],
    "9116": [1e-5, 0.6, 0, 0, 0.875],
    "9117": [0.64502, 1.155, 0, 0, 0.875],
    "9118": [0.64502, 1.155, 0, 0, 0.875],
    "9119": [1e-5, 0.6, 0, 0, 0.875],
    "9120": [0.64502, 1.155, 0, 0, 0.875],
    "9121": [0.64502, 1.155, 0, 0, 0.66667],
    "9122": [-99e-5, 0.601, 0, 0, 0.66667],
    "9123": [0.64502, 1.155, 0, 0, 0.66667],
    "9124": [0.64502, 1.155, 0, 0, 0.66667],
    "9125": [-99e-5, 0.601, 0, 0, 0.66667],
    "9126": [0.64502, 1.155, 0, 0, 0.66667],
    "9127": [1e-5, 0.9, 0, 0, 0.88889],
    "9128": [0.65002, 1.15, 0, 0, 0.88889],
    "9129": [0.90001, 0, 0, 0, 0.88889],
    "9130": [0, 0.3, 0, 0, 0.88889],
    "9131": [1e-5, 0.9, 0, 0, 0.88889],
    "9132": [0.65002, 1.15, 0, 0, 0.88889],
    "9133": [0.90001, 0, 0, 0, 0.88889],
    "9143": [0.88502, 0.915, 0, 0, 1.05556],
    "10216": [1.25003, 1.75, 0, 0, 0.80556],
    "10217": [1.25003, 1.75, 0, 0, 0.80556],
    "57344": [-499e-5, 0.605, 0, 0, 1.05556],
    "57345": [-499e-5, 0.605, 0, 0, 1.05556],
    "57680": [0, 0.12, 0, 0, 0.45],
    "57681": [0, 0.12, 0, 0, 0.45],
    "57682": [0, 0.12, 0, 0, 0.45],
    "57683": [0, 0.12, 0, 0, 0.45]
  },
  "Typewriter-Regular": {
    "32": [0, 0, 0, 0, 0.525],
    "33": [0, 0.61111, 0, 0, 0.525],
    "34": [0, 0.61111, 0, 0, 0.525],
    "35": [0, 0.61111, 0, 0, 0.525],
    "36": [0.08333, 0.69444, 0, 0, 0.525],
    "37": [0.08333, 0.69444, 0, 0, 0.525],
    "38": [0, 0.61111, 0, 0, 0.525],
    "39": [0, 0.61111, 0, 0, 0.525],
    "40": [0.08333, 0.69444, 0, 0, 0.525],
    "41": [0.08333, 0.69444, 0, 0, 0.525],
    "42": [0, 0.52083, 0, 0, 0.525],
    "43": [-0.08056, 0.53055, 0, 0, 0.525],
    "44": [0.13889, 0.125, 0, 0, 0.525],
    "45": [-0.08056, 0.53055, 0, 0, 0.525],
    "46": [0, 0.125, 0, 0, 0.525],
    "47": [0.08333, 0.69444, 0, 0, 0.525],
    "48": [0, 0.61111, 0, 0, 0.525],
    "49": [0, 0.61111, 0, 0, 0.525],
    "50": [0, 0.61111, 0, 0, 0.525],
    "51": [0, 0.61111, 0, 0, 0.525],
    "52": [0, 0.61111, 0, 0, 0.525],
    "53": [0, 0.61111, 0, 0, 0.525],
    "54": [0, 0.61111, 0, 0, 0.525],
    "55": [0, 0.61111, 0, 0, 0.525],
    "56": [0, 0.61111, 0, 0, 0.525],
    "57": [0, 0.61111, 0, 0, 0.525],
    "58": [0, 0.43056, 0, 0, 0.525],
    "59": [0.13889, 0.43056, 0, 0, 0.525],
    "60": [-0.05556, 0.55556, 0, 0, 0.525],
    "61": [-0.19549, 0.41562, 0, 0, 0.525],
    "62": [-0.05556, 0.55556, 0, 0, 0.525],
    "63": [0, 0.61111, 0, 0, 0.525],
    "64": [0, 0.61111, 0, 0, 0.525],
    "65": [0, 0.61111, 0, 0, 0.525],
    "66": [0, 0.61111, 0, 0, 0.525],
    "67": [0, 0.61111, 0, 0, 0.525],
    "68": [0, 0.61111, 0, 0, 0.525],
    "69": [0, 0.61111, 0, 0, 0.525],
    "70": [0, 0.61111, 0, 0, 0.525],
    "71": [0, 0.61111, 0, 0, 0.525],
    "72": [0, 0.61111, 0, 0, 0.525],
    "73": [0, 0.61111, 0, 0, 0.525],
    "74": [0, 0.61111, 0, 0, 0.525],
    "75": [0, 0.61111, 0, 0, 0.525],
    "76": [0, 0.61111, 0, 0, 0.525],
    "77": [0, 0.61111, 0, 0, 0.525],
    "78": [0, 0.61111, 0, 0, 0.525],
    "79": [0, 0.61111, 0, 0, 0.525],
    "80": [0, 0.61111, 0, 0, 0.525],
    "81": [0.13889, 0.61111, 0, 0, 0.525],
    "82": [0, 0.61111, 0, 0, 0.525],
    "83": [0, 0.61111, 0, 0, 0.525],
    "84": [0, 0.61111, 0, 0, 0.525],
    "85": [0, 0.61111, 0, 0, 0.525],
    "86": [0, 0.61111, 0, 0, 0.525],
    "87": [0, 0.61111, 0, 0, 0.525],
    "88": [0, 0.61111, 0, 0, 0.525],
    "89": [0, 0.61111, 0, 0, 0.525],
    "90": [0, 0.61111, 0, 0, 0.525],
    "91": [0.08333, 0.69444, 0, 0, 0.525],
    "92": [0.08333, 0.69444, 0, 0, 0.525],
    "93": [0.08333, 0.69444, 0, 0, 0.525],
    "94": [0, 0.61111, 0, 0, 0.525],
    "95": [0.09514, 0, 0, 0, 0.525],
    "96": [0, 0.61111, 0, 0, 0.525],
    "97": [0, 0.43056, 0, 0, 0.525],
    "98": [0, 0.61111, 0, 0, 0.525],
    "99": [0, 0.43056, 0, 0, 0.525],
    "100": [0, 0.61111, 0, 0, 0.525],
    "101": [0, 0.43056, 0, 0, 0.525],
    "102": [0, 0.61111, 0, 0, 0.525],
    "103": [0.22222, 0.43056, 0, 0, 0.525],
    "104": [0, 0.61111, 0, 0, 0.525],
    "105": [0, 0.61111, 0, 0, 0.525],
    "106": [0.22222, 0.61111, 0, 0, 0.525],
    "107": [0, 0.61111, 0, 0, 0.525],
    "108": [0, 0.61111, 0, 0, 0.525],
    "109": [0, 0.43056, 0, 0, 0.525],
    "110": [0, 0.43056, 0, 0, 0.525],
    "111": [0, 0.43056, 0, 0, 0.525],
    "112": [0.22222, 0.43056, 0, 0, 0.525],
    "113": [0.22222, 0.43056, 0, 0, 0.525],
    "114": [0, 0.43056, 0, 0, 0.525],
    "115": [0, 0.43056, 0, 0, 0.525],
    "116": [0, 0.55358, 0, 0, 0.525],
    "117": [0, 0.43056, 0, 0, 0.525],
    "118": [0, 0.43056, 0, 0, 0.525],
    "119": [0, 0.43056, 0, 0, 0.525],
    "120": [0, 0.43056, 0, 0, 0.525],
    "121": [0.22222, 0.43056, 0, 0, 0.525],
    "122": [0, 0.43056, 0, 0, 0.525],
    "123": [0.08333, 0.69444, 0, 0, 0.525],
    "124": [0.08333, 0.69444, 0, 0, 0.525],
    "125": [0.08333, 0.69444, 0, 0, 0.525],
    "126": [0, 0.61111, 0, 0, 0.525],
    "127": [0, 0.61111, 0, 0, 0.525],
    "160": [0, 0, 0, 0, 0.525],
    "176": [0, 0.61111, 0, 0, 0.525],
    "184": [0.19445, 0, 0, 0, 0.525],
    "305": [0, 0.43056, 0, 0, 0.525],
    "567": [0.22222, 0.43056, 0, 0, 0.525],
    "711": [0, 0.56597, 0, 0, 0.525],
    "713": [0, 0.56555, 0, 0, 0.525],
    "714": [0, 0.61111, 0, 0, 0.525],
    "715": [0, 0.61111, 0, 0, 0.525],
    "728": [0, 0.61111, 0, 0, 0.525],
    "730": [0, 0.61111, 0, 0, 0.525],
    "770": [0, 0.61111, 0, 0, 0.525],
    "771": [0, 0.61111, 0, 0, 0.525],
    "776": [0, 0.61111, 0, 0, 0.525],
    "915": [0, 0.61111, 0, 0, 0.525],
    "916": [0, 0.61111, 0, 0, 0.525],
    "920": [0, 0.61111, 0, 0, 0.525],
    "923": [0, 0.61111, 0, 0, 0.525],
    "926": [0, 0.61111, 0, 0, 0.525],
    "928": [0, 0.61111, 0, 0, 0.525],
    "931": [0, 0.61111, 0, 0, 0.525],
    "933": [0, 0.61111, 0, 0, 0.525],
    "934": [0, 0.61111, 0, 0, 0.525],
    "936": [0, 0.61111, 0, 0, 0.525],
    "937": [0, 0.61111, 0, 0, 0.525],
    "8216": [0, 0.61111, 0, 0, 0.525],
    "8217": [0, 0.61111, 0, 0, 0.525],
    "8242": [0, 0.61111, 0, 0, 0.525],
    "9251": [0.11111, 0.21944, 0, 0, 0.525]
  }
};
var sigmasAndXis = {
  slant: [0.25, 0.25, 0.25],
  // sigma1
  space: [0, 0, 0],
  // sigma2
  stretch: [0, 0, 0],
  // sigma3
  shrink: [0, 0, 0],
  // sigma4
  xHeight: [0.431, 0.431, 0.431],
  // sigma5
  quad: [1, 1.171, 1.472],
  // sigma6
  extraSpace: [0, 0, 0],
  // sigma7
  num1: [0.677, 0.732, 0.925],
  // sigma8
  num2: [0.394, 0.384, 0.387],
  // sigma9
  num3: [0.444, 0.471, 0.504],
  // sigma10
  denom1: [0.686, 0.752, 1.025],
  // sigma11
  denom2: [0.345, 0.344, 0.532],
  // sigma12
  sup1: [0.413, 0.503, 0.504],
  // sigma13
  sup2: [0.363, 0.431, 0.404],
  // sigma14
  sup3: [0.289, 0.286, 0.294],
  // sigma15
  sub1: [0.15, 0.143, 0.2],
  // sigma16
  sub2: [0.247, 0.286, 0.4],
  // sigma17
  supDrop: [0.386, 0.353, 0.494],
  // sigma18
  subDrop: [0.05, 0.071, 0.1],
  // sigma19
  delim1: [2.39, 1.7, 1.98],
  // sigma20
  delim2: [1.01, 1.157, 1.42],
  // sigma21
  axisHeight: [0.25, 0.25, 0.25],
  // sigma22
  // These font metrics are extracted from TeX by using tftopl on cmex10.tfm;
  // they correspond to the font parameters of the extension fonts (family 3).
  // See the TeXbook, page 441. In AMSTeX, the extension fonts scale; to
  // match cmex7, we'd use cmex7.tfm values for script and scriptscript
  // values.
  defaultRuleThickness: [0.04, 0.049, 0.049],
  // xi8; cmex7: 0.049
  bigOpSpacing1: [0.111, 0.111, 0.111],
  // xi9
  bigOpSpacing2: [0.166, 0.166, 0.166],
  // xi10
  bigOpSpacing3: [0.2, 0.2, 0.2],
  // xi11
  bigOpSpacing4: [0.6, 0.611, 0.611],
  // xi12; cmex7: 0.611
  bigOpSpacing5: [0.1, 0.143, 0.143],
  // xi13; cmex7: 0.143
  // The \sqrt rule width is taken from the height of the surd character.
  // Since we use the same font at all sizes, this thickness doesn't scale.
  sqrtRuleThickness: [0.04, 0.04, 0.04],
  // This value determines how large a pt is, for metrics which are defined
  // in terms of pts.
  // This value is also used in katex.less; if you change it make sure the
  // values match.
  ptPerEm: [10, 10, 10],
  // The space between adjacent `|` columns in an array definition. From
  // `\showthe\doublerulesep` in LaTeX. Equals 2.0 / ptPerEm.
  doubleRuleSep: [0.2, 0.2, 0.2],
  // The width of separator lines in {array} environments. From
  // `\showthe\arrayrulewidth` in LaTeX. Equals 0.4 / ptPerEm.
  arrayRuleWidth: [0.04, 0.04, 0.04],
  // Two values from LaTeX source2e:
  fboxsep: [0.3, 0.3, 0.3],
  //        3 pt / ptPerEm
  fboxrule: [0.04, 0.04, 0.04]
  // 0.4 pt / ptPerEm
};
var extraCharacterMap = {
  // Latin-1
  "\xC5": "A",
  "\xD0": "D",
  "\xDE": "o",
  "\xE5": "a",
  "\xF0": "d",
  "\xFE": "o",
  // Cyrillic
  "\u0410": "A",
  "\u0411": "B",
  "\u0412": "B",
  "\u0413": "F",
  "\u0414": "A",
  "\u0415": "E",
  "\u0416": "K",
  "\u0417": "3",
  "\u0418": "N",
  "\u0419": "N",
  "\u041A": "K",
  "\u041B": "N",
  "\u041C": "M",
  "\u041D": "H",
  "\u041E": "O",
  "\u041F": "N",
  "\u0420": "P",
  "\u0421": "C",
  "\u0422": "T",
  "\u0423": "y",
  "\u0424": "O",
  "\u0425": "X",
  "\u0426": "U",
  "\u0427": "h",
  "\u0428": "W",
  "\u0429": "W",
  "\u042A": "B",
  "\u042B": "X",
  "\u042C": "B",
  "\u042D": "3",
  "\u042E": "X",
  "\u042F": "R",
  "\u0430": "a",
  "\u0431": "b",
  "\u0432": "a",
  "\u0433": "r",
  "\u0434": "y",
  "\u0435": "e",
  "\u0436": "m",
  "\u0437": "e",
  "\u0438": "n",
  "\u0439": "n",
  "\u043A": "n",
  "\u043B": "n",
  "\u043C": "m",
  "\u043D": "n",
  "\u043E": "o",
  "\u043F": "n",
  "\u0440": "p",
  "\u0441": "c",
  "\u0442": "o",
  "\u0443": "y",
  "\u0444": "b",
  "\u0445": "x",
  "\u0446": "n",
  "\u0447": "n",
  "\u0448": "w",
  "\u0449": "w",
  "\u044A": "a",
  "\u044B": "m",
  "\u044C": "a",
  "\u044D": "e",
  "\u044E": "m",
  "\u044F": "r"
};
function setFontMetrics(fontName, metrics) {
  fontMetricsData[fontName] = metrics;
}
function getCharacterMetrics(character, font, mode) {
  if (!fontMetricsData[font]) {
    throw new Error("Font metrics not found for font: " + font + ".");
  }
  var ch = character.charCodeAt(0);
  var metrics = fontMetricsData[font][ch];
  if (!metrics && character[0] in extraCharacterMap) {
    ch = extraCharacterMap[character[0]].charCodeAt(0);
    metrics = fontMetricsData[font][ch];
  }
  if (!metrics && mode === "text") {
    if (supportedCodepoint(ch)) {
      metrics = fontMetricsData[font][77];
    }
  }
  if (metrics) {
    return {
      depth: metrics[0],
      height: metrics[1],
      italic: metrics[2],
      skew: metrics[3],
      width: metrics[4]
    };
  }
}
var fontMetricsBySizeIndex = {};
function getGlobalMetrics(size2) {
  var sizeIndex;
  if (size2 >= 5) {
    sizeIndex = 0;
  } else if (size2 >= 3) {
    sizeIndex = 1;
  } else {
    sizeIndex = 2;
  }
  if (!fontMetricsBySizeIndex[sizeIndex]) {
    var metrics = fontMetricsBySizeIndex[sizeIndex] = {
      cssEmPerMu: sigmasAndXis.quad[sizeIndex] / 18
    };
    for (var key in sigmasAndXis) {
      if (sigmasAndXis.hasOwnProperty(key)) {
        metrics[key] = sigmasAndXis[key][sizeIndex];
      }
    }
  }
  return fontMetricsBySizeIndex[sizeIndex];
}
var sizeStyleMap = [
  // Each element contains [textsize, scriptsize, scriptscriptsize].
  // The size mappings are taken from TeX with \normalsize=10pt.
  [1, 1, 1],
  // size1: [5, 5, 5]              \tiny
  [2, 1, 1],
  // size2: [6, 5, 5]
  [3, 1, 1],
  // size3: [7, 5, 5]              \scriptsize
  [4, 2, 1],
  // size4: [8, 6, 5]              \footnotesize
  [5, 2, 1],
  // size5: [9, 6, 5]              \small
  [6, 3, 1],
  // size6: [10, 7, 5]             \normalsize
  [7, 4, 2],
  // size7: [12, 8, 6]             \large
  [8, 6, 3],
  // size8: [14.4, 10, 7]          \Large
  [9, 7, 6],
  // size9: [17.28, 12, 10]        \LARGE
  [10, 8, 7],
  // size10: [20.74, 14.4, 12]     \huge
  [11, 10, 9]
  // size11: [24.88, 20.74, 17.28] \HUGE
];
var sizeMultipliers = [
  // fontMetrics.js:getGlobalMetrics also uses size indexes, so if
  // you change size indexes, change that function.
  0.5,
  0.6,
  0.7,
  0.8,
  0.9,
  1,
  1.2,
  1.44,
  1.728,
  2.074,
  2.488
];
var sizeAtStyle = function sizeAtStyle2(size2, style) {
  return style.size < 2 ? size2 : sizeStyleMap[size2 - 1][style.size - 1];
};
var Options = class {
  // A font family applies to a group of fonts (i.e. SansSerif), while a font
  // represents a specific font (i.e. SansSerif Bold).
  // See: https://tex.stackexchange.com/questions/22350/difference-between-textrm-and-mathrm
  /**
   * The base size index.
   */
  constructor(data2) {
    this.style = void 0;
    this.color = void 0;
    this.size = void 0;
    this.textSize = void 0;
    this.phantom = void 0;
    this.font = void 0;
    this.fontFamily = void 0;
    this.fontWeight = void 0;
    this.fontShape = void 0;
    this.sizeMultiplier = void 0;
    this.maxSize = void 0;
    this.minRuleThickness = void 0;
    this._fontMetrics = void 0;
    this.style = data2.style;
    this.color = data2.color;
    this.size = data2.size || Options.BASESIZE;
    this.textSize = data2.textSize || this.size;
    this.phantom = !!data2.phantom;
    this.font = data2.font || "";
    this.fontFamily = data2.fontFamily || "";
    this.fontWeight = data2.fontWeight || "";
    this.fontShape = data2.fontShape || "";
    this.sizeMultiplier = sizeMultipliers[this.size - 1];
    this.maxSize = data2.maxSize;
    this.minRuleThickness = data2.minRuleThickness;
    this._fontMetrics = void 0;
  }
  /**
   * Returns a new options object with the same properties as "this".  Properties
   * from "extension" will be copied to the new options object.
   */
  extend(extension2) {
    var data2 = {
      style: this.style,
      size: this.size,
      textSize: this.textSize,
      color: this.color,
      phantom: this.phantom,
      font: this.font,
      fontFamily: this.fontFamily,
      fontWeight: this.fontWeight,
      fontShape: this.fontShape,
      maxSize: this.maxSize,
      minRuleThickness: this.minRuleThickness
    };
    for (var key in extension2) {
      if (extension2.hasOwnProperty(key)) {
        data2[key] = extension2[key];
      }
    }
    return new Options(data2);
  }
  /**
   * Return an options object with the given style. If `this.style === style`,
   * returns `this`.
   */
  havingStyle(style) {
    if (this.style === style) {
      return this;
    } else {
      return this.extend({
        style,
        size: sizeAtStyle(this.textSize, style)
      });
    }
  }
  /**
   * Return an options object with a cramped version of the current style. If
   * the current style is cramped, returns `this`.
   */
  havingCrampedStyle() {
    return this.havingStyle(this.style.cramp());
  }
  /**
   * Return an options object with the given size and in at least `\textstyle`.
   * Returns `this` if appropriate.
   */
  havingSize(size2) {
    if (this.size === size2 && this.textSize === size2) {
      return this;
    } else {
      return this.extend({
        style: this.style.text(),
        size: size2,
        textSize: size2,
        sizeMultiplier: sizeMultipliers[size2 - 1]
      });
    }
  }
  /**
   * Like `this.havingSize(BASESIZE).havingStyle(style)`. If `style` is omitted,
   * changes to at least `\textstyle`.
   */
  havingBaseStyle(style) {
    style = style || this.style.text();
    var wantSize = sizeAtStyle(Options.BASESIZE, style);
    if (this.size === wantSize && this.textSize === Options.BASESIZE && this.style === style) {
      return this;
    } else {
      return this.extend({
        style,
        size: wantSize
      });
    }
  }
  /**
   * Remove the effect of sizing changes such as \Huge.
   * Keep the effect of the current style, such as \scriptstyle.
   */
  havingBaseSizing() {
    var size2;
    switch (this.style.id) {
      case 4:
      case 5:
        size2 = 3;
        break;
      case 6:
      case 7:
        size2 = 1;
        break;
      default:
        size2 = 6;
    }
    return this.extend({
      style: this.style.text(),
      size: size2
    });
  }
  /**
   * Create a new options object with the given color.
   */
  withColor(color) {
    return this.extend({
      color
    });
  }
  /**
   * Create a new options object with "phantom" set to true.
   */
  withPhantom() {
    return this.extend({
      phantom: true
    });
  }
  /**
   * Creates a new options object with the given math font or old text font.
   * @type {[type]}
   */
  withFont(font) {
    return this.extend({
      font
    });
  }
  /**
   * Create a new options objects with the given fontFamily.
   */
  withTextFontFamily(fontFamily) {
    return this.extend({
      fontFamily,
      font: ""
    });
  }
  /**
   * Creates a new options object with the given font weight
   */
  withTextFontWeight(fontWeight) {
    return this.extend({
      fontWeight,
      font: ""
    });
  }
  /**
   * Creates a new options object with the given font weight
   */
  withTextFontShape(fontShape) {
    return this.extend({
      fontShape,
      font: ""
    });
  }
  /**
   * Return the CSS sizing classes required to switch from enclosing options
   * `oldOptions` to `this`. Returns an array of classes.
   */
  sizingClasses(oldOptions) {
    if (oldOptions.size !== this.size) {
      return ["sizing", "reset-size" + oldOptions.size, "size" + this.size];
    } else {
      return [];
    }
  }
  /**
   * Return the CSS sizing classes required to switch to the base size. Like
   * `this.havingSize(BASESIZE).sizingClasses(this)`.
   */
  baseSizingClasses() {
    if (this.size !== Options.BASESIZE) {
      return ["sizing", "reset-size" + this.size, "size" + Options.BASESIZE];
    } else {
      return [];
    }
  }
  /**
   * Return the font metrics for this size.
   */
  fontMetrics() {
    if (!this._fontMetrics) {
      this._fontMetrics = getGlobalMetrics(this.size);
    }
    return this._fontMetrics;
  }
  /**
   * Gets the CSS color of the current options object
   */
  getColor() {
    if (this.phantom) {
      return "transparent";
    } else {
      return this.color;
    }
  }
};
Options.BASESIZE = 6;
var ptPerUnit = {
  // https://en.wikibooks.org/wiki/LaTeX/Lengths and
  // https://tex.stackexchange.com/a/8263
  "pt": 1,
  // TeX point
  "mm": 7227 / 2540,
  // millimeter
  "cm": 7227 / 254,
  // centimeter
  "in": 72.27,
  // inch
  "bp": 803 / 800,
  // big (PostScript) points
  "pc": 12,
  // pica
  "dd": 1238 / 1157,
  // didot
  "cc": 14856 / 1157,
  // cicero (12 didot)
  "nd": 685 / 642,
  // new didot
  "nc": 1370 / 107,
  // new cicero (12 new didot)
  "sp": 1 / 65536,
  // scaled point (TeX's internal smallest unit)
  // https://tex.stackexchange.com/a/41371
  "px": 803 / 800
  // \pdfpxdimen defaults to 1 bp in pdfTeX and LuaTeX
};
var relativeUnit = {
  "ex": true,
  "em": true,
  "mu": true
};
var validUnit = function validUnit2(unit) {
  if (typeof unit !== "string") {
    unit = unit.unit;
  }
  return unit in ptPerUnit || unit in relativeUnit || unit === "ex";
};
var calculateSize = function calculateSize2(sizeValue, options) {
  var scale3;
  if (sizeValue.unit in ptPerUnit) {
    scale3 = ptPerUnit[sizeValue.unit] / options.fontMetrics().ptPerEm / options.sizeMultiplier;
  } else if (sizeValue.unit === "mu") {
    scale3 = options.fontMetrics().cssEmPerMu;
  } else {
    var unitOptions;
    if (options.style.isTight()) {
      unitOptions = options.havingStyle(options.style.text());
    } else {
      unitOptions = options;
    }
    if (sizeValue.unit === "ex") {
      scale3 = unitOptions.fontMetrics().xHeight;
    } else if (sizeValue.unit === "em") {
      scale3 = unitOptions.fontMetrics().quad;
    } else {
      throw new ParseError("Invalid unit: '" + sizeValue.unit + "'");
    }
    if (unitOptions !== options) {
      scale3 *= unitOptions.sizeMultiplier / options.sizeMultiplier;
    }
  }
  return Math.min(sizeValue.number * scale3, options.maxSize);
};
var makeEm = function makeEm2(n2) {
  return +n2.toFixed(4) + "em";
};
var createClass = function createClass2(classes2) {
  return classes2.filter((cls) => cls).join(" ");
};
var initNode = function initNode2(classes2, options, style) {
  this.classes = classes2 || [];
  this.attributes = {};
  this.height = 0;
  this.depth = 0;
  this.maxFontSize = 0;
  this.style = style || {};
  if (options) {
    if (options.style.isTight()) {
      this.classes.push("mtight");
    }
    var color = options.getColor();
    if (color) {
      this.style.color = color;
    }
  }
};
var toNode = function toNode2(tagName) {
  var node3 = document.createElement(tagName);
  node3.className = createClass(this.classes);
  for (var style in this.style) {
    if (this.style.hasOwnProperty(style)) {
      node3.style[style] = this.style[style];
    }
  }
  for (var attr2 in this.attributes) {
    if (this.attributes.hasOwnProperty(attr2)) {
      node3.setAttribute(attr2, this.attributes[attr2]);
    }
  }
  for (var i2 = 0; i2 < this.children.length; i2++) {
    node3.appendChild(this.children[i2].toNode());
  }
  return node3;
};
var toMarkup = function toMarkup2(tagName) {
  var markup = "<" + tagName;
  if (this.classes.length) {
    markup += ' class="' + utils.escape(createClass(this.classes)) + '"';
  }
  var styles2 = "";
  for (var style in this.style) {
    if (this.style.hasOwnProperty(style)) {
      styles2 += utils.hyphenate(style) + ":" + this.style[style] + ";";
    }
  }
  if (styles2) {
    markup += ' style="' + utils.escape(styles2) + '"';
  }
  for (var attr2 in this.attributes) {
    if (this.attributes.hasOwnProperty(attr2)) {
      markup += " " + attr2 + '="' + utils.escape(this.attributes[attr2]) + '"';
    }
  }
  markup += ">";
  for (var i2 = 0; i2 < this.children.length; i2++) {
    markup += this.children[i2].toMarkup();
  }
  markup += "</" + tagName + ">";
  return markup;
};
var Span = class {
  constructor(classes2, children, options, style) {
    this.children = void 0;
    this.attributes = void 0;
    this.classes = void 0;
    this.height = void 0;
    this.depth = void 0;
    this.width = void 0;
    this.maxFontSize = void 0;
    this.style = void 0;
    initNode.call(this, classes2, options, style);
    this.children = children || [];
  }
  /**
   * Sets an arbitrary attribute on the span. Warning: use this wisely. Not
   * all browsers support attributes the same, and having too many custom
   * attributes is probably bad.
   */
  setAttribute(attribute, value) {
    this.attributes[attribute] = value;
  }
  hasClass(className) {
    return utils.contains(this.classes, className);
  }
  toNode() {
    return toNode.call(this, "span");
  }
  toMarkup() {
    return toMarkup.call(this, "span");
  }
};
var Anchor = class {
  constructor(href, classes2, children, options) {
    this.children = void 0;
    this.attributes = void 0;
    this.classes = void 0;
    this.height = void 0;
    this.depth = void 0;
    this.maxFontSize = void 0;
    this.style = void 0;
    initNode.call(this, classes2, options);
    this.children = children || [];
    this.setAttribute("href", href);
  }
  setAttribute(attribute, value) {
    this.attributes[attribute] = value;
  }
  hasClass(className) {
    return utils.contains(this.classes, className);
  }
  toNode() {
    return toNode.call(this, "a");
  }
  toMarkup() {
    return toMarkup.call(this, "a");
  }
};
var Img = class {
  constructor(src, alt, style) {
    this.src = void 0;
    this.alt = void 0;
    this.classes = void 0;
    this.height = void 0;
    this.depth = void 0;
    this.maxFontSize = void 0;
    this.style = void 0;
    this.alt = alt;
    this.src = src;
    this.classes = ["mord"];
    this.style = style;
  }
  hasClass(className) {
    return utils.contains(this.classes, className);
  }
  toNode() {
    var node3 = document.createElement("img");
    node3.src = this.src;
    node3.alt = this.alt;
    node3.className = "mord";
    for (var style in this.style) {
      if (this.style.hasOwnProperty(style)) {
        node3.style[style] = this.style[style];
      }
    }
    return node3;
  }
  toMarkup() {
    var markup = "<img  src='" + this.src + " 'alt='" + this.alt + "' ";
    var styles2 = "";
    for (var style in this.style) {
      if (this.style.hasOwnProperty(style)) {
        styles2 += utils.hyphenate(style) + ":" + this.style[style] + ";";
      }
    }
    if (styles2) {
      markup += ' style="' + utils.escape(styles2) + '"';
    }
    markup += "'/>";
    return markup;
  }
};
var iCombinations = {
  "\xEE": "\u0131\u0302",
  "\xEF": "\u0131\u0308",
  "\xED": "\u0131\u0301",
  // 'ī': '\u0131\u0304', // enable when we add Extended Latin
  "\xEC": "\u0131\u0300"
};
var SymbolNode = class {
  constructor(text4, height2, depth, italic, skew, width2, classes2, style) {
    this.text = void 0;
    this.height = void 0;
    this.depth = void 0;
    this.italic = void 0;
    this.skew = void 0;
    this.width = void 0;
    this.maxFontSize = void 0;
    this.classes = void 0;
    this.style = void 0;
    this.text = text4;
    this.height = height2 || 0;
    this.depth = depth || 0;
    this.italic = italic || 0;
    this.skew = skew || 0;
    this.width = width2 || 0;
    this.classes = classes2 || [];
    this.style = style || {};
    this.maxFontSize = 0;
    var script = scriptFromCodepoint(this.text.charCodeAt(0));
    if (script) {
      this.classes.push(script + "_fallback");
    }
    if (/[îïíì]/.test(this.text)) {
      this.text = iCombinations[this.text];
    }
  }
  hasClass(className) {
    return utils.contains(this.classes, className);
  }
  /**
   * Creates a text node or span from a symbol node. Note that a span is only
   * created if it is needed.
   */
  toNode() {
    var node3 = document.createTextNode(this.text);
    var span = null;
    if (this.italic > 0) {
      span = document.createElement("span");
      span.style.marginRight = makeEm(this.italic);
    }
    if (this.classes.length > 0) {
      span = span || document.createElement("span");
      span.className = createClass(this.classes);
    }
    for (var style in this.style) {
      if (this.style.hasOwnProperty(style)) {
        span = span || document.createElement("span");
        span.style[style] = this.style[style];
      }
    }
    if (span) {
      span.appendChild(node3);
      return span;
    } else {
      return node3;
    }
  }
  /**
   * Creates markup for a symbol node.
   */
  toMarkup() {
    var needsSpan = false;
    var markup = "<span";
    if (this.classes.length) {
      needsSpan = true;
      markup += ' class="';
      markup += utils.escape(createClass(this.classes));
      markup += '"';
    }
    var styles2 = "";
    if (this.italic > 0) {
      styles2 += "margin-right:" + this.italic + "em;";
    }
    for (var style in this.style) {
      if (this.style.hasOwnProperty(style)) {
        styles2 += utils.hyphenate(style) + ":" + this.style[style] + ";";
      }
    }
    if (styles2) {
      needsSpan = true;
      markup += ' style="' + utils.escape(styles2) + '"';
    }
    var escaped = utils.escape(this.text);
    if (needsSpan) {
      markup += ">";
      markup += escaped;
      markup += "</span>";
      return markup;
    } else {
      return escaped;
    }
  }
};
var SvgNode = class {
  constructor(children, attributes) {
    this.children = void 0;
    this.attributes = void 0;
    this.children = children || [];
    this.attributes = attributes || {};
  }
  toNode() {
    var svgNS = "http://www.w3.org/2000/svg";
    var node3 = document.createElementNS(svgNS, "svg");
    for (var attr2 in this.attributes) {
      if (Object.prototype.hasOwnProperty.call(this.attributes, attr2)) {
        node3.setAttribute(attr2, this.attributes[attr2]);
      }
    }
    for (var i2 = 0; i2 < this.children.length; i2++) {
      node3.appendChild(this.children[i2].toNode());
    }
    return node3;
  }
  toMarkup() {
    var markup = '<svg xmlns="http://www.w3.org/2000/svg"';
    for (var attr2 in this.attributes) {
      if (Object.prototype.hasOwnProperty.call(this.attributes, attr2)) {
        markup += " " + attr2 + "='" + this.attributes[attr2] + "'";
      }
    }
    markup += ">";
    for (var i2 = 0; i2 < this.children.length; i2++) {
      markup += this.children[i2].toMarkup();
    }
    markup += "</svg>";
    return markup;
  }
};
var PathNode = class {
  constructor(pathName, alternate) {
    this.pathName = void 0;
    this.alternate = void 0;
    this.pathName = pathName;
    this.alternate = alternate;
  }
  toNode() {
    var svgNS = "http://www.w3.org/2000/svg";
    var node3 = document.createElementNS(svgNS, "path");
    if (this.alternate) {
      node3.setAttribute("d", this.alternate);
    } else {
      node3.setAttribute("d", path[this.pathName]);
    }
    return node3;
  }
  toMarkup() {
    if (this.alternate) {
      return "<path d='" + this.alternate + "'/>";
    } else {
      return "<path d='" + path[this.pathName] + "'/>";
    }
  }
};
var LineNode = class {
  constructor(attributes) {
    this.attributes = void 0;
    this.attributes = attributes || {};
  }
  toNode() {
    var svgNS = "http://www.w3.org/2000/svg";
    var node3 = document.createElementNS(svgNS, "line");
    for (var attr2 in this.attributes) {
      if (Object.prototype.hasOwnProperty.call(this.attributes, attr2)) {
        node3.setAttribute(attr2, this.attributes[attr2]);
      }
    }
    return node3;
  }
  toMarkup() {
    var markup = "<line";
    for (var attr2 in this.attributes) {
      if (Object.prototype.hasOwnProperty.call(this.attributes, attr2)) {
        markup += " " + attr2 + "='" + this.attributes[attr2] + "'";
      }
    }
    markup += "/>";
    return markup;
  }
};
function assertSymbolDomNode(group) {
  if (group instanceof SymbolNode) {
    return group;
  } else {
    throw new Error("Expected symbolNode but got " + String(group) + ".");
  }
}
function assertSpan(group) {
  if (group instanceof Span) {
    return group;
  } else {
    throw new Error("Expected span<HtmlDomNode> but got " + String(group) + ".");
  }
}
var ATOMS = {
  "bin": 1,
  "close": 1,
  "inner": 1,
  "open": 1,
  "punct": 1,
  "rel": 1
};
var NON_ATOMS = {
  "accent-token": 1,
  "mathord": 1,
  "op-token": 1,
  "spacing": 1,
  "textord": 1
};
var symbols = {
  "math": {},
  "text": {}
};
function defineSymbol(mode, font, group, replace, name, acceptUnicodeChar) {
  symbols[mode][name] = {
    font,
    group,
    replace
  };
  if (acceptUnicodeChar && replace) {
    symbols[mode][replace] = symbols[mode][name];
  }
}
var math = "math";
var text = "text";
var main = "main";
var ams = "ams";
var accent = "accent-token";
var bin = "bin";
var close2 = "close";
var inner = "inner";
var mathord = "mathord";
var op = "op-token";
var open3 = "open";
var punct = "punct";
var rel = "rel";
var spacing = "spacing";
var textord = "textord";
defineSymbol(math, main, rel, "\u2261", "\\equiv", true);
defineSymbol(math, main, rel, "\u227A", "\\prec", true);
defineSymbol(math, main, rel, "\u227B", "\\succ", true);
defineSymbol(math, main, rel, "\u223C", "\\sim", true);
defineSymbol(math, main, rel, "\u22A5", "\\perp");
defineSymbol(math, main, rel, "\u2AAF", "\\preceq", true);
defineSymbol(math, main, rel, "\u2AB0", "\\succeq", true);
defineSymbol(math, main, rel, "\u2243", "\\simeq", true);
defineSymbol(math, main, rel, "\u2223", "\\mid", true);
defineSymbol(math, main, rel, "\u226A", "\\ll", true);
defineSymbol(math, main, rel, "\u226B", "\\gg", true);
defineSymbol(math, main, rel, "\u224D", "\\asymp", true);
defineSymbol(math, main, rel, "\u2225", "\\parallel");
defineSymbol(math, main, rel, "\u22C8", "\\bowtie", true);
defineSymbol(math, main, rel, "\u2323", "\\smile", true);
defineSymbol(math, main, rel, "\u2291", "\\sqsubseteq", true);
defineSymbol(math, main, rel, "\u2292", "\\sqsupseteq", true);
defineSymbol(math, main, rel, "\u2250", "\\doteq", true);
defineSymbol(math, main, rel, "\u2322", "\\frown", true);
defineSymbol(math, main, rel, "\u220B", "\\ni", true);
defineSymbol(math, main, rel, "\u221D", "\\propto", true);
defineSymbol(math, main, rel, "\u22A2", "\\vdash", true);
defineSymbol(math, main, rel, "\u22A3", "\\dashv", true);
defineSymbol(math, main, rel, "\u220B", "\\owns");
defineSymbol(math, main, punct, ".", "\\ldotp");
defineSymbol(math, main, punct, "\u22C5", "\\cdotp");
defineSymbol(math, main, textord, "#", "\\#");
defineSymbol(text, main, textord, "#", "\\#");
defineSymbol(math, main, textord, "&", "\\&");
defineSymbol(text, main, textord, "&", "\\&");
defineSymbol(math, main, textord, "\u2135", "\\aleph", true);
defineSymbol(math, main, textord, "\u2200", "\\forall", true);
defineSymbol(math, main, textord, "\u210F", "\\hbar", true);
defineSymbol(math, main, textord, "\u2203", "\\exists", true);
defineSymbol(math, main, textord, "\u2207", "\\nabla", true);
defineSymbol(math, main, textord, "\u266D", "\\flat", true);
defineSymbol(math, main, textord, "\u2113", "\\ell", true);
defineSymbol(math, main, textord, "\u266E", "\\natural", true);
defineSymbol(math, main, textord, "\u2663", "\\clubsuit", true);
defineSymbol(math, main, textord, "\u2118", "\\wp", true);
defineSymbol(math, main, textord, "\u266F", "\\sharp", true);
defineSymbol(math, main, textord, "\u2662", "\\diamondsuit", true);
defineSymbol(math, main, textord, "\u211C", "\\Re", true);
defineSymbol(math, main, textord, "\u2661", "\\heartsuit", true);
defineSymbol(math, main, textord, "\u2111", "\\Im", true);
defineSymbol(math, main, textord, "\u2660", "\\spadesuit", true);
defineSymbol(math, main, textord, "\xA7", "\\S", true);
defineSymbol(text, main, textord, "\xA7", "\\S");
defineSymbol(math, main, textord, "\xB6", "\\P", true);
defineSymbol(text, main, textord, "\xB6", "\\P");
defineSymbol(math, main, textord, "\u2020", "\\dag");
defineSymbol(text, main, textord, "\u2020", "\\dag");
defineSymbol(text, main, textord, "\u2020", "\\textdagger");
defineSymbol(math, main, textord, "\u2021", "\\ddag");
defineSymbol(text, main, textord, "\u2021", "\\ddag");
defineSymbol(text, main, textord, "\u2021", "\\textdaggerdbl");
defineSymbol(math, main, close2, "\u23B1", "\\rmoustache", true);
defineSymbol(math, main, open3, "\u23B0", "\\lmoustache", true);
defineSymbol(math, main, close2, "\u27EF", "\\rgroup", true);
defineSymbol(math, main, open3, "\u27EE", "\\lgroup", true);
defineSymbol(math, main, bin, "\u2213", "\\mp", true);
defineSymbol(math, main, bin, "\u2296", "\\ominus", true);
defineSymbol(math, main, bin, "\u228E", "\\uplus", true);
defineSymbol(math, main, bin, "\u2293", "\\sqcap", true);
defineSymbol(math, main, bin, "\u2217", "\\ast");
defineSymbol(math, main, bin, "\u2294", "\\sqcup", true);
defineSymbol(math, main, bin, "\u25EF", "\\bigcirc", true);
defineSymbol(math, main, bin, "\u2219", "\\bullet", true);
defineSymbol(math, main, bin, "\u2021", "\\ddagger");
defineSymbol(math, main, bin, "\u2240", "\\wr", true);
defineSymbol(math, main, bin, "\u2A3F", "\\amalg");
defineSymbol(math, main, bin, "&", "\\And");
defineSymbol(math, main, rel, "\u27F5", "\\longleftarrow", true);
defineSymbol(math, main, rel, "\u21D0", "\\Leftarrow", true);
defineSymbol(math, main, rel, "\u27F8", "\\Longleftarrow", true);
defineSymbol(math, main, rel, "\u27F6", "\\longrightarrow", true);
defineSymbol(math, main, rel, "\u21D2", "\\Rightarrow", true);
defineSymbol(math, main, rel, "\u27F9", "\\Longrightarrow", true);
defineSymbol(math, main, rel, "\u2194", "\\leftrightarrow", true);
defineSymbol(math, main, rel, "\u27F7", "\\longleftrightarrow", true);
defineSymbol(math, main, rel, "\u21D4", "\\Leftrightarrow", true);
defineSymbol(math, main, rel, "\u27FA", "\\Longleftrightarrow", true);
defineSymbol(math, main, rel, "\u21A6", "\\mapsto", true);
defineSymbol(math, main, rel, "\u27FC", "\\longmapsto", true);
defineSymbol(math, main, rel, "\u2197", "\\nearrow", true);
defineSymbol(math, main, rel, "\u21A9", "\\hookleftarrow", true);
defineSymbol(math, main, rel, "\u21AA", "\\hookrightarrow", true);
defineSymbol(math, main, rel, "\u2198", "\\searrow", true);
defineSymbol(math, main, rel, "\u21BC", "\\leftharpoonup", true);
defineSymbol(math, main, rel, "\u21C0", "\\rightharpoonup", true);
defineSymbol(math, main, rel, "\u2199", "\\swarrow", true);
defineSymbol(math, main, rel, "\u21BD", "\\leftharpoondown", true);
defineSymbol(math, main, rel, "\u21C1", "\\rightharpoondown", true);
defineSymbol(math, main, rel, "\u2196", "\\nwarrow", true);
defineSymbol(math, main, rel, "\u21CC", "\\rightleftharpoons", true);
defineSymbol(math, ams, rel, "\u226E", "\\nless", true);
defineSymbol(math, ams, rel, "\uE010", "\\@nleqslant");
defineSymbol(math, ams, rel, "\uE011", "\\@nleqq");
defineSymbol(math, ams, rel, "\u2A87", "\\lneq", true);
defineSymbol(math, ams, rel, "\u2268", "\\lneqq", true);
defineSymbol(math, ams, rel, "\uE00C", "\\@lvertneqq");
defineSymbol(math, ams, rel, "\u22E6", "\\lnsim", true);
defineSymbol(math, ams, rel, "\u2A89", "\\lnapprox", true);
defineSymbol(math, ams, rel, "\u2280", "\\nprec", true);
defineSymbol(math, ams, rel, "\u22E0", "\\npreceq", true);
defineSymbol(math, ams, rel, "\u22E8", "\\precnsim", true);
defineSymbol(math, ams, rel, "\u2AB9", "\\precnapprox", true);
defineSymbol(math, ams, rel, "\u2241", "\\nsim", true);
defineSymbol(math, ams, rel, "\uE006", "\\@nshortmid");
defineSymbol(math, ams, rel, "\u2224", "\\nmid", true);
defineSymbol(math, ams, rel, "\u22AC", "\\nvdash", true);
defineSymbol(math, ams, rel, "\u22AD", "\\nvDash", true);
defineSymbol(math, ams, rel, "\u22EA", "\\ntriangleleft");
defineSymbol(math, ams, rel, "\u22EC", "\\ntrianglelefteq", true);
defineSymbol(math, ams, rel, "\u228A", "\\subsetneq", true);
defineSymbol(math, ams, rel, "\uE01A", "\\@varsubsetneq");
defineSymbol(math, ams, rel, "\u2ACB", "\\subsetneqq", true);
defineSymbol(math, ams, rel, "\uE017", "\\@varsubsetneqq");
defineSymbol(math, ams, rel, "\u226F", "\\ngtr", true);
defineSymbol(math, ams, rel, "\uE00F", "\\@ngeqslant");
defineSymbol(math, ams, rel, "\uE00E", "\\@ngeqq");
defineSymbol(math, ams, rel, "\u2A88", "\\gneq", true);
defineSymbol(math, ams, rel, "\u2269", "\\gneqq", true);
defineSymbol(math, ams, rel, "\uE00D", "\\@gvertneqq");
defineSymbol(math, ams, rel, "\u22E7", "\\gnsim", true);
defineSymbol(math, ams, rel, "\u2A8A", "\\gnapprox", true);
defineSymbol(math, ams, rel, "\u2281", "\\nsucc", true);
defineSymbol(math, ams, rel, "\u22E1", "\\nsucceq", true);
defineSymbol(math, ams, rel, "\u22E9", "\\succnsim", true);
defineSymbol(math, ams, rel, "\u2ABA", "\\succnapprox", true);
defineSymbol(math, ams, rel, "\u2246", "\\ncong", true);
defineSymbol(math, ams, rel, "\uE007", "\\@nshortparallel");
defineSymbol(math, ams, rel, "\u2226", "\\nparallel", true);
defineSymbol(math, ams, rel, "\u22AF", "\\nVDash", true);
defineSymbol(math, ams, rel, "\u22EB", "\\ntriangleright");
defineSymbol(math, ams, rel, "\u22ED", "\\ntrianglerighteq", true);
defineSymbol(math, ams, rel, "\uE018", "\\@nsupseteqq");
defineSymbol(math, ams, rel, "\u228B", "\\supsetneq", true);
defineSymbol(math, ams, rel, "\uE01B", "\\@varsupsetneq");
defineSymbol(math, ams, rel, "\u2ACC", "\\supsetneqq", true);
defineSymbol(math, ams, rel, "\uE019", "\\@varsupsetneqq");
defineSymbol(math, ams, rel, "\u22AE", "\\nVdash", true);
defineSymbol(math, ams, rel, "\u2AB5", "\\precneqq", true);
defineSymbol(math, ams, rel, "\u2AB6", "\\succneqq", true);
defineSymbol(math, ams, rel, "\uE016", "\\@nsubseteqq");
defineSymbol(math, ams, bin, "\u22B4", "\\unlhd");
defineSymbol(math, ams, bin, "\u22B5", "\\unrhd");
defineSymbol(math, ams, rel, "\u219A", "\\nleftarrow", true);
defineSymbol(math, ams, rel, "\u219B", "\\nrightarrow", true);
defineSymbol(math, ams, rel, "\u21CD", "\\nLeftarrow", true);
defineSymbol(math, ams, rel, "\u21CF", "\\nRightarrow", true);
defineSymbol(math, ams, rel, "\u21AE", "\\nleftrightarrow", true);
defineSymbol(math, ams, rel, "\u21CE", "\\nLeftrightarrow", true);
defineSymbol(math, ams, rel, "\u25B3", "\\vartriangle");
defineSymbol(math, ams, textord, "\u210F", "\\hslash");
defineSymbol(math, ams, textord, "\u25BD", "\\triangledown");
defineSymbol(math, ams, textord, "\u25CA", "\\lozenge");
defineSymbol(math, ams, textord, "\u24C8", "\\circledS");
defineSymbol(math, ams, textord, "\xAE", "\\circledR");
defineSymbol(text, ams, textord, "\xAE", "\\circledR");
defineSymbol(math, ams, textord, "\u2221", "\\measuredangle", true);
defineSymbol(math, ams, textord, "\u2204", "\\nexists");
defineSymbol(math, ams, textord, "\u2127", "\\mho");
defineSymbol(math, ams, textord, "\u2132", "\\Finv", true);
defineSymbol(math, ams, textord, "\u2141", "\\Game", true);
defineSymbol(math, ams, textord, "\u2035", "\\backprime");
defineSymbol(math, ams, textord, "\u25B2", "\\blacktriangle");
defineSymbol(math, ams, textord, "\u25BC", "\\blacktriangledown");
defineSymbol(math, ams, textord, "\u25A0", "\\blacksquare");
defineSymbol(math, ams, textord, "\u29EB", "\\blacklozenge");
defineSymbol(math, ams, textord, "\u2605", "\\bigstar");
defineSymbol(math, ams, textord, "\u2222", "\\sphericalangle", true);
defineSymbol(math, ams, textord, "\u2201", "\\complement", true);
defineSymbol(math, ams, textord, "\xF0", "\\eth", true);
defineSymbol(text, main, textord, "\xF0", "\xF0");
defineSymbol(math, ams, textord, "\u2571", "\\diagup");
defineSymbol(math, ams, textord, "\u2572", "\\diagdown");
defineSymbol(math, ams, textord, "\u25A1", "\\square");
defineSymbol(math, ams, textord, "\u25A1", "\\Box");
defineSymbol(math, ams, textord, "\u25CA", "\\Diamond");
defineSymbol(math, ams, textord, "\xA5", "\\yen", true);
defineSymbol(text, ams, textord, "\xA5", "\\yen", true);
defineSymbol(math, ams, textord, "\u2713", "\\checkmark", true);
defineSymbol(text, ams, textord, "\u2713", "\\checkmark");
defineSymbol(math, ams, textord, "\u2136", "\\beth", true);
defineSymbol(math, ams, textord, "\u2138", "\\daleth", true);
defineSymbol(math, ams, textord, "\u2137", "\\gimel", true);
defineSymbol(math, ams, textord, "\u03DD", "\\digamma", true);
defineSymbol(math, ams, textord, "\u03F0", "\\varkappa");
defineSymbol(math, ams, open3, "\u250C", "\\@ulcorner", true);
defineSymbol(math, ams, close2, "\u2510", "\\@urcorner", true);
defineSymbol(math, ams, open3, "\u2514", "\\@llcorner", true);
defineSymbol(math, ams, close2, "\u2518", "\\@lrcorner", true);
defineSymbol(math, ams, rel, "\u2266", "\\leqq", true);
defineSymbol(math, ams, rel, "\u2A7D", "\\leqslant", true);
defineSymbol(math, ams, rel, "\u2A95", "\\eqslantless", true);
defineSymbol(math, ams, rel, "\u2272", "\\lesssim", true);
defineSymbol(math, ams, rel, "\u2A85", "\\lessapprox", true);
defineSymbol(math, ams, rel, "\u224A", "\\approxeq", true);
defineSymbol(math, ams, bin, "\u22D6", "\\lessdot");
defineSymbol(math, ams, rel, "\u22D8", "\\lll", true);
defineSymbol(math, ams, rel, "\u2276", "\\lessgtr", true);
defineSymbol(math, ams, rel, "\u22DA", "\\lesseqgtr", true);
defineSymbol(math, ams, rel, "\u2A8B", "\\lesseqqgtr", true);
defineSymbol(math, ams, rel, "\u2251", "\\doteqdot");
defineSymbol(math, ams, rel, "\u2253", "\\risingdotseq", true);
defineSymbol(math, ams, rel, "\u2252", "\\fallingdotseq", true);
defineSymbol(math, ams, rel, "\u223D", "\\backsim", true);
defineSymbol(math, ams, rel, "\u22CD", "\\backsimeq", true);
defineSymbol(math, ams, rel, "\u2AC5", "\\subseteqq", true);
defineSymbol(math, ams, rel, "\u22D0", "\\Subset", true);
defineSymbol(math, ams, rel, "\u228F", "\\sqsubset", true);
defineSymbol(math, ams, rel, "\u227C", "\\preccurlyeq", true);
defineSymbol(math, ams, rel, "\u22DE", "\\curlyeqprec", true);
defineSymbol(math, ams, rel, "\u227E", "\\precsim", true);
defineSymbol(math, ams, rel, "\u2AB7", "\\precapprox", true);
defineSymbol(math, ams, rel, "\u22B2", "\\vartriangleleft");
defineSymbol(math, ams, rel, "\u22B4", "\\trianglelefteq");
defineSymbol(math, ams, rel, "\u22A8", "\\vDash", true);
defineSymbol(math, ams, rel, "\u22AA", "\\Vvdash", true);
defineSymbol(math, ams, rel, "\u2323", "\\smallsmile");
defineSymbol(math, ams, rel, "\u2322", "\\smallfrown");
defineSymbol(math, ams, rel, "\u224F", "\\bumpeq", true);
defineSymbol(math, ams, rel, "\u224E", "\\Bumpeq", true);
defineSymbol(math, ams, rel, "\u2267", "\\geqq", true);
defineSymbol(math, ams, rel, "\u2A7E", "\\geqslant", true);
defineSymbol(math, ams, rel, "\u2A96", "\\eqslantgtr", true);
defineSymbol(math, ams, rel, "\u2273", "\\gtrsim", true);
defineSymbol(math, ams, rel, "\u2A86", "\\gtrapprox", true);
defineSymbol(math, ams, bin, "\u22D7", "\\gtrdot");
defineSymbol(math, ams, rel, "\u22D9", "\\ggg", true);
defineSymbol(math, ams, rel, "\u2277", "\\gtrless", true);
defineSymbol(math, ams, rel, "\u22DB", "\\gtreqless", true);
defineSymbol(math, ams, rel, "\u2A8C", "\\gtreqqless", true);
defineSymbol(math, ams, rel, "\u2256", "\\eqcirc", true);
defineSymbol(math, ams, rel, "\u2257", "\\circeq", true);
defineSymbol(math, ams, rel, "\u225C", "\\triangleq", true);
defineSymbol(math, ams, rel, "\u223C", "\\thicksim");
defineSymbol(math, ams, rel, "\u2248", "\\thickapprox");
defineSymbol(math, ams, rel, "\u2AC6", "\\supseteqq", true);
defineSymbol(math, ams, rel, "\u22D1", "\\Supset", true);
defineSymbol(math, ams, rel, "\u2290", "\\sqsupset", true);
defineSymbol(math, ams, rel, "\u227D", "\\succcurlyeq", true);
defineSymbol(math, ams, rel, "\u22DF", "\\curlyeqsucc", true);
defineSymbol(math, ams, rel, "\u227F", "\\succsim", true);
defineSymbol(math, ams, rel, "\u2AB8", "\\succapprox", true);
defineSymbol(math, ams, rel, "\u22B3", "\\vartriangleright");
defineSymbol(math, ams, rel, "\u22B5", "\\trianglerighteq");
defineSymbol(math, ams, rel, "\u22A9", "\\Vdash", true);
defineSymbol(math, ams, rel, "\u2223", "\\shortmid");
defineSymbol(math, ams, rel, "\u2225", "\\shortparallel");
defineSymbol(math, ams, rel, "\u226C", "\\between", true);
defineSymbol(math, ams, rel, "\u22D4", "\\pitchfork", true);
defineSymbol(math, ams, rel, "\u221D", "\\varpropto");
defineSymbol(math, ams, rel, "\u25C0", "\\blacktriangleleft");
defineSymbol(math, ams, rel, "\u2234", "\\therefore", true);
defineSymbol(math, ams, rel, "\u220D", "\\backepsilon");
defineSymbol(math, ams, rel, "\u25B6", "\\blacktriangleright");
defineSymbol(math, ams, rel, "\u2235", "\\because", true);
defineSymbol(math, ams, rel, "\u22D8", "\\llless");
defineSymbol(math, ams, rel, "\u22D9", "\\gggtr");
defineSymbol(math, ams, bin, "\u22B2", "\\lhd");
defineSymbol(math, ams, bin, "\u22B3", "\\rhd");
defineSymbol(math, ams, rel, "\u2242", "\\eqsim", true);
defineSymbol(math, main, rel, "\u22C8", "\\Join");
defineSymbol(math, ams, rel, "\u2251", "\\Doteq", true);
defineSymbol(math, ams, bin, "\u2214", "\\dotplus", true);
defineSymbol(math, ams, bin, "\u2216", "\\smallsetminus");
defineSymbol(math, ams, bin, "\u22D2", "\\Cap", true);
defineSymbol(math, ams, bin, "\u22D3", "\\Cup", true);
defineSymbol(math, ams, bin, "\u2A5E", "\\doublebarwedge", true);
defineSymbol(math, ams, bin, "\u229F", "\\boxminus", true);
defineSymbol(math, ams, bin, "\u229E", "\\boxplus", true);
defineSymbol(math, ams, bin, "\u22C7", "\\divideontimes", true);
defineSymbol(math, ams, bin, "\u22C9", "\\ltimes", true);
defineSymbol(math, ams, bin, "\u22CA", "\\rtimes", true);
defineSymbol(math, ams, bin, "\u22CB", "\\leftthreetimes", true);
defineSymbol(math, ams, bin, "\u22CC", "\\rightthreetimes", true);
defineSymbol(math, ams, bin, "\u22CF", "\\curlywedge", true);
defineSymbol(math, ams, bin, "\u22CE", "\\curlyvee", true);
defineSymbol(math, ams, bin, "\u229D", "\\circleddash", true);
defineSymbol(math, ams, bin, "\u229B", "\\circledast", true);
defineSymbol(math, ams, bin, "\u22C5", "\\centerdot");
defineSymbol(math, ams, bin, "\u22BA", "\\intercal", true);
defineSymbol(math, ams, bin, "\u22D2", "\\doublecap");
defineSymbol(math, ams, bin, "\u22D3", "\\doublecup");
defineSymbol(math, ams, bin, "\u22A0", "\\boxtimes", true);
defineSymbol(math, ams, rel, "\u21E2", "\\dashrightarrow", true);
defineSymbol(math, ams, rel, "\u21E0", "\\dashleftarrow", true);
defineSymbol(math, ams, rel, "\u21C7", "\\leftleftarrows", true);
defineSymbol(math, ams, rel, "\u21C6", "\\leftrightarrows", true);
defineSymbol(math, ams, rel, "\u21DA", "\\Lleftarrow", true);
defineSymbol(math, ams, rel, "\u219E", "\\twoheadleftarrow", true);
defineSymbol(math, ams, rel, "\u21A2", "\\leftarrowtail", true);
defineSymbol(math, ams, rel, "\u21AB", "\\looparrowleft", true);
defineSymbol(math, ams, rel, "\u21CB", "\\leftrightharpoons", true);
defineSymbol(math, ams, rel, "\u21B6", "\\curvearrowleft", true);
defineSymbol(math, ams, rel, "\u21BA", "\\circlearrowleft", true);
defineSymbol(math, ams, rel, "\u21B0", "\\Lsh", true);
defineSymbol(math, ams, rel, "\u21C8", "\\upuparrows", true);
defineSymbol(math, ams, rel, "\u21BF", "\\upharpoonleft", true);
defineSymbol(math, ams, rel, "\u21C3", "\\downharpoonleft", true);
defineSymbol(math, main, rel, "\u22B6", "\\origof", true);
defineSymbol(math, main, rel, "\u22B7", "\\imageof", true);
defineSymbol(math, ams, rel, "\u22B8", "\\multimap", true);
defineSymbol(math, ams, rel, "\u21AD", "\\leftrightsquigarrow", true);
defineSymbol(math, ams, rel, "\u21C9", "\\rightrightarrows", true);
defineSymbol(math, ams, rel, "\u21C4", "\\rightleftarrows", true);
defineSymbol(math, ams, rel, "\u21A0", "\\twoheadrightarrow", true);
defineSymbol(math, ams, rel, "\u21A3", "\\rightarrowtail", true);
defineSymbol(math, ams, rel, "\u21AC", "\\looparrowright", true);
defineSymbol(math, ams, rel, "\u21B7", "\\curvearrowright", true);
defineSymbol(math, ams, rel, "\u21BB", "\\circlearrowright", true);
defineSymbol(math, ams, rel, "\u21B1", "\\Rsh", true);
defineSymbol(math, ams, rel, "\u21CA", "\\downdownarrows", true);
defineSymbol(math, ams, rel, "\u21BE", "\\upharpoonright", true);
defineSymbol(math, ams, rel, "\u21C2", "\\downharpoonright", true);
defineSymbol(math, ams, rel, "\u21DD", "\\rightsquigarrow", true);
defineSymbol(math, ams, rel, "\u21DD", "\\leadsto");
defineSymbol(math, ams, rel, "\u21DB", "\\Rrightarrow", true);
defineSymbol(math, ams, rel, "\u21BE", "\\restriction");
defineSymbol(math, main, textord, "\u2018", "`");
defineSymbol(math, main, textord, "$", "\\$");
defineSymbol(text, main, textord, "$", "\\$");
defineSymbol(text, main, textord, "$", "\\textdollar");
defineSymbol(math, main, textord, "%", "\\%");
defineSymbol(text, main, textord, "%", "\\%");
defineSymbol(math, main, textord, "_", "\\_");
defineSymbol(text, main, textord, "_", "\\_");
defineSymbol(text, main, textord, "_", "\\textunderscore");
defineSymbol(math, main, textord, "\u2220", "\\angle", true);
defineSymbol(math, main, textord, "\u221E", "\\infty", true);
defineSymbol(math, main, textord, "\u2032", "\\prime");
defineSymbol(math, main, textord, "\u25B3", "\\triangle");
defineSymbol(math, main, textord, "\u0393", "\\Gamma", true);
defineSymbol(math, main, textord, "\u0394", "\\Delta", true);
defineSymbol(math, main, textord, "\u0398", "\\Theta", true);
defineSymbol(math, main, textord, "\u039B", "\\Lambda", true);
defineSymbol(math, main, textord, "\u039E", "\\Xi", true);
defineSymbol(math, main, textord, "\u03A0", "\\Pi", true);
defineSymbol(math, main, textord, "\u03A3", "\\Sigma", true);
defineSymbol(math, main, textord, "\u03A5", "\\Upsilon", true);
defineSymbol(math, main, textord, "\u03A6", "\\Phi", true);
defineSymbol(math, main, textord, "\u03A8", "\\Psi", true);
defineSymbol(math, main, textord, "\u03A9", "\\Omega", true);
defineSymbol(math, main, textord, "A", "\u0391");
defineSymbol(math, main, textord, "B", "\u0392");
defineSymbol(math, main, textord, "E", "\u0395");
defineSymbol(math, main, textord, "Z", "\u0396");
defineSymbol(math, main, textord, "H", "\u0397");
defineSymbol(math, main, textord, "I", "\u0399");
defineSymbol(math, main, textord, "K", "\u039A");
defineSymbol(math, main, textord, "M", "\u039C");
defineSymbol(math, main, textord, "N", "\u039D");
defineSymbol(math, main, textord, "O", "\u039F");
defineSymbol(math, main, textord, "P", "\u03A1");
defineSymbol(math, main, textord, "T", "\u03A4");
defineSymbol(math, main, textord, "X", "\u03A7");
defineSymbol(math, main, textord, "\xAC", "\\neg", true);
defineSymbol(math, main, textord, "\xAC", "\\lnot");
defineSymbol(math, main, textord, "\u22A4", "\\top");
defineSymbol(math, main, textord, "\u22A5", "\\bot");
defineSymbol(math, main, textord, "\u2205", "\\emptyset");
defineSymbol(math, ams, textord, "\u2205", "\\varnothing");
defineSymbol(math, main, mathord, "\u03B1", "\\alpha", true);
defineSymbol(math, main, mathord, "\u03B2", "\\beta", true);
defineSymbol(math, main, mathord, "\u03B3", "\\gamma", true);
defineSymbol(math, main, mathord, "\u03B4", "\\delta", true);
defineSymbol(math, main, mathord, "\u03F5", "\\epsilon", true);
defineSymbol(math, main, mathord, "\u03B6", "\\zeta", true);
defineSymbol(math, main, mathord, "\u03B7", "\\eta", true);
defineSymbol(math, main, mathord, "\u03B8", "\\theta", true);
defineSymbol(math, main, mathord, "\u03B9", "\\iota", true);
defineSymbol(math, main, mathord, "\u03BA", "\\kappa", true);
defineSymbol(math, main, mathord, "\u03BB", "\\lambda", true);
defineSymbol(math, main, mathord, "\u03BC", "\\mu", true);
defineSymbol(math, main, mathord, "\u03BD", "\\nu", true);
defineSymbol(math, main, mathord, "\u03BE", "\\xi", true);
defineSymbol(math, main, mathord, "\u03BF", "\\omicron", true);
defineSymbol(math, main, mathord, "\u03C0", "\\pi", true);
defineSymbol(math, main, mathord, "\u03C1", "\\rho", true);
defineSymbol(math, main, mathord, "\u03C3", "\\sigma", true);
defineSymbol(math, main, mathord, "\u03C4", "\\tau", true);
defineSymbol(math, main, mathord, "\u03C5", "\\upsilon", true);
defineSymbol(math, main, mathord, "\u03D5", "\\phi", true);
defineSymbol(math, main, mathord, "\u03C7", "\\chi", true);
defineSymbol(math, main, mathord, "\u03C8", "\\psi", true);
defineSymbol(math, main, mathord, "\u03C9", "\\omega", true);
defineSymbol(math, main, mathord, "\u03B5", "\\varepsilon", true);
defineSymbol(math, main, mathord, "\u03D1", "\\vartheta", true);
defineSymbol(math, main, mathord, "\u03D6", "\\varpi", true);
defineSymbol(math, main, mathord, "\u03F1", "\\varrho", true);
defineSymbol(math, main, mathord, "\u03C2", "\\varsigma", true);
defineSymbol(math, main, mathord, "\u03C6", "\\varphi", true);
defineSymbol(math, main, bin, "\u2217", "*", true);
defineSymbol(math, main, bin, "+", "+");
defineSymbol(math, main, bin, "\u2212", "-", true);
defineSymbol(math, main, bin, "\u22C5", "\\cdot", true);
defineSymbol(math, main, bin, "\u2218", "\\circ", true);
defineSymbol(math, main, bin, "\xF7", "\\div", true);
defineSymbol(math, main, bin, "\xB1", "\\pm", true);
defineSymbol(math, main, bin, "\xD7", "\\times", true);
defineSymbol(math, main, bin, "\u2229", "\\cap", true);
defineSymbol(math, main, bin, "\u222A", "\\cup", true);
defineSymbol(math, main, bin, "\u2216", "\\setminus", true);
defineSymbol(math, main, bin, "\u2227", "\\land");
defineSymbol(math, main, bin, "\u2228", "\\lor");
defineSymbol(math, main, bin, "\u2227", "\\wedge", true);
defineSymbol(math, main, bin, "\u2228", "\\vee", true);
defineSymbol(math, main, textord, "\u221A", "\\surd");
defineSymbol(math, main, open3, "\u27E8", "\\langle", true);
defineSymbol(math, main, open3, "\u2223", "\\lvert");
defineSymbol(math, main, open3, "\u2225", "\\lVert");
defineSymbol(math, main, close2, "?", "?");
defineSymbol(math, main, close2, "!", "!");
defineSymbol(math, main, close2, "\u27E9", "\\rangle", true);
defineSymbol(math, main, close2, "\u2223", "\\rvert");
defineSymbol(math, main, close2, "\u2225", "\\rVert");
defineSymbol(math, main, rel, "=", "=");
defineSymbol(math, main, rel, ":", ":");
defineSymbol(math, main, rel, "\u2248", "\\approx", true);
defineSymbol(math, main, rel, "\u2245", "\\cong", true);
defineSymbol(math, main, rel, "\u2265", "\\ge");
defineSymbol(math, main, rel, "\u2265", "\\geq", true);
defineSymbol(math, main, rel, "\u2190", "\\gets");
defineSymbol(math, main, rel, ">", "\\gt", true);
defineSymbol(math, main, rel, "\u2208", "\\in", true);
defineSymbol(math, main, rel, "\uE020", "\\@not");
defineSymbol(math, main, rel, "\u2282", "\\subset", true);
defineSymbol(math, main, rel, "\u2283", "\\supset", true);
defineSymbol(math, main, rel, "\u2286", "\\subseteq", true);
defineSymbol(math, main, rel, "\u2287", "\\supseteq", true);
defineSymbol(math, ams, rel, "\u2288", "\\nsubseteq", true);
defineSymbol(math, ams, rel, "\u2289", "\\nsupseteq", true);
defineSymbol(math, main, rel, "\u22A8", "\\models");
defineSymbol(math, main, rel, "\u2190", "\\leftarrow", true);
defineSymbol(math, main, rel, "\u2264", "\\le");
defineSymbol(math, main, rel, "\u2264", "\\leq", true);
defineSymbol(math, main, rel, "<", "\\lt", true);
defineSymbol(math, main, rel, "\u2192", "\\rightarrow", true);
defineSymbol(math, main, rel, "\u2192", "\\to");
defineSymbol(math, ams, rel, "\u2271", "\\ngeq", true);
defineSymbol(math, ams, rel, "\u2270", "\\nleq", true);
defineSymbol(math, main, spacing, "\xA0", "\\ ");
defineSymbol(math, main, spacing, "\xA0", "\\space");
defineSymbol(math, main, spacing, "\xA0", "\\nobreakspace");
defineSymbol(text, main, spacing, "\xA0", "\\ ");
defineSymbol(text, main, spacing, "\xA0", " ");
defineSymbol(text, main, spacing, "\xA0", "\\space");
defineSymbol(text, main, spacing, "\xA0", "\\nobreakspace");
defineSymbol(math, main, spacing, null, "\\nobreak");
defineSymbol(math, main, spacing, null, "\\allowbreak");
defineSymbol(math, main, punct, ",", ",");
defineSymbol(math, main, punct, ";", ";");
defineSymbol(math, ams, bin, "\u22BC", "\\barwedge", true);
defineSymbol(math, ams, bin, "\u22BB", "\\veebar", true);
defineSymbol(math, main, bin, "\u2299", "\\odot", true);
defineSymbol(math, main, bin, "\u2295", "\\oplus", true);
defineSymbol(math, main, bin, "\u2297", "\\otimes", true);
defineSymbol(math, main, textord, "\u2202", "\\partial", true);
defineSymbol(math, main, bin, "\u2298", "\\oslash", true);
defineSymbol(math, ams, bin, "\u229A", "\\circledcirc", true);
defineSymbol(math, ams, bin, "\u22A1", "\\boxdot", true);
defineSymbol(math, main, bin, "\u25B3", "\\bigtriangleup");
defineSymbol(math, main, bin, "\u25BD", "\\bigtriangledown");
defineSymbol(math, main, bin, "\u2020", "\\dagger");
defineSymbol(math, main, bin, "\u22C4", "\\diamond");
defineSymbol(math, main, bin, "\u22C6", "\\star");
defineSymbol(math, main, bin, "\u25C3", "\\triangleleft");
defineSymbol(math, main, bin, "\u25B9", "\\triangleright");
defineSymbol(math, main, open3, "{", "\\{");
defineSymbol(text, main, textord, "{", "\\{");
defineSymbol(text, main, textord, "{", "\\textbraceleft");
defineSymbol(math, main, close2, "}", "\\}");
defineSymbol(text, main, textord, "}", "\\}");
defineSymbol(text, main, textord, "}", "\\textbraceright");
defineSymbol(math, main, open3, "{", "\\lbrace");
defineSymbol(math, main, close2, "}", "\\rbrace");
defineSymbol(math, main, open3, "[", "\\lbrack", true);
defineSymbol(text, main, textord, "[", "\\lbrack", true);
defineSymbol(math, main, close2, "]", "\\rbrack", true);
defineSymbol(text, main, textord, "]", "\\rbrack", true);
defineSymbol(math, main, open3, "(", "\\lparen", true);
defineSymbol(math, main, close2, ")", "\\rparen", true);
defineSymbol(text, main, textord, "<", "\\textless", true);
defineSymbol(text, main, textord, ">", "\\textgreater", true);
defineSymbol(math, main, open3, "\u230A", "\\lfloor", true);
defineSymbol(math, main, close2, "\u230B", "\\rfloor", true);
defineSymbol(math, main, open3, "\u2308", "\\lceil", true);
defineSymbol(math, main, close2, "\u2309", "\\rceil", true);
defineSymbol(math, main, textord, "\\", "\\backslash");
defineSymbol(math, main, textord, "\u2223", "|");
defineSymbol(math, main, textord, "\u2223", "\\vert");
defineSymbol(text, main, textord, "|", "\\textbar", true);
defineSymbol(math, main, textord, "\u2225", "\\|");
defineSymbol(math, main, textord, "\u2225", "\\Vert");
defineSymbol(text, main, textord, "\u2225", "\\textbardbl");
defineSymbol(text, main, textord, "~", "\\textasciitilde");
defineSymbol(text, main, textord, "\\", "\\textbackslash");
defineSymbol(text, main, textord, "^", "\\textasciicircum");
defineSymbol(math, main, rel, "\u2191", "\\uparrow", true);
defineSymbol(math, main, rel, "\u21D1", "\\Uparrow", true);
defineSymbol(math, main, rel, "\u2193", "\\downarrow", true);
defineSymbol(math, main, rel, "\u21D3", "\\Downarrow", true);
defineSymbol(math, main, rel, "\u2195", "\\updownarrow", true);
defineSymbol(math, main, rel, "\u21D5", "\\Updownarrow", true);
defineSymbol(math, main, op, "\u2210", "\\coprod");
defineSymbol(math, main, op, "\u22C1", "\\bigvee");
defineSymbol(math, main, op, "\u22C0", "\\bigwedge");
defineSymbol(math, main, op, "\u2A04", "\\biguplus");
defineSymbol(math, main, op, "\u22C2", "\\bigcap");
defineSymbol(math, main, op, "\u22C3", "\\bigcup");
defineSymbol(math, main, op, "\u222B", "\\int");
defineSymbol(math, main, op, "\u222B", "\\intop");
defineSymbol(math, main, op, "\u222C", "\\iint");
defineSymbol(math, main, op, "\u222D", "\\iiint");
defineSymbol(math, main, op, "\u220F", "\\prod");
defineSymbol(math, main, op, "\u2211", "\\sum");
defineSymbol(math, main, op, "\u2A02", "\\bigotimes");
defineSymbol(math, main, op, "\u2A01", "\\bigoplus");
defineSymbol(math, main, op, "\u2A00", "\\bigodot");
defineSymbol(math, main, op, "\u222E", "\\oint");
defineSymbol(math, main, op, "\u222F", "\\oiint");
defineSymbol(math, main, op, "\u2230", "\\oiiint");
defineSymbol(math, main, op, "\u2A06", "\\bigsqcup");
defineSymbol(math, main, op, "\u222B", "\\smallint");
defineSymbol(text, main, inner, "\u2026", "\\textellipsis");
defineSymbol(math, main, inner, "\u2026", "\\mathellipsis");
defineSymbol(text, main, inner, "\u2026", "\\ldots", true);
defineSymbol(math, main, inner, "\u2026", "\\ldots", true);
defineSymbol(math, main, inner, "\u22EF", "\\@cdots", true);
defineSymbol(math, main, inner, "\u22F1", "\\ddots", true);
defineSymbol(math, main, textord, "\u22EE", "\\varvdots");
defineSymbol(math, main, accent, "\u02CA", "\\acute");
defineSymbol(math, main, accent, "\u02CB", "\\grave");
defineSymbol(math, main, accent, "\xA8", "\\ddot");
defineSymbol(math, main, accent, "~", "\\tilde");
defineSymbol(math, main, accent, "\u02C9", "\\bar");
defineSymbol(math, main, accent, "\u02D8", "\\breve");
defineSymbol(math, main, accent, "\u02C7", "\\check");
defineSymbol(math, main, accent, "^", "\\hat");
defineSymbol(math, main, accent, "\u20D7", "\\vec");
defineSymbol(math, main, accent, "\u02D9", "\\dot");
defineSymbol(math, main, accent, "\u02DA", "\\mathring");
defineSymbol(math, main, mathord, "\uE131", "\\@imath");
defineSymbol(math, main, mathord, "\uE237", "\\@jmath");
defineSymbol(math, main, textord, "\u0131", "\u0131");
defineSymbol(math, main, textord, "\u0237", "\u0237");
defineSymbol(text, main, textord, "\u0131", "\\i", true);
defineSymbol(text, main, textord, "\u0237", "\\j", true);
defineSymbol(text, main, textord, "\xDF", "\\ss", true);
defineSymbol(text, main, textord, "\xE6", "\\ae", true);
defineSymbol(text, main, textord, "\u0153", "\\oe", true);
defineSymbol(text, main, textord, "\xF8", "\\o", true);
defineSymbol(text, main, textord, "\xC6", "\\AE", true);
defineSymbol(text, main, textord, "\u0152", "\\OE", true);
defineSymbol(text, main, textord, "\xD8", "\\O", true);
defineSymbol(text, main, accent, "\u02CA", "\\'");
defineSymbol(text, main, accent, "\u02CB", "\\`");
defineSymbol(text, main, accent, "\u02C6", "\\^");
defineSymbol(text, main, accent, "\u02DC", "\\~");
defineSymbol(text, main, accent, "\u02C9", "\\=");
defineSymbol(text, main, accent, "\u02D8", "\\u");
defineSymbol(text, main, accent, "\u02D9", "\\.");
defineSymbol(text, main, accent, "\xB8", "\\c");
defineSymbol(text, main, accent, "\u02DA", "\\r");
defineSymbol(text, main, accent, "\u02C7", "\\v");
defineSymbol(text, main, accent, "\xA8", '\\"');
defineSymbol(text, main, accent, "\u02DD", "\\H");
defineSymbol(text, main, accent, "\u25EF", "\\textcircled");
var ligatures = {
  "--": true,
  "---": true,
  "``": true,
  "''": true
};
defineSymbol(text, main, textord, "\u2013", "--", true);
defineSymbol(text, main, textord, "\u2013", "\\textendash");
defineSymbol(text, main, textord, "\u2014", "---", true);
defineSymbol(text, main, textord, "\u2014", "\\textemdash");
defineSymbol(text, main, textord, "\u2018", "`", true);
defineSymbol(text, main, textord, "\u2018", "\\textquoteleft");
defineSymbol(text, main, textord, "\u2019", "'", true);
defineSymbol(text, main, textord, "\u2019", "\\textquoteright");
defineSymbol(text, main, textord, "\u201C", "``", true);
defineSymbol(text, main, textord, "\u201C", "\\textquotedblleft");
defineSymbol(text, main, textord, "\u201D", "''", true);
defineSymbol(text, main, textord, "\u201D", "\\textquotedblright");
defineSymbol(math, main, textord, "\xB0", "\\degree", true);
defineSymbol(text, main, textord, "\xB0", "\\degree");
defineSymbol(text, main, textord, "\xB0", "\\textdegree", true);
defineSymbol(math, main, textord, "\xA3", "\\pounds");
defineSymbol(math, main, textord, "\xA3", "\\mathsterling", true);
defineSymbol(text, main, textord, "\xA3", "\\pounds");
defineSymbol(text, main, textord, "\xA3", "\\textsterling", true);
defineSymbol(math, ams, textord, "\u2720", "\\maltese");
defineSymbol(text, ams, textord, "\u2720", "\\maltese");
var mathTextSymbols = '0123456789/@."';
for (i2 = 0; i2 < mathTextSymbols.length; i2++) {
  ch = mathTextSymbols.charAt(i2);
  defineSymbol(math, main, textord, ch, ch);
}
var ch;
var i2;
var textSymbols = '0123456789!@*()-=+";:?/.,';
for (_i = 0; _i < textSymbols.length; _i++) {
  _ch = textSymbols.charAt(_i);
  defineSymbol(text, main, textord, _ch, _ch);
}
var _ch;
var _i;
var letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
for (_i2 = 0; _i2 < letters.length; _i2++) {
  _ch2 = letters.charAt(_i2);
  defineSymbol(math, main, mathord, _ch2, _ch2);
  defineSymbol(text, main, textord, _ch2, _ch2);
}
var _ch2;
var _i2;
defineSymbol(math, ams, textord, "C", "\u2102");
defineSymbol(text, ams, textord, "C", "\u2102");
defineSymbol(math, ams, textord, "H", "\u210D");
defineSymbol(text, ams, textord, "H", "\u210D");
defineSymbol(math, ams, textord, "N", "\u2115");
defineSymbol(text, ams, textord, "N", "\u2115");
defineSymbol(math, ams, textord, "P", "\u2119");
defineSymbol(text, ams, textord, "P", "\u2119");
defineSymbol(math, ams, textord, "Q", "\u211A");
defineSymbol(text, ams, textord, "Q", "\u211A");
defineSymbol(math, ams, textord, "R", "\u211D");
defineSymbol(text, ams, textord, "R", "\u211D");
defineSymbol(math, ams, textord, "Z", "\u2124");
defineSymbol(text, ams, textord, "Z", "\u2124");
defineSymbol(math, main, mathord, "h", "\u210E");
defineSymbol(text, main, mathord, "h", "\u210E");
var wideChar = "";
for (_i3 = 0; _i3 < letters.length; _i3++) {
  _ch3 = letters.charAt(_i3);
  wideChar = String.fromCharCode(55349, 56320 + _i3);
  defineSymbol(math, main, mathord, _ch3, wideChar);
  defineSymbol(text, main, textord, _ch3, wideChar);
  wideChar = String.fromCharCode(55349, 56372 + _i3);
  defineSymbol(math, main, mathord, _ch3, wideChar);
  defineSymbol(text, main, textord, _ch3, wideChar);
  wideChar = String.fromCharCode(55349, 56424 + _i3);
  defineSymbol(math, main, mathord, _ch3, wideChar);
  defineSymbol(text, main, textord, _ch3, wideChar);
  wideChar = String.fromCharCode(55349, 56580 + _i3);
  defineSymbol(math, main, mathord, _ch3, wideChar);
  defineSymbol(text, main, textord, _ch3, wideChar);
  wideChar = String.fromCharCode(55349, 56736 + _i3);
  defineSymbol(math, main, mathord, _ch3, wideChar);
  defineSymbol(text, main, textord, _ch3, wideChar);
  wideChar = String.fromCharCode(55349, 56788 + _i3);
  defineSymbol(math, main, mathord, _ch3, wideChar);
  defineSymbol(text, main, textord, _ch3, wideChar);
  wideChar = String.fromCharCode(55349, 56840 + _i3);
  defineSymbol(math, main, mathord, _ch3, wideChar);
  defineSymbol(text, main, textord, _ch3, wideChar);
  wideChar = String.fromCharCode(55349, 56944 + _i3);
  defineSymbol(math, main, mathord, _ch3, wideChar);
  defineSymbol(text, main, textord, _ch3, wideChar);
  if (_i3 < 26) {
    wideChar = String.fromCharCode(55349, 56632 + _i3);
    defineSymbol(math, main, mathord, _ch3, wideChar);
    defineSymbol(text, main, textord, _ch3, wideChar);
    wideChar = String.fromCharCode(55349, 56476 + _i3);
    defineSymbol(math, main, mathord, _ch3, wideChar);
    defineSymbol(text, main, textord, _ch3, wideChar);
  }
}
var _ch3;
var _i3;
wideChar = String.fromCharCode(55349, 56668);
defineSymbol(math, main, mathord, "k", wideChar);
defineSymbol(text, main, textord, "k", wideChar);
for (_i4 = 0; _i4 < 10; _i4++) {
  _ch4 = _i4.toString();
  wideChar = String.fromCharCode(55349, 57294 + _i4);
  defineSymbol(math, main, mathord, _ch4, wideChar);
  defineSymbol(text, main, textord, _ch4, wideChar);
  wideChar = String.fromCharCode(55349, 57314 + _i4);
  defineSymbol(math, main, mathord, _ch4, wideChar);
  defineSymbol(text, main, textord, _ch4, wideChar);
  wideChar = String.fromCharCode(55349, 57324 + _i4);
  defineSymbol(math, main, mathord, _ch4, wideChar);
  defineSymbol(text, main, textord, _ch4, wideChar);
  wideChar = String.fromCharCode(55349, 57334 + _i4);
  defineSymbol(math, main, mathord, _ch4, wideChar);
  defineSymbol(text, main, textord, _ch4, wideChar);
}
var _ch4;
var _i4;
var extraLatin = "\xD0\xDE\xFE";
for (_i5 = 0; _i5 < extraLatin.length; _i5++) {
  _ch5 = extraLatin.charAt(_i5);
  defineSymbol(math, main, mathord, _ch5, _ch5);
  defineSymbol(text, main, textord, _ch5, _ch5);
}
var _ch5;
var _i5;
var wideLatinLetterData = [
  ["mathbf", "textbf", "Main-Bold"],
  // A-Z bold upright
  ["mathbf", "textbf", "Main-Bold"],
  // a-z bold upright
  ["mathnormal", "textit", "Math-Italic"],
  // A-Z italic
  ["mathnormal", "textit", "Math-Italic"],
  // a-z italic
  ["boldsymbol", "boldsymbol", "Main-BoldItalic"],
  // A-Z bold italic
  ["boldsymbol", "boldsymbol", "Main-BoldItalic"],
  // a-z bold italic
  // Map fancy A-Z letters to script, not calligraphic.
  // This aligns with unicode-math and math fonts (except Cambria Math).
  ["mathscr", "textscr", "Script-Regular"],
  // A-Z script
  ["", "", ""],
  // a-z script.  No font
  ["", "", ""],
  // A-Z bold script. No font
  ["", "", ""],
  // a-z bold script. No font
  ["mathfrak", "textfrak", "Fraktur-Regular"],
  // A-Z Fraktur
  ["mathfrak", "textfrak", "Fraktur-Regular"],
  // a-z Fraktur
  ["mathbb", "textbb", "AMS-Regular"],
  // A-Z double-struck
  ["mathbb", "textbb", "AMS-Regular"],
  // k double-struck
  ["", "", ""],
  // A-Z bold Fraktur No font metrics
  ["", "", ""],
  // a-z bold Fraktur.   No font.
  ["mathsf", "textsf", "SansSerif-Regular"],
  // A-Z sans-serif
  ["mathsf", "textsf", "SansSerif-Regular"],
  // a-z sans-serif
  ["mathboldsf", "textboldsf", "SansSerif-Bold"],
  // A-Z bold sans-serif
  ["mathboldsf", "textboldsf", "SansSerif-Bold"],
  // a-z bold sans-serif
  ["mathitsf", "textitsf", "SansSerif-Italic"],
  // A-Z italic sans-serif
  ["mathitsf", "textitsf", "SansSerif-Italic"],
  // a-z italic sans-serif
  ["", "", ""],
  // A-Z bold italic sans. No font
  ["", "", ""],
  // a-z bold italic sans. No font
  ["mathtt", "texttt", "Typewriter-Regular"],
  // A-Z monospace
  ["mathtt", "texttt", "Typewriter-Regular"]
  // a-z monospace
];
var wideNumeralData = [
  ["mathbf", "textbf", "Main-Bold"],
  // 0-9 bold
  ["", "", ""],
  // 0-9 double-struck. No KaTeX font.
  ["mathsf", "textsf", "SansSerif-Regular"],
  // 0-9 sans-serif
  ["mathboldsf", "textboldsf", "SansSerif-Bold"],
  // 0-9 bold sans-serif
  ["mathtt", "texttt", "Typewriter-Regular"]
  // 0-9 monospace
];
var wideCharacterFont = function wideCharacterFont2(wideChar2, mode) {
  var H = wideChar2.charCodeAt(0);
  var L = wideChar2.charCodeAt(1);
  var codePoint = (H - 55296) * 1024 + (L - 56320) + 65536;
  var j = mode === "math" ? 0 : 1;
  if (119808 <= codePoint && codePoint < 120484) {
    var i2 = Math.floor((codePoint - 119808) / 26);
    return [wideLatinLetterData[i2][2], wideLatinLetterData[i2][j]];
  } else if (120782 <= codePoint && codePoint <= 120831) {
    var _i = Math.floor((codePoint - 120782) / 10);
    return [wideNumeralData[_i][2], wideNumeralData[_i][j]];
  } else if (codePoint === 120485 || codePoint === 120486) {
    return [wideLatinLetterData[0][2], wideLatinLetterData[0][j]];
  } else if (120486 < codePoint && codePoint < 120782) {
    return ["", ""];
  } else {
    throw new ParseError("Unsupported character: " + wideChar2);
  }
};
var lookupSymbol = function lookupSymbol2(value, fontName, mode) {
  if (symbols[mode][value] && symbols[mode][value].replace) {
    value = symbols[mode][value].replace;
  }
  return {
    value,
    metrics: getCharacterMetrics(value, fontName, mode)
  };
};
var makeSymbol = function makeSymbol2(value, fontName, mode, options, classes2) {
  var lookup = lookupSymbol(value, fontName, mode);
  var metrics = lookup.metrics;
  value = lookup.value;
  var symbolNode;
  if (metrics) {
    var italic = metrics.italic;
    if (mode === "text" || options && options.font === "mathit") {
      italic = 0;
    }
    symbolNode = new SymbolNode(value, metrics.height, metrics.depth, italic, metrics.skew, metrics.width, classes2);
  } else {
    typeof console !== "undefined" && console.warn("No character metrics " + ("for '" + value + "' in style '" + fontName + "' and mode '" + mode + "'"));
    symbolNode = new SymbolNode(value, 0, 0, 0, 0, 0, classes2);
  }
  if (options) {
    symbolNode.maxFontSize = options.sizeMultiplier;
    if (options.style.isTight()) {
      symbolNode.classes.push("mtight");
    }
    var color = options.getColor();
    if (color) {
      symbolNode.style.color = color;
    }
  }
  return symbolNode;
};
var mathsym = function mathsym2(value, mode, options, classes2) {
  if (classes2 === void 0) {
    classes2 = [];
  }
  if (options.font === "boldsymbol" && lookupSymbol(value, "Main-Bold", mode).metrics) {
    return makeSymbol(value, "Main-Bold", mode, options, classes2.concat(["mathbf"]));
  } else if (value === "\\" || symbols[mode][value].font === "main") {
    return makeSymbol(value, "Main-Regular", mode, options, classes2);
  } else {
    return makeSymbol(value, "AMS-Regular", mode, options, classes2.concat(["amsrm"]));
  }
};
var boldsymbol = function boldsymbol2(value, mode, options, classes2, type) {
  if (type !== "textord" && lookupSymbol(value, "Math-BoldItalic", mode).metrics) {
    return {
      fontName: "Math-BoldItalic",
      fontClass: "boldsymbol"
    };
  } else {
    return {
      fontName: "Main-Bold",
      fontClass: "mathbf"
    };
  }
};
var makeOrd = function makeOrd2(group, options, type) {
  var mode = group.mode;
  var text4 = group.text;
  var classes2 = ["mord"];
  var isFont = mode === "math" || mode === "text" && options.font;
  var fontOrFamily = isFont ? options.font : options.fontFamily;
  if (text4.charCodeAt(0) === 55349) {
    var [wideFontName, wideFontClass] = wideCharacterFont(text4, mode);
    return makeSymbol(text4, wideFontName, mode, options, classes2.concat(wideFontClass));
  } else if (fontOrFamily) {
    var fontName;
    var fontClasses;
    if (fontOrFamily === "boldsymbol") {
      var fontData = boldsymbol(text4, mode, options, classes2, type);
      fontName = fontData.fontName;
      fontClasses = [fontData.fontClass];
    } else if (isFont) {
      fontName = fontMap[fontOrFamily].fontName;
      fontClasses = [fontOrFamily];
    } else {
      fontName = retrieveTextFontName(fontOrFamily, options.fontWeight, options.fontShape);
      fontClasses = [fontOrFamily, options.fontWeight, options.fontShape];
    }
    if (lookupSymbol(text4, fontName, mode).metrics) {
      return makeSymbol(text4, fontName, mode, options, classes2.concat(fontClasses));
    } else if (ligatures.hasOwnProperty(text4) && fontName.slice(0, 10) === "Typewriter") {
      var parts = [];
      for (var i2 = 0; i2 < text4.length; i2++) {
        parts.push(makeSymbol(text4[i2], fontName, mode, options, classes2.concat(fontClasses)));
      }
      return makeFragment(parts);
    }
  }
  if (type === "mathord") {
    return makeSymbol(text4, "Math-Italic", mode, options, classes2.concat(["mathnormal"]));
  } else if (type === "textord") {
    var font = symbols[mode][text4] && symbols[mode][text4].font;
    if (font === "ams") {
      var _fontName = retrieveTextFontName("amsrm", options.fontWeight, options.fontShape);
      return makeSymbol(text4, _fontName, mode, options, classes2.concat("amsrm", options.fontWeight, options.fontShape));
    } else if (font === "main" || !font) {
      var _fontName2 = retrieveTextFontName("textrm", options.fontWeight, options.fontShape);
      return makeSymbol(text4, _fontName2, mode, options, classes2.concat(options.fontWeight, options.fontShape));
    } else {
      var _fontName3 = retrieveTextFontName(font, options.fontWeight, options.fontShape);
      return makeSymbol(text4, _fontName3, mode, options, classes2.concat(_fontName3, options.fontWeight, options.fontShape));
    }
  } else {
    throw new Error("unexpected type: " + type + " in makeOrd");
  }
};
var canCombine = (prev2, next2) => {
  if (createClass(prev2.classes) !== createClass(next2.classes) || prev2.skew !== next2.skew || prev2.maxFontSize !== next2.maxFontSize) {
    return false;
  }
  if (prev2.classes.length === 1) {
    var cls = prev2.classes[0];
    if (cls === "mbin" || cls === "mord") {
      return false;
    }
  }
  for (var style in prev2.style) {
    if (prev2.style.hasOwnProperty(style) && prev2.style[style] !== next2.style[style]) {
      return false;
    }
  }
  for (var _style in next2.style) {
    if (next2.style.hasOwnProperty(_style) && prev2.style[_style] !== next2.style[_style]) {
      return false;
    }
  }
  return true;
};
var tryCombineChars = (chars) => {
  for (var i2 = 0; i2 < chars.length - 1; i2++) {
    var prev2 = chars[i2];
    var next2 = chars[i2 + 1];
    if (prev2 instanceof SymbolNode && next2 instanceof SymbolNode && canCombine(prev2, next2)) {
      prev2.text += next2.text;
      prev2.height = Math.max(prev2.height, next2.height);
      prev2.depth = Math.max(prev2.depth, next2.depth);
      prev2.italic = next2.italic;
      chars.splice(i2 + 1, 1);
      i2--;
    }
  }
  return chars;
};
var sizeElementFromChildren = function sizeElementFromChildren2(elem) {
  var height2 = 0;
  var depth = 0;
  var maxFontSize = 0;
  for (var i2 = 0; i2 < elem.children.length; i2++) {
    var child = elem.children[i2];
    if (child.height > height2) {
      height2 = child.height;
    }
    if (child.depth > depth) {
      depth = child.depth;
    }
    if (child.maxFontSize > maxFontSize) {
      maxFontSize = child.maxFontSize;
    }
  }
  elem.height = height2;
  elem.depth = depth;
  elem.maxFontSize = maxFontSize;
};
var makeSpan$2 = function makeSpan(classes2, children, options, style) {
  var span = new Span(classes2, children, options, style);
  sizeElementFromChildren(span);
  return span;
};
var makeSvgSpan = (classes2, children, options, style) => new Span(classes2, children, options, style);
var makeLineSpan = function makeLineSpan2(className, options, thickness) {
  var line = makeSpan$2([className], [], options);
  line.height = Math.max(thickness || options.fontMetrics().defaultRuleThickness, options.minRuleThickness);
  line.style.borderBottomWidth = makeEm(line.height);
  line.maxFontSize = 1;
  return line;
};
var makeAnchor = function makeAnchor2(href, classes2, children, options) {
  var anchor = new Anchor(href, classes2, children, options);
  sizeElementFromChildren(anchor);
  return anchor;
};
var makeFragment = function makeFragment2(children) {
  var fragment = new DocumentFragment(children);
  sizeElementFromChildren(fragment);
  return fragment;
};
var wrapFragment = function wrapFragment2(group, options) {
  if (group instanceof DocumentFragment) {
    return makeSpan$2([], [group], options);
  }
  return group;
};
var getVListChildrenAndDepth = function getVListChildrenAndDepth2(params) {
  if (params.positionType === "individualShift") {
    var oldChildren = params.children;
    var children = [oldChildren[0]];
    var _depth = -oldChildren[0].shift - oldChildren[0].elem.depth;
    var currPos = _depth;
    for (var i2 = 1; i2 < oldChildren.length; i2++) {
      var diff = -oldChildren[i2].shift - currPos - oldChildren[i2].elem.depth;
      var size2 = diff - (oldChildren[i2 - 1].elem.height + oldChildren[i2 - 1].elem.depth);
      currPos = currPos + diff;
      children.push({
        type: "kern",
        size: size2
      });
      children.push(oldChildren[i2]);
    }
    return {
      children,
      depth: _depth
    };
  }
  var depth;
  if (params.positionType === "top") {
    var bottom = params.positionData;
    for (var _i = 0; _i < params.children.length; _i++) {
      var child = params.children[_i];
      bottom -= child.type === "kern" ? child.size : child.elem.height + child.elem.depth;
    }
    depth = bottom;
  } else if (params.positionType === "bottom") {
    depth = -params.positionData;
  } else {
    var firstChild = params.children[0];
    if (firstChild.type !== "elem") {
      throw new Error('First child must have type "elem".');
    }
    if (params.positionType === "shift") {
      depth = -firstChild.elem.depth - params.positionData;
    } else if (params.positionType === "firstBaseline") {
      depth = -firstChild.elem.depth;
    } else {
      throw new Error("Invalid positionType " + params.positionType + ".");
    }
  }
  return {
    children: params.children,
    depth
  };
};
var makeVList = function makeVList2(params, options) {
  var {
    children,
    depth
  } = getVListChildrenAndDepth(params);
  var pstrutSize = 0;
  for (var i2 = 0; i2 < children.length; i2++) {
    var child = children[i2];
    if (child.type === "elem") {
      var elem = child.elem;
      pstrutSize = Math.max(pstrutSize, elem.maxFontSize, elem.height);
    }
  }
  pstrutSize += 2;
  var pstrut = makeSpan$2(["pstrut"], []);
  pstrut.style.height = makeEm(pstrutSize);
  var realChildren = [];
  var minPos = depth;
  var maxPos = depth;
  var currPos = depth;
  for (var _i2 = 0; _i2 < children.length; _i2++) {
    var _child = children[_i2];
    if (_child.type === "kern") {
      currPos += _child.size;
    } else {
      var _elem = _child.elem;
      var classes2 = _child.wrapperClasses || [];
      var style = _child.wrapperStyle || {};
      var childWrap = makeSpan$2(classes2, [pstrut, _elem], void 0, style);
      childWrap.style.top = makeEm(-pstrutSize - currPos - _elem.depth);
      if (_child.marginLeft) {
        childWrap.style.marginLeft = _child.marginLeft;
      }
      if (_child.marginRight) {
        childWrap.style.marginRight = _child.marginRight;
      }
      realChildren.push(childWrap);
      currPos += _elem.height + _elem.depth;
    }
    minPos = Math.min(minPos, currPos);
    maxPos = Math.max(maxPos, currPos);
  }
  var vlist = makeSpan$2(["vlist"], realChildren);
  vlist.style.height = makeEm(maxPos);
  var rows;
  if (minPos < 0) {
    var emptySpan = makeSpan$2([], []);
    var depthStrut = makeSpan$2(["vlist"], [emptySpan]);
    depthStrut.style.height = makeEm(-minPos);
    var topStrut = makeSpan$2(["vlist-s"], [new SymbolNode("\u200B")]);
    rows = [makeSpan$2(["vlist-r"], [vlist, topStrut]), makeSpan$2(["vlist-r"], [depthStrut])];
  } else {
    rows = [makeSpan$2(["vlist-r"], [vlist])];
  }
  var vtable = makeSpan$2(["vlist-t"], rows);
  if (rows.length === 2) {
    vtable.classes.push("vlist-t2");
  }
  vtable.height = maxPos;
  vtable.depth = -minPos;
  return vtable;
};
var makeGlue = (measurement, options) => {
  var rule = makeSpan$2(["mspace"], [], options);
  var size2 = calculateSize(measurement, options);
  rule.style.marginRight = makeEm(size2);
  return rule;
};
var retrieveTextFontName = function retrieveTextFontName2(fontFamily, fontWeight, fontShape) {
  var baseFontName = "";
  switch (fontFamily) {
    case "amsrm":
      baseFontName = "AMS";
      break;
    case "textrm":
      baseFontName = "Main";
      break;
    case "textsf":
      baseFontName = "SansSerif";
      break;
    case "texttt":
      baseFontName = "Typewriter";
      break;
    default:
      baseFontName = fontFamily;
  }
  var fontStylesName;
  if (fontWeight === "textbf" && fontShape === "textit") {
    fontStylesName = "BoldItalic";
  } else if (fontWeight === "textbf") {
    fontStylesName = "Bold";
  } else if (fontWeight === "textit") {
    fontStylesName = "Italic";
  } else {
    fontStylesName = "Regular";
  }
  return baseFontName + "-" + fontStylesName;
};
var fontMap = {
  // styles
  "mathbf": {
    variant: "bold",
    fontName: "Main-Bold"
  },
  "mathrm": {
    variant: "normal",
    fontName: "Main-Regular"
  },
  "textit": {
    variant: "italic",
    fontName: "Main-Italic"
  },
  "mathit": {
    variant: "italic",
    fontName: "Main-Italic"
  },
  "mathnormal": {
    variant: "italic",
    fontName: "Math-Italic"
  },
  // "boldsymbol" is missing because they require the use of multiple fonts:
  // Math-BoldItalic and Main-Bold.  This is handled by a special case in
  // makeOrd which ends up calling boldsymbol.
  // families
  "mathbb": {
    variant: "double-struck",
    fontName: "AMS-Regular"
  },
  "mathcal": {
    variant: "script",
    fontName: "Caligraphic-Regular"
  },
  "mathfrak": {
    variant: "fraktur",
    fontName: "Fraktur-Regular"
  },
  "mathscr": {
    variant: "script",
    fontName: "Script-Regular"
  },
  "mathsf": {
    variant: "sans-serif",
    fontName: "SansSerif-Regular"
  },
  "mathtt": {
    variant: "monospace",
    fontName: "Typewriter-Regular"
  }
};
var svgData = {
  //   path, width, height
  vec: ["vec", 0.471, 0.714],
  // values from the font glyph
  oiintSize1: ["oiintSize1", 0.957, 0.499],
  // oval to overlay the integrand
  oiintSize2: ["oiintSize2", 1.472, 0.659],
  oiiintSize1: ["oiiintSize1", 1.304, 0.499],
  oiiintSize2: ["oiiintSize2", 1.98, 0.659]
};
var staticSvg = function staticSvg2(value, options) {
  var [pathName, width2, height2] = svgData[value];
  var path2 = new PathNode(pathName);
  var svgNode = new SvgNode([path2], {
    "width": makeEm(width2),
    "height": makeEm(height2),
    // Override CSS rule `.katex svg { width: 100% }`
    "style": "width:" + makeEm(width2),
    "viewBox": "0 0 " + 1e3 * width2 + " " + 1e3 * height2,
    "preserveAspectRatio": "xMinYMin"
  });
  var span = makeSvgSpan(["overlay"], [svgNode], options);
  span.height = height2;
  span.style.height = makeEm(height2);
  span.style.width = makeEm(width2);
  return span;
};
var buildCommon = {
  fontMap,
  makeSymbol,
  mathsym,
  makeSpan: makeSpan$2,
  makeSvgSpan,
  makeLineSpan,
  makeAnchor,
  makeFragment,
  wrapFragment,
  makeVList,
  makeOrd,
  makeGlue,
  staticSvg,
  svgData,
  tryCombineChars
};
var thinspace = {
  number: 3,
  unit: "mu"
};
var mediumspace = {
  number: 4,
  unit: "mu"
};
var thickspace = {
  number: 5,
  unit: "mu"
};
var spacings = {
  mord: {
    mop: thinspace,
    mbin: mediumspace,
    mrel: thickspace,
    minner: thinspace
  },
  mop: {
    mord: thinspace,
    mop: thinspace,
    mrel: thickspace,
    minner: thinspace
  },
  mbin: {
    mord: mediumspace,
    mop: mediumspace,
    mopen: mediumspace,
    minner: mediumspace
  },
  mrel: {
    mord: thickspace,
    mop: thickspace,
    mopen: thickspace,
    minner: thickspace
  },
  mopen: {},
  mclose: {
    mop: thinspace,
    mbin: mediumspace,
    mrel: thickspace,
    minner: thinspace
  },
  mpunct: {
    mord: thinspace,
    mop: thinspace,
    mrel: thickspace,
    mopen: thinspace,
    mclose: thinspace,
    mpunct: thinspace,
    minner: thinspace
  },
  minner: {
    mord: thinspace,
    mop: thinspace,
    mbin: mediumspace,
    mrel: thickspace,
    mopen: thinspace,
    mpunct: thinspace,
    minner: thinspace
  }
};
var tightSpacings = {
  mord: {
    mop: thinspace
  },
  mop: {
    mord: thinspace,
    mop: thinspace
  },
  mbin: {},
  mrel: {},
  mopen: {},
  mclose: {
    mop: thinspace
  },
  mpunct: {},
  minner: {
    mop: thinspace
  }
};
var _functions = {};
var _htmlGroupBuilders = {};
var _mathmlGroupBuilders = {};
function defineFunction(_ref) {
  var {
    type,
    names: names2,
    props,
    handler,
    htmlBuilder: htmlBuilder3,
    mathmlBuilder: mathmlBuilder3
  } = _ref;
  var data2 = {
    type,
    numArgs: props.numArgs,
    argTypes: props.argTypes,
    allowedInArgument: !!props.allowedInArgument,
    allowedInText: !!props.allowedInText,
    allowedInMath: props.allowedInMath === void 0 ? true : props.allowedInMath,
    numOptionalArgs: props.numOptionalArgs || 0,
    infix: !!props.infix,
    primitive: !!props.primitive,
    handler
  };
  for (var i2 = 0; i2 < names2.length; ++i2) {
    _functions[names2[i2]] = data2;
  }
  if (type) {
    if (htmlBuilder3) {
      _htmlGroupBuilders[type] = htmlBuilder3;
    }
    if (mathmlBuilder3) {
      _mathmlGroupBuilders[type] = mathmlBuilder3;
    }
  }
}
function defineFunctionBuilders(_ref2) {
  var {
    type,
    htmlBuilder: htmlBuilder3,
    mathmlBuilder: mathmlBuilder3
  } = _ref2;
  defineFunction({
    type,
    names: [],
    props: {
      numArgs: 0
    },
    handler() {
      throw new Error("Should never be called.");
    },
    htmlBuilder: htmlBuilder3,
    mathmlBuilder: mathmlBuilder3
  });
}
var normalizeArgument = function normalizeArgument2(arg) {
  return arg.type === "ordgroup" && arg.body.length === 1 ? arg.body[0] : arg;
};
var ordargument = function ordargument2(arg) {
  return arg.type === "ordgroup" ? arg.body : [arg];
};
var makeSpan$1 = buildCommon.makeSpan;
var binLeftCanceller = ["leftmost", "mbin", "mopen", "mrel", "mop", "mpunct"];
var binRightCanceller = ["rightmost", "mrel", "mclose", "mpunct"];
var styleMap$1 = {
  "display": Style$1.DISPLAY,
  "text": Style$1.TEXT,
  "script": Style$1.SCRIPT,
  "scriptscript": Style$1.SCRIPTSCRIPT
};
var DomEnum = {
  mord: "mord",
  mop: "mop",
  mbin: "mbin",
  mrel: "mrel",
  mopen: "mopen",
  mclose: "mclose",
  mpunct: "mpunct",
  minner: "minner"
};
var buildExpression$1 = function buildExpression(expression, options, isRealGroup, surrounding) {
  if (surrounding === void 0) {
    surrounding = [null, null];
  }
  var groups = [];
  for (var i2 = 0; i2 < expression.length; i2++) {
    var output = buildGroup$1(expression[i2], options);
    if (output instanceof DocumentFragment) {
      var children = output.children;
      groups.push(...children);
    } else {
      groups.push(output);
    }
  }
  buildCommon.tryCombineChars(groups);
  if (!isRealGroup) {
    return groups;
  }
  var glueOptions = options;
  if (expression.length === 1) {
    var node3 = expression[0];
    if (node3.type === "sizing") {
      glueOptions = options.havingSize(node3.size);
    } else if (node3.type === "styling") {
      glueOptions = options.havingStyle(styleMap$1[node3.style]);
    }
  }
  var dummyPrev = makeSpan$1([surrounding[0] || "leftmost"], [], options);
  var dummyNext = makeSpan$1([surrounding[1] || "rightmost"], [], options);
  var isRoot = isRealGroup === "root";
  traverseNonSpaceNodes(groups, (node4, prev2) => {
    var prevType = prev2.classes[0];
    var type = node4.classes[0];
    if (prevType === "mbin" && utils.contains(binRightCanceller, type)) {
      prev2.classes[0] = "mord";
    } else if (type === "mbin" && utils.contains(binLeftCanceller, prevType)) {
      node4.classes[0] = "mord";
    }
  }, {
    node: dummyPrev
  }, dummyNext, isRoot);
  traverseNonSpaceNodes(groups, (node4, prev2) => {
    var prevType = getTypeOfDomTree(prev2);
    var type = getTypeOfDomTree(node4);
    var space = prevType && type ? node4.hasClass("mtight") ? tightSpacings[prevType][type] : spacings[prevType][type] : null;
    if (space) {
      return buildCommon.makeGlue(space, glueOptions);
    }
  }, {
    node: dummyPrev
  }, dummyNext, isRoot);
  return groups;
};
var traverseNonSpaceNodes = function traverseNonSpaceNodes2(nodes, callback, prev2, next2, isRoot) {
  if (next2) {
    nodes.push(next2);
  }
  var i2 = 0;
  for (; i2 < nodes.length; i2++) {
    var node3 = nodes[i2];
    var partialGroup = checkPartialGroup(node3);
    if (partialGroup) {
      traverseNonSpaceNodes2(partialGroup.children, callback, prev2, null, isRoot);
      continue;
    }
    var nonspace = !node3.hasClass("mspace");
    if (nonspace) {
      var result = callback(node3, prev2.node);
      if (result) {
        if (prev2.insertAfter) {
          prev2.insertAfter(result);
        } else {
          nodes.unshift(result);
          i2++;
        }
      }
    }
    if (nonspace) {
      prev2.node = node3;
    } else if (isRoot && node3.hasClass("newline")) {
      prev2.node = makeSpan$1(["leftmost"]);
    }
    prev2.insertAfter = ((index3) => (n2) => {
      nodes.splice(index3 + 1, 0, n2);
      i2++;
    })(i2);
  }
  if (next2) {
    nodes.pop();
  }
};
var checkPartialGroup = function checkPartialGroup2(node3) {
  if (node3 instanceof DocumentFragment || node3 instanceof Anchor || node3 instanceof Span && node3.hasClass("enclosing")) {
    return node3;
  }
  return null;
};
var getOutermostNode = function getOutermostNode2(node3, side) {
  var partialGroup = checkPartialGroup(node3);
  if (partialGroup) {
    var children = partialGroup.children;
    if (children.length) {
      if (side === "right") {
        return getOutermostNode2(children[children.length - 1], "right");
      } else if (side === "left") {
        return getOutermostNode2(children[0], "left");
      }
    }
  }
  return node3;
};
var getTypeOfDomTree = function getTypeOfDomTree2(node3, side) {
  if (!node3) {
    return null;
  }
  if (side) {
    node3 = getOutermostNode(node3, side);
  }
  return DomEnum[node3.classes[0]] || null;
};
var makeNullDelimiter = function makeNullDelimiter2(options, classes2) {
  var moreClasses = ["nulldelimiter"].concat(options.baseSizingClasses());
  return makeSpan$1(classes2.concat(moreClasses));
};
var buildGroup$1 = function buildGroup(group, options, baseOptions) {
  if (!group) {
    return makeSpan$1();
  }
  if (_htmlGroupBuilders[group.type]) {
    var groupNode = _htmlGroupBuilders[group.type](group, options);
    if (baseOptions && options.size !== baseOptions.size) {
      groupNode = makeSpan$1(options.sizingClasses(baseOptions), [groupNode], options);
      var multiplier = options.sizeMultiplier / baseOptions.sizeMultiplier;
      groupNode.height *= multiplier;
      groupNode.depth *= multiplier;
    }
    return groupNode;
  } else {
    throw new ParseError("Got group of unknown type: '" + group.type + "'");
  }
};
function buildHTMLUnbreakable(children, options) {
  var body = makeSpan$1(["base"], children, options);
  var strut = makeSpan$1(["strut"]);
  strut.style.height = makeEm(body.height + body.depth);
  if (body.depth) {
    strut.style.verticalAlign = makeEm(-body.depth);
  }
  body.children.unshift(strut);
  return body;
}
function buildHTML(tree, options) {
  var tag = null;
  if (tree.length === 1 && tree[0].type === "tag") {
    tag = tree[0].tag;
    tree = tree[0].body;
  }
  var expression = buildExpression$1(tree, options, "root");
  var eqnNum;
  if (expression.length === 2 && expression[1].hasClass("tag")) {
    eqnNum = expression.pop();
  }
  var children = [];
  var parts = [];
  for (var i2 = 0; i2 < expression.length; i2++) {
    parts.push(expression[i2]);
    if (expression[i2].hasClass("mbin") || expression[i2].hasClass("mrel") || expression[i2].hasClass("allowbreak")) {
      var nobreak = false;
      while (i2 < expression.length - 1 && expression[i2 + 1].hasClass("mspace") && !expression[i2 + 1].hasClass("newline")) {
        i2++;
        parts.push(expression[i2]);
        if (expression[i2].hasClass("nobreak")) {
          nobreak = true;
        }
      }
      if (!nobreak) {
        children.push(buildHTMLUnbreakable(parts, options));
        parts = [];
      }
    } else if (expression[i2].hasClass("newline")) {
      parts.pop();
      if (parts.length > 0) {
        children.push(buildHTMLUnbreakable(parts, options));
        parts = [];
      }
      children.push(expression[i2]);
    }
  }
  if (parts.length > 0) {
    children.push(buildHTMLUnbreakable(parts, options));
  }
  var tagChild;
  if (tag) {
    tagChild = buildHTMLUnbreakable(buildExpression$1(tag, options, true));
    tagChild.classes = ["tag"];
    children.push(tagChild);
  } else if (eqnNum) {
    children.push(eqnNum);
  }
  var htmlNode = makeSpan$1(["katex-html"], children);
  htmlNode.setAttribute("aria-hidden", "true");
  if (tagChild) {
    var strut = tagChild.children[0];
    strut.style.height = makeEm(htmlNode.height + htmlNode.depth);
    if (htmlNode.depth) {
      strut.style.verticalAlign = makeEm(-htmlNode.depth);
    }
  }
  return htmlNode;
}
function newDocumentFragment(children) {
  return new DocumentFragment(children);
}
var MathNode = class {
  constructor(type, children, classes2) {
    this.type = void 0;
    this.attributes = void 0;
    this.children = void 0;
    this.classes = void 0;
    this.type = type;
    this.attributes = {};
    this.children = children || [];
    this.classes = classes2 || [];
  }
  /**
   * Sets an attribute on a MathML node. MathML depends on attributes to convey a
   * semantic content, so this is used heavily.
   */
  setAttribute(name, value) {
    this.attributes[name] = value;
  }
  /**
   * Gets an attribute on a MathML node.
   */
  getAttribute(name) {
    return this.attributes[name];
  }
  /**
   * Converts the math node into a MathML-namespaced DOM element.
   */
  toNode() {
    var node3 = document.createElementNS("http://www.w3.org/1998/Math/MathML", this.type);
    for (var attr2 in this.attributes) {
      if (Object.prototype.hasOwnProperty.call(this.attributes, attr2)) {
        node3.setAttribute(attr2, this.attributes[attr2]);
      }
    }
    if (this.classes.length > 0) {
      node3.className = createClass(this.classes);
    }
    for (var i2 = 0; i2 < this.children.length; i2++) {
      node3.appendChild(this.children[i2].toNode());
    }
    return node3;
  }
  /**
   * Converts the math node into an HTML markup string.
   */
  toMarkup() {
    var markup = "<" + this.type;
    for (var attr2 in this.attributes) {
      if (Object.prototype.hasOwnProperty.call(this.attributes, attr2)) {
        markup += " " + attr2 + '="';
        markup += utils.escape(this.attributes[attr2]);
        markup += '"';
      }
    }
    if (this.classes.length > 0) {
      markup += ' class ="' + utils.escape(createClass(this.classes)) + '"';
    }
    markup += ">";
    for (var i2 = 0; i2 < this.children.length; i2++) {
      markup += this.children[i2].toMarkup();
    }
    markup += "</" + this.type + ">";
    return markup;
  }
  /**
   * Converts the math node into a string, similar to innerText, but escaped.
   */
  toText() {
    return this.children.map((child) => child.toText()).join("");
  }
};
var TextNode2 = class {
  constructor(text4) {
    this.text = void 0;
    this.text = text4;
  }
  /**
   * Converts the text node into a DOM text node.
   */
  toNode() {
    return document.createTextNode(this.text);
  }
  /**
   * Converts the text node into escaped HTML markup
   * (representing the text itself).
   */
  toMarkup() {
    return utils.escape(this.toText());
  }
  /**
   * Converts the text node into a string
   * (representing the text itself).
   */
  toText() {
    return this.text;
  }
};
var SpaceNode = class {
  /**
   * Create a Space node with width given in CSS ems.
   */
  constructor(width2) {
    this.width = void 0;
    this.character = void 0;
    this.width = width2;
    if (width2 >= 0.05555 && width2 <= 0.05556) {
      this.character = "\u200A";
    } else if (width2 >= 0.1666 && width2 <= 0.1667) {
      this.character = "\u2009";
    } else if (width2 >= 0.2222 && width2 <= 0.2223) {
      this.character = "\u2005";
    } else if (width2 >= 0.2777 && width2 <= 0.2778) {
      this.character = "\u2005\u200A";
    } else if (width2 >= -0.05556 && width2 <= -0.05555) {
      this.character = "\u200A\u2063";
    } else if (width2 >= -0.1667 && width2 <= -0.1666) {
      this.character = "\u2009\u2063";
    } else if (width2 >= -0.2223 && width2 <= -0.2222) {
      this.character = "\u205F\u2063";
    } else if (width2 >= -0.2778 && width2 <= -0.2777) {
      this.character = "\u2005\u2063";
    } else {
      this.character = null;
    }
  }
  /**
   * Converts the math node into a MathML-namespaced DOM element.
   */
  toNode() {
    if (this.character) {
      return document.createTextNode(this.character);
    } else {
      var node3 = document.createElementNS("http://www.w3.org/1998/Math/MathML", "mspace");
      node3.setAttribute("width", makeEm(this.width));
      return node3;
    }
  }
  /**
   * Converts the math node into an HTML markup string.
   */
  toMarkup() {
    if (this.character) {
      return "<mtext>" + this.character + "</mtext>";
    } else {
      return '<mspace width="' + makeEm(this.width) + '"/>';
    }
  }
  /**
   * Converts the math node into a string, similar to innerText.
   */
  toText() {
    if (this.character) {
      return this.character;
    } else {
      return " ";
    }
  }
};
var mathMLTree = {
  MathNode,
  TextNode: TextNode2,
  SpaceNode,
  newDocumentFragment
};
var makeText = function makeText2(text4, mode, options) {
  if (symbols[mode][text4] && symbols[mode][text4].replace && text4.charCodeAt(0) !== 55349 && !(ligatures.hasOwnProperty(text4) && options && (options.fontFamily && options.fontFamily.slice(4, 6) === "tt" || options.font && options.font.slice(4, 6) === "tt"))) {
    text4 = symbols[mode][text4].replace;
  }
  return new mathMLTree.TextNode(text4);
};
var makeRow = function makeRow2(body) {
  if (body.length === 1) {
    return body[0];
  } else {
    return new mathMLTree.MathNode("mrow", body);
  }
};
var getVariant = function getVariant2(group, options) {
  if (options.fontFamily === "texttt") {
    return "monospace";
  } else if (options.fontFamily === "textsf") {
    if (options.fontShape === "textit" && options.fontWeight === "textbf") {
      return "sans-serif-bold-italic";
    } else if (options.fontShape === "textit") {
      return "sans-serif-italic";
    } else if (options.fontWeight === "textbf") {
      return "bold-sans-serif";
    } else {
      return "sans-serif";
    }
  } else if (options.fontShape === "textit" && options.fontWeight === "textbf") {
    return "bold-italic";
  } else if (options.fontShape === "textit") {
    return "italic";
  } else if (options.fontWeight === "textbf") {
    return "bold";
  }
  var font = options.font;
  if (!font || font === "mathnormal") {
    return null;
  }
  var mode = group.mode;
  if (font === "mathit") {
    return "italic";
  } else if (font === "boldsymbol") {
    return group.type === "textord" ? "bold" : "bold-italic";
  } else if (font === "mathbf") {
    return "bold";
  } else if (font === "mathbb") {
    return "double-struck";
  } else if (font === "mathfrak") {
    return "fraktur";
  } else if (font === "mathscr" || font === "mathcal") {
    return "script";
  } else if (font === "mathsf") {
    return "sans-serif";
  } else if (font === "mathtt") {
    return "monospace";
  }
  var text4 = group.text;
  if (utils.contains(["\\imath", "\\jmath"], text4)) {
    return null;
  }
  if (symbols[mode][text4] && symbols[mode][text4].replace) {
    text4 = symbols[mode][text4].replace;
  }
  var fontName = buildCommon.fontMap[font].fontName;
  if (getCharacterMetrics(text4, fontName, mode)) {
    return buildCommon.fontMap[font].variant;
  }
  return null;
};
var buildExpression2 = function buildExpression3(expression, options, isOrdgroup) {
  if (expression.length === 1) {
    var group = buildGroup2(expression[0], options);
    if (isOrdgroup && group instanceof MathNode && group.type === "mo") {
      group.setAttribute("lspace", "0em");
      group.setAttribute("rspace", "0em");
    }
    return [group];
  }
  var groups = [];
  var lastGroup;
  for (var i2 = 0; i2 < expression.length; i2++) {
    var _group = buildGroup2(expression[i2], options);
    if (_group instanceof MathNode && lastGroup instanceof MathNode) {
      if (_group.type === "mtext" && lastGroup.type === "mtext" && _group.getAttribute("mathvariant") === lastGroup.getAttribute("mathvariant")) {
        lastGroup.children.push(..._group.children);
        continue;
      } else if (_group.type === "mn" && lastGroup.type === "mn") {
        lastGroup.children.push(..._group.children);
        continue;
      } else if (_group.type === "mi" && _group.children.length === 1 && lastGroup.type === "mn") {
        var child = _group.children[0];
        if (child instanceof TextNode2 && child.text === ".") {
          lastGroup.children.push(..._group.children);
          continue;
        }
      } else if (lastGroup.type === "mi" && lastGroup.children.length === 1) {
        var lastChild = lastGroup.children[0];
        if (lastChild instanceof TextNode2 && lastChild.text === "\u0338" && (_group.type === "mo" || _group.type === "mi" || _group.type === "mn")) {
          var _child = _group.children[0];
          if (_child instanceof TextNode2 && _child.text.length > 0) {
            _child.text = _child.text.slice(0, 1) + "\u0338" + _child.text.slice(1);
            groups.pop();
          }
        }
      }
    }
    groups.push(_group);
    lastGroup = _group;
  }
  return groups;
};
var buildExpressionRow = function buildExpressionRow2(expression, options, isOrdgroup) {
  return makeRow(buildExpression2(expression, options, isOrdgroup));
};
var buildGroup2 = function buildGroup3(group, options) {
  if (!group) {
    return new mathMLTree.MathNode("mrow");
  }
  if (_mathmlGroupBuilders[group.type]) {
    var result = _mathmlGroupBuilders[group.type](group, options);
    return result;
  } else {
    throw new ParseError("Got group of unknown type: '" + group.type + "'");
  }
};
function buildMathML(tree, texExpression, options, isDisplayMode, forMathmlOnly) {
  var expression = buildExpression2(tree, options);
  var wrapper;
  if (expression.length === 1 && expression[0] instanceof MathNode && utils.contains(["mrow", "mtable"], expression[0].type)) {
    wrapper = expression[0];
  } else {
    wrapper = new mathMLTree.MathNode("mrow", expression);
  }
  var annotation = new mathMLTree.MathNode("annotation", [new mathMLTree.TextNode(texExpression)]);
  annotation.setAttribute("encoding", "application/x-tex");
  var semantics = new mathMLTree.MathNode("semantics", [wrapper, annotation]);
  var math2 = new mathMLTree.MathNode("math", [semantics]);
  math2.setAttribute("xmlns", "http://www.w3.org/1998/Math/MathML");
  if (isDisplayMode) {
    math2.setAttribute("display", "block");
  }
  var wrapperClass = forMathmlOnly ? "katex" : "katex-mathml";
  return buildCommon.makeSpan([wrapperClass], [math2]);
}
var optionsFromSettings = function optionsFromSettings2(settings) {
  return new Options({
    style: settings.displayMode ? Style$1.DISPLAY : Style$1.TEXT,
    maxSize: settings.maxSize,
    minRuleThickness: settings.minRuleThickness
  });
};
var displayWrap = function displayWrap2(node3, settings) {
  if (settings.displayMode) {
    var classes2 = ["katex-display"];
    if (settings.leqno) {
      classes2.push("leqno");
    }
    if (settings.fleqn) {
      classes2.push("fleqn");
    }
    node3 = buildCommon.makeSpan(classes2, [node3]);
  }
  return node3;
};
var buildTree = function buildTree2(tree, expression, settings) {
  var options = optionsFromSettings(settings);
  var katexNode;
  if (settings.output === "mathml") {
    return buildMathML(tree, expression, options, settings.displayMode, true);
  } else if (settings.output === "html") {
    var htmlNode = buildHTML(tree, options);
    katexNode = buildCommon.makeSpan(["katex"], [htmlNode]);
  } else {
    var mathMLNode = buildMathML(tree, expression, options, settings.displayMode, false);
    var _htmlNode = buildHTML(tree, options);
    katexNode = buildCommon.makeSpan(["katex"], [mathMLNode, _htmlNode]);
  }
  return displayWrap(katexNode, settings);
};
var buildHTMLTree = function buildHTMLTree2(tree, expression, settings) {
  var options = optionsFromSettings(settings);
  var htmlNode = buildHTML(tree, options);
  var katexNode = buildCommon.makeSpan(["katex"], [htmlNode]);
  return displayWrap(katexNode, settings);
};
var stretchyCodePoint = {
  widehat: "^",
  widecheck: "\u02C7",
  widetilde: "~",
  utilde: "~",
  overleftarrow: "\u2190",
  underleftarrow: "\u2190",
  xleftarrow: "\u2190",
  overrightarrow: "\u2192",
  underrightarrow: "\u2192",
  xrightarrow: "\u2192",
  underbrace: "\u23DF",
  overbrace: "\u23DE",
  overgroup: "\u23E0",
  undergroup: "\u23E1",
  overleftrightarrow: "\u2194",
  underleftrightarrow: "\u2194",
  xleftrightarrow: "\u2194",
  Overrightarrow: "\u21D2",
  xRightarrow: "\u21D2",
  overleftharpoon: "\u21BC",
  xleftharpoonup: "\u21BC",
  overrightharpoon: "\u21C0",
  xrightharpoonup: "\u21C0",
  xLeftarrow: "\u21D0",
  xLeftrightarrow: "\u21D4",
  xhookleftarrow: "\u21A9",
  xhookrightarrow: "\u21AA",
  xmapsto: "\u21A6",
  xrightharpoondown: "\u21C1",
  xleftharpoondown: "\u21BD",
  xrightleftharpoons: "\u21CC",
  xleftrightharpoons: "\u21CB",
  xtwoheadleftarrow: "\u219E",
  xtwoheadrightarrow: "\u21A0",
  xlongequal: "=",
  xtofrom: "\u21C4",
  xrightleftarrows: "\u21C4",
  xrightequilibrium: "\u21CC",
  // Not a perfect match.
  xleftequilibrium: "\u21CB",
  // None better available.
  "\\cdrightarrow": "\u2192",
  "\\cdleftarrow": "\u2190",
  "\\cdlongequal": "="
};
var mathMLnode = function mathMLnode2(label) {
  var node3 = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode(stretchyCodePoint[label.replace(/^\\/, "")])]);
  node3.setAttribute("stretchy", "true");
  return node3;
};
var katexImagesData = {
  //   path(s), minWidth, height, align
  overrightarrow: [["rightarrow"], 0.888, 522, "xMaxYMin"],
  overleftarrow: [["leftarrow"], 0.888, 522, "xMinYMin"],
  underrightarrow: [["rightarrow"], 0.888, 522, "xMaxYMin"],
  underleftarrow: [["leftarrow"], 0.888, 522, "xMinYMin"],
  xrightarrow: [["rightarrow"], 1.469, 522, "xMaxYMin"],
  "\\cdrightarrow": [["rightarrow"], 3, 522, "xMaxYMin"],
  // CD minwwidth2.5pc
  xleftarrow: [["leftarrow"], 1.469, 522, "xMinYMin"],
  "\\cdleftarrow": [["leftarrow"], 3, 522, "xMinYMin"],
  Overrightarrow: [["doublerightarrow"], 0.888, 560, "xMaxYMin"],
  xRightarrow: [["doublerightarrow"], 1.526, 560, "xMaxYMin"],
  xLeftarrow: [["doubleleftarrow"], 1.526, 560, "xMinYMin"],
  overleftharpoon: [["leftharpoon"], 0.888, 522, "xMinYMin"],
  xleftharpoonup: [["leftharpoon"], 0.888, 522, "xMinYMin"],
  xleftharpoondown: [["leftharpoondown"], 0.888, 522, "xMinYMin"],
  overrightharpoon: [["rightharpoon"], 0.888, 522, "xMaxYMin"],
  xrightharpoonup: [["rightharpoon"], 0.888, 522, "xMaxYMin"],
  xrightharpoondown: [["rightharpoondown"], 0.888, 522, "xMaxYMin"],
  xlongequal: [["longequal"], 0.888, 334, "xMinYMin"],
  "\\cdlongequal": [["longequal"], 3, 334, "xMinYMin"],
  xtwoheadleftarrow: [["twoheadleftarrow"], 0.888, 334, "xMinYMin"],
  xtwoheadrightarrow: [["twoheadrightarrow"], 0.888, 334, "xMaxYMin"],
  overleftrightarrow: [["leftarrow", "rightarrow"], 0.888, 522],
  overbrace: [["leftbrace", "midbrace", "rightbrace"], 1.6, 548],
  underbrace: [["leftbraceunder", "midbraceunder", "rightbraceunder"], 1.6, 548],
  underleftrightarrow: [["leftarrow", "rightarrow"], 0.888, 522],
  xleftrightarrow: [["leftarrow", "rightarrow"], 1.75, 522],
  xLeftrightarrow: [["doubleleftarrow", "doublerightarrow"], 1.75, 560],
  xrightleftharpoons: [["leftharpoondownplus", "rightharpoonplus"], 1.75, 716],
  xleftrightharpoons: [["leftharpoonplus", "rightharpoondownplus"], 1.75, 716],
  xhookleftarrow: [["leftarrow", "righthook"], 1.08, 522],
  xhookrightarrow: [["lefthook", "rightarrow"], 1.08, 522],
  overlinesegment: [["leftlinesegment", "rightlinesegment"], 0.888, 522],
  underlinesegment: [["leftlinesegment", "rightlinesegment"], 0.888, 522],
  overgroup: [["leftgroup", "rightgroup"], 0.888, 342],
  undergroup: [["leftgroupunder", "rightgroupunder"], 0.888, 342],
  xmapsto: [["leftmapsto", "rightarrow"], 1.5, 522],
  xtofrom: [["leftToFrom", "rightToFrom"], 1.75, 528],
  // The next three arrows are from the mhchem package.
  // In mhchem.sty, min-length is 2.0em. But these arrows might appear in the
  // document as \xrightarrow or \xrightleftharpoons. Those have
  // min-length = 1.75em, so we set min-length on these next three to match.
  xrightleftarrows: [["baraboveleftarrow", "rightarrowabovebar"], 1.75, 901],
  xrightequilibrium: [["baraboveshortleftharpoon", "rightharpoonaboveshortbar"], 1.75, 716],
  xleftequilibrium: [["shortbaraboveleftharpoon", "shortrightharpoonabovebar"], 1.75, 716]
};
var groupLength = function groupLength2(arg) {
  if (arg.type === "ordgroup") {
    return arg.body.length;
  } else {
    return 1;
  }
};
var svgSpan = function svgSpan2(group, options) {
  function buildSvgSpan_() {
    var viewBoxWidth = 4e5;
    var label = group.label.slice(1);
    if (utils.contains(["widehat", "widecheck", "widetilde", "utilde"], label)) {
      var grp = group;
      var numChars = groupLength(grp.base);
      var viewBoxHeight;
      var pathName;
      var _height;
      if (numChars > 5) {
        if (label === "widehat" || label === "widecheck") {
          viewBoxHeight = 420;
          viewBoxWidth = 2364;
          _height = 0.42;
          pathName = label + "4";
        } else {
          viewBoxHeight = 312;
          viewBoxWidth = 2340;
          _height = 0.34;
          pathName = "tilde4";
        }
      } else {
        var imgIndex = [1, 1, 2, 2, 3, 3][numChars];
        if (label === "widehat" || label === "widecheck") {
          viewBoxWidth = [0, 1062, 2364, 2364, 2364][imgIndex];
          viewBoxHeight = [0, 239, 300, 360, 420][imgIndex];
          _height = [0, 0.24, 0.3, 0.3, 0.36, 0.42][imgIndex];
          pathName = label + imgIndex;
        } else {
          viewBoxWidth = [0, 600, 1033, 2339, 2340][imgIndex];
          viewBoxHeight = [0, 260, 286, 306, 312][imgIndex];
          _height = [0, 0.26, 0.286, 0.3, 0.306, 0.34][imgIndex];
          pathName = "tilde" + imgIndex;
        }
      }
      var path2 = new PathNode(pathName);
      var svgNode = new SvgNode([path2], {
        "width": "100%",
        "height": makeEm(_height),
        "viewBox": "0 0 " + viewBoxWidth + " " + viewBoxHeight,
        "preserveAspectRatio": "none"
      });
      return {
        span: buildCommon.makeSvgSpan([], [svgNode], options),
        minWidth: 0,
        height: _height
      };
    } else {
      var spans = [];
      var data2 = katexImagesData[label];
      var [paths, _minWidth, _viewBoxHeight] = data2;
      var _height2 = _viewBoxHeight / 1e3;
      var numSvgChildren = paths.length;
      var widthClasses;
      var aligns;
      if (numSvgChildren === 1) {
        var align1 = data2[3];
        widthClasses = ["hide-tail"];
        aligns = [align1];
      } else if (numSvgChildren === 2) {
        widthClasses = ["halfarrow-left", "halfarrow-right"];
        aligns = ["xMinYMin", "xMaxYMin"];
      } else if (numSvgChildren === 3) {
        widthClasses = ["brace-left", "brace-center", "brace-right"];
        aligns = ["xMinYMin", "xMidYMin", "xMaxYMin"];
      } else {
        throw new Error("Correct katexImagesData or update code here to support\n                    " + numSvgChildren + " children.");
      }
      for (var i2 = 0; i2 < numSvgChildren; i2++) {
        var _path = new PathNode(paths[i2]);
        var _svgNode = new SvgNode([_path], {
          "width": "400em",
          "height": makeEm(_height2),
          "viewBox": "0 0 " + viewBoxWidth + " " + _viewBoxHeight,
          "preserveAspectRatio": aligns[i2] + " slice"
        });
        var _span = buildCommon.makeSvgSpan([widthClasses[i2]], [_svgNode], options);
        if (numSvgChildren === 1) {
          return {
            span: _span,
            minWidth: _minWidth,
            height: _height2
          };
        } else {
          _span.style.height = makeEm(_height2);
          spans.push(_span);
        }
      }
      return {
        span: buildCommon.makeSpan(["stretchy"], spans, options),
        minWidth: _minWidth,
        height: _height2
      };
    }
  }
  var {
    span,
    minWidth,
    height: height2
  } = buildSvgSpan_();
  span.height = height2;
  span.style.height = makeEm(height2);
  if (minWidth > 0) {
    span.style.minWidth = makeEm(minWidth);
  }
  return span;
};
var encloseSpan = function encloseSpan2(inner2, label, topPad, bottomPad, options) {
  var img;
  var totalHeight = inner2.height + inner2.depth + topPad + bottomPad;
  if (/fbox|color|angl/.test(label)) {
    img = buildCommon.makeSpan(["stretchy", label], [], options);
    if (label === "fbox") {
      var color = options.color && options.getColor();
      if (color) {
        img.style.borderColor = color;
      }
    }
  } else {
    var lines = [];
    if (/^[bx]cancel$/.test(label)) {
      lines.push(new LineNode({
        "x1": "0",
        "y1": "0",
        "x2": "100%",
        "y2": "100%",
        "stroke-width": "0.046em"
      }));
    }
    if (/^x?cancel$/.test(label)) {
      lines.push(new LineNode({
        "x1": "0",
        "y1": "100%",
        "x2": "100%",
        "y2": "0",
        "stroke-width": "0.046em"
      }));
    }
    var svgNode = new SvgNode(lines, {
      "width": "100%",
      "height": makeEm(totalHeight)
    });
    img = buildCommon.makeSvgSpan([], [svgNode], options);
  }
  img.height = totalHeight;
  img.style.height = makeEm(totalHeight);
  return img;
};
var stretchy = {
  encloseSpan,
  mathMLnode,
  svgSpan
};
function assertNodeType(node3, type) {
  if (!node3 || node3.type !== type) {
    throw new Error("Expected node of type " + type + ", but got " + (node3 ? "node of type " + node3.type : String(node3)));
  }
  return node3;
}
function assertSymbolNodeType(node3) {
  var typedNode = checkSymbolNodeType(node3);
  if (!typedNode) {
    throw new Error("Expected node of symbol group type, but got " + (node3 ? "node of type " + node3.type : String(node3)));
  }
  return typedNode;
}
function checkSymbolNodeType(node3) {
  if (node3 && (node3.type === "atom" || NON_ATOMS.hasOwnProperty(node3.type))) {
    return node3;
  }
  return null;
}
var htmlBuilder$a = (grp, options) => {
  var base;
  var group;
  var supSubGroup;
  if (grp && grp.type === "supsub") {
    group = assertNodeType(grp.base, "accent");
    base = group.base;
    grp.base = base;
    supSubGroup = assertSpan(buildGroup$1(grp, options));
    grp.base = group;
  } else {
    group = assertNodeType(grp, "accent");
    base = group.base;
  }
  var body = buildGroup$1(base, options.havingCrampedStyle());
  var mustShift = group.isShifty && utils.isCharacterBox(base);
  var skew = 0;
  if (mustShift) {
    var baseChar = utils.getBaseElem(base);
    var baseGroup = buildGroup$1(baseChar, options.havingCrampedStyle());
    skew = assertSymbolDomNode(baseGroup).skew;
  }
  var accentBelow = group.label === "\\c";
  var clearance = accentBelow ? body.height + body.depth : Math.min(body.height, options.fontMetrics().xHeight);
  var accentBody;
  if (!group.isStretchy) {
    var accent2;
    var width2;
    if (group.label === "\\vec") {
      accent2 = buildCommon.staticSvg("vec", options);
      width2 = buildCommon.svgData.vec[1];
    } else {
      accent2 = buildCommon.makeOrd({
        mode: group.mode,
        text: group.label
      }, options, "textord");
      accent2 = assertSymbolDomNode(accent2);
      accent2.italic = 0;
      width2 = accent2.width;
      if (accentBelow) {
        clearance += accent2.depth;
      }
    }
    accentBody = buildCommon.makeSpan(["accent-body"], [accent2]);
    var accentFull = group.label === "\\textcircled";
    if (accentFull) {
      accentBody.classes.push("accent-full");
      clearance = body.height;
    }
    var left = skew;
    if (!accentFull) {
      left -= width2 / 2;
    }
    accentBody.style.left = makeEm(left);
    if (group.label === "\\textcircled") {
      accentBody.style.top = ".2em";
    }
    accentBody = buildCommon.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: body
      }, {
        type: "kern",
        size: -clearance
      }, {
        type: "elem",
        elem: accentBody
      }]
    }, options);
  } else {
    accentBody = stretchy.svgSpan(group, options);
    accentBody = buildCommon.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: body
      }, {
        type: "elem",
        elem: accentBody,
        wrapperClasses: ["svg-align"],
        wrapperStyle: skew > 0 ? {
          width: "calc(100% - " + makeEm(2 * skew) + ")",
          marginLeft: makeEm(2 * skew)
        } : void 0
      }]
    }, options);
  }
  var accentWrap = buildCommon.makeSpan(["mord", "accent"], [accentBody], options);
  if (supSubGroup) {
    supSubGroup.children[0] = accentWrap;
    supSubGroup.height = Math.max(accentWrap.height, supSubGroup.height);
    supSubGroup.classes[0] = "mord";
    return supSubGroup;
  } else {
    return accentWrap;
  }
};
var mathmlBuilder$9 = (group, options) => {
  var accentNode = group.isStretchy ? stretchy.mathMLnode(group.label) : new mathMLTree.MathNode("mo", [makeText(group.label, group.mode)]);
  var node3 = new mathMLTree.MathNode("mover", [buildGroup2(group.base, options), accentNode]);
  node3.setAttribute("accent", "true");
  return node3;
};
var NON_STRETCHY_ACCENT_REGEX = new RegExp(["\\acute", "\\grave", "\\ddot", "\\tilde", "\\bar", "\\breve", "\\check", "\\hat", "\\vec", "\\dot", "\\mathring"].map((accent2) => "\\" + accent2).join("|"));
defineFunction({
  type: "accent",
  names: ["\\acute", "\\grave", "\\ddot", "\\tilde", "\\bar", "\\breve", "\\check", "\\hat", "\\vec", "\\dot", "\\mathring", "\\widecheck", "\\widehat", "\\widetilde", "\\overrightarrow", "\\overleftarrow", "\\Overrightarrow", "\\overleftrightarrow", "\\overgroup", "\\overlinesegment", "\\overleftharpoon", "\\overrightharpoon"],
  props: {
    numArgs: 1
  },
  handler: (context, args) => {
    var base = normalizeArgument(args[0]);
    var isStretchy = !NON_STRETCHY_ACCENT_REGEX.test(context.funcName);
    var isShifty = !isStretchy || context.funcName === "\\widehat" || context.funcName === "\\widetilde" || context.funcName === "\\widecheck";
    return {
      type: "accent",
      mode: context.parser.mode,
      label: context.funcName,
      isStretchy,
      isShifty,
      base
    };
  },
  htmlBuilder: htmlBuilder$a,
  mathmlBuilder: mathmlBuilder$9
});
defineFunction({
  type: "accent",
  names: ["\\'", "\\`", "\\^", "\\~", "\\=", "\\u", "\\.", '\\"', "\\c", "\\r", "\\H", "\\v", "\\textcircled"],
  props: {
    numArgs: 1,
    allowedInText: true,
    allowedInMath: true,
    // unless in strict mode
    argTypes: ["primitive"]
  },
  handler: (context, args) => {
    var base = args[0];
    var mode = context.parser.mode;
    if (mode === "math") {
      context.parser.settings.reportNonstrict("mathVsTextAccents", "LaTeX's accent " + context.funcName + " works only in text mode");
      mode = "text";
    }
    return {
      type: "accent",
      mode,
      label: context.funcName,
      isStretchy: false,
      isShifty: true,
      base
    };
  },
  htmlBuilder: htmlBuilder$a,
  mathmlBuilder: mathmlBuilder$9
});
defineFunction({
  type: "accentUnder",
  names: ["\\underleftarrow", "\\underrightarrow", "\\underleftrightarrow", "\\undergroup", "\\underlinesegment", "\\utilde"],
  props: {
    numArgs: 1
  },
  handler: (_ref, args) => {
    var {
      parser: parser2,
      funcName
    } = _ref;
    var base = args[0];
    return {
      type: "accentUnder",
      mode: parser2.mode,
      label: funcName,
      base
    };
  },
  htmlBuilder: (group, options) => {
    var innerGroup = buildGroup$1(group.base, options);
    var accentBody = stretchy.svgSpan(group, options);
    var kern = group.label === "\\utilde" ? 0.12 : 0;
    var vlist = buildCommon.makeVList({
      positionType: "top",
      positionData: innerGroup.height,
      children: [{
        type: "elem",
        elem: accentBody,
        wrapperClasses: ["svg-align"]
      }, {
        type: "kern",
        size: kern
      }, {
        type: "elem",
        elem: innerGroup
      }]
    }, options);
    return buildCommon.makeSpan(["mord", "accentunder"], [vlist], options);
  },
  mathmlBuilder: (group, options) => {
    var accentNode = stretchy.mathMLnode(group.label);
    var node3 = new mathMLTree.MathNode("munder", [buildGroup2(group.base, options), accentNode]);
    node3.setAttribute("accentunder", "true");
    return node3;
  }
});
var paddedNode = (group) => {
  var node3 = new mathMLTree.MathNode("mpadded", group ? [group] : []);
  node3.setAttribute("width", "+0.6em");
  node3.setAttribute("lspace", "0.3em");
  return node3;
};
defineFunction({
  type: "xArrow",
  names: [
    "\\xleftarrow",
    "\\xrightarrow",
    "\\xLeftarrow",
    "\\xRightarrow",
    "\\xleftrightarrow",
    "\\xLeftrightarrow",
    "\\xhookleftarrow",
    "\\xhookrightarrow",
    "\\xmapsto",
    "\\xrightharpoondown",
    "\\xrightharpoonup",
    "\\xleftharpoondown",
    "\\xleftharpoonup",
    "\\xrightleftharpoons",
    "\\xleftrightharpoons",
    "\\xlongequal",
    "\\xtwoheadrightarrow",
    "\\xtwoheadleftarrow",
    "\\xtofrom",
    // The next 3 functions are here to support the mhchem extension.
    // Direct use of these functions is discouraged and may break someday.
    "\\xrightleftarrows",
    "\\xrightequilibrium",
    "\\xleftequilibrium",
    // The next 3 functions are here only to support the {CD} environment.
    "\\\\cdrightarrow",
    "\\\\cdleftarrow",
    "\\\\cdlongequal"
  ],
  props: {
    numArgs: 1,
    numOptionalArgs: 1
  },
  handler(_ref, args, optArgs) {
    var {
      parser: parser2,
      funcName
    } = _ref;
    return {
      type: "xArrow",
      mode: parser2.mode,
      label: funcName,
      body: args[0],
      below: optArgs[0]
    };
  },
  // Flow is unable to correctly infer the type of `group`, even though it's
  // unambiguously determined from the passed-in `type` above.
  htmlBuilder(group, options) {
    var style = options.style;
    var newOptions = options.havingStyle(style.sup());
    var upperGroup = buildCommon.wrapFragment(buildGroup$1(group.body, newOptions, options), options);
    var arrowPrefix = group.label.slice(0, 2) === "\\x" ? "x" : "cd";
    upperGroup.classes.push(arrowPrefix + "-arrow-pad");
    var lowerGroup;
    if (group.below) {
      newOptions = options.havingStyle(style.sub());
      lowerGroup = buildCommon.wrapFragment(buildGroup$1(group.below, newOptions, options), options);
      lowerGroup.classes.push(arrowPrefix + "-arrow-pad");
    }
    var arrowBody = stretchy.svgSpan(group, options);
    var arrowShift = -options.fontMetrics().axisHeight + 0.5 * arrowBody.height;
    var upperShift = -options.fontMetrics().axisHeight - 0.5 * arrowBody.height - 0.111;
    if (upperGroup.depth > 0.25 || group.label === "\\xleftequilibrium") {
      upperShift -= upperGroup.depth;
    }
    var vlist;
    if (lowerGroup) {
      var lowerShift = -options.fontMetrics().axisHeight + lowerGroup.height + 0.5 * arrowBody.height + 0.111;
      vlist = buildCommon.makeVList({
        positionType: "individualShift",
        children: [{
          type: "elem",
          elem: upperGroup,
          shift: upperShift
        }, {
          type: "elem",
          elem: arrowBody,
          shift: arrowShift
        }, {
          type: "elem",
          elem: lowerGroup,
          shift: lowerShift
        }]
      }, options);
    } else {
      vlist = buildCommon.makeVList({
        positionType: "individualShift",
        children: [{
          type: "elem",
          elem: upperGroup,
          shift: upperShift
        }, {
          type: "elem",
          elem: arrowBody,
          shift: arrowShift
        }]
      }, options);
    }
    vlist.children[0].children[0].children[1].classes.push("svg-align");
    return buildCommon.makeSpan(["mrel", "x-arrow"], [vlist], options);
  },
  mathmlBuilder(group, options) {
    var arrowNode = stretchy.mathMLnode(group.label);
    arrowNode.setAttribute("minsize", group.label.charAt(0) === "x" ? "1.75em" : "3.0em");
    var node3;
    if (group.body) {
      var upperNode = paddedNode(buildGroup2(group.body, options));
      if (group.below) {
        var lowerNode = paddedNode(buildGroup2(group.below, options));
        node3 = new mathMLTree.MathNode("munderover", [arrowNode, lowerNode, upperNode]);
      } else {
        node3 = new mathMLTree.MathNode("mover", [arrowNode, upperNode]);
      }
    } else if (group.below) {
      var _lowerNode = paddedNode(buildGroup2(group.below, options));
      node3 = new mathMLTree.MathNode("munder", [arrowNode, _lowerNode]);
    } else {
      node3 = paddedNode();
      node3 = new mathMLTree.MathNode("mover", [arrowNode, node3]);
    }
    return node3;
  }
});
var makeSpan2 = buildCommon.makeSpan;
function htmlBuilder$9(group, options) {
  var elements3 = buildExpression$1(group.body, options, true);
  return makeSpan2([group.mclass], elements3, options);
}
function mathmlBuilder$8(group, options) {
  var node3;
  var inner2 = buildExpression2(group.body, options);
  if (group.mclass === "minner") {
    node3 = new mathMLTree.MathNode("mpadded", inner2);
  } else if (group.mclass === "mord") {
    if (group.isCharacterBox) {
      node3 = inner2[0];
      node3.type = "mi";
    } else {
      node3 = new mathMLTree.MathNode("mi", inner2);
    }
  } else {
    if (group.isCharacterBox) {
      node3 = inner2[0];
      node3.type = "mo";
    } else {
      node3 = new mathMLTree.MathNode("mo", inner2);
    }
    if (group.mclass === "mbin") {
      node3.attributes.lspace = "0.22em";
      node3.attributes.rspace = "0.22em";
    } else if (group.mclass === "mpunct") {
      node3.attributes.lspace = "0em";
      node3.attributes.rspace = "0.17em";
    } else if (group.mclass === "mopen" || group.mclass === "mclose") {
      node3.attributes.lspace = "0em";
      node3.attributes.rspace = "0em";
    } else if (group.mclass === "minner") {
      node3.attributes.lspace = "0.0556em";
      node3.attributes.width = "+0.1111em";
    }
  }
  return node3;
}
defineFunction({
  type: "mclass",
  names: ["\\mathord", "\\mathbin", "\\mathrel", "\\mathopen", "\\mathclose", "\\mathpunct", "\\mathinner"],
  props: {
    numArgs: 1,
    primitive: true
  },
  handler(_ref, args) {
    var {
      parser: parser2,
      funcName
    } = _ref;
    var body = args[0];
    return {
      type: "mclass",
      mode: parser2.mode,
      mclass: "m" + funcName.slice(5),
      // TODO(kevinb): don't prefix with 'm'
      body: ordargument(body),
      isCharacterBox: utils.isCharacterBox(body)
    };
  },
  htmlBuilder: htmlBuilder$9,
  mathmlBuilder: mathmlBuilder$8
});
var binrelClass = (arg) => {
  var atom = arg.type === "ordgroup" && arg.body.length ? arg.body[0] : arg;
  if (atom.type === "atom" && (atom.family === "bin" || atom.family === "rel")) {
    return "m" + atom.family;
  } else {
    return "mord";
  }
};
defineFunction({
  type: "mclass",
  names: ["\\@binrel"],
  props: {
    numArgs: 2
  },
  handler(_ref2, args) {
    var {
      parser: parser2
    } = _ref2;
    return {
      type: "mclass",
      mode: parser2.mode,
      mclass: binrelClass(args[0]),
      body: ordargument(args[1]),
      isCharacterBox: utils.isCharacterBox(args[1])
    };
  }
});
defineFunction({
  type: "mclass",
  names: ["\\stackrel", "\\overset", "\\underset"],
  props: {
    numArgs: 2
  },
  handler(_ref3, args) {
    var {
      parser: parser2,
      funcName
    } = _ref3;
    var baseArg = args[1];
    var shiftedArg = args[0];
    var mclass;
    if (funcName !== "\\stackrel") {
      mclass = binrelClass(baseArg);
    } else {
      mclass = "mrel";
    }
    var baseOp = {
      type: "op",
      mode: baseArg.mode,
      limits: true,
      alwaysHandleSupSub: true,
      parentIsSupSub: false,
      symbol: false,
      suppressBaseShift: funcName !== "\\stackrel",
      body: ordargument(baseArg)
    };
    var supsub = {
      type: "supsub",
      mode: shiftedArg.mode,
      base: baseOp,
      sup: funcName === "\\underset" ? null : shiftedArg,
      sub: funcName === "\\underset" ? shiftedArg : null
    };
    return {
      type: "mclass",
      mode: parser2.mode,
      mclass,
      body: [supsub],
      isCharacterBox: utils.isCharacterBox(supsub)
    };
  },
  htmlBuilder: htmlBuilder$9,
  mathmlBuilder: mathmlBuilder$8
});
defineFunction({
  type: "pmb",
  names: ["\\pmb"],
  props: {
    numArgs: 1,
    allowedInText: true
  },
  handler(_ref, args) {
    var {
      parser: parser2
    } = _ref;
    return {
      type: "pmb",
      mode: parser2.mode,
      mclass: binrelClass(args[0]),
      body: ordargument(args[0])
    };
  },
  htmlBuilder(group, options) {
    var elements3 = buildExpression$1(group.body, options, true);
    var node3 = buildCommon.makeSpan([group.mclass], elements3, options);
    node3.style.textShadow = "0.02em 0.01em 0.04px";
    return node3;
  },
  mathmlBuilder(group, style) {
    var inner2 = buildExpression2(group.body, style);
    var node3 = new mathMLTree.MathNode("mstyle", inner2);
    node3.setAttribute("style", "text-shadow: 0.02em 0.01em 0.04px");
    return node3;
  }
});
var cdArrowFunctionName = {
  ">": "\\\\cdrightarrow",
  "<": "\\\\cdleftarrow",
  "=": "\\\\cdlongequal",
  "A": "\\uparrow",
  "V": "\\downarrow",
  "|": "\\Vert",
  ".": "no arrow"
};
var newCell = () => {
  return {
    type: "styling",
    body: [],
    mode: "math",
    style: "display"
  };
};
var isStartOfArrow = (node3) => {
  return node3.type === "textord" && node3.text === "@";
};
var isLabelEnd = (node3, endChar) => {
  return (node3.type === "mathord" || node3.type === "atom") && node3.text === endChar;
};
function cdArrow(arrowChar, labels, parser2) {
  var funcName = cdArrowFunctionName[arrowChar];
  switch (funcName) {
    case "\\\\cdrightarrow":
    case "\\\\cdleftarrow":
      return parser2.callFunction(funcName, [labels[0]], [labels[1]]);
    case "\\uparrow":
    case "\\downarrow": {
      var leftLabel = parser2.callFunction("\\\\cdleft", [labels[0]], []);
      var bareArrow = {
        type: "atom",
        text: funcName,
        mode: "math",
        family: "rel"
      };
      var sizedArrow = parser2.callFunction("\\Big", [bareArrow], []);
      var rightLabel = parser2.callFunction("\\\\cdright", [labels[1]], []);
      var arrowGroup = {
        type: "ordgroup",
        mode: "math",
        body: [leftLabel, sizedArrow, rightLabel]
      };
      return parser2.callFunction("\\\\cdparent", [arrowGroup], []);
    }
    case "\\\\cdlongequal":
      return parser2.callFunction("\\\\cdlongequal", [], []);
    case "\\Vert": {
      var arrow = {
        type: "textord",
        text: "\\Vert",
        mode: "math"
      };
      return parser2.callFunction("\\Big", [arrow], []);
    }
    default:
      return {
        type: "textord",
        text: " ",
        mode: "math"
      };
  }
}
function parseCD(parser2) {
  var parsedRows = [];
  parser2.gullet.beginGroup();
  parser2.gullet.macros.set("\\cr", "\\\\\\relax");
  parser2.gullet.beginGroup();
  while (true) {
    parsedRows.push(parser2.parseExpression(false, "\\\\"));
    parser2.gullet.endGroup();
    parser2.gullet.beginGroup();
    var next2 = parser2.fetch().text;
    if (next2 === "&" || next2 === "\\\\") {
      parser2.consume();
    } else if (next2 === "\\end") {
      if (parsedRows[parsedRows.length - 1].length === 0) {
        parsedRows.pop();
      }
      break;
    } else {
      throw new ParseError("Expected \\\\ or \\cr or \\end", parser2.nextToken);
    }
  }
  var row = [];
  var body = [row];
  for (var i2 = 0; i2 < parsedRows.length; i2++) {
    var rowNodes = parsedRows[i2];
    var cell = newCell();
    for (var j = 0; j < rowNodes.length; j++) {
      if (!isStartOfArrow(rowNodes[j])) {
        cell.body.push(rowNodes[j]);
      } else {
        row.push(cell);
        j += 1;
        var arrowChar = assertSymbolNodeType(rowNodes[j]).text;
        var labels = new Array(2);
        labels[0] = {
          type: "ordgroup",
          mode: "math",
          body: []
        };
        labels[1] = {
          type: "ordgroup",
          mode: "math",
          body: []
        };
        if ("=|.".indexOf(arrowChar) > -1)
          ;
        else if ("<>AV".indexOf(arrowChar) > -1) {
          for (var labelNum = 0; labelNum < 2; labelNum++) {
            var inLabel = true;
            for (var k = j + 1; k < rowNodes.length; k++) {
              if (isLabelEnd(rowNodes[k], arrowChar)) {
                inLabel = false;
                j = k;
                break;
              }
              if (isStartOfArrow(rowNodes[k])) {
                throw new ParseError("Missing a " + arrowChar + " character to complete a CD arrow.", rowNodes[k]);
              }
              labels[labelNum].body.push(rowNodes[k]);
            }
            if (inLabel) {
              throw new ParseError("Missing a " + arrowChar + " character to complete a CD arrow.", rowNodes[j]);
            }
          }
        } else {
          throw new ParseError('Expected one of "<>AV=|." after @', rowNodes[j]);
        }
        var arrow = cdArrow(arrowChar, labels, parser2);
        var wrappedArrow = {
          type: "styling",
          body: [arrow],
          mode: "math",
          style: "display"
          // CD is always displaystyle.
        };
        row.push(wrappedArrow);
        cell = newCell();
      }
    }
    if (i2 % 2 === 0) {
      row.push(cell);
    } else {
      row.shift();
    }
    row = [];
    body.push(row);
  }
  parser2.gullet.endGroup();
  parser2.gullet.endGroup();
  var cols = new Array(body[0].length).fill({
    type: "align",
    align: "c",
    pregap: 0.25,
    // CD package sets \enskip between columns.
    postgap: 0.25
    // So pre and post each get half an \enskip, i.e. 0.25em.
  });
  return {
    type: "array",
    mode: "math",
    body,
    arraystretch: 1,
    addJot: true,
    rowGaps: [null],
    cols,
    colSeparationType: "CD",
    hLinesBeforeRow: new Array(body.length + 1).fill([])
  };
}
defineFunction({
  type: "cdlabel",
  names: ["\\\\cdleft", "\\\\cdright"],
  props: {
    numArgs: 1
  },
  handler(_ref, args) {
    var {
      parser: parser2,
      funcName
    } = _ref;
    return {
      type: "cdlabel",
      mode: parser2.mode,
      side: funcName.slice(4),
      label: args[0]
    };
  },
  htmlBuilder(group, options) {
    var newOptions = options.havingStyle(options.style.sup());
    var label = buildCommon.wrapFragment(buildGroup$1(group.label, newOptions, options), options);
    label.classes.push("cd-label-" + group.side);
    label.style.bottom = makeEm(0.8 - label.depth);
    label.height = 0;
    label.depth = 0;
    return label;
  },
  mathmlBuilder(group, options) {
    var label = new mathMLTree.MathNode("mrow", [buildGroup2(group.label, options)]);
    label = new mathMLTree.MathNode("mpadded", [label]);
    label.setAttribute("width", "0");
    if (group.side === "left") {
      label.setAttribute("lspace", "-1width");
    }
    label.setAttribute("voffset", "0.7em");
    label = new mathMLTree.MathNode("mstyle", [label]);
    label.setAttribute("displaystyle", "false");
    label.setAttribute("scriptlevel", "1");
    return label;
  }
});
defineFunction({
  type: "cdlabelparent",
  names: ["\\\\cdparent"],
  props: {
    numArgs: 1
  },
  handler(_ref2, args) {
    var {
      parser: parser2
    } = _ref2;
    return {
      type: "cdlabelparent",
      mode: parser2.mode,
      fragment: args[0]
    };
  },
  htmlBuilder(group, options) {
    var parent = buildCommon.wrapFragment(buildGroup$1(group.fragment, options), options);
    parent.classes.push("cd-vert-arrow");
    return parent;
  },
  mathmlBuilder(group, options) {
    return new mathMLTree.MathNode("mrow", [buildGroup2(group.fragment, options)]);
  }
});
defineFunction({
  type: "textord",
  names: ["\\@char"],
  props: {
    numArgs: 1,
    allowedInText: true
  },
  handler(_ref, args) {
    var {
      parser: parser2
    } = _ref;
    var arg = assertNodeType(args[0], "ordgroup");
    var group = arg.body;
    var number = "";
    for (var i2 = 0; i2 < group.length; i2++) {
      var node3 = assertNodeType(group[i2], "textord");
      number += node3.text;
    }
    var code = parseInt(number);
    var text4;
    if (isNaN(code)) {
      throw new ParseError("\\@char has non-numeric argument " + number);
    } else if (code < 0 || code >= 1114111) {
      throw new ParseError("\\@char with invalid code point " + number);
    } else if (code <= 65535) {
      text4 = String.fromCharCode(code);
    } else {
      code -= 65536;
      text4 = String.fromCharCode((code >> 10) + 55296, (code & 1023) + 56320);
    }
    return {
      type: "textord",
      mode: parser2.mode,
      text: text4
    };
  }
});
var htmlBuilder$8 = (group, options) => {
  var elements3 = buildExpression$1(group.body, options.withColor(group.color), false);
  return buildCommon.makeFragment(elements3);
};
var mathmlBuilder$7 = (group, options) => {
  var inner2 = buildExpression2(group.body, options.withColor(group.color));
  var node3 = new mathMLTree.MathNode("mstyle", inner2);
  node3.setAttribute("mathcolor", group.color);
  return node3;
};
defineFunction({
  type: "color",
  names: ["\\textcolor"],
  props: {
    numArgs: 2,
    allowedInText: true,
    argTypes: ["color", "original"]
  },
  handler(_ref, args) {
    var {
      parser: parser2
    } = _ref;
    var color = assertNodeType(args[0], "color-token").color;
    var body = args[1];
    return {
      type: "color",
      mode: parser2.mode,
      color,
      body: ordargument(body)
    };
  },
  htmlBuilder: htmlBuilder$8,
  mathmlBuilder: mathmlBuilder$7
});
defineFunction({
  type: "color",
  names: ["\\color"],
  props: {
    numArgs: 1,
    allowedInText: true,
    argTypes: ["color"]
  },
  handler(_ref2, args) {
    var {
      parser: parser2,
      breakOnTokenText
    } = _ref2;
    var color = assertNodeType(args[0], "color-token").color;
    parser2.gullet.macros.set("\\current@color", color);
    var body = parser2.parseExpression(true, breakOnTokenText);
    return {
      type: "color",
      mode: parser2.mode,
      color,
      body
    };
  },
  htmlBuilder: htmlBuilder$8,
  mathmlBuilder: mathmlBuilder$7
});
defineFunction({
  type: "cr",
  names: ["\\\\"],
  props: {
    numArgs: 0,
    numOptionalArgs: 0,
    allowedInText: true
  },
  handler(_ref, args, optArgs) {
    var {
      parser: parser2
    } = _ref;
    var size2 = parser2.gullet.future().text === "[" ? parser2.parseSizeGroup(true) : null;
    var newLine = !parser2.settings.displayMode || !parser2.settings.useStrictBehavior("newLineInDisplayMode", "In LaTeX, \\\\ or \\newline does nothing in display mode");
    return {
      type: "cr",
      mode: parser2.mode,
      newLine,
      size: size2 && assertNodeType(size2, "size").value
    };
  },
  // The following builders are called only at the top level,
  // not within tabular/array environments.
  htmlBuilder(group, options) {
    var span = buildCommon.makeSpan(["mspace"], [], options);
    if (group.newLine) {
      span.classes.push("newline");
      if (group.size) {
        span.style.marginTop = makeEm(calculateSize(group.size, options));
      }
    }
    return span;
  },
  mathmlBuilder(group, options) {
    var node3 = new mathMLTree.MathNode("mspace");
    if (group.newLine) {
      node3.setAttribute("linebreak", "newline");
      if (group.size) {
        node3.setAttribute("height", makeEm(calculateSize(group.size, options)));
      }
    }
    return node3;
  }
});
var globalMap = {
  "\\global": "\\global",
  "\\long": "\\\\globallong",
  "\\\\globallong": "\\\\globallong",
  "\\def": "\\gdef",
  "\\gdef": "\\gdef",
  "\\edef": "\\xdef",
  "\\xdef": "\\xdef",
  "\\let": "\\\\globallet",
  "\\futurelet": "\\\\globalfuture"
};
var checkControlSequence = (tok) => {
  var name = tok.text;
  if (/^(?:[\\{}$&#^_]|EOF)$/.test(name)) {
    throw new ParseError("Expected a control sequence", tok);
  }
  return name;
};
var getRHS = (parser2) => {
  var tok = parser2.gullet.popToken();
  if (tok.text === "=") {
    tok = parser2.gullet.popToken();
    if (tok.text === " ") {
      tok = parser2.gullet.popToken();
    }
  }
  return tok;
};
var letCommand = (parser2, name, tok, global2) => {
  var macro = parser2.gullet.macros.get(tok.text);
  if (macro == null) {
    tok.noexpand = true;
    macro = {
      tokens: [tok],
      numArgs: 0,
      // reproduce the same behavior in expansion
      unexpandable: !parser2.gullet.isExpandable(tok.text)
    };
  }
  parser2.gullet.macros.set(name, macro, global2);
};
defineFunction({
  type: "internal",
  names: [
    "\\global",
    "\\long",
    "\\\\globallong"
    // can’t be entered directly
  ],
  props: {
    numArgs: 0,
    allowedInText: true
  },
  handler(_ref) {
    var {
      parser: parser2,
      funcName
    } = _ref;
    parser2.consumeSpaces();
    var token = parser2.fetch();
    if (globalMap[token.text]) {
      if (funcName === "\\global" || funcName === "\\\\globallong") {
        token.text = globalMap[token.text];
      }
      return assertNodeType(parser2.parseFunction(), "internal");
    }
    throw new ParseError("Invalid token after macro prefix", token);
  }
});
defineFunction({
  type: "internal",
  names: ["\\def", "\\gdef", "\\edef", "\\xdef"],
  props: {
    numArgs: 0,
    allowedInText: true,
    primitive: true
  },
  handler(_ref2) {
    var {
      parser: parser2,
      funcName
    } = _ref2;
    var tok = parser2.gullet.popToken();
    var name = tok.text;
    if (/^(?:[\\{}$&#^_]|EOF)$/.test(name)) {
      throw new ParseError("Expected a control sequence", tok);
    }
    var numArgs = 0;
    var insert;
    var delimiters2 = [[]];
    while (parser2.gullet.future().text !== "{") {
      tok = parser2.gullet.popToken();
      if (tok.text === "#") {
        if (parser2.gullet.future().text === "{") {
          insert = parser2.gullet.future();
          delimiters2[numArgs].push("{");
          break;
        }
        tok = parser2.gullet.popToken();
        if (!/^[1-9]$/.test(tok.text)) {
          throw new ParseError('Invalid argument number "' + tok.text + '"');
        }
        if (parseInt(tok.text) !== numArgs + 1) {
          throw new ParseError('Argument number "' + tok.text + '" out of order');
        }
        numArgs++;
        delimiters2.push([]);
      } else if (tok.text === "EOF") {
        throw new ParseError("Expected a macro definition");
      } else {
        delimiters2[numArgs].push(tok.text);
      }
    }
    var {
      tokens
    } = parser2.gullet.consumeArg();
    if (insert) {
      tokens.unshift(insert);
    }
    if (funcName === "\\edef" || funcName === "\\xdef") {
      tokens = parser2.gullet.expandTokens(tokens);
      tokens.reverse();
    }
    parser2.gullet.macros.set(name, {
      tokens,
      numArgs,
      delimiters: delimiters2
    }, funcName === globalMap[funcName]);
    return {
      type: "internal",
      mode: parser2.mode
    };
  }
});
defineFunction({
  type: "internal",
  names: [
    "\\let",
    "\\\\globallet"
    // can’t be entered directly
  ],
  props: {
    numArgs: 0,
    allowedInText: true,
    primitive: true
  },
  handler(_ref3) {
    var {
      parser: parser2,
      funcName
    } = _ref3;
    var name = checkControlSequence(parser2.gullet.popToken());
    parser2.gullet.consumeSpaces();
    var tok = getRHS(parser2);
    letCommand(parser2, name, tok, funcName === "\\\\globallet");
    return {
      type: "internal",
      mode: parser2.mode
    };
  }
});
defineFunction({
  type: "internal",
  names: [
    "\\futurelet",
    "\\\\globalfuture"
    // can’t be entered directly
  ],
  props: {
    numArgs: 0,
    allowedInText: true,
    primitive: true
  },
  handler(_ref4) {
    var {
      parser: parser2,
      funcName
    } = _ref4;
    var name = checkControlSequence(parser2.gullet.popToken());
    var middle = parser2.gullet.popToken();
    var tok = parser2.gullet.popToken();
    letCommand(parser2, name, tok, funcName === "\\\\globalfuture");
    parser2.gullet.pushToken(tok);
    parser2.gullet.pushToken(middle);
    return {
      type: "internal",
      mode: parser2.mode
    };
  }
});
var getMetrics = function getMetrics2(symbol, font, mode) {
  var replace = symbols.math[symbol] && symbols.math[symbol].replace;
  var metrics = getCharacterMetrics(replace || symbol, font, mode);
  if (!metrics) {
    throw new Error("Unsupported symbol " + symbol + " and font size " + font + ".");
  }
  return metrics;
};
var styleWrap = function styleWrap2(delim, toStyle, options, classes2) {
  var newOptions = options.havingBaseStyle(toStyle);
  var span = buildCommon.makeSpan(classes2.concat(newOptions.sizingClasses(options)), [delim], options);
  var delimSizeMultiplier = newOptions.sizeMultiplier / options.sizeMultiplier;
  span.height *= delimSizeMultiplier;
  span.depth *= delimSizeMultiplier;
  span.maxFontSize = newOptions.sizeMultiplier;
  return span;
};
var centerSpan = function centerSpan2(span, options, style) {
  var newOptions = options.havingBaseStyle(style);
  var shift = (1 - options.sizeMultiplier / newOptions.sizeMultiplier) * options.fontMetrics().axisHeight;
  span.classes.push("delimcenter");
  span.style.top = makeEm(shift);
  span.height -= shift;
  span.depth += shift;
};
var makeSmallDelim = function makeSmallDelim2(delim, style, center2, options, mode, classes2) {
  var text4 = buildCommon.makeSymbol(delim, "Main-Regular", mode, options);
  var span = styleWrap(text4, style, options, classes2);
  if (center2) {
    centerSpan(span, options, style);
  }
  return span;
};
var mathrmSize = function mathrmSize2(value, size2, mode, options) {
  return buildCommon.makeSymbol(value, "Size" + size2 + "-Regular", mode, options);
};
var makeLargeDelim = function makeLargeDelim2(delim, size2, center2, options, mode, classes2) {
  var inner2 = mathrmSize(delim, size2, mode, options);
  var span = styleWrap(buildCommon.makeSpan(["delimsizing", "size" + size2], [inner2], options), Style$1.TEXT, options, classes2);
  if (center2) {
    centerSpan(span, options, Style$1.TEXT);
  }
  return span;
};
var makeGlyphSpan = function makeGlyphSpan2(symbol, font, mode) {
  var sizeClass;
  if (font === "Size1-Regular") {
    sizeClass = "delim-size1";
  } else {
    sizeClass = "delim-size4";
  }
  var corner = buildCommon.makeSpan(["delimsizinginner", sizeClass], [buildCommon.makeSpan([], [buildCommon.makeSymbol(symbol, font, mode)])]);
  return {
    type: "elem",
    elem: corner
  };
};
var makeInner = function makeInner2(ch, height2, options) {
  var width2 = fontMetricsData["Size4-Regular"][ch.charCodeAt(0)] ? fontMetricsData["Size4-Regular"][ch.charCodeAt(0)][4] : fontMetricsData["Size1-Regular"][ch.charCodeAt(0)][4];
  var path2 = new PathNode("inner", innerPath(ch, Math.round(1e3 * height2)));
  var svgNode = new SvgNode([path2], {
    "width": makeEm(width2),
    "height": makeEm(height2),
    // Override CSS rule `.katex svg { width: 100% }`
    "style": "width:" + makeEm(width2),
    "viewBox": "0 0 " + 1e3 * width2 + " " + Math.round(1e3 * height2),
    "preserveAspectRatio": "xMinYMin"
  });
  var span = buildCommon.makeSvgSpan([], [svgNode], options);
  span.height = height2;
  span.style.height = makeEm(height2);
  span.style.width = makeEm(width2);
  return {
    type: "elem",
    elem: span
  };
};
var lapInEms = 8e-3;
var lap = {
  type: "kern",
  size: -1 * lapInEms
};
var verts = ["|", "\\lvert", "\\rvert", "\\vert"];
var doubleVerts = ["\\|", "\\lVert", "\\rVert", "\\Vert"];
var makeStackedDelim = function makeStackedDelim2(delim, heightTotal, center2, options, mode, classes2) {
  var top;
  var middle;
  var repeat2;
  var bottom;
  var svgLabel = "";
  var viewBoxWidth = 0;
  top = repeat2 = bottom = delim;
  middle = null;
  var font = "Size1-Regular";
  if (delim === "\\uparrow") {
    repeat2 = bottom = "\u23D0";
  } else if (delim === "\\Uparrow") {
    repeat2 = bottom = "\u2016";
  } else if (delim === "\\downarrow") {
    top = repeat2 = "\u23D0";
  } else if (delim === "\\Downarrow") {
    top = repeat2 = "\u2016";
  } else if (delim === "\\updownarrow") {
    top = "\\uparrow";
    repeat2 = "\u23D0";
    bottom = "\\downarrow";
  } else if (delim === "\\Updownarrow") {
    top = "\\Uparrow";
    repeat2 = "\u2016";
    bottom = "\\Downarrow";
  } else if (utils.contains(verts, delim)) {
    repeat2 = "\u2223";
    svgLabel = "vert";
    viewBoxWidth = 333;
  } else if (utils.contains(doubleVerts, delim)) {
    repeat2 = "\u2225";
    svgLabel = "doublevert";
    viewBoxWidth = 556;
  } else if (delim === "[" || delim === "\\lbrack") {
    top = "\u23A1";
    repeat2 = "\u23A2";
    bottom = "\u23A3";
    font = "Size4-Regular";
    svgLabel = "lbrack";
    viewBoxWidth = 667;
  } else if (delim === "]" || delim === "\\rbrack") {
    top = "\u23A4";
    repeat2 = "\u23A5";
    bottom = "\u23A6";
    font = "Size4-Regular";
    svgLabel = "rbrack";
    viewBoxWidth = 667;
  } else if (delim === "\\lfloor" || delim === "\u230A") {
    repeat2 = top = "\u23A2";
    bottom = "\u23A3";
    font = "Size4-Regular";
    svgLabel = "lfloor";
    viewBoxWidth = 667;
  } else if (delim === "\\lceil" || delim === "\u2308") {
    top = "\u23A1";
    repeat2 = bottom = "\u23A2";
    font = "Size4-Regular";
    svgLabel = "lceil";
    viewBoxWidth = 667;
  } else if (delim === "\\rfloor" || delim === "\u230B") {
    repeat2 = top = "\u23A5";
    bottom = "\u23A6";
    font = "Size4-Regular";
    svgLabel = "rfloor";
    viewBoxWidth = 667;
  } else if (delim === "\\rceil" || delim === "\u2309") {
    top = "\u23A4";
    repeat2 = bottom = "\u23A5";
    font = "Size4-Regular";
    svgLabel = "rceil";
    viewBoxWidth = 667;
  } else if (delim === "(" || delim === "\\lparen") {
    top = "\u239B";
    repeat2 = "\u239C";
    bottom = "\u239D";
    font = "Size4-Regular";
    svgLabel = "lparen";
    viewBoxWidth = 875;
  } else if (delim === ")" || delim === "\\rparen") {
    top = "\u239E";
    repeat2 = "\u239F";
    bottom = "\u23A0";
    font = "Size4-Regular";
    svgLabel = "rparen";
    viewBoxWidth = 875;
  } else if (delim === "\\{" || delim === "\\lbrace") {
    top = "\u23A7";
    middle = "\u23A8";
    bottom = "\u23A9";
    repeat2 = "\u23AA";
    font = "Size4-Regular";
  } else if (delim === "\\}" || delim === "\\rbrace") {
    top = "\u23AB";
    middle = "\u23AC";
    bottom = "\u23AD";
    repeat2 = "\u23AA";
    font = "Size4-Regular";
  } else if (delim === "\\lgroup" || delim === "\u27EE") {
    top = "\u23A7";
    bottom = "\u23A9";
    repeat2 = "\u23AA";
    font = "Size4-Regular";
  } else if (delim === "\\rgroup" || delim === "\u27EF") {
    top = "\u23AB";
    bottom = "\u23AD";
    repeat2 = "\u23AA";
    font = "Size4-Regular";
  } else if (delim === "\\lmoustache" || delim === "\u23B0") {
    top = "\u23A7";
    bottom = "\u23AD";
    repeat2 = "\u23AA";
    font = "Size4-Regular";
  } else if (delim === "\\rmoustache" || delim === "\u23B1") {
    top = "\u23AB";
    bottom = "\u23A9";
    repeat2 = "\u23AA";
    font = "Size4-Regular";
  }
  var topMetrics = getMetrics(top, font, mode);
  var topHeightTotal = topMetrics.height + topMetrics.depth;
  var repeatMetrics = getMetrics(repeat2, font, mode);
  var repeatHeightTotal = repeatMetrics.height + repeatMetrics.depth;
  var bottomMetrics = getMetrics(bottom, font, mode);
  var bottomHeightTotal = bottomMetrics.height + bottomMetrics.depth;
  var middleHeightTotal = 0;
  var middleFactor = 1;
  if (middle !== null) {
    var middleMetrics = getMetrics(middle, font, mode);
    middleHeightTotal = middleMetrics.height + middleMetrics.depth;
    middleFactor = 2;
  }
  var minHeight = topHeightTotal + bottomHeightTotal + middleHeightTotal;
  var repeatCount = Math.max(0, Math.ceil((heightTotal - minHeight) / (middleFactor * repeatHeightTotal)));
  var realHeightTotal = minHeight + repeatCount * middleFactor * repeatHeightTotal;
  var axisHeight = options.fontMetrics().axisHeight;
  if (center2) {
    axisHeight *= options.sizeMultiplier;
  }
  var depth = realHeightTotal / 2 - axisHeight;
  var stack = [];
  if (svgLabel.length > 0) {
    var midHeight = realHeightTotal - topHeightTotal - bottomHeightTotal;
    var viewBoxHeight = Math.round(realHeightTotal * 1e3);
    var pathStr = tallDelim(svgLabel, Math.round(midHeight * 1e3));
    var path2 = new PathNode(svgLabel, pathStr);
    var width2 = (viewBoxWidth / 1e3).toFixed(3) + "em";
    var height2 = (viewBoxHeight / 1e3).toFixed(3) + "em";
    var svg2 = new SvgNode([path2], {
      "width": width2,
      "height": height2,
      "viewBox": "0 0 " + viewBoxWidth + " " + viewBoxHeight
    });
    var wrapper = buildCommon.makeSvgSpan([], [svg2], options);
    wrapper.height = viewBoxHeight / 1e3;
    wrapper.style.width = width2;
    wrapper.style.height = height2;
    stack.push({
      type: "elem",
      elem: wrapper
    });
  } else {
    stack.push(makeGlyphSpan(bottom, font, mode));
    stack.push(lap);
    if (middle === null) {
      var innerHeight = realHeightTotal - topHeightTotal - bottomHeightTotal + 2 * lapInEms;
      stack.push(makeInner(repeat2, innerHeight, options));
    } else {
      var _innerHeight = (realHeightTotal - topHeightTotal - bottomHeightTotal - middleHeightTotal) / 2 + 2 * lapInEms;
      stack.push(makeInner(repeat2, _innerHeight, options));
      stack.push(lap);
      stack.push(makeGlyphSpan(middle, font, mode));
      stack.push(lap);
      stack.push(makeInner(repeat2, _innerHeight, options));
    }
    stack.push(lap);
    stack.push(makeGlyphSpan(top, font, mode));
  }
  var newOptions = options.havingBaseStyle(Style$1.TEXT);
  var inner2 = buildCommon.makeVList({
    positionType: "bottom",
    positionData: depth,
    children: stack
  }, newOptions);
  return styleWrap(buildCommon.makeSpan(["delimsizing", "mult"], [inner2], newOptions), Style$1.TEXT, options, classes2);
};
var vbPad = 80;
var emPad = 0.08;
var sqrtSvg = function sqrtSvg2(sqrtName, height2, viewBoxHeight, extraVinculum, options) {
  var path2 = sqrtPath(sqrtName, extraVinculum, viewBoxHeight);
  var pathNode = new PathNode(sqrtName, path2);
  var svg2 = new SvgNode([pathNode], {
    // Note: 1000:1 ratio of viewBox to document em width.
    "width": "400em",
    "height": makeEm(height2),
    "viewBox": "0 0 400000 " + viewBoxHeight,
    "preserveAspectRatio": "xMinYMin slice"
  });
  return buildCommon.makeSvgSpan(["hide-tail"], [svg2], options);
};
var makeSqrtImage = function makeSqrtImage2(height2, options) {
  var newOptions = options.havingBaseSizing();
  var delim = traverseSequence("\\surd", height2 * newOptions.sizeMultiplier, stackLargeDelimiterSequence, newOptions);
  var sizeMultiplier = newOptions.sizeMultiplier;
  var extraVinculum = Math.max(0, options.minRuleThickness - options.fontMetrics().sqrtRuleThickness);
  var span;
  var spanHeight = 0;
  var texHeight = 0;
  var viewBoxHeight = 0;
  var advanceWidth;
  if (delim.type === "small") {
    viewBoxHeight = 1e3 + 1e3 * extraVinculum + vbPad;
    if (height2 < 1) {
      sizeMultiplier = 1;
    } else if (height2 < 1.4) {
      sizeMultiplier = 0.7;
    }
    spanHeight = (1 + extraVinculum + emPad) / sizeMultiplier;
    texHeight = (1 + extraVinculum) / sizeMultiplier;
    span = sqrtSvg("sqrtMain", spanHeight, viewBoxHeight, extraVinculum, options);
    span.style.minWidth = "0.853em";
    advanceWidth = 0.833 / sizeMultiplier;
  } else if (delim.type === "large") {
    viewBoxHeight = (1e3 + vbPad) * sizeToMaxHeight[delim.size];
    texHeight = (sizeToMaxHeight[delim.size] + extraVinculum) / sizeMultiplier;
    spanHeight = (sizeToMaxHeight[delim.size] + extraVinculum + emPad) / sizeMultiplier;
    span = sqrtSvg("sqrtSize" + delim.size, spanHeight, viewBoxHeight, extraVinculum, options);
    span.style.minWidth = "1.02em";
    advanceWidth = 1 / sizeMultiplier;
  } else {
    spanHeight = height2 + extraVinculum + emPad;
    texHeight = height2 + extraVinculum;
    viewBoxHeight = Math.floor(1e3 * height2 + extraVinculum) + vbPad;
    span = sqrtSvg("sqrtTall", spanHeight, viewBoxHeight, extraVinculum, options);
    span.style.minWidth = "0.742em";
    advanceWidth = 1.056;
  }
  span.height = texHeight;
  span.style.height = makeEm(spanHeight);
  return {
    span,
    advanceWidth,
    // Calculate the actual line width.
    // This actually should depend on the chosen font -- e.g. \boldmath
    // should use the thicker surd symbols from e.g. KaTeX_Main-Bold, and
    // have thicker rules.
    ruleWidth: (options.fontMetrics().sqrtRuleThickness + extraVinculum) * sizeMultiplier
  };
};
var stackLargeDelimiters = ["(", "\\lparen", ")", "\\rparen", "[", "\\lbrack", "]", "\\rbrack", "\\{", "\\lbrace", "\\}", "\\rbrace", "\\lfloor", "\\rfloor", "\u230A", "\u230B", "\\lceil", "\\rceil", "\u2308", "\u2309", "\\surd"];
var stackAlwaysDelimiters = ["\\uparrow", "\\downarrow", "\\updownarrow", "\\Uparrow", "\\Downarrow", "\\Updownarrow", "|", "\\|", "\\vert", "\\Vert", "\\lvert", "\\rvert", "\\lVert", "\\rVert", "\\lgroup", "\\rgroup", "\u27EE", "\u27EF", "\\lmoustache", "\\rmoustache", "\u23B0", "\u23B1"];
var stackNeverDelimiters = ["<", ">", "\\langle", "\\rangle", "/", "\\backslash", "\\lt", "\\gt"];
var sizeToMaxHeight = [0, 1.2, 1.8, 2.4, 3];
var makeSizedDelim = function makeSizedDelim2(delim, size2, options, mode, classes2) {
  if (delim === "<" || delim === "\\lt" || delim === "\u27E8") {
    delim = "\\langle";
  } else if (delim === ">" || delim === "\\gt" || delim === "\u27E9") {
    delim = "\\rangle";
  }
  if (utils.contains(stackLargeDelimiters, delim) || utils.contains(stackNeverDelimiters, delim)) {
    return makeLargeDelim(delim, size2, false, options, mode, classes2);
  } else if (utils.contains(stackAlwaysDelimiters, delim)) {
    return makeStackedDelim(delim, sizeToMaxHeight[size2], false, options, mode, classes2);
  } else {
    throw new ParseError("Illegal delimiter: '" + delim + "'");
  }
};
var stackNeverDelimiterSequence = [{
  type: "small",
  style: Style$1.SCRIPTSCRIPT
}, {
  type: "small",
  style: Style$1.SCRIPT
}, {
  type: "small",
  style: Style$1.TEXT
}, {
  type: "large",
  size: 1
}, {
  type: "large",
  size: 2
}, {
  type: "large",
  size: 3
}, {
  type: "large",
  size: 4
}];
var stackAlwaysDelimiterSequence = [{
  type: "small",
  style: Style$1.SCRIPTSCRIPT
}, {
  type: "small",
  style: Style$1.SCRIPT
}, {
  type: "small",
  style: Style$1.TEXT
}, {
  type: "stack"
}];
var stackLargeDelimiterSequence = [{
  type: "small",
  style: Style$1.SCRIPTSCRIPT
}, {
  type: "small",
  style: Style$1.SCRIPT
}, {
  type: "small",
  style: Style$1.TEXT
}, {
  type: "large",
  size: 1
}, {
  type: "large",
  size: 2
}, {
  type: "large",
  size: 3
}, {
  type: "large",
  size: 4
}, {
  type: "stack"
}];
var delimTypeToFont = function delimTypeToFont2(type) {
  if (type.type === "small") {
    return "Main-Regular";
  } else if (type.type === "large") {
    return "Size" + type.size + "-Regular";
  } else if (type.type === "stack") {
    return "Size4-Regular";
  } else {
    throw new Error("Add support for delim type '" + type.type + "' here.");
  }
};
var traverseSequence = function traverseSequence2(delim, height2, sequence, options) {
  var start = Math.min(2, 3 - options.style.size);
  for (var i2 = start; i2 < sequence.length; i2++) {
    if (sequence[i2].type === "stack") {
      break;
    }
    var metrics = getMetrics(delim, delimTypeToFont(sequence[i2]), "math");
    var heightDepth = metrics.height + metrics.depth;
    if (sequence[i2].type === "small") {
      var newOptions = options.havingBaseStyle(sequence[i2].style);
      heightDepth *= newOptions.sizeMultiplier;
    }
    if (heightDepth > height2) {
      return sequence[i2];
    }
  }
  return sequence[sequence.length - 1];
};
var makeCustomSizedDelim = function makeCustomSizedDelim2(delim, height2, center2, options, mode, classes2) {
  if (delim === "<" || delim === "\\lt" || delim === "\u27E8") {
    delim = "\\langle";
  } else if (delim === ">" || delim === "\\gt" || delim === "\u27E9") {
    delim = "\\rangle";
  }
  var sequence;
  if (utils.contains(stackNeverDelimiters, delim)) {
    sequence = stackNeverDelimiterSequence;
  } else if (utils.contains(stackLargeDelimiters, delim)) {
    sequence = stackLargeDelimiterSequence;
  } else {
    sequence = stackAlwaysDelimiterSequence;
  }
  var delimType = traverseSequence(delim, height2, sequence, options);
  if (delimType.type === "small") {
    return makeSmallDelim(delim, delimType.style, center2, options, mode, classes2);
  } else if (delimType.type === "large") {
    return makeLargeDelim(delim, delimType.size, center2, options, mode, classes2);
  } else {
    return makeStackedDelim(delim, height2, center2, options, mode, classes2);
  }
};
var makeLeftRightDelim = function makeLeftRightDelim2(delim, height2, depth, options, mode, classes2) {
  var axisHeight = options.fontMetrics().axisHeight * options.sizeMultiplier;
  var delimiterFactor = 901;
  var delimiterExtend = 5 / options.fontMetrics().ptPerEm;
  var maxDistFromAxis = Math.max(height2 - axisHeight, depth + axisHeight);
  var totalHeight = Math.max(
    // In real TeX, calculations are done using integral values which are
    // 65536 per pt, or 655360 per em. So, the division here truncates in
    // TeX but doesn't here, producing different results. If we wanted to
    // exactly match TeX's calculation, we could do
    //   Math.floor(655360 * maxDistFromAxis / 500) *
    //    delimiterFactor / 655360
    // (To see the difference, compare
    //    x^{x^{\left(\rule{0.1em}{0.68em}\right)}}
    // in TeX and KaTeX)
    maxDistFromAxis / 500 * delimiterFactor,
    2 * maxDistFromAxis - delimiterExtend
  );
  return makeCustomSizedDelim(delim, totalHeight, true, options, mode, classes2);
};
var delimiter2 = {
  sqrtImage: makeSqrtImage,
  sizedDelim: makeSizedDelim,
  sizeToMaxHeight,
  customSizedDelim: makeCustomSizedDelim,
  leftRightDelim: makeLeftRightDelim
};
var delimiterSizes = {
  "\\bigl": {
    mclass: "mopen",
    size: 1
  },
  "\\Bigl": {
    mclass: "mopen",
    size: 2
  },
  "\\biggl": {
    mclass: "mopen",
    size: 3
  },
  "\\Biggl": {
    mclass: "mopen",
    size: 4
  },
  "\\bigr": {
    mclass: "mclose",
    size: 1
  },
  "\\Bigr": {
    mclass: "mclose",
    size: 2
  },
  "\\biggr": {
    mclass: "mclose",
    size: 3
  },
  "\\Biggr": {
    mclass: "mclose",
    size: 4
  },
  "\\bigm": {
    mclass: "mrel",
    size: 1
  },
  "\\Bigm": {
    mclass: "mrel",
    size: 2
  },
  "\\biggm": {
    mclass: "mrel",
    size: 3
  },
  "\\Biggm": {
    mclass: "mrel",
    size: 4
  },
  "\\big": {
    mclass: "mord",
    size: 1
  },
  "\\Big": {
    mclass: "mord",
    size: 2
  },
  "\\bigg": {
    mclass: "mord",
    size: 3
  },
  "\\Bigg": {
    mclass: "mord",
    size: 4
  }
};
var delimiters = ["(", "\\lparen", ")", "\\rparen", "[", "\\lbrack", "]", "\\rbrack", "\\{", "\\lbrace", "\\}", "\\rbrace", "\\lfloor", "\\rfloor", "\u230A", "\u230B", "\\lceil", "\\rceil", "\u2308", "\u2309", "<", ">", "\\langle", "\u27E8", "\\rangle", "\u27E9", "\\lt", "\\gt", "\\lvert", "\\rvert", "\\lVert", "\\rVert", "\\lgroup", "\\rgroup", "\u27EE", "\u27EF", "\\lmoustache", "\\rmoustache", "\u23B0", "\u23B1", "/", "\\backslash", "|", "\\vert", "\\|", "\\Vert", "\\uparrow", "\\Uparrow", "\\downarrow", "\\Downarrow", "\\updownarrow", "\\Updownarrow", "."];
function checkDelimiter(delim, context) {
  var symDelim = checkSymbolNodeType(delim);
  if (symDelim && utils.contains(delimiters, symDelim.text)) {
    return symDelim;
  } else if (symDelim) {
    throw new ParseError("Invalid delimiter '" + symDelim.text + "' after '" + context.funcName + "'", delim);
  } else {
    throw new ParseError("Invalid delimiter type '" + delim.type + "'", delim);
  }
}
defineFunction({
  type: "delimsizing",
  names: ["\\bigl", "\\Bigl", "\\biggl", "\\Biggl", "\\bigr", "\\Bigr", "\\biggr", "\\Biggr", "\\bigm", "\\Bigm", "\\biggm", "\\Biggm", "\\big", "\\Big", "\\bigg", "\\Bigg"],
  props: {
    numArgs: 1,
    argTypes: ["primitive"]
  },
  handler: (context, args) => {
    var delim = checkDelimiter(args[0], context);
    return {
      type: "delimsizing",
      mode: context.parser.mode,
      size: delimiterSizes[context.funcName].size,
      mclass: delimiterSizes[context.funcName].mclass,
      delim: delim.text
    };
  },
  htmlBuilder: (group, options) => {
    if (group.delim === ".") {
      return buildCommon.makeSpan([group.mclass]);
    }
    return delimiter2.sizedDelim(group.delim, group.size, options, group.mode, [group.mclass]);
  },
  mathmlBuilder: (group) => {
    var children = [];
    if (group.delim !== ".") {
      children.push(makeText(group.delim, group.mode));
    }
    var node3 = new mathMLTree.MathNode("mo", children);
    if (group.mclass === "mopen" || group.mclass === "mclose") {
      node3.setAttribute("fence", "true");
    } else {
      node3.setAttribute("fence", "false");
    }
    node3.setAttribute("stretchy", "true");
    var size2 = makeEm(delimiter2.sizeToMaxHeight[group.size]);
    node3.setAttribute("minsize", size2);
    node3.setAttribute("maxsize", size2);
    return node3;
  }
});
function assertParsed(group) {
  if (!group.body) {
    throw new Error("Bug: The leftright ParseNode wasn't fully parsed.");
  }
}
defineFunction({
  type: "leftright-right",
  names: ["\\right"],
  props: {
    numArgs: 1,
    primitive: true
  },
  handler: (context, args) => {
    var color = context.parser.gullet.macros.get("\\current@color");
    if (color && typeof color !== "string") {
      throw new ParseError("\\current@color set to non-string in \\right");
    }
    return {
      type: "leftright-right",
      mode: context.parser.mode,
      delim: checkDelimiter(args[0], context).text,
      color
      // undefined if not set via \color
    };
  }
});
defineFunction({
  type: "leftright",
  names: ["\\left"],
  props: {
    numArgs: 1,
    primitive: true
  },
  handler: (context, args) => {
    var delim = checkDelimiter(args[0], context);
    var parser2 = context.parser;
    ++parser2.leftrightDepth;
    var body = parser2.parseExpression(false);
    --parser2.leftrightDepth;
    parser2.expect("\\right", false);
    var right = assertNodeType(parser2.parseFunction(), "leftright-right");
    return {
      type: "leftright",
      mode: parser2.mode,
      body,
      left: delim.text,
      right: right.delim,
      rightColor: right.color
    };
  },
  htmlBuilder: (group, options) => {
    assertParsed(group);
    var inner2 = buildExpression$1(group.body, options, true, ["mopen", "mclose"]);
    var innerHeight = 0;
    var innerDepth = 0;
    var hadMiddle = false;
    for (var i2 = 0; i2 < inner2.length; i2++) {
      if (inner2[i2].isMiddle) {
        hadMiddle = true;
      } else {
        innerHeight = Math.max(inner2[i2].height, innerHeight);
        innerDepth = Math.max(inner2[i2].depth, innerDepth);
      }
    }
    innerHeight *= options.sizeMultiplier;
    innerDepth *= options.sizeMultiplier;
    var leftDelim;
    if (group.left === ".") {
      leftDelim = makeNullDelimiter(options, ["mopen"]);
    } else {
      leftDelim = delimiter2.leftRightDelim(group.left, innerHeight, innerDepth, options, group.mode, ["mopen"]);
    }
    inner2.unshift(leftDelim);
    if (hadMiddle) {
      for (var _i = 1; _i < inner2.length; _i++) {
        var middleDelim = inner2[_i];
        var isMiddle = middleDelim.isMiddle;
        if (isMiddle) {
          inner2[_i] = delimiter2.leftRightDelim(isMiddle.delim, innerHeight, innerDepth, isMiddle.options, group.mode, []);
        }
      }
    }
    var rightDelim;
    if (group.right === ".") {
      rightDelim = makeNullDelimiter(options, ["mclose"]);
    } else {
      var colorOptions = group.rightColor ? options.withColor(group.rightColor) : options;
      rightDelim = delimiter2.leftRightDelim(group.right, innerHeight, innerDepth, colorOptions, group.mode, ["mclose"]);
    }
    inner2.push(rightDelim);
    return buildCommon.makeSpan(["minner"], inner2, options);
  },
  mathmlBuilder: (group, options) => {
    assertParsed(group);
    var inner2 = buildExpression2(group.body, options);
    if (group.left !== ".") {
      var leftNode = new mathMLTree.MathNode("mo", [makeText(group.left, group.mode)]);
      leftNode.setAttribute("fence", "true");
      inner2.unshift(leftNode);
    }
    if (group.right !== ".") {
      var rightNode = new mathMLTree.MathNode("mo", [makeText(group.right, group.mode)]);
      rightNode.setAttribute("fence", "true");
      if (group.rightColor) {
        rightNode.setAttribute("mathcolor", group.rightColor);
      }
      inner2.push(rightNode);
    }
    return makeRow(inner2);
  }
});
defineFunction({
  type: "middle",
  names: ["\\middle"],
  props: {
    numArgs: 1,
    primitive: true
  },
  handler: (context, args) => {
    var delim = checkDelimiter(args[0], context);
    if (!context.parser.leftrightDepth) {
      throw new ParseError("\\middle without preceding \\left", delim);
    }
    return {
      type: "middle",
      mode: context.parser.mode,
      delim: delim.text
    };
  },
  htmlBuilder: (group, options) => {
    var middleDelim;
    if (group.delim === ".") {
      middleDelim = makeNullDelimiter(options, []);
    } else {
      middleDelim = delimiter2.sizedDelim(group.delim, 1, options, group.mode, []);
      var isMiddle = {
        delim: group.delim,
        options
      };
      middleDelim.isMiddle = isMiddle;
    }
    return middleDelim;
  },
  mathmlBuilder: (group, options) => {
    var textNode = group.delim === "\\vert" || group.delim === "|" ? makeText("|", "text") : makeText(group.delim, group.mode);
    var middleNode = new mathMLTree.MathNode("mo", [textNode]);
    middleNode.setAttribute("fence", "true");
    middleNode.setAttribute("lspace", "0.05em");
    middleNode.setAttribute("rspace", "0.05em");
    return middleNode;
  }
});
var htmlBuilder$7 = (group, options) => {
  var inner2 = buildCommon.wrapFragment(buildGroup$1(group.body, options), options);
  var label = group.label.slice(1);
  var scale3 = options.sizeMultiplier;
  var img;
  var imgShift = 0;
  var isSingleChar = utils.isCharacterBox(group.body);
  if (label === "sout") {
    img = buildCommon.makeSpan(["stretchy", "sout"]);
    img.height = options.fontMetrics().defaultRuleThickness / scale3;
    imgShift = -0.5 * options.fontMetrics().xHeight;
  } else if (label === "phase") {
    var lineWeight = calculateSize({
      number: 0.6,
      unit: "pt"
    }, options);
    var clearance = calculateSize({
      number: 0.35,
      unit: "ex"
    }, options);
    var newOptions = options.havingBaseSizing();
    scale3 = scale3 / newOptions.sizeMultiplier;
    var angleHeight = inner2.height + inner2.depth + lineWeight + clearance;
    inner2.style.paddingLeft = makeEm(angleHeight / 2 + lineWeight);
    var viewBoxHeight = Math.floor(1e3 * angleHeight * scale3);
    var path2 = phasePath(viewBoxHeight);
    var svgNode = new SvgNode([new PathNode("phase", path2)], {
      "width": "400em",
      "height": makeEm(viewBoxHeight / 1e3),
      "viewBox": "0 0 400000 " + viewBoxHeight,
      "preserveAspectRatio": "xMinYMin slice"
    });
    img = buildCommon.makeSvgSpan(["hide-tail"], [svgNode], options);
    img.style.height = makeEm(angleHeight);
    imgShift = inner2.depth + lineWeight + clearance;
  } else {
    if (/cancel/.test(label)) {
      if (!isSingleChar) {
        inner2.classes.push("cancel-pad");
      }
    } else if (label === "angl") {
      inner2.classes.push("anglpad");
    } else {
      inner2.classes.push("boxpad");
    }
    var topPad = 0;
    var bottomPad = 0;
    var ruleThickness = 0;
    if (/box/.test(label)) {
      ruleThickness = Math.max(
        options.fontMetrics().fboxrule,
        // default
        options.minRuleThickness
        // User override.
      );
      topPad = options.fontMetrics().fboxsep + (label === "colorbox" ? 0 : ruleThickness);
      bottomPad = topPad;
    } else if (label === "angl") {
      ruleThickness = Math.max(options.fontMetrics().defaultRuleThickness, options.minRuleThickness);
      topPad = 4 * ruleThickness;
      bottomPad = Math.max(0, 0.25 - inner2.depth);
    } else {
      topPad = isSingleChar ? 0.2 : 0;
      bottomPad = topPad;
    }
    img = stretchy.encloseSpan(inner2, label, topPad, bottomPad, options);
    if (/fbox|boxed|fcolorbox/.test(label)) {
      img.style.borderStyle = "solid";
      img.style.borderWidth = makeEm(ruleThickness);
    } else if (label === "angl" && ruleThickness !== 0.049) {
      img.style.borderTopWidth = makeEm(ruleThickness);
      img.style.borderRightWidth = makeEm(ruleThickness);
    }
    imgShift = inner2.depth + bottomPad;
    if (group.backgroundColor) {
      img.style.backgroundColor = group.backgroundColor;
      if (group.borderColor) {
        img.style.borderColor = group.borderColor;
      }
    }
  }
  var vlist;
  if (group.backgroundColor) {
    vlist = buildCommon.makeVList({
      positionType: "individualShift",
      children: [
        // Put the color background behind inner;
        {
          type: "elem",
          elem: img,
          shift: imgShift
        },
        {
          type: "elem",
          elem: inner2,
          shift: 0
        }
      ]
    }, options);
  } else {
    var classes2 = /cancel|phase/.test(label) ? ["svg-align"] : [];
    vlist = buildCommon.makeVList({
      positionType: "individualShift",
      children: [
        // Write the \cancel stroke on top of inner.
        {
          type: "elem",
          elem: inner2,
          shift: 0
        },
        {
          type: "elem",
          elem: img,
          shift: imgShift,
          wrapperClasses: classes2
        }
      ]
    }, options);
  }
  if (/cancel/.test(label)) {
    vlist.height = inner2.height;
    vlist.depth = inner2.depth;
  }
  if (/cancel/.test(label) && !isSingleChar) {
    return buildCommon.makeSpan(["mord", "cancel-lap"], [vlist], options);
  } else {
    return buildCommon.makeSpan(["mord"], [vlist], options);
  }
};
var mathmlBuilder$6 = (group, options) => {
  var fboxsep = 0;
  var node3 = new mathMLTree.MathNode(group.label.indexOf("colorbox") > -1 ? "mpadded" : "menclose", [buildGroup2(group.body, options)]);
  switch (group.label) {
    case "\\cancel":
      node3.setAttribute("notation", "updiagonalstrike");
      break;
    case "\\bcancel":
      node3.setAttribute("notation", "downdiagonalstrike");
      break;
    case "\\phase":
      node3.setAttribute("notation", "phasorangle");
      break;
    case "\\sout":
      node3.setAttribute("notation", "horizontalstrike");
      break;
    case "\\fbox":
      node3.setAttribute("notation", "box");
      break;
    case "\\angl":
      node3.setAttribute("notation", "actuarial");
      break;
    case "\\fcolorbox":
    case "\\colorbox":
      fboxsep = options.fontMetrics().fboxsep * options.fontMetrics().ptPerEm;
      node3.setAttribute("width", "+" + 2 * fboxsep + "pt");
      node3.setAttribute("height", "+" + 2 * fboxsep + "pt");
      node3.setAttribute("lspace", fboxsep + "pt");
      node3.setAttribute("voffset", fboxsep + "pt");
      if (group.label === "\\fcolorbox") {
        var thk = Math.max(
          options.fontMetrics().fboxrule,
          // default
          options.minRuleThickness
          // user override
        );
        node3.setAttribute("style", "border: " + thk + "em solid " + String(group.borderColor));
      }
      break;
    case "\\xcancel":
      node3.setAttribute("notation", "updiagonalstrike downdiagonalstrike");
      break;
  }
  if (group.backgroundColor) {
    node3.setAttribute("mathbackground", group.backgroundColor);
  }
  return node3;
};
defineFunction({
  type: "enclose",
  names: ["\\colorbox"],
  props: {
    numArgs: 2,
    allowedInText: true,
    argTypes: ["color", "text"]
  },
  handler(_ref, args, optArgs) {
    var {
      parser: parser2,
      funcName
    } = _ref;
    var color = assertNodeType(args[0], "color-token").color;
    var body = args[1];
    return {
      type: "enclose",
      mode: parser2.mode,
      label: funcName,
      backgroundColor: color,
      body
    };
  },
  htmlBuilder: htmlBuilder$7,
  mathmlBuilder: mathmlBuilder$6
});
defineFunction({
  type: "enclose",
  names: ["\\fcolorbox"],
  props: {
    numArgs: 3,
    allowedInText: true,
    argTypes: ["color", "color", "text"]
  },
  handler(_ref2, args, optArgs) {
    var {
      parser: parser2,
      funcName
    } = _ref2;
    var borderColor = assertNodeType(args[0], "color-token").color;
    var backgroundColor = assertNodeType(args[1], "color-token").color;
    var body = args[2];
    return {
      type: "enclose",
      mode: parser2.mode,
      label: funcName,
      backgroundColor,
      borderColor,
      body
    };
  },
  htmlBuilder: htmlBuilder$7,
  mathmlBuilder: mathmlBuilder$6
});
defineFunction({
  type: "enclose",
  names: ["\\fbox"],
  props: {
    numArgs: 1,
    argTypes: ["hbox"],
    allowedInText: true
  },
  handler(_ref3, args) {
    var {
      parser: parser2
    } = _ref3;
    return {
      type: "enclose",
      mode: parser2.mode,
      label: "\\fbox",
      body: args[0]
    };
  }
});
defineFunction({
  type: "enclose",
  names: ["\\cancel", "\\bcancel", "\\xcancel", "\\sout", "\\phase"],
  props: {
    numArgs: 1
  },
  handler(_ref4, args) {
    var {
      parser: parser2,
      funcName
    } = _ref4;
    var body = args[0];
    return {
      type: "enclose",
      mode: parser2.mode,
      label: funcName,
      body
    };
  },
  htmlBuilder: htmlBuilder$7,
  mathmlBuilder: mathmlBuilder$6
});
defineFunction({
  type: "enclose",
  names: ["\\angl"],
  props: {
    numArgs: 1,
    argTypes: ["hbox"],
    allowedInText: false
  },
  handler(_ref5, args) {
    var {
      parser: parser2
    } = _ref5;
    return {
      type: "enclose",
      mode: parser2.mode,
      label: "\\angl",
      body: args[0]
    };
  }
});
var _environments = {};
function defineEnvironment(_ref) {
  var {
    type,
    names: names2,
    props,
    handler,
    htmlBuilder: htmlBuilder3,
    mathmlBuilder: mathmlBuilder3
  } = _ref;
  var data2 = {
    type,
    numArgs: props.numArgs || 0,
    allowedInText: false,
    numOptionalArgs: 0,
    handler
  };
  for (var i2 = 0; i2 < names2.length; ++i2) {
    _environments[names2[i2]] = data2;
  }
  if (htmlBuilder3) {
    _htmlGroupBuilders[type] = htmlBuilder3;
  }
  if (mathmlBuilder3) {
    _mathmlGroupBuilders[type] = mathmlBuilder3;
  }
}
var _macros = {};
function defineMacro(name, body) {
  _macros[name] = body;
}
function getHLines(parser2) {
  var hlineInfo = [];
  parser2.consumeSpaces();
  var nxt = parser2.fetch().text;
  if (nxt === "\\relax") {
    parser2.consume();
    parser2.consumeSpaces();
    nxt = parser2.fetch().text;
  }
  while (nxt === "\\hline" || nxt === "\\hdashline") {
    parser2.consume();
    hlineInfo.push(nxt === "\\hdashline");
    parser2.consumeSpaces();
    nxt = parser2.fetch().text;
  }
  return hlineInfo;
}
var validateAmsEnvironmentContext = (context) => {
  var settings = context.parser.settings;
  if (!settings.displayMode) {
    throw new ParseError("{" + context.envName + "} can be used only in display mode.");
  }
};
function getAutoTag(name) {
  if (name.indexOf("ed") === -1) {
    return name.indexOf("*") === -1;
  }
}
function parseArray(parser2, _ref, style) {
  var {
    hskipBeforeAndAfter,
    addJot,
    cols,
    arraystretch,
    colSeparationType,
    autoTag,
    singleRow,
    emptySingleRow,
    maxNumCols,
    leqno
  } = _ref;
  parser2.gullet.beginGroup();
  if (!singleRow) {
    parser2.gullet.macros.set("\\cr", "\\\\\\relax");
  }
  if (!arraystretch) {
    var stretch = parser2.gullet.expandMacroAsText("\\arraystretch");
    if (stretch == null) {
      arraystretch = 1;
    } else {
      arraystretch = parseFloat(stretch);
      if (!arraystretch || arraystretch < 0) {
        throw new ParseError("Invalid \\arraystretch: " + stretch);
      }
    }
  }
  parser2.gullet.beginGroup();
  var row = [];
  var body = [row];
  var rowGaps = [];
  var hLinesBeforeRow = [];
  var tags = autoTag != null ? [] : void 0;
  function beginRow() {
    if (autoTag) {
      parser2.gullet.macros.set("\\@eqnsw", "1", true);
    }
  }
  function endRow() {
    if (tags) {
      if (parser2.gullet.macros.get("\\df@tag")) {
        tags.push(parser2.subparse([new Token("\\df@tag")]));
        parser2.gullet.macros.set("\\df@tag", void 0, true);
      } else {
        tags.push(Boolean(autoTag) && parser2.gullet.macros.get("\\@eqnsw") === "1");
      }
    }
  }
  beginRow();
  hLinesBeforeRow.push(getHLines(parser2));
  while (true) {
    var cell = parser2.parseExpression(false, singleRow ? "\\end" : "\\\\");
    parser2.gullet.endGroup();
    parser2.gullet.beginGroup();
    cell = {
      type: "ordgroup",
      mode: parser2.mode,
      body: cell
    };
    if (style) {
      cell = {
        type: "styling",
        mode: parser2.mode,
        style,
        body: [cell]
      };
    }
    row.push(cell);
    var next2 = parser2.fetch().text;
    if (next2 === "&") {
      if (maxNumCols && row.length === maxNumCols) {
        if (singleRow || colSeparationType) {
          throw new ParseError("Too many tab characters: &", parser2.nextToken);
        } else {
          parser2.settings.reportNonstrict("textEnv", "Too few columns specified in the {array} column argument.");
        }
      }
      parser2.consume();
    } else if (next2 === "\\end") {
      endRow();
      if (row.length === 1 && cell.type === "styling" && cell.body[0].body.length === 0 && (body.length > 1 || !emptySingleRow)) {
        body.pop();
      }
      if (hLinesBeforeRow.length < body.length + 1) {
        hLinesBeforeRow.push([]);
      }
      break;
    } else if (next2 === "\\\\") {
      parser2.consume();
      var size2 = void 0;
      if (parser2.gullet.future().text !== " ") {
        size2 = parser2.parseSizeGroup(true);
      }
      rowGaps.push(size2 ? size2.value : null);
      endRow();
      hLinesBeforeRow.push(getHLines(parser2));
      row = [];
      body.push(row);
      beginRow();
    } else {
      throw new ParseError("Expected & or \\\\ or \\cr or \\end", parser2.nextToken);
    }
  }
  parser2.gullet.endGroup();
  parser2.gullet.endGroup();
  return {
    type: "array",
    mode: parser2.mode,
    addJot,
    arraystretch,
    body,
    cols,
    rowGaps,
    hskipBeforeAndAfter,
    hLinesBeforeRow,
    colSeparationType,
    tags,
    leqno
  };
}
function dCellStyle(envName) {
  if (envName.slice(0, 1) === "d") {
    return "display";
  } else {
    return "text";
  }
}
var htmlBuilder$6 = function htmlBuilder(group, options) {
  var r2;
  var c3;
  var nr = group.body.length;
  var hLinesBeforeRow = group.hLinesBeforeRow;
  var nc = 0;
  var body = new Array(nr);
  var hlines = [];
  var ruleThickness = Math.max(
    // From LaTeX \showthe\arrayrulewidth. Equals 0.04 em.
    options.fontMetrics().arrayRuleWidth,
    options.minRuleThickness
    // User override.
  );
  var pt = 1 / options.fontMetrics().ptPerEm;
  var arraycolsep = 5 * pt;
  if (group.colSeparationType && group.colSeparationType === "small") {
    var localMultiplier = options.havingStyle(Style$1.SCRIPT).sizeMultiplier;
    arraycolsep = 0.2778 * (localMultiplier / options.sizeMultiplier);
  }
  var baselineskip = group.colSeparationType === "CD" ? calculateSize({
    number: 3,
    unit: "ex"
  }, options) : 12 * pt;
  var jot = 3 * pt;
  var arrayskip = group.arraystretch * baselineskip;
  var arstrutHeight = 0.7 * arrayskip;
  var arstrutDepth = 0.3 * arrayskip;
  var totalHeight = 0;
  function setHLinePos(hlinesInGap) {
    for (var i2 = 0; i2 < hlinesInGap.length; ++i2) {
      if (i2 > 0) {
        totalHeight += 0.25;
      }
      hlines.push({
        pos: totalHeight,
        isDashed: hlinesInGap[i2]
      });
    }
  }
  setHLinePos(hLinesBeforeRow[0]);
  for (r2 = 0; r2 < group.body.length; ++r2) {
    var inrow = group.body[r2];
    var height2 = arstrutHeight;
    var depth = arstrutDepth;
    if (nc < inrow.length) {
      nc = inrow.length;
    }
    var outrow = new Array(inrow.length);
    for (c3 = 0; c3 < inrow.length; ++c3) {
      var elt = buildGroup$1(inrow[c3], options);
      if (depth < elt.depth) {
        depth = elt.depth;
      }
      if (height2 < elt.height) {
        height2 = elt.height;
      }
      outrow[c3] = elt;
    }
    var rowGap = group.rowGaps[r2];
    var gap = 0;
    if (rowGap) {
      gap = calculateSize(rowGap, options);
      if (gap > 0) {
        gap += arstrutDepth;
        if (depth < gap) {
          depth = gap;
        }
        gap = 0;
      }
    }
    if (group.addJot) {
      depth += jot;
    }
    outrow.height = height2;
    outrow.depth = depth;
    totalHeight += height2;
    outrow.pos = totalHeight;
    totalHeight += depth + gap;
    body[r2] = outrow;
    setHLinePos(hLinesBeforeRow[r2 + 1]);
  }
  var offset = totalHeight / 2 + options.fontMetrics().axisHeight;
  var colDescriptions = group.cols || [];
  var cols = [];
  var colSep;
  var colDescrNum;
  var tagSpans = [];
  if (group.tags && group.tags.some((tag2) => tag2)) {
    for (r2 = 0; r2 < nr; ++r2) {
      var rw = body[r2];
      var shift = rw.pos - offset;
      var tag = group.tags[r2];
      var tagSpan = void 0;
      if (tag === true) {
        tagSpan = buildCommon.makeSpan(["eqn-num"], [], options);
      } else if (tag === false) {
        tagSpan = buildCommon.makeSpan([], [], options);
      } else {
        tagSpan = buildCommon.makeSpan([], buildExpression$1(tag, options, true), options);
      }
      tagSpan.depth = rw.depth;
      tagSpan.height = rw.height;
      tagSpans.push({
        type: "elem",
        elem: tagSpan,
        shift
      });
    }
  }
  for (
    c3 = 0, colDescrNum = 0;
    // Continue while either there are more columns or more column
    // descriptions, so trailing separators don't get lost.
    c3 < nc || colDescrNum < colDescriptions.length;
    ++c3, ++colDescrNum
  ) {
    var colDescr = colDescriptions[colDescrNum] || {};
    var firstSeparator = true;
    while (colDescr.type === "separator") {
      if (!firstSeparator) {
        colSep = buildCommon.makeSpan(["arraycolsep"], []);
        colSep.style.width = makeEm(options.fontMetrics().doubleRuleSep);
        cols.push(colSep);
      }
      if (colDescr.separator === "|" || colDescr.separator === ":") {
        var lineType = colDescr.separator === "|" ? "solid" : "dashed";
        var separator = buildCommon.makeSpan(["vertical-separator"], [], options);
        separator.style.height = makeEm(totalHeight);
        separator.style.borderRightWidth = makeEm(ruleThickness);
        separator.style.borderRightStyle = lineType;
        separator.style.margin = "0 " + makeEm(-ruleThickness / 2);
        var _shift = totalHeight - offset;
        if (_shift) {
          separator.style.verticalAlign = makeEm(-_shift);
        }
        cols.push(separator);
      } else {
        throw new ParseError("Invalid separator type: " + colDescr.separator);
      }
      colDescrNum++;
      colDescr = colDescriptions[colDescrNum] || {};
      firstSeparator = false;
    }
    if (c3 >= nc) {
      continue;
    }
    var sepwidth = void 0;
    if (c3 > 0 || group.hskipBeforeAndAfter) {
      sepwidth = utils.deflt(colDescr.pregap, arraycolsep);
      if (sepwidth !== 0) {
        colSep = buildCommon.makeSpan(["arraycolsep"], []);
        colSep.style.width = makeEm(sepwidth);
        cols.push(colSep);
      }
    }
    var col = [];
    for (r2 = 0; r2 < nr; ++r2) {
      var row = body[r2];
      var elem = row[c3];
      if (!elem) {
        continue;
      }
      var _shift2 = row.pos - offset;
      elem.depth = row.depth;
      elem.height = row.height;
      col.push({
        type: "elem",
        elem,
        shift: _shift2
      });
    }
    col = buildCommon.makeVList({
      positionType: "individualShift",
      children: col
    }, options);
    col = buildCommon.makeSpan(["col-align-" + (colDescr.align || "c")], [col]);
    cols.push(col);
    if (c3 < nc - 1 || group.hskipBeforeAndAfter) {
      sepwidth = utils.deflt(colDescr.postgap, arraycolsep);
      if (sepwidth !== 0) {
        colSep = buildCommon.makeSpan(["arraycolsep"], []);
        colSep.style.width = makeEm(sepwidth);
        cols.push(colSep);
      }
    }
  }
  body = buildCommon.makeSpan(["mtable"], cols);
  if (hlines.length > 0) {
    var line = buildCommon.makeLineSpan("hline", options, ruleThickness);
    var dashes = buildCommon.makeLineSpan("hdashline", options, ruleThickness);
    var vListElems = [{
      type: "elem",
      elem: body,
      shift: 0
    }];
    while (hlines.length > 0) {
      var hline = hlines.pop();
      var lineShift = hline.pos - offset;
      if (hline.isDashed) {
        vListElems.push({
          type: "elem",
          elem: dashes,
          shift: lineShift
        });
      } else {
        vListElems.push({
          type: "elem",
          elem: line,
          shift: lineShift
        });
      }
    }
    body = buildCommon.makeVList({
      positionType: "individualShift",
      children: vListElems
    }, options);
  }
  if (tagSpans.length === 0) {
    return buildCommon.makeSpan(["mord"], [body], options);
  } else {
    var eqnNumCol = buildCommon.makeVList({
      positionType: "individualShift",
      children: tagSpans
    }, options);
    eqnNumCol = buildCommon.makeSpan(["tag"], [eqnNumCol], options);
    return buildCommon.makeFragment([body, eqnNumCol]);
  }
};
var alignMap = {
  c: "center ",
  l: "left ",
  r: "right "
};
var mathmlBuilder$5 = function mathmlBuilder(group, options) {
  var tbl = [];
  var glue = new mathMLTree.MathNode("mtd", [], ["mtr-glue"]);
  var tag = new mathMLTree.MathNode("mtd", [], ["mml-eqn-num"]);
  for (var i2 = 0; i2 < group.body.length; i2++) {
    var rw = group.body[i2];
    var row = [];
    for (var j = 0; j < rw.length; j++) {
      row.push(new mathMLTree.MathNode("mtd", [buildGroup2(rw[j], options)]));
    }
    if (group.tags && group.tags[i2]) {
      row.unshift(glue);
      row.push(glue);
      if (group.leqno) {
        row.unshift(tag);
      } else {
        row.push(tag);
      }
    }
    tbl.push(new mathMLTree.MathNode("mtr", row));
  }
  var table = new mathMLTree.MathNode("mtable", tbl);
  var gap = group.arraystretch === 0.5 ? 0.1 : 0.16 + group.arraystretch - 1 + (group.addJot ? 0.09 : 0);
  table.setAttribute("rowspacing", makeEm(gap));
  var menclose = "";
  var align = "";
  if (group.cols && group.cols.length > 0) {
    var cols = group.cols;
    var columnLines = "";
    var prevTypeWasAlign = false;
    var iStart = 0;
    var iEnd = cols.length;
    if (cols[0].type === "separator") {
      menclose += "top ";
      iStart = 1;
    }
    if (cols[cols.length - 1].type === "separator") {
      menclose += "bottom ";
      iEnd -= 1;
    }
    for (var _i = iStart; _i < iEnd; _i++) {
      if (cols[_i].type === "align") {
        align += alignMap[cols[_i].align];
        if (prevTypeWasAlign) {
          columnLines += "none ";
        }
        prevTypeWasAlign = true;
      } else if (cols[_i].type === "separator") {
        if (prevTypeWasAlign) {
          columnLines += cols[_i].separator === "|" ? "solid " : "dashed ";
          prevTypeWasAlign = false;
        }
      }
    }
    table.setAttribute("columnalign", align.trim());
    if (/[sd]/.test(columnLines)) {
      table.setAttribute("columnlines", columnLines.trim());
    }
  }
  if (group.colSeparationType === "align") {
    var _cols = group.cols || [];
    var spacing2 = "";
    for (var _i2 = 1; _i2 < _cols.length; _i2++) {
      spacing2 += _i2 % 2 ? "0em " : "1em ";
    }
    table.setAttribute("columnspacing", spacing2.trim());
  } else if (group.colSeparationType === "alignat" || group.colSeparationType === "gather") {
    table.setAttribute("columnspacing", "0em");
  } else if (group.colSeparationType === "small") {
    table.setAttribute("columnspacing", "0.2778em");
  } else if (group.colSeparationType === "CD") {
    table.setAttribute("columnspacing", "0.5em");
  } else {
    table.setAttribute("columnspacing", "1em");
  }
  var rowLines = "";
  var hlines = group.hLinesBeforeRow;
  menclose += hlines[0].length > 0 ? "left " : "";
  menclose += hlines[hlines.length - 1].length > 0 ? "right " : "";
  for (var _i3 = 1; _i3 < hlines.length - 1; _i3++) {
    rowLines += hlines[_i3].length === 0 ? "none " : hlines[_i3][0] ? "dashed " : "solid ";
  }
  if (/[sd]/.test(rowLines)) {
    table.setAttribute("rowlines", rowLines.trim());
  }
  if (menclose !== "") {
    table = new mathMLTree.MathNode("menclose", [table]);
    table.setAttribute("notation", menclose.trim());
  }
  if (group.arraystretch && group.arraystretch < 1) {
    table = new mathMLTree.MathNode("mstyle", [table]);
    table.setAttribute("scriptlevel", "1");
  }
  return table;
};
var alignedHandler = function alignedHandler2(context, args) {
  if (context.envName.indexOf("ed") === -1) {
    validateAmsEnvironmentContext(context);
  }
  var cols = [];
  var separationType = context.envName.indexOf("at") > -1 ? "alignat" : "align";
  var isSplit = context.envName === "split";
  var res = parseArray(context.parser, {
    cols,
    addJot: true,
    autoTag: isSplit ? void 0 : getAutoTag(context.envName),
    emptySingleRow: true,
    colSeparationType: separationType,
    maxNumCols: isSplit ? 2 : void 0,
    leqno: context.parser.settings.leqno
  }, "display");
  var numMaths;
  var numCols = 0;
  var emptyGroup = {
    type: "ordgroup",
    mode: context.mode,
    body: []
  };
  if (args[0] && args[0].type === "ordgroup") {
    var arg0 = "";
    for (var i2 = 0; i2 < args[0].body.length; i2++) {
      var textord2 = assertNodeType(args[0].body[i2], "textord");
      arg0 += textord2.text;
    }
    numMaths = Number(arg0);
    numCols = numMaths * 2;
  }
  var isAligned = !numCols;
  res.body.forEach(function(row) {
    for (var _i4 = 1; _i4 < row.length; _i4 += 2) {
      var styling = assertNodeType(row[_i4], "styling");
      var ordgroup = assertNodeType(styling.body[0], "ordgroup");
      ordgroup.body.unshift(emptyGroup);
    }
    if (!isAligned) {
      var curMaths = row.length / 2;
      if (numMaths < curMaths) {
        throw new ParseError("Too many math in a row: " + ("expected " + numMaths + ", but got " + curMaths), row[0]);
      }
    } else if (numCols < row.length) {
      numCols = row.length;
    }
  });
  for (var _i5 = 0; _i5 < numCols; ++_i5) {
    var align = "r";
    var pregap = 0;
    if (_i5 % 2 === 1) {
      align = "l";
    } else if (_i5 > 0 && isAligned) {
      pregap = 1;
    }
    cols[_i5] = {
      type: "align",
      align,
      pregap,
      postgap: 0
    };
  }
  res.colSeparationType = isAligned ? "align" : "alignat";
  return res;
};
defineEnvironment({
  type: "array",
  names: ["array", "darray"],
  props: {
    numArgs: 1
  },
  handler(context, args) {
    var symNode = checkSymbolNodeType(args[0]);
    var colalign = symNode ? [args[0]] : assertNodeType(args[0], "ordgroup").body;
    var cols = colalign.map(function(nde) {
      var node3 = assertSymbolNodeType(nde);
      var ca = node3.text;
      if ("lcr".indexOf(ca) !== -1) {
        return {
          type: "align",
          align: ca
        };
      } else if (ca === "|") {
        return {
          type: "separator",
          separator: "|"
        };
      } else if (ca === ":") {
        return {
          type: "separator",
          separator: ":"
        };
      }
      throw new ParseError("Unknown column alignment: " + ca, nde);
    });
    var res = {
      cols,
      hskipBeforeAndAfter: true,
      // \@preamble in lttab.dtx
      maxNumCols: cols.length
    };
    return parseArray(context.parser, res, dCellStyle(context.envName));
  },
  htmlBuilder: htmlBuilder$6,
  mathmlBuilder: mathmlBuilder$5
});
defineEnvironment({
  type: "array",
  names: ["matrix", "pmatrix", "bmatrix", "Bmatrix", "vmatrix", "Vmatrix", "matrix*", "pmatrix*", "bmatrix*", "Bmatrix*", "vmatrix*", "Vmatrix*"],
  props: {
    numArgs: 0
  },
  handler(context) {
    var delimiters2 = {
      "matrix": null,
      "pmatrix": ["(", ")"],
      "bmatrix": ["[", "]"],
      "Bmatrix": ["\\{", "\\}"],
      "vmatrix": ["|", "|"],
      "Vmatrix": ["\\Vert", "\\Vert"]
    }[context.envName.replace("*", "")];
    var colAlign = "c";
    var payload = {
      hskipBeforeAndAfter: false,
      cols: [{
        type: "align",
        align: colAlign
      }]
    };
    if (context.envName.charAt(context.envName.length - 1) === "*") {
      var parser2 = context.parser;
      parser2.consumeSpaces();
      if (parser2.fetch().text === "[") {
        parser2.consume();
        parser2.consumeSpaces();
        colAlign = parser2.fetch().text;
        if ("lcr".indexOf(colAlign) === -1) {
          throw new ParseError("Expected l or c or r", parser2.nextToken);
        }
        parser2.consume();
        parser2.consumeSpaces();
        parser2.expect("]");
        parser2.consume();
        payload.cols = [{
          type: "align",
          align: colAlign
        }];
      }
    }
    var res = parseArray(context.parser, payload, dCellStyle(context.envName));
    var numCols = Math.max(0, ...res.body.map((row) => row.length));
    res.cols = new Array(numCols).fill({
      type: "align",
      align: colAlign
    });
    return delimiters2 ? {
      type: "leftright",
      mode: context.mode,
      body: [res],
      left: delimiters2[0],
      right: delimiters2[1],
      rightColor: void 0
      // \right uninfluenced by \color in array
    } : res;
  },
  htmlBuilder: htmlBuilder$6,
  mathmlBuilder: mathmlBuilder$5
});
defineEnvironment({
  type: "array",
  names: ["smallmatrix"],
  props: {
    numArgs: 0
  },
  handler(context) {
    var payload = {
      arraystretch: 0.5
    };
    var res = parseArray(context.parser, payload, "script");
    res.colSeparationType = "small";
    return res;
  },
  htmlBuilder: htmlBuilder$6,
  mathmlBuilder: mathmlBuilder$5
});
defineEnvironment({
  type: "array",
  names: ["subarray"],
  props: {
    numArgs: 1
  },
  handler(context, args) {
    var symNode = checkSymbolNodeType(args[0]);
    var colalign = symNode ? [args[0]] : assertNodeType(args[0], "ordgroup").body;
    var cols = colalign.map(function(nde) {
      var node3 = assertSymbolNodeType(nde);
      var ca = node3.text;
      if ("lc".indexOf(ca) !== -1) {
        return {
          type: "align",
          align: ca
        };
      }
      throw new ParseError("Unknown column alignment: " + ca, nde);
    });
    if (cols.length > 1) {
      throw new ParseError("{subarray} can contain only one column");
    }
    var res = {
      cols,
      hskipBeforeAndAfter: false,
      arraystretch: 0.5
    };
    res = parseArray(context.parser, res, "script");
    if (res.body.length > 0 && res.body[0].length > 1) {
      throw new ParseError("{subarray} can contain only one column");
    }
    return res;
  },
  htmlBuilder: htmlBuilder$6,
  mathmlBuilder: mathmlBuilder$5
});
defineEnvironment({
  type: "array",
  names: ["cases", "dcases", "rcases", "drcases"],
  props: {
    numArgs: 0
  },
  handler(context) {
    var payload = {
      arraystretch: 1.2,
      cols: [{
        type: "align",
        align: "l",
        pregap: 0,
        // TODO(kevinb) get the current style.
        // For now we use the metrics for TEXT style which is what we were
        // doing before.  Before attempting to get the current style we
        // should look at TeX's behavior especially for \over and matrices.
        postgap: 1
        /* 1em quad */
      }, {
        type: "align",
        align: "l",
        pregap: 0,
        postgap: 0
      }]
    };
    var res = parseArray(context.parser, payload, dCellStyle(context.envName));
    return {
      type: "leftright",
      mode: context.mode,
      body: [res],
      left: context.envName.indexOf("r") > -1 ? "." : "\\{",
      right: context.envName.indexOf("r") > -1 ? "\\}" : ".",
      rightColor: void 0
    };
  },
  htmlBuilder: htmlBuilder$6,
  mathmlBuilder: mathmlBuilder$5
});
defineEnvironment({
  type: "array",
  names: ["align", "align*", "aligned", "split"],
  props: {
    numArgs: 0
  },
  handler: alignedHandler,
  htmlBuilder: htmlBuilder$6,
  mathmlBuilder: mathmlBuilder$5
});
defineEnvironment({
  type: "array",
  names: ["gathered", "gather", "gather*"],
  props: {
    numArgs: 0
  },
  handler(context) {
    if (utils.contains(["gather", "gather*"], context.envName)) {
      validateAmsEnvironmentContext(context);
    }
    var res = {
      cols: [{
        type: "align",
        align: "c"
      }],
      addJot: true,
      colSeparationType: "gather",
      autoTag: getAutoTag(context.envName),
      emptySingleRow: true,
      leqno: context.parser.settings.leqno
    };
    return parseArray(context.parser, res, "display");
  },
  htmlBuilder: htmlBuilder$6,
  mathmlBuilder: mathmlBuilder$5
});
defineEnvironment({
  type: "array",
  names: ["alignat", "alignat*", "alignedat"],
  props: {
    numArgs: 1
  },
  handler: alignedHandler,
  htmlBuilder: htmlBuilder$6,
  mathmlBuilder: mathmlBuilder$5
});
defineEnvironment({
  type: "array",
  names: ["equation", "equation*"],
  props: {
    numArgs: 0
  },
  handler(context) {
    validateAmsEnvironmentContext(context);
    var res = {
      autoTag: getAutoTag(context.envName),
      emptySingleRow: true,
      singleRow: true,
      maxNumCols: 1,
      leqno: context.parser.settings.leqno
    };
    return parseArray(context.parser, res, "display");
  },
  htmlBuilder: htmlBuilder$6,
  mathmlBuilder: mathmlBuilder$5
});
defineEnvironment({
  type: "array",
  names: ["CD"],
  props: {
    numArgs: 0
  },
  handler(context) {
    validateAmsEnvironmentContext(context);
    return parseCD(context.parser);
  },
  htmlBuilder: htmlBuilder$6,
  mathmlBuilder: mathmlBuilder$5
});
defineMacro("\\nonumber", "\\gdef\\@eqnsw{0}");
defineMacro("\\notag", "\\nonumber");
defineFunction({
  type: "text",
  // Doesn't matter what this is.
  names: ["\\hline", "\\hdashline"],
  props: {
    numArgs: 0,
    allowedInText: true,
    allowedInMath: true
  },
  handler(context, args) {
    throw new ParseError(context.funcName + " valid only within array environment");
  }
});
var environments = _environments;
defineFunction({
  type: "environment",
  names: ["\\begin", "\\end"],
  props: {
    numArgs: 1,
    argTypes: ["text"]
  },
  handler(_ref, args) {
    var {
      parser: parser2,
      funcName
    } = _ref;
    var nameGroup = args[0];
    if (nameGroup.type !== "ordgroup") {
      throw new ParseError("Invalid environment name", nameGroup);
    }
    var envName = "";
    for (var i2 = 0; i2 < nameGroup.body.length; ++i2) {
      envName += assertNodeType(nameGroup.body[i2], "textord").text;
    }
    if (funcName === "\\begin") {
      if (!environments.hasOwnProperty(envName)) {
        throw new ParseError("No such environment: " + envName, nameGroup);
      }
      var env = environments[envName];
      var {
        args: _args,
        optArgs
      } = parser2.parseArguments("\\begin{" + envName + "}", env);
      var context = {
        mode: parser2.mode,
        envName,
        parser: parser2
      };
      var result = env.handler(context, _args, optArgs);
      parser2.expect("\\end", false);
      var endNameToken = parser2.nextToken;
      var end = assertNodeType(parser2.parseFunction(), "environment");
      if (end.name !== envName) {
        throw new ParseError("Mismatch: \\begin{" + envName + "} matched by \\end{" + end.name + "}", endNameToken);
      }
      return result;
    }
    return {
      type: "environment",
      mode: parser2.mode,
      name: envName,
      nameGroup
    };
  }
});
var htmlBuilder$5 = (group, options) => {
  var font = group.font;
  var newOptions = options.withFont(font);
  return buildGroup$1(group.body, newOptions);
};
var mathmlBuilder$4 = (group, options) => {
  var font = group.font;
  var newOptions = options.withFont(font);
  return buildGroup2(group.body, newOptions);
};
var fontAliases = {
  "\\Bbb": "\\mathbb",
  "\\bold": "\\mathbf",
  "\\frak": "\\mathfrak",
  "\\bm": "\\boldsymbol"
};
defineFunction({
  type: "font",
  names: [
    // styles, except \boldsymbol defined below
    "\\mathrm",
    "\\mathit",
    "\\mathbf",
    "\\mathnormal",
    // families
    "\\mathbb",
    "\\mathcal",
    "\\mathfrak",
    "\\mathscr",
    "\\mathsf",
    "\\mathtt",
    // aliases, except \bm defined below
    "\\Bbb",
    "\\bold",
    "\\frak"
  ],
  props: {
    numArgs: 1,
    allowedInArgument: true
  },
  handler: (_ref, args) => {
    var {
      parser: parser2,
      funcName
    } = _ref;
    var body = normalizeArgument(args[0]);
    var func = funcName;
    if (func in fontAliases) {
      func = fontAliases[func];
    }
    return {
      type: "font",
      mode: parser2.mode,
      font: func.slice(1),
      body
    };
  },
  htmlBuilder: htmlBuilder$5,
  mathmlBuilder: mathmlBuilder$4
});
defineFunction({
  type: "mclass",
  names: ["\\boldsymbol", "\\bm"],
  props: {
    numArgs: 1
  },
  handler: (_ref2, args) => {
    var {
      parser: parser2
    } = _ref2;
    var body = args[0];
    var isCharacterBox3 = utils.isCharacterBox(body);
    return {
      type: "mclass",
      mode: parser2.mode,
      mclass: binrelClass(body),
      body: [{
        type: "font",
        mode: parser2.mode,
        font: "boldsymbol",
        body
      }],
      isCharacterBox: isCharacterBox3
    };
  }
});
defineFunction({
  type: "font",
  names: ["\\rm", "\\sf", "\\tt", "\\bf", "\\it", "\\cal"],
  props: {
    numArgs: 0,
    allowedInText: true
  },
  handler: (_ref3, args) => {
    var {
      parser: parser2,
      funcName,
      breakOnTokenText
    } = _ref3;
    var {
      mode
    } = parser2;
    var body = parser2.parseExpression(true, breakOnTokenText);
    var style = "math" + funcName.slice(1);
    return {
      type: "font",
      mode,
      font: style,
      body: {
        type: "ordgroup",
        mode: parser2.mode,
        body
      }
    };
  },
  htmlBuilder: htmlBuilder$5,
  mathmlBuilder: mathmlBuilder$4
});
var adjustStyle = (size2, originalStyle) => {
  var style = originalStyle;
  if (size2 === "display") {
    style = style.id >= Style$1.SCRIPT.id ? style.text() : Style$1.DISPLAY;
  } else if (size2 === "text" && style.size === Style$1.DISPLAY.size) {
    style = Style$1.TEXT;
  } else if (size2 === "script") {
    style = Style$1.SCRIPT;
  } else if (size2 === "scriptscript") {
    style = Style$1.SCRIPTSCRIPT;
  }
  return style;
};
var htmlBuilder$4 = (group, options) => {
  var style = adjustStyle(group.size, options.style);
  var nstyle = style.fracNum();
  var dstyle = style.fracDen();
  var newOptions;
  newOptions = options.havingStyle(nstyle);
  var numerm = buildGroup$1(group.numer, newOptions, options);
  if (group.continued) {
    var hStrut = 8.5 / options.fontMetrics().ptPerEm;
    var dStrut = 3.5 / options.fontMetrics().ptPerEm;
    numerm.height = numerm.height < hStrut ? hStrut : numerm.height;
    numerm.depth = numerm.depth < dStrut ? dStrut : numerm.depth;
  }
  newOptions = options.havingStyle(dstyle);
  var denomm = buildGroup$1(group.denom, newOptions, options);
  var rule;
  var ruleWidth;
  var ruleSpacing;
  if (group.hasBarLine) {
    if (group.barSize) {
      ruleWidth = calculateSize(group.barSize, options);
      rule = buildCommon.makeLineSpan("frac-line", options, ruleWidth);
    } else {
      rule = buildCommon.makeLineSpan("frac-line", options);
    }
    ruleWidth = rule.height;
    ruleSpacing = rule.height;
  } else {
    rule = null;
    ruleWidth = 0;
    ruleSpacing = options.fontMetrics().defaultRuleThickness;
  }
  var numShift;
  var clearance;
  var denomShift;
  if (style.size === Style$1.DISPLAY.size || group.size === "display") {
    numShift = options.fontMetrics().num1;
    if (ruleWidth > 0) {
      clearance = 3 * ruleSpacing;
    } else {
      clearance = 7 * ruleSpacing;
    }
    denomShift = options.fontMetrics().denom1;
  } else {
    if (ruleWidth > 0) {
      numShift = options.fontMetrics().num2;
      clearance = ruleSpacing;
    } else {
      numShift = options.fontMetrics().num3;
      clearance = 3 * ruleSpacing;
    }
    denomShift = options.fontMetrics().denom2;
  }
  var frac;
  if (!rule) {
    var candidateClearance = numShift - numerm.depth - (denomm.height - denomShift);
    if (candidateClearance < clearance) {
      numShift += 0.5 * (clearance - candidateClearance);
      denomShift += 0.5 * (clearance - candidateClearance);
    }
    frac = buildCommon.makeVList({
      positionType: "individualShift",
      children: [{
        type: "elem",
        elem: denomm,
        shift: denomShift
      }, {
        type: "elem",
        elem: numerm,
        shift: -numShift
      }]
    }, options);
  } else {
    var axisHeight = options.fontMetrics().axisHeight;
    if (numShift - numerm.depth - (axisHeight + 0.5 * ruleWidth) < clearance) {
      numShift += clearance - (numShift - numerm.depth - (axisHeight + 0.5 * ruleWidth));
    }
    if (axisHeight - 0.5 * ruleWidth - (denomm.height - denomShift) < clearance) {
      denomShift += clearance - (axisHeight - 0.5 * ruleWidth - (denomm.height - denomShift));
    }
    var midShift = -(axisHeight - 0.5 * ruleWidth);
    frac = buildCommon.makeVList({
      positionType: "individualShift",
      children: [{
        type: "elem",
        elem: denomm,
        shift: denomShift
      }, {
        type: "elem",
        elem: rule,
        shift: midShift
      }, {
        type: "elem",
        elem: numerm,
        shift: -numShift
      }]
    }, options);
  }
  newOptions = options.havingStyle(style);
  frac.height *= newOptions.sizeMultiplier / options.sizeMultiplier;
  frac.depth *= newOptions.sizeMultiplier / options.sizeMultiplier;
  var delimSize;
  if (style.size === Style$1.DISPLAY.size) {
    delimSize = options.fontMetrics().delim1;
  } else if (style.size === Style$1.SCRIPTSCRIPT.size) {
    delimSize = options.havingStyle(Style$1.SCRIPT).fontMetrics().delim2;
  } else {
    delimSize = options.fontMetrics().delim2;
  }
  var leftDelim;
  var rightDelim;
  if (group.leftDelim == null) {
    leftDelim = makeNullDelimiter(options, ["mopen"]);
  } else {
    leftDelim = delimiter2.customSizedDelim(group.leftDelim, delimSize, true, options.havingStyle(style), group.mode, ["mopen"]);
  }
  if (group.continued) {
    rightDelim = buildCommon.makeSpan([]);
  } else if (group.rightDelim == null) {
    rightDelim = makeNullDelimiter(options, ["mclose"]);
  } else {
    rightDelim = delimiter2.customSizedDelim(group.rightDelim, delimSize, true, options.havingStyle(style), group.mode, ["mclose"]);
  }
  return buildCommon.makeSpan(["mord"].concat(newOptions.sizingClasses(options)), [leftDelim, buildCommon.makeSpan(["mfrac"], [frac]), rightDelim], options);
};
var mathmlBuilder$3 = (group, options) => {
  var node3 = new mathMLTree.MathNode("mfrac", [buildGroup2(group.numer, options), buildGroup2(group.denom, options)]);
  if (!group.hasBarLine) {
    node3.setAttribute("linethickness", "0px");
  } else if (group.barSize) {
    var ruleWidth = calculateSize(group.barSize, options);
    node3.setAttribute("linethickness", makeEm(ruleWidth));
  }
  var style = adjustStyle(group.size, options.style);
  if (style.size !== options.style.size) {
    node3 = new mathMLTree.MathNode("mstyle", [node3]);
    var isDisplay = style.size === Style$1.DISPLAY.size ? "true" : "false";
    node3.setAttribute("displaystyle", isDisplay);
    node3.setAttribute("scriptlevel", "0");
  }
  if (group.leftDelim != null || group.rightDelim != null) {
    var withDelims = [];
    if (group.leftDelim != null) {
      var leftOp = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode(group.leftDelim.replace("\\", ""))]);
      leftOp.setAttribute("fence", "true");
      withDelims.push(leftOp);
    }
    withDelims.push(node3);
    if (group.rightDelim != null) {
      var rightOp = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode(group.rightDelim.replace("\\", ""))]);
      rightOp.setAttribute("fence", "true");
      withDelims.push(rightOp);
    }
    return makeRow(withDelims);
  }
  return node3;
};
defineFunction({
  type: "genfrac",
  names: [
    "\\dfrac",
    "\\frac",
    "\\tfrac",
    "\\dbinom",
    "\\binom",
    "\\tbinom",
    "\\\\atopfrac",
    // can’t be entered directly
    "\\\\bracefrac",
    "\\\\brackfrac"
    // ditto
  ],
  props: {
    numArgs: 2,
    allowedInArgument: true
  },
  handler: (_ref, args) => {
    var {
      parser: parser2,
      funcName
    } = _ref;
    var numer = args[0];
    var denom = args[1];
    var hasBarLine;
    var leftDelim = null;
    var rightDelim = null;
    var size2 = "auto";
    switch (funcName) {
      case "\\dfrac":
      case "\\frac":
      case "\\tfrac":
        hasBarLine = true;
        break;
      case "\\\\atopfrac":
        hasBarLine = false;
        break;
      case "\\dbinom":
      case "\\binom":
      case "\\tbinom":
        hasBarLine = false;
        leftDelim = "(";
        rightDelim = ")";
        break;
      case "\\\\bracefrac":
        hasBarLine = false;
        leftDelim = "\\{";
        rightDelim = "\\}";
        break;
      case "\\\\brackfrac":
        hasBarLine = false;
        leftDelim = "[";
        rightDelim = "]";
        break;
      default:
        throw new Error("Unrecognized genfrac command");
    }
    switch (funcName) {
      case "\\dfrac":
      case "\\dbinom":
        size2 = "display";
        break;
      case "\\tfrac":
      case "\\tbinom":
        size2 = "text";
        break;
    }
    return {
      type: "genfrac",
      mode: parser2.mode,
      continued: false,
      numer,
      denom,
      hasBarLine,
      leftDelim,
      rightDelim,
      size: size2,
      barSize: null
    };
  },
  htmlBuilder: htmlBuilder$4,
  mathmlBuilder: mathmlBuilder$3
});
defineFunction({
  type: "genfrac",
  names: ["\\cfrac"],
  props: {
    numArgs: 2
  },
  handler: (_ref2, args) => {
    var {
      parser: parser2,
      funcName
    } = _ref2;
    var numer = args[0];
    var denom = args[1];
    return {
      type: "genfrac",
      mode: parser2.mode,
      continued: true,
      numer,
      denom,
      hasBarLine: true,
      leftDelim: null,
      rightDelim: null,
      size: "display",
      barSize: null
    };
  }
});
defineFunction({
  type: "infix",
  names: ["\\over", "\\choose", "\\atop", "\\brace", "\\brack"],
  props: {
    numArgs: 0,
    infix: true
  },
  handler(_ref3) {
    var {
      parser: parser2,
      funcName,
      token
    } = _ref3;
    var replaceWith;
    switch (funcName) {
      case "\\over":
        replaceWith = "\\frac";
        break;
      case "\\choose":
        replaceWith = "\\binom";
        break;
      case "\\atop":
        replaceWith = "\\\\atopfrac";
        break;
      case "\\brace":
        replaceWith = "\\\\bracefrac";
        break;
      case "\\brack":
        replaceWith = "\\\\brackfrac";
        break;
      default:
        throw new Error("Unrecognized infix genfrac command");
    }
    return {
      type: "infix",
      mode: parser2.mode,
      replaceWith,
      token
    };
  }
});
var stylArray = ["display", "text", "script", "scriptscript"];
var delimFromValue = function delimFromValue2(delimString) {
  var delim = null;
  if (delimString.length > 0) {
    delim = delimString;
    delim = delim === "." ? null : delim;
  }
  return delim;
};
defineFunction({
  type: "genfrac",
  names: ["\\genfrac"],
  props: {
    numArgs: 6,
    allowedInArgument: true,
    argTypes: ["math", "math", "size", "text", "math", "math"]
  },
  handler(_ref4, args) {
    var {
      parser: parser2
    } = _ref4;
    var numer = args[4];
    var denom = args[5];
    var leftNode = normalizeArgument(args[0]);
    var leftDelim = leftNode.type === "atom" && leftNode.family === "open" ? delimFromValue(leftNode.text) : null;
    var rightNode = normalizeArgument(args[1]);
    var rightDelim = rightNode.type === "atom" && rightNode.family === "close" ? delimFromValue(rightNode.text) : null;
    var barNode = assertNodeType(args[2], "size");
    var hasBarLine;
    var barSize = null;
    if (barNode.isBlank) {
      hasBarLine = true;
    } else {
      barSize = barNode.value;
      hasBarLine = barSize.number > 0;
    }
    var size2 = "auto";
    var styl = args[3];
    if (styl.type === "ordgroup") {
      if (styl.body.length > 0) {
        var textOrd = assertNodeType(styl.body[0], "textord");
        size2 = stylArray[Number(textOrd.text)];
      }
    } else {
      styl = assertNodeType(styl, "textord");
      size2 = stylArray[Number(styl.text)];
    }
    return {
      type: "genfrac",
      mode: parser2.mode,
      numer,
      denom,
      continued: false,
      hasBarLine,
      barSize,
      leftDelim,
      rightDelim,
      size: size2
    };
  },
  htmlBuilder: htmlBuilder$4,
  mathmlBuilder: mathmlBuilder$3
});
defineFunction({
  type: "infix",
  names: ["\\above"],
  props: {
    numArgs: 1,
    argTypes: ["size"],
    infix: true
  },
  handler(_ref5, args) {
    var {
      parser: parser2,
      funcName,
      token
    } = _ref5;
    return {
      type: "infix",
      mode: parser2.mode,
      replaceWith: "\\\\abovefrac",
      size: assertNodeType(args[0], "size").value,
      token
    };
  }
});
defineFunction({
  type: "genfrac",
  names: ["\\\\abovefrac"],
  props: {
    numArgs: 3,
    argTypes: ["math", "size", "math"]
  },
  handler: (_ref6, args) => {
    var {
      parser: parser2,
      funcName
    } = _ref6;
    var numer = args[0];
    var barSize = assert(assertNodeType(args[1], "infix").size);
    var denom = args[2];
    var hasBarLine = barSize.number > 0;
    return {
      type: "genfrac",
      mode: parser2.mode,
      numer,
      denom,
      continued: false,
      hasBarLine,
      barSize,
      leftDelim: null,
      rightDelim: null,
      size: "auto"
    };
  },
  htmlBuilder: htmlBuilder$4,
  mathmlBuilder: mathmlBuilder$3
});
var htmlBuilder$3 = (grp, options) => {
  var style = options.style;
  var supSubGroup;
  var group;
  if (grp.type === "supsub") {
    supSubGroup = grp.sup ? buildGroup$1(grp.sup, options.havingStyle(style.sup()), options) : buildGroup$1(grp.sub, options.havingStyle(style.sub()), options);
    group = assertNodeType(grp.base, "horizBrace");
  } else {
    group = assertNodeType(grp, "horizBrace");
  }
  var body = buildGroup$1(group.base, options.havingBaseStyle(Style$1.DISPLAY));
  var braceBody = stretchy.svgSpan(group, options);
  var vlist;
  if (group.isOver) {
    vlist = buildCommon.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: body
      }, {
        type: "kern",
        size: 0.1
      }, {
        type: "elem",
        elem: braceBody
      }]
    }, options);
    vlist.children[0].children[0].children[1].classes.push("svg-align");
  } else {
    vlist = buildCommon.makeVList({
      positionType: "bottom",
      positionData: body.depth + 0.1 + braceBody.height,
      children: [{
        type: "elem",
        elem: braceBody
      }, {
        type: "kern",
        size: 0.1
      }, {
        type: "elem",
        elem: body
      }]
    }, options);
    vlist.children[0].children[0].children[0].classes.push("svg-align");
  }
  if (supSubGroup) {
    var vSpan = buildCommon.makeSpan(["mord", group.isOver ? "mover" : "munder"], [vlist], options);
    if (group.isOver) {
      vlist = buildCommon.makeVList({
        positionType: "firstBaseline",
        children: [{
          type: "elem",
          elem: vSpan
        }, {
          type: "kern",
          size: 0.2
        }, {
          type: "elem",
          elem: supSubGroup
        }]
      }, options);
    } else {
      vlist = buildCommon.makeVList({
        positionType: "bottom",
        positionData: vSpan.depth + 0.2 + supSubGroup.height + supSubGroup.depth,
        children: [{
          type: "elem",
          elem: supSubGroup
        }, {
          type: "kern",
          size: 0.2
        }, {
          type: "elem",
          elem: vSpan
        }]
      }, options);
    }
  }
  return buildCommon.makeSpan(["mord", group.isOver ? "mover" : "munder"], [vlist], options);
};
var mathmlBuilder$2 = (group, options) => {
  var accentNode = stretchy.mathMLnode(group.label);
  return new mathMLTree.MathNode(group.isOver ? "mover" : "munder", [buildGroup2(group.base, options), accentNode]);
};
defineFunction({
  type: "horizBrace",
  names: ["\\overbrace", "\\underbrace"],
  props: {
    numArgs: 1
  },
  handler(_ref, args) {
    var {
      parser: parser2,
      funcName
    } = _ref;
    return {
      type: "horizBrace",
      mode: parser2.mode,
      label: funcName,
      isOver: /^\\over/.test(funcName),
      base: args[0]
    };
  },
  htmlBuilder: htmlBuilder$3,
  mathmlBuilder: mathmlBuilder$2
});
defineFunction({
  type: "href",
  names: ["\\href"],
  props: {
    numArgs: 2,
    argTypes: ["url", "original"],
    allowedInText: true
  },
  handler: (_ref, args) => {
    var {
      parser: parser2
    } = _ref;
    var body = args[1];
    var href = assertNodeType(args[0], "url").url;
    if (!parser2.settings.isTrusted({
      command: "\\href",
      url: href
    })) {
      return parser2.formatUnsupportedCmd("\\href");
    }
    return {
      type: "href",
      mode: parser2.mode,
      href,
      body: ordargument(body)
    };
  },
  htmlBuilder: (group, options) => {
    var elements3 = buildExpression$1(group.body, options, false);
    return buildCommon.makeAnchor(group.href, [], elements3, options);
  },
  mathmlBuilder: (group, options) => {
    var math2 = buildExpressionRow(group.body, options);
    if (!(math2 instanceof MathNode)) {
      math2 = new MathNode("mrow", [math2]);
    }
    math2.setAttribute("href", group.href);
    return math2;
  }
});
defineFunction({
  type: "href",
  names: ["\\url"],
  props: {
    numArgs: 1,
    argTypes: ["url"],
    allowedInText: true
  },
  handler: (_ref2, args) => {
    var {
      parser: parser2
    } = _ref2;
    var href = assertNodeType(args[0], "url").url;
    if (!parser2.settings.isTrusted({
      command: "\\url",
      url: href
    })) {
      return parser2.formatUnsupportedCmd("\\url");
    }
    var chars = [];
    for (var i2 = 0; i2 < href.length; i2++) {
      var c3 = href[i2];
      if (c3 === "~") {
        c3 = "\\textasciitilde";
      }
      chars.push({
        type: "textord",
        mode: "text",
        text: c3
      });
    }
    var body = {
      type: "text",
      mode: parser2.mode,
      font: "\\texttt",
      body: chars
    };
    return {
      type: "href",
      mode: parser2.mode,
      href,
      body: ordargument(body)
    };
  }
});
defineFunction({
  type: "hbox",
  names: ["\\hbox"],
  props: {
    numArgs: 1,
    argTypes: ["text"],
    allowedInText: true,
    primitive: true
  },
  handler(_ref, args) {
    var {
      parser: parser2
    } = _ref;
    return {
      type: "hbox",
      mode: parser2.mode,
      body: ordargument(args[0])
    };
  },
  htmlBuilder(group, options) {
    var elements3 = buildExpression$1(group.body, options, false);
    return buildCommon.makeFragment(elements3);
  },
  mathmlBuilder(group, options) {
    return new mathMLTree.MathNode("mrow", buildExpression2(group.body, options));
  }
});
defineFunction({
  type: "html",
  names: ["\\htmlClass", "\\htmlId", "\\htmlStyle", "\\htmlData"],
  props: {
    numArgs: 2,
    argTypes: ["raw", "original"],
    allowedInText: true
  },
  handler: (_ref, args) => {
    var {
      parser: parser2,
      funcName,
      token
    } = _ref;
    var value = assertNodeType(args[0], "raw").string;
    var body = args[1];
    if (parser2.settings.strict) {
      parser2.settings.reportNonstrict("htmlExtension", "HTML extension is disabled on strict mode");
    }
    var trustContext;
    var attributes = {};
    switch (funcName) {
      case "\\htmlClass":
        attributes.class = value;
        trustContext = {
          command: "\\htmlClass",
          class: value
        };
        break;
      case "\\htmlId":
        attributes.id = value;
        trustContext = {
          command: "\\htmlId",
          id: value
        };
        break;
      case "\\htmlStyle":
        attributes.style = value;
        trustContext = {
          command: "\\htmlStyle",
          style: value
        };
        break;
      case "\\htmlData": {
        var data2 = value.split(",");
        for (var i2 = 0; i2 < data2.length; i2++) {
          var keyVal = data2[i2].split("=");
          if (keyVal.length !== 2) {
            throw new ParseError("Error parsing key-value for \\htmlData");
          }
          attributes["data-" + keyVal[0].trim()] = keyVal[1].trim();
        }
        trustContext = {
          command: "\\htmlData",
          attributes
        };
        break;
      }
      default:
        throw new Error("Unrecognized html command");
    }
    if (!parser2.settings.isTrusted(trustContext)) {
      return parser2.formatUnsupportedCmd(funcName);
    }
    return {
      type: "html",
      mode: parser2.mode,
      attributes,
      body: ordargument(body)
    };
  },
  htmlBuilder: (group, options) => {
    var elements3 = buildExpression$1(group.body, options, false);
    var classes2 = ["enclosing"];
    if (group.attributes.class) {
      classes2.push(...group.attributes.class.trim().split(/\s+/));
    }
    var span = buildCommon.makeSpan(classes2, elements3, options);
    for (var attr2 in group.attributes) {
      if (attr2 !== "class" && group.attributes.hasOwnProperty(attr2)) {
        span.setAttribute(attr2, group.attributes[attr2]);
      }
    }
    return span;
  },
  mathmlBuilder: (group, options) => {
    return buildExpressionRow(group.body, options);
  }
});
defineFunction({
  type: "htmlmathml",
  names: ["\\html@mathml"],
  props: {
    numArgs: 2,
    allowedInText: true
  },
  handler: (_ref, args) => {
    var {
      parser: parser2
    } = _ref;
    return {
      type: "htmlmathml",
      mode: parser2.mode,
      html: ordargument(args[0]),
      mathml: ordargument(args[1])
    };
  },
  htmlBuilder: (group, options) => {
    var elements3 = buildExpression$1(group.html, options, false);
    return buildCommon.makeFragment(elements3);
  },
  mathmlBuilder: (group, options) => {
    return buildExpressionRow(group.mathml, options);
  }
});
var sizeData = function sizeData2(str) {
  if (/^[-+]? *(\d+(\.\d*)?|\.\d+)$/.test(str)) {
    return {
      number: +str,
      unit: "bp"
    };
  } else {
    var match = /([-+]?) *(\d+(?:\.\d*)?|\.\d+) *([a-z]{2})/.exec(str);
    if (!match) {
      throw new ParseError("Invalid size: '" + str + "' in \\includegraphics");
    }
    var data2 = {
      number: +(match[1] + match[2]),
      // sign + magnitude, cast to number
      unit: match[3]
    };
    if (!validUnit(data2)) {
      throw new ParseError("Invalid unit: '" + data2.unit + "' in \\includegraphics.");
    }
    return data2;
  }
};
defineFunction({
  type: "includegraphics",
  names: ["\\includegraphics"],
  props: {
    numArgs: 1,
    numOptionalArgs: 1,
    argTypes: ["raw", "url"],
    allowedInText: false
  },
  handler: (_ref, args, optArgs) => {
    var {
      parser: parser2
    } = _ref;
    var width2 = {
      number: 0,
      unit: "em"
    };
    var height2 = {
      number: 0.9,
      unit: "em"
    };
    var totalheight = {
      number: 0,
      unit: "em"
    };
    var alt = "";
    if (optArgs[0]) {
      var attributeStr = assertNodeType(optArgs[0], "raw").string;
      var attributes = attributeStr.split(",");
      for (var i2 = 0; i2 < attributes.length; i2++) {
        var keyVal = attributes[i2].split("=");
        if (keyVal.length === 2) {
          var str = keyVal[1].trim();
          switch (keyVal[0].trim()) {
            case "alt":
              alt = str;
              break;
            case "width":
              width2 = sizeData(str);
              break;
            case "height":
              height2 = sizeData(str);
              break;
            case "totalheight":
              totalheight = sizeData(str);
              break;
            default:
              throw new ParseError("Invalid key: '" + keyVal[0] + "' in \\includegraphics.");
          }
        }
      }
    }
    var src = assertNodeType(args[0], "url").url;
    if (alt === "") {
      alt = src;
      alt = alt.replace(/^.*[\\/]/, "");
      alt = alt.substring(0, alt.lastIndexOf("."));
    }
    if (!parser2.settings.isTrusted({
      command: "\\includegraphics",
      url: src
    })) {
      return parser2.formatUnsupportedCmd("\\includegraphics");
    }
    return {
      type: "includegraphics",
      mode: parser2.mode,
      alt,
      width: width2,
      height: height2,
      totalheight,
      src
    };
  },
  htmlBuilder: (group, options) => {
    var height2 = calculateSize(group.height, options);
    var depth = 0;
    if (group.totalheight.number > 0) {
      depth = calculateSize(group.totalheight, options) - height2;
    }
    var width2 = 0;
    if (group.width.number > 0) {
      width2 = calculateSize(group.width, options);
    }
    var style = {
      height: makeEm(height2 + depth)
    };
    if (width2 > 0) {
      style.width = makeEm(width2);
    }
    if (depth > 0) {
      style.verticalAlign = makeEm(-depth);
    }
    var node3 = new Img(group.src, group.alt, style);
    node3.height = height2;
    node3.depth = depth;
    return node3;
  },
  mathmlBuilder: (group, options) => {
    var node3 = new mathMLTree.MathNode("mglyph", []);
    node3.setAttribute("alt", group.alt);
    var height2 = calculateSize(group.height, options);
    var depth = 0;
    if (group.totalheight.number > 0) {
      depth = calculateSize(group.totalheight, options) - height2;
      node3.setAttribute("valign", makeEm(-depth));
    }
    node3.setAttribute("height", makeEm(height2 + depth));
    if (group.width.number > 0) {
      var width2 = calculateSize(group.width, options);
      node3.setAttribute("width", makeEm(width2));
    }
    node3.setAttribute("src", group.src);
    return node3;
  }
});
defineFunction({
  type: "kern",
  names: ["\\kern", "\\mkern", "\\hskip", "\\mskip"],
  props: {
    numArgs: 1,
    argTypes: ["size"],
    primitive: true,
    allowedInText: true
  },
  handler(_ref, args) {
    var {
      parser: parser2,
      funcName
    } = _ref;
    var size2 = assertNodeType(args[0], "size");
    if (parser2.settings.strict) {
      var mathFunction = funcName[1] === "m";
      var muUnit = size2.value.unit === "mu";
      if (mathFunction) {
        if (!muUnit) {
          parser2.settings.reportNonstrict("mathVsTextUnits", "LaTeX's " + funcName + " supports only mu units, " + ("not " + size2.value.unit + " units"));
        }
        if (parser2.mode !== "math") {
          parser2.settings.reportNonstrict("mathVsTextUnits", "LaTeX's " + funcName + " works only in math mode");
        }
      } else {
        if (muUnit) {
          parser2.settings.reportNonstrict("mathVsTextUnits", "LaTeX's " + funcName + " doesn't support mu units");
        }
      }
    }
    return {
      type: "kern",
      mode: parser2.mode,
      dimension: size2.value
    };
  },
  htmlBuilder(group, options) {
    return buildCommon.makeGlue(group.dimension, options);
  },
  mathmlBuilder(group, options) {
    var dimension = calculateSize(group.dimension, options);
    return new mathMLTree.SpaceNode(dimension);
  }
});
defineFunction({
  type: "lap",
  names: ["\\mathllap", "\\mathrlap", "\\mathclap"],
  props: {
    numArgs: 1,
    allowedInText: true
  },
  handler: (_ref, args) => {
    var {
      parser: parser2,
      funcName
    } = _ref;
    var body = args[0];
    return {
      type: "lap",
      mode: parser2.mode,
      alignment: funcName.slice(5),
      body
    };
  },
  htmlBuilder: (group, options) => {
    var inner2;
    if (group.alignment === "clap") {
      inner2 = buildCommon.makeSpan([], [buildGroup$1(group.body, options)]);
      inner2 = buildCommon.makeSpan(["inner"], [inner2], options);
    } else {
      inner2 = buildCommon.makeSpan(["inner"], [buildGroup$1(group.body, options)]);
    }
    var fix = buildCommon.makeSpan(["fix"], []);
    var node3 = buildCommon.makeSpan([group.alignment], [inner2, fix], options);
    var strut = buildCommon.makeSpan(["strut"]);
    strut.style.height = makeEm(node3.height + node3.depth);
    if (node3.depth) {
      strut.style.verticalAlign = makeEm(-node3.depth);
    }
    node3.children.unshift(strut);
    node3 = buildCommon.makeSpan(["thinbox"], [node3], options);
    return buildCommon.makeSpan(["mord", "vbox"], [node3], options);
  },
  mathmlBuilder: (group, options) => {
    var node3 = new mathMLTree.MathNode("mpadded", [buildGroup2(group.body, options)]);
    if (group.alignment !== "rlap") {
      var offset = group.alignment === "llap" ? "-1" : "-0.5";
      node3.setAttribute("lspace", offset + "width");
    }
    node3.setAttribute("width", "0px");
    return node3;
  }
});
defineFunction({
  type: "styling",
  names: ["\\(", "$"],
  props: {
    numArgs: 0,
    allowedInText: true,
    allowedInMath: false
  },
  handler(_ref, args) {
    var {
      funcName,
      parser: parser2
    } = _ref;
    var outerMode = parser2.mode;
    parser2.switchMode("math");
    var close3 = funcName === "\\(" ? "\\)" : "$";
    var body = parser2.parseExpression(false, close3);
    parser2.expect(close3);
    parser2.switchMode(outerMode);
    return {
      type: "styling",
      mode: parser2.mode,
      style: "text",
      body
    };
  }
});
defineFunction({
  type: "text",
  // Doesn't matter what this is.
  names: ["\\)", "\\]"],
  props: {
    numArgs: 0,
    allowedInText: true,
    allowedInMath: false
  },
  handler(context, args) {
    throw new ParseError("Mismatched " + context.funcName);
  }
});
var chooseMathStyle = (group, options) => {
  switch (options.style.size) {
    case Style$1.DISPLAY.size:
      return group.display;
    case Style$1.TEXT.size:
      return group.text;
    case Style$1.SCRIPT.size:
      return group.script;
    case Style$1.SCRIPTSCRIPT.size:
      return group.scriptscript;
    default:
      return group.text;
  }
};
defineFunction({
  type: "mathchoice",
  names: ["\\mathchoice"],
  props: {
    numArgs: 4,
    primitive: true
  },
  handler: (_ref, args) => {
    var {
      parser: parser2
    } = _ref;
    return {
      type: "mathchoice",
      mode: parser2.mode,
      display: ordargument(args[0]),
      text: ordargument(args[1]),
      script: ordargument(args[2]),
      scriptscript: ordargument(args[3])
    };
  },
  htmlBuilder: (group, options) => {
    var body = chooseMathStyle(group, options);
    var elements3 = buildExpression$1(body, options, false);
    return buildCommon.makeFragment(elements3);
  },
  mathmlBuilder: (group, options) => {
    var body = chooseMathStyle(group, options);
    return buildExpressionRow(body, options);
  }
});
var assembleSupSub = (base, supGroup, subGroup, options, style, slant, baseShift) => {
  base = buildCommon.makeSpan([], [base]);
  var subIsSingleCharacter = subGroup && utils.isCharacterBox(subGroup);
  var sub2;
  var sup2;
  if (supGroup) {
    var elem = buildGroup$1(supGroup, options.havingStyle(style.sup()), options);
    sup2 = {
      elem,
      kern: Math.max(options.fontMetrics().bigOpSpacing1, options.fontMetrics().bigOpSpacing3 - elem.depth)
    };
  }
  if (subGroup) {
    var _elem = buildGroup$1(subGroup, options.havingStyle(style.sub()), options);
    sub2 = {
      elem: _elem,
      kern: Math.max(options.fontMetrics().bigOpSpacing2, options.fontMetrics().bigOpSpacing4 - _elem.height)
    };
  }
  var finalGroup;
  if (sup2 && sub2) {
    var bottom = options.fontMetrics().bigOpSpacing5 + sub2.elem.height + sub2.elem.depth + sub2.kern + base.depth + baseShift;
    finalGroup = buildCommon.makeVList({
      positionType: "bottom",
      positionData: bottom,
      children: [{
        type: "kern",
        size: options.fontMetrics().bigOpSpacing5
      }, {
        type: "elem",
        elem: sub2.elem,
        marginLeft: makeEm(-slant)
      }, {
        type: "kern",
        size: sub2.kern
      }, {
        type: "elem",
        elem: base
      }, {
        type: "kern",
        size: sup2.kern
      }, {
        type: "elem",
        elem: sup2.elem,
        marginLeft: makeEm(slant)
      }, {
        type: "kern",
        size: options.fontMetrics().bigOpSpacing5
      }]
    }, options);
  } else if (sub2) {
    var top = base.height - baseShift;
    finalGroup = buildCommon.makeVList({
      positionType: "top",
      positionData: top,
      children: [{
        type: "kern",
        size: options.fontMetrics().bigOpSpacing5
      }, {
        type: "elem",
        elem: sub2.elem,
        marginLeft: makeEm(-slant)
      }, {
        type: "kern",
        size: sub2.kern
      }, {
        type: "elem",
        elem: base
      }]
    }, options);
  } else if (sup2) {
    var _bottom = base.depth + baseShift;
    finalGroup = buildCommon.makeVList({
      positionType: "bottom",
      positionData: _bottom,
      children: [{
        type: "elem",
        elem: base
      }, {
        type: "kern",
        size: sup2.kern
      }, {
        type: "elem",
        elem: sup2.elem,
        marginLeft: makeEm(slant)
      }, {
        type: "kern",
        size: options.fontMetrics().bigOpSpacing5
      }]
    }, options);
  } else {
    return base;
  }
  var parts = [finalGroup];
  if (sub2 && slant !== 0 && !subIsSingleCharacter) {
    var spacer = buildCommon.makeSpan(["mspace"], [], options);
    spacer.style.marginRight = makeEm(slant);
    parts.unshift(spacer);
  }
  return buildCommon.makeSpan(["mop", "op-limits"], parts, options);
};
var noSuccessor = ["\\smallint"];
var htmlBuilder$2 = (grp, options) => {
  var supGroup;
  var subGroup;
  var hasLimits = false;
  var group;
  if (grp.type === "supsub") {
    supGroup = grp.sup;
    subGroup = grp.sub;
    group = assertNodeType(grp.base, "op");
    hasLimits = true;
  } else {
    group = assertNodeType(grp, "op");
  }
  var style = options.style;
  var large = false;
  if (style.size === Style$1.DISPLAY.size && group.symbol && !utils.contains(noSuccessor, group.name)) {
    large = true;
  }
  var base;
  if (group.symbol) {
    var fontName = large ? "Size2-Regular" : "Size1-Regular";
    var stash = "";
    if (group.name === "\\oiint" || group.name === "\\oiiint") {
      stash = group.name.slice(1);
      group.name = stash === "oiint" ? "\\iint" : "\\iiint";
    }
    base = buildCommon.makeSymbol(group.name, fontName, "math", options, ["mop", "op-symbol", large ? "large-op" : "small-op"]);
    if (stash.length > 0) {
      var italic = base.italic;
      var oval = buildCommon.staticSvg(stash + "Size" + (large ? "2" : "1"), options);
      base = buildCommon.makeVList({
        positionType: "individualShift",
        children: [{
          type: "elem",
          elem: base,
          shift: 0
        }, {
          type: "elem",
          elem: oval,
          shift: large ? 0.08 : 0
        }]
      }, options);
      group.name = "\\" + stash;
      base.classes.unshift("mop");
      base.italic = italic;
    }
  } else if (group.body) {
    var inner2 = buildExpression$1(group.body, options, true);
    if (inner2.length === 1 && inner2[0] instanceof SymbolNode) {
      base = inner2[0];
      base.classes[0] = "mop";
    } else {
      base = buildCommon.makeSpan(["mop"], inner2, options);
    }
  } else {
    var output = [];
    for (var i2 = 1; i2 < group.name.length; i2++) {
      output.push(buildCommon.mathsym(group.name[i2], group.mode, options));
    }
    base = buildCommon.makeSpan(["mop"], output, options);
  }
  var baseShift = 0;
  var slant = 0;
  if ((base instanceof SymbolNode || group.name === "\\oiint" || group.name === "\\oiiint") && !group.suppressBaseShift) {
    baseShift = (base.height - base.depth) / 2 - options.fontMetrics().axisHeight;
    slant = base.italic;
  }
  if (hasLimits) {
    return assembleSupSub(base, supGroup, subGroup, options, style, slant, baseShift);
  } else {
    if (baseShift) {
      base.style.position = "relative";
      base.style.top = makeEm(baseShift);
    }
    return base;
  }
};
var mathmlBuilder$1 = (group, options) => {
  var node3;
  if (group.symbol) {
    node3 = new MathNode("mo", [makeText(group.name, group.mode)]);
    if (utils.contains(noSuccessor, group.name)) {
      node3.setAttribute("largeop", "false");
    }
  } else if (group.body) {
    node3 = new MathNode("mo", buildExpression2(group.body, options));
  } else {
    node3 = new MathNode("mi", [new TextNode2(group.name.slice(1))]);
    var operator = new MathNode("mo", [makeText("\u2061", "text")]);
    if (group.parentIsSupSub) {
      node3 = new MathNode("mrow", [node3, operator]);
    } else {
      node3 = newDocumentFragment([node3, operator]);
    }
  }
  return node3;
};
var singleCharBigOps = {
  "\u220F": "\\prod",
  "\u2210": "\\coprod",
  "\u2211": "\\sum",
  "\u22C0": "\\bigwedge",
  "\u22C1": "\\bigvee",
  "\u22C2": "\\bigcap",
  "\u22C3": "\\bigcup",
  "\u2A00": "\\bigodot",
  "\u2A01": "\\bigoplus",
  "\u2A02": "\\bigotimes",
  "\u2A04": "\\biguplus",
  "\u2A06": "\\bigsqcup"
};
defineFunction({
  type: "op",
  names: ["\\coprod", "\\bigvee", "\\bigwedge", "\\biguplus", "\\bigcap", "\\bigcup", "\\intop", "\\prod", "\\sum", "\\bigotimes", "\\bigoplus", "\\bigodot", "\\bigsqcup", "\\smallint", "\u220F", "\u2210", "\u2211", "\u22C0", "\u22C1", "\u22C2", "\u22C3", "\u2A00", "\u2A01", "\u2A02", "\u2A04", "\u2A06"],
  props: {
    numArgs: 0
  },
  handler: (_ref, args) => {
    var {
      parser: parser2,
      funcName
    } = _ref;
    var fName = funcName;
    if (fName.length === 1) {
      fName = singleCharBigOps[fName];
    }
    return {
      type: "op",
      mode: parser2.mode,
      limits: true,
      parentIsSupSub: false,
      symbol: true,
      name: fName
    };
  },
  htmlBuilder: htmlBuilder$2,
  mathmlBuilder: mathmlBuilder$1
});
defineFunction({
  type: "op",
  names: ["\\mathop"],
  props: {
    numArgs: 1,
    primitive: true
  },
  handler: (_ref2, args) => {
    var {
      parser: parser2
    } = _ref2;
    var body = args[0];
    return {
      type: "op",
      mode: parser2.mode,
      limits: false,
      parentIsSupSub: false,
      symbol: false,
      body: ordargument(body)
    };
  },
  htmlBuilder: htmlBuilder$2,
  mathmlBuilder: mathmlBuilder$1
});
var singleCharIntegrals = {
  "\u222B": "\\int",
  "\u222C": "\\iint",
  "\u222D": "\\iiint",
  "\u222E": "\\oint",
  "\u222F": "\\oiint",
  "\u2230": "\\oiiint"
};
defineFunction({
  type: "op",
  names: ["\\arcsin", "\\arccos", "\\arctan", "\\arctg", "\\arcctg", "\\arg", "\\ch", "\\cos", "\\cosec", "\\cosh", "\\cot", "\\cotg", "\\coth", "\\csc", "\\ctg", "\\cth", "\\deg", "\\dim", "\\exp", "\\hom", "\\ker", "\\lg", "\\ln", "\\log", "\\sec", "\\sin", "\\sinh", "\\sh", "\\tan", "\\tanh", "\\tg", "\\th"],
  props: {
    numArgs: 0
  },
  handler(_ref3) {
    var {
      parser: parser2,
      funcName
    } = _ref3;
    return {
      type: "op",
      mode: parser2.mode,
      limits: false,
      parentIsSupSub: false,
      symbol: false,
      name: funcName
    };
  },
  htmlBuilder: htmlBuilder$2,
  mathmlBuilder: mathmlBuilder$1
});
defineFunction({
  type: "op",
  names: ["\\det", "\\gcd", "\\inf", "\\lim", "\\max", "\\min", "\\Pr", "\\sup"],
  props: {
    numArgs: 0
  },
  handler(_ref4) {
    var {
      parser: parser2,
      funcName
    } = _ref4;
    return {
      type: "op",
      mode: parser2.mode,
      limits: true,
      parentIsSupSub: false,
      symbol: false,
      name: funcName
    };
  },
  htmlBuilder: htmlBuilder$2,
  mathmlBuilder: mathmlBuilder$1
});
defineFunction({
  type: "op",
  names: ["\\int", "\\iint", "\\iiint", "\\oint", "\\oiint", "\\oiiint", "\u222B", "\u222C", "\u222D", "\u222E", "\u222F", "\u2230"],
  props: {
    numArgs: 0
  },
  handler(_ref5) {
    var {
      parser: parser2,
      funcName
    } = _ref5;
    var fName = funcName;
    if (fName.length === 1) {
      fName = singleCharIntegrals[fName];
    }
    return {
      type: "op",
      mode: parser2.mode,
      limits: false,
      parentIsSupSub: false,
      symbol: true,
      name: fName
    };
  },
  htmlBuilder: htmlBuilder$2,
  mathmlBuilder: mathmlBuilder$1
});
var htmlBuilder$1 = (grp, options) => {
  var supGroup;
  var subGroup;
  var hasLimits = false;
  var group;
  if (grp.type === "supsub") {
    supGroup = grp.sup;
    subGroup = grp.sub;
    group = assertNodeType(grp.base, "operatorname");
    hasLimits = true;
  } else {
    group = assertNodeType(grp, "operatorname");
  }
  var base;
  if (group.body.length > 0) {
    var body = group.body.map((child2) => {
      var childText = child2.text;
      if (typeof childText === "string") {
        return {
          type: "textord",
          mode: child2.mode,
          text: childText
        };
      } else {
        return child2;
      }
    });
    var expression = buildExpression$1(body, options.withFont("mathrm"), true);
    for (var i2 = 0; i2 < expression.length; i2++) {
      var child = expression[i2];
      if (child instanceof SymbolNode) {
        child.text = child.text.replace(/\u2212/, "-").replace(/\u2217/, "*");
      }
    }
    base = buildCommon.makeSpan(["mop"], expression, options);
  } else {
    base = buildCommon.makeSpan(["mop"], [], options);
  }
  if (hasLimits) {
    return assembleSupSub(base, supGroup, subGroup, options, options.style, 0, 0);
  } else {
    return base;
  }
};
var mathmlBuilder2 = (group, options) => {
  var expression = buildExpression2(group.body, options.withFont("mathrm"));
  var isAllString = true;
  for (var i2 = 0; i2 < expression.length; i2++) {
    var node3 = expression[i2];
    if (node3 instanceof mathMLTree.SpaceNode)
      ;
    else if (node3 instanceof mathMLTree.MathNode) {
      switch (node3.type) {
        case "mi":
        case "mn":
        case "ms":
        case "mspace":
        case "mtext":
          break;
        case "mo": {
          var child = node3.children[0];
          if (node3.children.length === 1 && child instanceof mathMLTree.TextNode) {
            child.text = child.text.replace(/\u2212/, "-").replace(/\u2217/, "*");
          } else {
            isAllString = false;
          }
          break;
        }
        default:
          isAllString = false;
      }
    } else {
      isAllString = false;
    }
  }
  if (isAllString) {
    var word = expression.map((node4) => node4.toText()).join("");
    expression = [new mathMLTree.TextNode(word)];
  }
  var identifier = new mathMLTree.MathNode("mi", expression);
  identifier.setAttribute("mathvariant", "normal");
  var operator = new mathMLTree.MathNode("mo", [makeText("\u2061", "text")]);
  if (group.parentIsSupSub) {
    return new mathMLTree.MathNode("mrow", [identifier, operator]);
  } else {
    return mathMLTree.newDocumentFragment([identifier, operator]);
  }
};
defineFunction({
  type: "operatorname",
  names: ["\\operatorname@", "\\operatornamewithlimits"],
  props: {
    numArgs: 1
  },
  handler: (_ref, args) => {
    var {
      parser: parser2,
      funcName
    } = _ref;
    var body = args[0];
    return {
      type: "operatorname",
      mode: parser2.mode,
      body: ordargument(body),
      alwaysHandleSupSub: funcName === "\\operatornamewithlimits",
      limits: false,
      parentIsSupSub: false
    };
  },
  htmlBuilder: htmlBuilder$1,
  mathmlBuilder: mathmlBuilder2
});
defineMacro("\\operatorname", "\\@ifstar\\operatornamewithlimits\\operatorname@");
defineFunctionBuilders({
  type: "ordgroup",
  htmlBuilder(group, options) {
    if (group.semisimple) {
      return buildCommon.makeFragment(buildExpression$1(group.body, options, false));
    }
    return buildCommon.makeSpan(["mord"], buildExpression$1(group.body, options, true), options);
  },
  mathmlBuilder(group, options) {
    return buildExpressionRow(group.body, options, true);
  }
});
defineFunction({
  type: "overline",
  names: ["\\overline"],
  props: {
    numArgs: 1
  },
  handler(_ref, args) {
    var {
      parser: parser2
    } = _ref;
    var body = args[0];
    return {
      type: "overline",
      mode: parser2.mode,
      body
    };
  },
  htmlBuilder(group, options) {
    var innerGroup = buildGroup$1(group.body, options.havingCrampedStyle());
    var line = buildCommon.makeLineSpan("overline-line", options);
    var defaultRuleThickness = options.fontMetrics().defaultRuleThickness;
    var vlist = buildCommon.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: innerGroup
      }, {
        type: "kern",
        size: 3 * defaultRuleThickness
      }, {
        type: "elem",
        elem: line
      }, {
        type: "kern",
        size: defaultRuleThickness
      }]
    }, options);
    return buildCommon.makeSpan(["mord", "overline"], [vlist], options);
  },
  mathmlBuilder(group, options) {
    var operator = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode("\u203E")]);
    operator.setAttribute("stretchy", "true");
    var node3 = new mathMLTree.MathNode("mover", [buildGroup2(group.body, options), operator]);
    node3.setAttribute("accent", "true");
    return node3;
  }
});
defineFunction({
  type: "phantom",
  names: ["\\phantom"],
  props: {
    numArgs: 1,
    allowedInText: true
  },
  handler: (_ref, args) => {
    var {
      parser: parser2
    } = _ref;
    var body = args[0];
    return {
      type: "phantom",
      mode: parser2.mode,
      body: ordargument(body)
    };
  },
  htmlBuilder: (group, options) => {
    var elements3 = buildExpression$1(group.body, options.withPhantom(), false);
    return buildCommon.makeFragment(elements3);
  },
  mathmlBuilder: (group, options) => {
    var inner2 = buildExpression2(group.body, options);
    return new mathMLTree.MathNode("mphantom", inner2);
  }
});
defineFunction({
  type: "hphantom",
  names: ["\\hphantom"],
  props: {
    numArgs: 1,
    allowedInText: true
  },
  handler: (_ref2, args) => {
    var {
      parser: parser2
    } = _ref2;
    var body = args[0];
    return {
      type: "hphantom",
      mode: parser2.mode,
      body
    };
  },
  htmlBuilder: (group, options) => {
    var node3 = buildCommon.makeSpan([], [buildGroup$1(group.body, options.withPhantom())]);
    node3.height = 0;
    node3.depth = 0;
    if (node3.children) {
      for (var i2 = 0; i2 < node3.children.length; i2++) {
        node3.children[i2].height = 0;
        node3.children[i2].depth = 0;
      }
    }
    node3 = buildCommon.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: node3
      }]
    }, options);
    return buildCommon.makeSpan(["mord"], [node3], options);
  },
  mathmlBuilder: (group, options) => {
    var inner2 = buildExpression2(ordargument(group.body), options);
    var phantom = new mathMLTree.MathNode("mphantom", inner2);
    var node3 = new mathMLTree.MathNode("mpadded", [phantom]);
    node3.setAttribute("height", "0px");
    node3.setAttribute("depth", "0px");
    return node3;
  }
});
defineFunction({
  type: "vphantom",
  names: ["\\vphantom"],
  props: {
    numArgs: 1,
    allowedInText: true
  },
  handler: (_ref3, args) => {
    var {
      parser: parser2
    } = _ref3;
    var body = args[0];
    return {
      type: "vphantom",
      mode: parser2.mode,
      body
    };
  },
  htmlBuilder: (group, options) => {
    var inner2 = buildCommon.makeSpan(["inner"], [buildGroup$1(group.body, options.withPhantom())]);
    var fix = buildCommon.makeSpan(["fix"], []);
    return buildCommon.makeSpan(["mord", "rlap"], [inner2, fix], options);
  },
  mathmlBuilder: (group, options) => {
    var inner2 = buildExpression2(ordargument(group.body), options);
    var phantom = new mathMLTree.MathNode("mphantom", inner2);
    var node3 = new mathMLTree.MathNode("mpadded", [phantom]);
    node3.setAttribute("width", "0px");
    return node3;
  }
});
defineFunction({
  type: "raisebox",
  names: ["\\raisebox"],
  props: {
    numArgs: 2,
    argTypes: ["size", "hbox"],
    allowedInText: true
  },
  handler(_ref, args) {
    var {
      parser: parser2
    } = _ref;
    var amount = assertNodeType(args[0], "size").value;
    var body = args[1];
    return {
      type: "raisebox",
      mode: parser2.mode,
      dy: amount,
      body
    };
  },
  htmlBuilder(group, options) {
    var body = buildGroup$1(group.body, options);
    var dy2 = calculateSize(group.dy, options);
    return buildCommon.makeVList({
      positionType: "shift",
      positionData: -dy2,
      children: [{
        type: "elem",
        elem: body
      }]
    }, options);
  },
  mathmlBuilder(group, options) {
    var node3 = new mathMLTree.MathNode("mpadded", [buildGroup2(group.body, options)]);
    var dy2 = group.dy.number + group.dy.unit;
    node3.setAttribute("voffset", dy2);
    return node3;
  }
});
defineFunction({
  type: "internal",
  names: ["\\relax"],
  props: {
    numArgs: 0,
    allowedInText: true
  },
  handler(_ref) {
    var {
      parser: parser2
    } = _ref;
    return {
      type: "internal",
      mode: parser2.mode
    };
  }
});
defineFunction({
  type: "rule",
  names: ["\\rule"],
  props: {
    numArgs: 2,
    numOptionalArgs: 1,
    argTypes: ["size", "size", "size"]
  },
  handler(_ref, args, optArgs) {
    var {
      parser: parser2
    } = _ref;
    var shift = optArgs[0];
    var width2 = assertNodeType(args[0], "size");
    var height2 = assertNodeType(args[1], "size");
    return {
      type: "rule",
      mode: parser2.mode,
      shift: shift && assertNodeType(shift, "size").value,
      width: width2.value,
      height: height2.value
    };
  },
  htmlBuilder(group, options) {
    var rule = buildCommon.makeSpan(["mord", "rule"], [], options);
    var width2 = calculateSize(group.width, options);
    var height2 = calculateSize(group.height, options);
    var shift = group.shift ? calculateSize(group.shift, options) : 0;
    rule.style.borderRightWidth = makeEm(width2);
    rule.style.borderTopWidth = makeEm(height2);
    rule.style.bottom = makeEm(shift);
    rule.width = width2;
    rule.height = height2 + shift;
    rule.depth = -shift;
    rule.maxFontSize = height2 * 1.125 * options.sizeMultiplier;
    return rule;
  },
  mathmlBuilder(group, options) {
    var width2 = calculateSize(group.width, options);
    var height2 = calculateSize(group.height, options);
    var shift = group.shift ? calculateSize(group.shift, options) : 0;
    var color = options.color && options.getColor() || "black";
    var rule = new mathMLTree.MathNode("mspace");
    rule.setAttribute("mathbackground", color);
    rule.setAttribute("width", makeEm(width2));
    rule.setAttribute("height", makeEm(height2));
    var wrapper = new mathMLTree.MathNode("mpadded", [rule]);
    if (shift >= 0) {
      wrapper.setAttribute("height", makeEm(shift));
    } else {
      wrapper.setAttribute("height", makeEm(shift));
      wrapper.setAttribute("depth", makeEm(-shift));
    }
    wrapper.setAttribute("voffset", makeEm(shift));
    return wrapper;
  }
});
function sizingGroup(value, options, baseOptions) {
  var inner2 = buildExpression$1(value, options, false);
  var multiplier = options.sizeMultiplier / baseOptions.sizeMultiplier;
  for (var i2 = 0; i2 < inner2.length; i2++) {
    var pos = inner2[i2].classes.indexOf("sizing");
    if (pos < 0) {
      Array.prototype.push.apply(inner2[i2].classes, options.sizingClasses(baseOptions));
    } else if (inner2[i2].classes[pos + 1] === "reset-size" + options.size) {
      inner2[i2].classes[pos + 1] = "reset-size" + baseOptions.size;
    }
    inner2[i2].height *= multiplier;
    inner2[i2].depth *= multiplier;
  }
  return buildCommon.makeFragment(inner2);
}
var sizeFuncs = ["\\tiny", "\\sixptsize", "\\scriptsize", "\\footnotesize", "\\small", "\\normalsize", "\\large", "\\Large", "\\LARGE", "\\huge", "\\Huge"];
var htmlBuilder2 = (group, options) => {
  var newOptions = options.havingSize(group.size);
  return sizingGroup(group.body, newOptions, options);
};
defineFunction({
  type: "sizing",
  names: sizeFuncs,
  props: {
    numArgs: 0,
    allowedInText: true
  },
  handler: (_ref, args) => {
    var {
      breakOnTokenText,
      funcName,
      parser: parser2
    } = _ref;
    var body = parser2.parseExpression(false, breakOnTokenText);
    return {
      type: "sizing",
      mode: parser2.mode,
      // Figure out what size to use based on the list of functions above
      size: sizeFuncs.indexOf(funcName) + 1,
      body
    };
  },
  htmlBuilder: htmlBuilder2,
  mathmlBuilder: (group, options) => {
    var newOptions = options.havingSize(group.size);
    var inner2 = buildExpression2(group.body, newOptions);
    var node3 = new mathMLTree.MathNode("mstyle", inner2);
    node3.setAttribute("mathsize", makeEm(newOptions.sizeMultiplier));
    return node3;
  }
});
defineFunction({
  type: "smash",
  names: ["\\smash"],
  props: {
    numArgs: 1,
    numOptionalArgs: 1,
    allowedInText: true
  },
  handler: (_ref, args, optArgs) => {
    var {
      parser: parser2
    } = _ref;
    var smashHeight = false;
    var smashDepth = false;
    var tbArg = optArgs[0] && assertNodeType(optArgs[0], "ordgroup");
    if (tbArg) {
      var letter = "";
      for (var i2 = 0; i2 < tbArg.body.length; ++i2) {
        var node3 = tbArg.body[i2];
        letter = node3.text;
        if (letter === "t") {
          smashHeight = true;
        } else if (letter === "b") {
          smashDepth = true;
        } else {
          smashHeight = false;
          smashDepth = false;
          break;
        }
      }
    } else {
      smashHeight = true;
      smashDepth = true;
    }
    var body = args[0];
    return {
      type: "smash",
      mode: parser2.mode,
      body,
      smashHeight,
      smashDepth
    };
  },
  htmlBuilder: (group, options) => {
    var node3 = buildCommon.makeSpan([], [buildGroup$1(group.body, options)]);
    if (!group.smashHeight && !group.smashDepth) {
      return node3;
    }
    if (group.smashHeight) {
      node3.height = 0;
      if (node3.children) {
        for (var i2 = 0; i2 < node3.children.length; i2++) {
          node3.children[i2].height = 0;
        }
      }
    }
    if (group.smashDepth) {
      node3.depth = 0;
      if (node3.children) {
        for (var _i = 0; _i < node3.children.length; _i++) {
          node3.children[_i].depth = 0;
        }
      }
    }
    var smashedNode = buildCommon.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: node3
      }]
    }, options);
    return buildCommon.makeSpan(["mord"], [smashedNode], options);
  },
  mathmlBuilder: (group, options) => {
    var node3 = new mathMLTree.MathNode("mpadded", [buildGroup2(group.body, options)]);
    if (group.smashHeight) {
      node3.setAttribute("height", "0px");
    }
    if (group.smashDepth) {
      node3.setAttribute("depth", "0px");
    }
    return node3;
  }
});
defineFunction({
  type: "sqrt",
  names: ["\\sqrt"],
  props: {
    numArgs: 1,
    numOptionalArgs: 1
  },
  handler(_ref, args, optArgs) {
    var {
      parser: parser2
    } = _ref;
    var index3 = optArgs[0];
    var body = args[0];
    return {
      type: "sqrt",
      mode: parser2.mode,
      body,
      index: index3
    };
  },
  htmlBuilder(group, options) {
    var inner2 = buildGroup$1(group.body, options.havingCrampedStyle());
    if (inner2.height === 0) {
      inner2.height = options.fontMetrics().xHeight;
    }
    inner2 = buildCommon.wrapFragment(inner2, options);
    var metrics = options.fontMetrics();
    var theta = metrics.defaultRuleThickness;
    var phi = theta;
    if (options.style.id < Style$1.TEXT.id) {
      phi = options.fontMetrics().xHeight;
    }
    var lineClearance = theta + phi / 4;
    var minDelimiterHeight = inner2.height + inner2.depth + lineClearance + theta;
    var {
      span: img,
      ruleWidth,
      advanceWidth
    } = delimiter2.sqrtImage(minDelimiterHeight, options);
    var delimDepth = img.height - ruleWidth;
    if (delimDepth > inner2.height + inner2.depth + lineClearance) {
      lineClearance = (lineClearance + delimDepth - inner2.height - inner2.depth) / 2;
    }
    var imgShift = img.height - inner2.height - lineClearance - ruleWidth;
    inner2.style.paddingLeft = makeEm(advanceWidth);
    var body = buildCommon.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: inner2,
        wrapperClasses: ["svg-align"]
      }, {
        type: "kern",
        size: -(inner2.height + imgShift)
      }, {
        type: "elem",
        elem: img
      }, {
        type: "kern",
        size: ruleWidth
      }]
    }, options);
    if (!group.index) {
      return buildCommon.makeSpan(["mord", "sqrt"], [body], options);
    } else {
      var newOptions = options.havingStyle(Style$1.SCRIPTSCRIPT);
      var rootm = buildGroup$1(group.index, newOptions, options);
      var toShift = 0.6 * (body.height - body.depth);
      var rootVList = buildCommon.makeVList({
        positionType: "shift",
        positionData: -toShift,
        children: [{
          type: "elem",
          elem: rootm
        }]
      }, options);
      var rootVListWrap = buildCommon.makeSpan(["root"], [rootVList]);
      return buildCommon.makeSpan(["mord", "sqrt"], [rootVListWrap, body], options);
    }
  },
  mathmlBuilder(group, options) {
    var {
      body,
      index: index3
    } = group;
    return index3 ? new mathMLTree.MathNode("mroot", [buildGroup2(body, options), buildGroup2(index3, options)]) : new mathMLTree.MathNode("msqrt", [buildGroup2(body, options)]);
  }
});
var styleMap = {
  "display": Style$1.DISPLAY,
  "text": Style$1.TEXT,
  "script": Style$1.SCRIPT,
  "scriptscript": Style$1.SCRIPTSCRIPT
};
defineFunction({
  type: "styling",
  names: ["\\displaystyle", "\\textstyle", "\\scriptstyle", "\\scriptscriptstyle"],
  props: {
    numArgs: 0,
    allowedInText: true,
    primitive: true
  },
  handler(_ref, args) {
    var {
      breakOnTokenText,
      funcName,
      parser: parser2
    } = _ref;
    var body = parser2.parseExpression(true, breakOnTokenText);
    var style = funcName.slice(1, funcName.length - 5);
    return {
      type: "styling",
      mode: parser2.mode,
      // Figure out what style to use by pulling out the style from
      // the function name
      style,
      body
    };
  },
  htmlBuilder(group, options) {
    var newStyle = styleMap[group.style];
    var newOptions = options.havingStyle(newStyle).withFont("");
    return sizingGroup(group.body, newOptions, options);
  },
  mathmlBuilder(group, options) {
    var newStyle = styleMap[group.style];
    var newOptions = options.havingStyle(newStyle);
    var inner2 = buildExpression2(group.body, newOptions);
    var node3 = new mathMLTree.MathNode("mstyle", inner2);
    var styleAttributes = {
      "display": ["0", "true"],
      "text": ["0", "false"],
      "script": ["1", "false"],
      "scriptscript": ["2", "false"]
    };
    var attr2 = styleAttributes[group.style];
    node3.setAttribute("scriptlevel", attr2[0]);
    node3.setAttribute("displaystyle", attr2[1]);
    return node3;
  }
});
var htmlBuilderDelegate = function htmlBuilderDelegate2(group, options) {
  var base = group.base;
  if (!base) {
    return null;
  } else if (base.type === "op") {
    var delegate = base.limits && (options.style.size === Style$1.DISPLAY.size || base.alwaysHandleSupSub);
    return delegate ? htmlBuilder$2 : null;
  } else if (base.type === "operatorname") {
    var _delegate = base.alwaysHandleSupSub && (options.style.size === Style$1.DISPLAY.size || base.limits);
    return _delegate ? htmlBuilder$1 : null;
  } else if (base.type === "accent") {
    return utils.isCharacterBox(base.base) ? htmlBuilder$a : null;
  } else if (base.type === "horizBrace") {
    var isSup = !group.sub;
    return isSup === base.isOver ? htmlBuilder$3 : null;
  } else {
    return null;
  }
};
defineFunctionBuilders({
  type: "supsub",
  htmlBuilder(group, options) {
    var builderDelegate = htmlBuilderDelegate(group, options);
    if (builderDelegate) {
      return builderDelegate(group, options);
    }
    var {
      base: valueBase,
      sup: valueSup,
      sub: valueSub
    } = group;
    var base = buildGroup$1(valueBase, options);
    var supm;
    var subm;
    var metrics = options.fontMetrics();
    var supShift = 0;
    var subShift = 0;
    var isCharacterBox3 = valueBase && utils.isCharacterBox(valueBase);
    if (valueSup) {
      var newOptions = options.havingStyle(options.style.sup());
      supm = buildGroup$1(valueSup, newOptions, options);
      if (!isCharacterBox3) {
        supShift = base.height - newOptions.fontMetrics().supDrop * newOptions.sizeMultiplier / options.sizeMultiplier;
      }
    }
    if (valueSub) {
      var _newOptions = options.havingStyle(options.style.sub());
      subm = buildGroup$1(valueSub, _newOptions, options);
      if (!isCharacterBox3) {
        subShift = base.depth + _newOptions.fontMetrics().subDrop * _newOptions.sizeMultiplier / options.sizeMultiplier;
      }
    }
    var minSupShift;
    if (options.style === Style$1.DISPLAY) {
      minSupShift = metrics.sup1;
    } else if (options.style.cramped) {
      minSupShift = metrics.sup3;
    } else {
      minSupShift = metrics.sup2;
    }
    var multiplier = options.sizeMultiplier;
    var marginRight = makeEm(0.5 / metrics.ptPerEm / multiplier);
    var marginLeft = null;
    if (subm) {
      var isOiint = group.base && group.base.type === "op" && group.base.name && (group.base.name === "\\oiint" || group.base.name === "\\oiiint");
      if (base instanceof SymbolNode || isOiint) {
        marginLeft = makeEm(-base.italic);
      }
    }
    var supsub;
    if (supm && subm) {
      supShift = Math.max(supShift, minSupShift, supm.depth + 0.25 * metrics.xHeight);
      subShift = Math.max(subShift, metrics.sub2);
      var ruleWidth = metrics.defaultRuleThickness;
      var maxWidth = 4 * ruleWidth;
      if (supShift - supm.depth - (subm.height - subShift) < maxWidth) {
        subShift = maxWidth - (supShift - supm.depth) + subm.height;
        var psi = 0.8 * metrics.xHeight - (supShift - supm.depth);
        if (psi > 0) {
          supShift += psi;
          subShift -= psi;
        }
      }
      var vlistElem = [{
        type: "elem",
        elem: subm,
        shift: subShift,
        marginRight,
        marginLeft
      }, {
        type: "elem",
        elem: supm,
        shift: -supShift,
        marginRight
      }];
      supsub = buildCommon.makeVList({
        positionType: "individualShift",
        children: vlistElem
      }, options);
    } else if (subm) {
      subShift = Math.max(subShift, metrics.sub1, subm.height - 0.8 * metrics.xHeight);
      var _vlistElem = [{
        type: "elem",
        elem: subm,
        marginLeft,
        marginRight
      }];
      supsub = buildCommon.makeVList({
        positionType: "shift",
        positionData: subShift,
        children: _vlistElem
      }, options);
    } else if (supm) {
      supShift = Math.max(supShift, minSupShift, supm.depth + 0.25 * metrics.xHeight);
      supsub = buildCommon.makeVList({
        positionType: "shift",
        positionData: -supShift,
        children: [{
          type: "elem",
          elem: supm,
          marginRight
        }]
      }, options);
    } else {
      throw new Error("supsub must have either sup or sub.");
    }
    var mclass = getTypeOfDomTree(base, "right") || "mord";
    return buildCommon.makeSpan([mclass], [base, buildCommon.makeSpan(["msupsub"], [supsub])], options);
  },
  mathmlBuilder(group, options) {
    var isBrace = false;
    var isOver;
    var isSup;
    if (group.base && group.base.type === "horizBrace") {
      isSup = !!group.sup;
      if (isSup === group.base.isOver) {
        isBrace = true;
        isOver = group.base.isOver;
      }
    }
    if (group.base && (group.base.type === "op" || group.base.type === "operatorname")) {
      group.base.parentIsSupSub = true;
    }
    var children = [buildGroup2(group.base, options)];
    if (group.sub) {
      children.push(buildGroup2(group.sub, options));
    }
    if (group.sup) {
      children.push(buildGroup2(group.sup, options));
    }
    var nodeType;
    if (isBrace) {
      nodeType = isOver ? "mover" : "munder";
    } else if (!group.sub) {
      var base = group.base;
      if (base && base.type === "op" && base.limits && (options.style === Style$1.DISPLAY || base.alwaysHandleSupSub)) {
        nodeType = "mover";
      } else if (base && base.type === "operatorname" && base.alwaysHandleSupSub && (base.limits || options.style === Style$1.DISPLAY)) {
        nodeType = "mover";
      } else {
        nodeType = "msup";
      }
    } else if (!group.sup) {
      var _base = group.base;
      if (_base && _base.type === "op" && _base.limits && (options.style === Style$1.DISPLAY || _base.alwaysHandleSupSub)) {
        nodeType = "munder";
      } else if (_base && _base.type === "operatorname" && _base.alwaysHandleSupSub && (_base.limits || options.style === Style$1.DISPLAY)) {
        nodeType = "munder";
      } else {
        nodeType = "msub";
      }
    } else {
      var _base2 = group.base;
      if (_base2 && _base2.type === "op" && _base2.limits && options.style === Style$1.DISPLAY) {
        nodeType = "munderover";
      } else if (_base2 && _base2.type === "operatorname" && _base2.alwaysHandleSupSub && (options.style === Style$1.DISPLAY || _base2.limits)) {
        nodeType = "munderover";
      } else {
        nodeType = "msubsup";
      }
    }
    return new mathMLTree.MathNode(nodeType, children);
  }
});
defineFunctionBuilders({
  type: "atom",
  htmlBuilder(group, options) {
    return buildCommon.mathsym(group.text, group.mode, options, ["m" + group.family]);
  },
  mathmlBuilder(group, options) {
    var node3 = new mathMLTree.MathNode("mo", [makeText(group.text, group.mode)]);
    if (group.family === "bin") {
      var variant = getVariant(group, options);
      if (variant === "bold-italic") {
        node3.setAttribute("mathvariant", variant);
      }
    } else if (group.family === "punct") {
      node3.setAttribute("separator", "true");
    } else if (group.family === "open" || group.family === "close") {
      node3.setAttribute("stretchy", "false");
    }
    return node3;
  }
});
var defaultVariant = {
  "mi": "italic",
  "mn": "normal",
  "mtext": "normal"
};
defineFunctionBuilders({
  type: "mathord",
  htmlBuilder(group, options) {
    return buildCommon.makeOrd(group, options, "mathord");
  },
  mathmlBuilder(group, options) {
    var node3 = new mathMLTree.MathNode("mi", [makeText(group.text, group.mode, options)]);
    var variant = getVariant(group, options) || "italic";
    if (variant !== defaultVariant[node3.type]) {
      node3.setAttribute("mathvariant", variant);
    }
    return node3;
  }
});
defineFunctionBuilders({
  type: "textord",
  htmlBuilder(group, options) {
    return buildCommon.makeOrd(group, options, "textord");
  },
  mathmlBuilder(group, options) {
    var text4 = makeText(group.text, group.mode, options);
    var variant = getVariant(group, options) || "normal";
    var node3;
    if (group.mode === "text") {
      node3 = new mathMLTree.MathNode("mtext", [text4]);
    } else if (/[0-9]/.test(group.text)) {
      node3 = new mathMLTree.MathNode("mn", [text4]);
    } else if (group.text === "\\prime") {
      node3 = new mathMLTree.MathNode("mo", [text4]);
    } else {
      node3 = new mathMLTree.MathNode("mi", [text4]);
    }
    if (variant !== defaultVariant[node3.type]) {
      node3.setAttribute("mathvariant", variant);
    }
    return node3;
  }
});
var cssSpace = {
  "\\nobreak": "nobreak",
  "\\allowbreak": "allowbreak"
};
var regularSpace = {
  " ": {},
  "\\ ": {},
  "~": {
    className: "nobreak"
  },
  "\\space": {},
  "\\nobreakspace": {
    className: "nobreak"
  }
};
defineFunctionBuilders({
  type: "spacing",
  htmlBuilder(group, options) {
    if (regularSpace.hasOwnProperty(group.text)) {
      var className = regularSpace[group.text].className || "";
      if (group.mode === "text") {
        var ord = buildCommon.makeOrd(group, options, "textord");
        ord.classes.push(className);
        return ord;
      } else {
        return buildCommon.makeSpan(["mspace", className], [buildCommon.mathsym(group.text, group.mode, options)], options);
      }
    } else if (cssSpace.hasOwnProperty(group.text)) {
      return buildCommon.makeSpan(["mspace", cssSpace[group.text]], [], options);
    } else {
      throw new ParseError('Unknown type of space "' + group.text + '"');
    }
  },
  mathmlBuilder(group, options) {
    var node3;
    if (regularSpace.hasOwnProperty(group.text)) {
      node3 = new mathMLTree.MathNode("mtext", [new mathMLTree.TextNode("\xA0")]);
    } else if (cssSpace.hasOwnProperty(group.text)) {
      return new mathMLTree.MathNode("mspace");
    } else {
      throw new ParseError('Unknown type of space "' + group.text + '"');
    }
    return node3;
  }
});
var pad = () => {
  var padNode = new mathMLTree.MathNode("mtd", []);
  padNode.setAttribute("width", "50%");
  return padNode;
};
defineFunctionBuilders({
  type: "tag",
  mathmlBuilder(group, options) {
    var table = new mathMLTree.MathNode("mtable", [new mathMLTree.MathNode("mtr", [pad(), new mathMLTree.MathNode("mtd", [buildExpressionRow(group.body, options)]), pad(), new mathMLTree.MathNode("mtd", [buildExpressionRow(group.tag, options)])])]);
    table.setAttribute("width", "100%");
    return table;
  }
});
var textFontFamilies = {
  "\\text": void 0,
  "\\textrm": "textrm",
  "\\textsf": "textsf",
  "\\texttt": "texttt",
  "\\textnormal": "textrm"
};
var textFontWeights = {
  "\\textbf": "textbf",
  "\\textmd": "textmd"
};
var textFontShapes = {
  "\\textit": "textit",
  "\\textup": "textup"
};
var optionsWithFont = (group, options) => {
  var font = group.font;
  if (!font) {
    return options;
  } else if (textFontFamilies[font]) {
    return options.withTextFontFamily(textFontFamilies[font]);
  } else if (textFontWeights[font]) {
    return options.withTextFontWeight(textFontWeights[font]);
  } else {
    return options.withTextFontShape(textFontShapes[font]);
  }
};
defineFunction({
  type: "text",
  names: [
    // Font families
    "\\text",
    "\\textrm",
    "\\textsf",
    "\\texttt",
    "\\textnormal",
    // Font weights
    "\\textbf",
    "\\textmd",
    // Font Shapes
    "\\textit",
    "\\textup"
  ],
  props: {
    numArgs: 1,
    argTypes: ["text"],
    allowedInArgument: true,
    allowedInText: true
  },
  handler(_ref, args) {
    var {
      parser: parser2,
      funcName
    } = _ref;
    var body = args[0];
    return {
      type: "text",
      mode: parser2.mode,
      body: ordargument(body),
      font: funcName
    };
  },
  htmlBuilder(group, options) {
    var newOptions = optionsWithFont(group, options);
    var inner2 = buildExpression$1(group.body, newOptions, true);
    return buildCommon.makeSpan(["mord", "text"], inner2, newOptions);
  },
  mathmlBuilder(group, options) {
    var newOptions = optionsWithFont(group, options);
    return buildExpressionRow(group.body, newOptions);
  }
});
defineFunction({
  type: "underline",
  names: ["\\underline"],
  props: {
    numArgs: 1,
    allowedInText: true
  },
  handler(_ref, args) {
    var {
      parser: parser2
    } = _ref;
    return {
      type: "underline",
      mode: parser2.mode,
      body: args[0]
    };
  },
  htmlBuilder(group, options) {
    var innerGroup = buildGroup$1(group.body, options);
    var line = buildCommon.makeLineSpan("underline-line", options);
    var defaultRuleThickness = options.fontMetrics().defaultRuleThickness;
    var vlist = buildCommon.makeVList({
      positionType: "top",
      positionData: innerGroup.height,
      children: [{
        type: "kern",
        size: defaultRuleThickness
      }, {
        type: "elem",
        elem: line
      }, {
        type: "kern",
        size: 3 * defaultRuleThickness
      }, {
        type: "elem",
        elem: innerGroup
      }]
    }, options);
    return buildCommon.makeSpan(["mord", "underline"], [vlist], options);
  },
  mathmlBuilder(group, options) {
    var operator = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode("\u203E")]);
    operator.setAttribute("stretchy", "true");
    var node3 = new mathMLTree.MathNode("munder", [buildGroup2(group.body, options), operator]);
    node3.setAttribute("accentunder", "true");
    return node3;
  }
});
defineFunction({
  type: "vcenter",
  names: ["\\vcenter"],
  props: {
    numArgs: 1,
    argTypes: ["original"],
    // In LaTeX, \vcenter can act only on a box.
    allowedInText: false
  },
  handler(_ref, args) {
    var {
      parser: parser2
    } = _ref;
    return {
      type: "vcenter",
      mode: parser2.mode,
      body: args[0]
    };
  },
  htmlBuilder(group, options) {
    var body = buildGroup$1(group.body, options);
    var axisHeight = options.fontMetrics().axisHeight;
    var dy2 = 0.5 * (body.height - axisHeight - (body.depth + axisHeight));
    return buildCommon.makeVList({
      positionType: "shift",
      positionData: dy2,
      children: [{
        type: "elem",
        elem: body
      }]
    }, options);
  },
  mathmlBuilder(group, options) {
    return new mathMLTree.MathNode("mpadded", [buildGroup2(group.body, options)], ["vcenter"]);
  }
});
defineFunction({
  type: "verb",
  names: ["\\verb"],
  props: {
    numArgs: 0,
    allowedInText: true
  },
  handler(context, args, optArgs) {
    throw new ParseError("\\verb ended by end of line instead of matching delimiter");
  },
  htmlBuilder(group, options) {
    var text4 = makeVerb(group);
    var body = [];
    var newOptions = options.havingStyle(options.style.text());
    for (var i2 = 0; i2 < text4.length; i2++) {
      var c3 = text4[i2];
      if (c3 === "~") {
        c3 = "\\textasciitilde";
      }
      body.push(buildCommon.makeSymbol(c3, "Typewriter-Regular", group.mode, newOptions, ["mord", "texttt"]));
    }
    return buildCommon.makeSpan(["mord", "text"].concat(newOptions.sizingClasses(options)), buildCommon.tryCombineChars(body), newOptions);
  },
  mathmlBuilder(group, options) {
    var text4 = new mathMLTree.TextNode(makeVerb(group));
    var node3 = new mathMLTree.MathNode("mtext", [text4]);
    node3.setAttribute("mathvariant", "monospace");
    return node3;
  }
});
var makeVerb = (group) => group.body.replace(/ /g, group.star ? "\u2423" : "\xA0");
var functions = _functions;
var spaceRegexString = "[ \r\n	]";
var controlWordRegexString = "\\\\[a-zA-Z@]+";
var controlSymbolRegexString = "\\\\[^\uD800-\uDFFF]";
var controlWordWhitespaceRegexString = "(" + controlWordRegexString + ")" + spaceRegexString + "*";
var controlSpaceRegexString = "\\\\(\n|[ \r	]+\n?)[ \r	]*";
var combiningDiacriticalMarkString = "[\u0300-\u036F]";
var combiningDiacriticalMarksEndRegex = new RegExp(combiningDiacriticalMarkString + "+$");
var tokenRegexString = "(" + spaceRegexString + "+)|" + // whitespace
(controlSpaceRegexString + "|") + // \whitespace
"([!-\\[\\]-\u2027\u202A-\uD7FF\uF900-\uFFFF]" + // single codepoint
(combiningDiacriticalMarkString + "*") + // ...plus accents
"|[\uD800-\uDBFF][\uDC00-\uDFFF]" + // surrogate pair
(combiningDiacriticalMarkString + "*") + // ...plus accents
"|\\\\verb\\*([^]).*?\\4|\\\\verb([^*a-zA-Z]).*?\\5" + // \verb unstarred
("|" + controlWordWhitespaceRegexString) + // \macroName + spaces
("|" + controlSymbolRegexString + ")");
var Lexer = class {
  // Category codes. The lexer only supports comment characters (14) for now.
  // MacroExpander additionally distinguishes active (13).
  constructor(input, settings) {
    this.input = void 0;
    this.settings = void 0;
    this.tokenRegex = void 0;
    this.catcodes = void 0;
    this.input = input;
    this.settings = settings;
    this.tokenRegex = new RegExp(tokenRegexString, "g");
    this.catcodes = {
      "%": 14,
      // comment character
      "~": 13
      // active character
    };
  }
  setCatcode(char, code) {
    this.catcodes[char] = code;
  }
  /**
   * This function lexes a single token.
   */
  lex() {
    var input = this.input;
    var pos = this.tokenRegex.lastIndex;
    if (pos === input.length) {
      return new Token("EOF", new SourceLocation(this, pos, pos));
    }
    var match = this.tokenRegex.exec(input);
    if (match === null || match.index !== pos) {
      throw new ParseError("Unexpected character: '" + input[pos] + "'", new Token(input[pos], new SourceLocation(this, pos, pos + 1)));
    }
    var text4 = match[6] || match[3] || (match[2] ? "\\ " : " ");
    if (this.catcodes[text4] === 14) {
      var nlIndex = input.indexOf("\n", this.tokenRegex.lastIndex);
      if (nlIndex === -1) {
        this.tokenRegex.lastIndex = input.length;
        this.settings.reportNonstrict("commentAtEnd", "% comment has no terminating newline; LaTeX would fail because of commenting the end of math mode (e.g. $)");
      } else {
        this.tokenRegex.lastIndex = nlIndex + 1;
      }
      return this.lex();
    }
    return new Token(text4, new SourceLocation(this, pos, this.tokenRegex.lastIndex));
  }
};
var Namespace = class {
  /**
   * Both arguments are optional.  The first argument is an object of
   * built-in mappings which never change.  The second argument is an object
   * of initial (global-level) mappings, which will constantly change
   * according to any global/top-level `set`s done.
   */
  constructor(builtins, globalMacros) {
    if (builtins === void 0) {
      builtins = {};
    }
    if (globalMacros === void 0) {
      globalMacros = {};
    }
    this.current = void 0;
    this.builtins = void 0;
    this.undefStack = void 0;
    this.current = globalMacros;
    this.builtins = builtins;
    this.undefStack = [];
  }
  /**
   * Start a new nested group, affecting future local `set`s.
   */
  beginGroup() {
    this.undefStack.push({});
  }
  /**
   * End current nested group, restoring values before the group began.
   */
  endGroup() {
    if (this.undefStack.length === 0) {
      throw new ParseError("Unbalanced namespace destruction: attempt to pop global namespace; please report this as a bug");
    }
    var undefs = this.undefStack.pop();
    for (var undef in undefs) {
      if (undefs.hasOwnProperty(undef)) {
        if (undefs[undef] == null) {
          delete this.current[undef];
        } else {
          this.current[undef] = undefs[undef];
        }
      }
    }
  }
  /**
   * Ends all currently nested groups (if any), restoring values before the
   * groups began.  Useful in case of an error in the middle of parsing.
   */
  endGroups() {
    while (this.undefStack.length > 0) {
      this.endGroup();
    }
  }
  /**
   * Detect whether `name` has a definition.  Equivalent to
   * `get(name) != null`.
   */
  has(name) {
    return this.current.hasOwnProperty(name) || this.builtins.hasOwnProperty(name);
  }
  /**
   * Get the current value of a name, or `undefined` if there is no value.
   *
   * Note: Do not use `if (namespace.get(...))` to detect whether a macro
   * is defined, as the definition may be the empty string which evaluates
   * to `false` in JavaScript.  Use `if (namespace.get(...) != null)` or
   * `if (namespace.has(...))`.
   */
  get(name) {
    if (this.current.hasOwnProperty(name)) {
      return this.current[name];
    } else {
      return this.builtins[name];
    }
  }
  /**
   * Set the current value of a name, and optionally set it globally too.
   * Local set() sets the current value and (when appropriate) adds an undo
   * operation to the undo stack.  Global set() may change the undo
   * operation at every level, so takes time linear in their number.
   * A value of undefined means to delete existing definitions.
   */
  set(name, value, global2) {
    if (global2 === void 0) {
      global2 = false;
    }
    if (global2) {
      for (var i2 = 0; i2 < this.undefStack.length; i2++) {
        delete this.undefStack[i2][name];
      }
      if (this.undefStack.length > 0) {
        this.undefStack[this.undefStack.length - 1][name] = value;
      }
    } else {
      var top = this.undefStack[this.undefStack.length - 1];
      if (top && !top.hasOwnProperty(name)) {
        top[name] = this.current[name];
      }
    }
    if (value == null) {
      delete this.current[name];
    } else {
      this.current[name] = value;
    }
  }
};
var macros = _macros;
defineMacro("\\noexpand", function(context) {
  var t2 = context.popToken();
  if (context.isExpandable(t2.text)) {
    t2.noexpand = true;
    t2.treatAsRelax = true;
  }
  return {
    tokens: [t2],
    numArgs: 0
  };
});
defineMacro("\\expandafter", function(context) {
  var t2 = context.popToken();
  context.expandOnce(true);
  return {
    tokens: [t2],
    numArgs: 0
  };
});
defineMacro("\\@firstoftwo", function(context) {
  var args = context.consumeArgs(2);
  return {
    tokens: args[0],
    numArgs: 0
  };
});
defineMacro("\\@secondoftwo", function(context) {
  var args = context.consumeArgs(2);
  return {
    tokens: args[1],
    numArgs: 0
  };
});
defineMacro("\\@ifnextchar", function(context) {
  var args = context.consumeArgs(3);
  context.consumeSpaces();
  var nextToken = context.future();
  if (args[0].length === 1 && args[0][0].text === nextToken.text) {
    return {
      tokens: args[1],
      numArgs: 0
    };
  } else {
    return {
      tokens: args[2],
      numArgs: 0
    };
  }
});
defineMacro("\\@ifstar", "\\@ifnextchar *{\\@firstoftwo{#1}}");
defineMacro("\\TextOrMath", function(context) {
  var args = context.consumeArgs(2);
  if (context.mode === "text") {
    return {
      tokens: args[0],
      numArgs: 0
    };
  } else {
    return {
      tokens: args[1],
      numArgs: 0
    };
  }
});
var digitToNumber = {
  "0": 0,
  "1": 1,
  "2": 2,
  "3": 3,
  "4": 4,
  "5": 5,
  "6": 6,
  "7": 7,
  "8": 8,
  "9": 9,
  "a": 10,
  "A": 10,
  "b": 11,
  "B": 11,
  "c": 12,
  "C": 12,
  "d": 13,
  "D": 13,
  "e": 14,
  "E": 14,
  "f": 15,
  "F": 15
};
defineMacro("\\char", function(context) {
  var token = context.popToken();
  var base;
  var number = "";
  if (token.text === "'") {
    base = 8;
    token = context.popToken();
  } else if (token.text === '"') {
    base = 16;
    token = context.popToken();
  } else if (token.text === "`") {
    token = context.popToken();
    if (token.text[0] === "\\") {
      number = token.text.charCodeAt(1);
    } else if (token.text === "EOF") {
      throw new ParseError("\\char` missing argument");
    } else {
      number = token.text.charCodeAt(0);
    }
  } else {
    base = 10;
  }
  if (base) {
    number = digitToNumber[token.text];
    if (number == null || number >= base) {
      throw new ParseError("Invalid base-" + base + " digit " + token.text);
    }
    var digit;
    while ((digit = digitToNumber[context.future().text]) != null && digit < base) {
      number *= base;
      number += digit;
      context.popToken();
    }
  }
  return "\\@char{" + number + "}";
});
var newcommand = (context, existsOK, nonexistsOK) => {
  var arg = context.consumeArg().tokens;
  if (arg.length !== 1) {
    throw new ParseError("\\newcommand's first argument must be a macro name");
  }
  var name = arg[0].text;
  var exists = context.isDefined(name);
  if (exists && !existsOK) {
    throw new ParseError("\\newcommand{" + name + "} attempting to redefine " + (name + "; use \\renewcommand"));
  }
  if (!exists && !nonexistsOK) {
    throw new ParseError("\\renewcommand{" + name + "} when command " + name + " does not yet exist; use \\newcommand");
  }
  var numArgs = 0;
  arg = context.consumeArg().tokens;
  if (arg.length === 1 && arg[0].text === "[") {
    var argText = "";
    var token = context.expandNextToken();
    while (token.text !== "]" && token.text !== "EOF") {
      argText += token.text;
      token = context.expandNextToken();
    }
    if (!argText.match(/^\s*[0-9]+\s*$/)) {
      throw new ParseError("Invalid number of arguments: " + argText);
    }
    numArgs = parseInt(argText);
    arg = context.consumeArg().tokens;
  }
  context.macros.set(name, {
    tokens: arg,
    numArgs
  });
  return "";
};
defineMacro("\\newcommand", (context) => newcommand(context, false, true));
defineMacro("\\renewcommand", (context) => newcommand(context, true, false));
defineMacro("\\providecommand", (context) => newcommand(context, true, true));
defineMacro("\\message", (context) => {
  var arg = context.consumeArgs(1)[0];
  console.log(arg.reverse().map((token) => token.text).join(""));
  return "";
});
defineMacro("\\errmessage", (context) => {
  var arg = context.consumeArgs(1)[0];
  console.error(arg.reverse().map((token) => token.text).join(""));
  return "";
});
defineMacro("\\show", (context) => {
  var tok = context.popToken();
  var name = tok.text;
  console.log(tok, context.macros.get(name), functions[name], symbols.math[name], symbols.text[name]);
  return "";
});
defineMacro("\\bgroup", "{");
defineMacro("\\egroup", "}");
defineMacro("~", "\\nobreakspace");
defineMacro("\\lq", "`");
defineMacro("\\rq", "'");
defineMacro("\\aa", "\\r a");
defineMacro("\\AA", "\\r A");
defineMacro("\\textcopyright", "\\html@mathml{\\textcircled{c}}{\\char`\xA9}");
defineMacro("\\copyright", "\\TextOrMath{\\textcopyright}{\\text{\\textcopyright}}");
defineMacro("\\textregistered", "\\html@mathml{\\textcircled{\\scriptsize R}}{\\char`\xAE}");
defineMacro("\u212C", "\\mathscr{B}");
defineMacro("\u2130", "\\mathscr{E}");
defineMacro("\u2131", "\\mathscr{F}");
defineMacro("\u210B", "\\mathscr{H}");
defineMacro("\u2110", "\\mathscr{I}");
defineMacro("\u2112", "\\mathscr{L}");
defineMacro("\u2133", "\\mathscr{M}");
defineMacro("\u211B", "\\mathscr{R}");
defineMacro("\u212D", "\\mathfrak{C}");
defineMacro("\u210C", "\\mathfrak{H}");
defineMacro("\u2128", "\\mathfrak{Z}");
defineMacro("\\Bbbk", "\\Bbb{k}");
defineMacro("\xB7", "\\cdotp");
defineMacro("\\llap", "\\mathllap{\\textrm{#1}}");
defineMacro("\\rlap", "\\mathrlap{\\textrm{#1}}");
defineMacro("\\clap", "\\mathclap{\\textrm{#1}}");
defineMacro("\\mathstrut", "\\vphantom{(}");
defineMacro("\\underbar", "\\underline{\\text{#1}}");
defineMacro("\\not", '\\html@mathml{\\mathrel{\\mathrlap\\@not}}{\\char"338}');
defineMacro("\\neq", "\\html@mathml{\\mathrel{\\not=}}{\\mathrel{\\char`\u2260}}");
defineMacro("\\ne", "\\neq");
defineMacro("\u2260", "\\neq");
defineMacro("\\notin", "\\html@mathml{\\mathrel{{\\in}\\mathllap{/\\mskip1mu}}}{\\mathrel{\\char`\u2209}}");
defineMacro("\u2209", "\\notin");
defineMacro("\u2258", "\\html@mathml{\\mathrel{=\\kern{-1em}\\raisebox{0.4em}{$\\scriptsize\\frown$}}}{\\mathrel{\\char`\u2258}}");
defineMacro("\u2259", "\\html@mathml{\\stackrel{\\tiny\\wedge}{=}}{\\mathrel{\\char`\u2258}}");
defineMacro("\u225A", "\\html@mathml{\\stackrel{\\tiny\\vee}{=}}{\\mathrel{\\char`\u225A}}");
defineMacro("\u225B", "\\html@mathml{\\stackrel{\\scriptsize\\star}{=}}{\\mathrel{\\char`\u225B}}");
defineMacro("\u225D", "\\html@mathml{\\stackrel{\\tiny\\mathrm{def}}{=}}{\\mathrel{\\char`\u225D}}");
defineMacro("\u225E", "\\html@mathml{\\stackrel{\\tiny\\mathrm{m}}{=}}{\\mathrel{\\char`\u225E}}");
defineMacro("\u225F", "\\html@mathml{\\stackrel{\\tiny?}{=}}{\\mathrel{\\char`\u225F}}");
defineMacro("\u27C2", "\\perp");
defineMacro("\u203C", "\\mathclose{!\\mkern-0.8mu!}");
defineMacro("\u220C", "\\notni");
defineMacro("\u231C", "\\ulcorner");
defineMacro("\u231D", "\\urcorner");
defineMacro("\u231E", "\\llcorner");
defineMacro("\u231F", "\\lrcorner");
defineMacro("\xA9", "\\copyright");
defineMacro("\xAE", "\\textregistered");
defineMacro("\uFE0F", "\\textregistered");
defineMacro("\\ulcorner", '\\html@mathml{\\@ulcorner}{\\mathop{\\char"231c}}');
defineMacro("\\urcorner", '\\html@mathml{\\@urcorner}{\\mathop{\\char"231d}}');
defineMacro("\\llcorner", '\\html@mathml{\\@llcorner}{\\mathop{\\char"231e}}');
defineMacro("\\lrcorner", '\\html@mathml{\\@lrcorner}{\\mathop{\\char"231f}}');
defineMacro("\\vdots", "\\mathord{\\varvdots\\rule{0pt}{15pt}}");
defineMacro("\u22EE", "\\vdots");
defineMacro("\\varGamma", "\\mathit{\\Gamma}");
defineMacro("\\varDelta", "\\mathit{\\Delta}");
defineMacro("\\varTheta", "\\mathit{\\Theta}");
defineMacro("\\varLambda", "\\mathit{\\Lambda}");
defineMacro("\\varXi", "\\mathit{\\Xi}");
defineMacro("\\varPi", "\\mathit{\\Pi}");
defineMacro("\\varSigma", "\\mathit{\\Sigma}");
defineMacro("\\varUpsilon", "\\mathit{\\Upsilon}");
defineMacro("\\varPhi", "\\mathit{\\Phi}");
defineMacro("\\varPsi", "\\mathit{\\Psi}");
defineMacro("\\varOmega", "\\mathit{\\Omega}");
defineMacro("\\substack", "\\begin{subarray}{c}#1\\end{subarray}");
defineMacro("\\colon", "\\nobreak\\mskip2mu\\mathpunct{}\\mathchoice{\\mkern-3mu}{\\mkern-3mu}{}{}{:}\\mskip6mu\\relax");
defineMacro("\\boxed", "\\fbox{$\\displaystyle{#1}$}");
defineMacro("\\iff", "\\DOTSB\\;\\Longleftrightarrow\\;");
defineMacro("\\implies", "\\DOTSB\\;\\Longrightarrow\\;");
defineMacro("\\impliedby", "\\DOTSB\\;\\Longleftarrow\\;");
var dotsByToken = {
  ",": "\\dotsc",
  "\\not": "\\dotsb",
  // \keybin@ checks for the following:
  "+": "\\dotsb",
  "=": "\\dotsb",
  "<": "\\dotsb",
  ">": "\\dotsb",
  "-": "\\dotsb",
  "*": "\\dotsb",
  ":": "\\dotsb",
  // Symbols whose definition starts with \DOTSB:
  "\\DOTSB": "\\dotsb",
  "\\coprod": "\\dotsb",
  "\\bigvee": "\\dotsb",
  "\\bigwedge": "\\dotsb",
  "\\biguplus": "\\dotsb",
  "\\bigcap": "\\dotsb",
  "\\bigcup": "\\dotsb",
  "\\prod": "\\dotsb",
  "\\sum": "\\dotsb",
  "\\bigotimes": "\\dotsb",
  "\\bigoplus": "\\dotsb",
  "\\bigodot": "\\dotsb",
  "\\bigsqcup": "\\dotsb",
  "\\And": "\\dotsb",
  "\\longrightarrow": "\\dotsb",
  "\\Longrightarrow": "\\dotsb",
  "\\longleftarrow": "\\dotsb",
  "\\Longleftarrow": "\\dotsb",
  "\\longleftrightarrow": "\\dotsb",
  "\\Longleftrightarrow": "\\dotsb",
  "\\mapsto": "\\dotsb",
  "\\longmapsto": "\\dotsb",
  "\\hookrightarrow": "\\dotsb",
  "\\doteq": "\\dotsb",
  // Symbols whose definition starts with \mathbin:
  "\\mathbin": "\\dotsb",
  // Symbols whose definition starts with \mathrel:
  "\\mathrel": "\\dotsb",
  "\\relbar": "\\dotsb",
  "\\Relbar": "\\dotsb",
  "\\xrightarrow": "\\dotsb",
  "\\xleftarrow": "\\dotsb",
  // Symbols whose definition starts with \DOTSI:
  "\\DOTSI": "\\dotsi",
  "\\int": "\\dotsi",
  "\\oint": "\\dotsi",
  "\\iint": "\\dotsi",
  "\\iiint": "\\dotsi",
  "\\iiiint": "\\dotsi",
  "\\idotsint": "\\dotsi",
  // Symbols whose definition starts with \DOTSX:
  "\\DOTSX": "\\dotsx"
};
defineMacro("\\dots", function(context) {
  var thedots = "\\dotso";
  var next2 = context.expandAfterFuture().text;
  if (next2 in dotsByToken) {
    thedots = dotsByToken[next2];
  } else if (next2.slice(0, 4) === "\\not") {
    thedots = "\\dotsb";
  } else if (next2 in symbols.math) {
    if (utils.contains(["bin", "rel"], symbols.math[next2].group)) {
      thedots = "\\dotsb";
    }
  }
  return thedots;
});
var spaceAfterDots = {
  // \rightdelim@ checks for the following:
  ")": true,
  "]": true,
  "\\rbrack": true,
  "\\}": true,
  "\\rbrace": true,
  "\\rangle": true,
  "\\rceil": true,
  "\\rfloor": true,
  "\\rgroup": true,
  "\\rmoustache": true,
  "\\right": true,
  "\\bigr": true,
  "\\biggr": true,
  "\\Bigr": true,
  "\\Biggr": true,
  // \extra@ also tests for the following:
  "$": true,
  // \extrap@ checks for the following:
  ";": true,
  ".": true,
  ",": true
};
defineMacro("\\dotso", function(context) {
  var next2 = context.future().text;
  if (next2 in spaceAfterDots) {
    return "\\ldots\\,";
  } else {
    return "\\ldots";
  }
});
defineMacro("\\dotsc", function(context) {
  var next2 = context.future().text;
  if (next2 in spaceAfterDots && next2 !== ",") {
    return "\\ldots\\,";
  } else {
    return "\\ldots";
  }
});
defineMacro("\\cdots", function(context) {
  var next2 = context.future().text;
  if (next2 in spaceAfterDots) {
    return "\\@cdots\\,";
  } else {
    return "\\@cdots";
  }
});
defineMacro("\\dotsb", "\\cdots");
defineMacro("\\dotsm", "\\cdots");
defineMacro("\\dotsi", "\\!\\cdots");
defineMacro("\\dotsx", "\\ldots\\,");
defineMacro("\\DOTSI", "\\relax");
defineMacro("\\DOTSB", "\\relax");
defineMacro("\\DOTSX", "\\relax");
defineMacro("\\tmspace", "\\TextOrMath{\\kern#1#3}{\\mskip#1#2}\\relax");
defineMacro("\\,", "\\tmspace+{3mu}{.1667em}");
defineMacro("\\thinspace", "\\,");
defineMacro("\\>", "\\mskip{4mu}");
defineMacro("\\:", "\\tmspace+{4mu}{.2222em}");
defineMacro("\\medspace", "\\:");
defineMacro("\\;", "\\tmspace+{5mu}{.2777em}");
defineMacro("\\thickspace", "\\;");
defineMacro("\\!", "\\tmspace-{3mu}{.1667em}");
defineMacro("\\negthinspace", "\\!");
defineMacro("\\negmedspace", "\\tmspace-{4mu}{.2222em}");
defineMacro("\\negthickspace", "\\tmspace-{5mu}{.277em}");
defineMacro("\\enspace", "\\kern.5em ");
defineMacro("\\enskip", "\\hskip.5em\\relax");
defineMacro("\\quad", "\\hskip1em\\relax");
defineMacro("\\qquad", "\\hskip2em\\relax");
defineMacro("\\tag", "\\@ifstar\\tag@literal\\tag@paren");
defineMacro("\\tag@paren", "\\tag@literal{({#1})}");
defineMacro("\\tag@literal", (context) => {
  if (context.macros.get("\\df@tag")) {
    throw new ParseError("Multiple \\tag");
  }
  return "\\gdef\\df@tag{\\text{#1}}";
});
defineMacro("\\bmod", "\\mathchoice{\\mskip1mu}{\\mskip1mu}{\\mskip5mu}{\\mskip5mu}\\mathbin{\\rm mod}\\mathchoice{\\mskip1mu}{\\mskip1mu}{\\mskip5mu}{\\mskip5mu}");
defineMacro("\\pod", "\\allowbreak\\mathchoice{\\mkern18mu}{\\mkern8mu}{\\mkern8mu}{\\mkern8mu}(#1)");
defineMacro("\\pmod", "\\pod{{\\rm mod}\\mkern6mu#1}");
defineMacro("\\mod", "\\allowbreak\\mathchoice{\\mkern18mu}{\\mkern12mu}{\\mkern12mu}{\\mkern12mu}{\\rm mod}\\,\\,#1");
defineMacro("\\newline", "\\\\\\relax");
defineMacro("\\TeX", "\\textrm{\\html@mathml{T\\kern-.1667em\\raisebox{-.5ex}{E}\\kern-.125emX}{TeX}}");
var latexRaiseA = makeEm(fontMetricsData["Main-Regular"]["T".charCodeAt(0)][1] - 0.7 * fontMetricsData["Main-Regular"]["A".charCodeAt(0)][1]);
defineMacro("\\LaTeX", "\\textrm{\\html@mathml{" + ("L\\kern-.36em\\raisebox{" + latexRaiseA + "}{\\scriptstyle A}") + "\\kern-.15em\\TeX}{LaTeX}}");
defineMacro("\\KaTeX", "\\textrm{\\html@mathml{" + ("K\\kern-.17em\\raisebox{" + latexRaiseA + "}{\\scriptstyle A}") + "\\kern-.15em\\TeX}{KaTeX}}");
defineMacro("\\hspace", "\\@ifstar\\@hspacer\\@hspace");
defineMacro("\\@hspace", "\\hskip #1\\relax");
defineMacro("\\@hspacer", "\\rule{0pt}{0pt}\\hskip #1\\relax");
defineMacro("\\ordinarycolon", ":");
defineMacro("\\vcentcolon", "\\mathrel{\\mathop\\ordinarycolon}");
defineMacro("\\dblcolon", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-.9mu}\\vcentcolon}}{\\mathop{\\char"2237}}');
defineMacro("\\coloneqq", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}=}}{\\mathop{\\char"2254}}');
defineMacro("\\Coloneqq", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}=}}{\\mathop{\\char"2237\\char"3d}}');
defineMacro("\\coloneq", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\mathrel{-}}}{\\mathop{\\char"3a\\char"2212}}');
defineMacro("\\Coloneq", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\mathrel{-}}}{\\mathop{\\char"2237\\char"2212}}');
defineMacro("\\eqqcolon", '\\html@mathml{\\mathrel{=\\mathrel{\\mkern-1.2mu}\\vcentcolon}}{\\mathop{\\char"2255}}');
defineMacro("\\Eqqcolon", '\\html@mathml{\\mathrel{=\\mathrel{\\mkern-1.2mu}\\dblcolon}}{\\mathop{\\char"3d\\char"2237}}');
defineMacro("\\eqcolon", '\\html@mathml{\\mathrel{\\mathrel{-}\\mathrel{\\mkern-1.2mu}\\vcentcolon}}{\\mathop{\\char"2239}}');
defineMacro("\\Eqcolon", '\\html@mathml{\\mathrel{\\mathrel{-}\\mathrel{\\mkern-1.2mu}\\dblcolon}}{\\mathop{\\char"2212\\char"2237}}');
defineMacro("\\colonapprox", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\approx}}{\\mathop{\\char"3a\\char"2248}}');
defineMacro("\\Colonapprox", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\approx}}{\\mathop{\\char"2237\\char"2248}}');
defineMacro("\\colonsim", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\sim}}{\\mathop{\\char"3a\\char"223c}}');
defineMacro("\\Colonsim", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\sim}}{\\mathop{\\char"2237\\char"223c}}');
defineMacro("\u2237", "\\dblcolon");
defineMacro("\u2239", "\\eqcolon");
defineMacro("\u2254", "\\coloneqq");
defineMacro("\u2255", "\\eqqcolon");
defineMacro("\u2A74", "\\Coloneqq");
defineMacro("\\ratio", "\\vcentcolon");
defineMacro("\\coloncolon", "\\dblcolon");
defineMacro("\\colonequals", "\\coloneqq");
defineMacro("\\coloncolonequals", "\\Coloneqq");
defineMacro("\\equalscolon", "\\eqqcolon");
defineMacro("\\equalscoloncolon", "\\Eqqcolon");
defineMacro("\\colonminus", "\\coloneq");
defineMacro("\\coloncolonminus", "\\Coloneq");
defineMacro("\\minuscolon", "\\eqcolon");
defineMacro("\\minuscoloncolon", "\\Eqcolon");
defineMacro("\\coloncolonapprox", "\\Colonapprox");
defineMacro("\\coloncolonsim", "\\Colonsim");
defineMacro("\\simcolon", "\\mathrel{\\sim\\mathrel{\\mkern-1.2mu}\\vcentcolon}");
defineMacro("\\simcoloncolon", "\\mathrel{\\sim\\mathrel{\\mkern-1.2mu}\\dblcolon}");
defineMacro("\\approxcolon", "\\mathrel{\\approx\\mathrel{\\mkern-1.2mu}\\vcentcolon}");
defineMacro("\\approxcoloncolon", "\\mathrel{\\approx\\mathrel{\\mkern-1.2mu}\\dblcolon}");
defineMacro("\\notni", "\\html@mathml{\\not\\ni}{\\mathrel{\\char`\u220C}}");
defineMacro("\\limsup", "\\DOTSB\\operatorname*{lim\\,sup}");
defineMacro("\\liminf", "\\DOTSB\\operatorname*{lim\\,inf}");
defineMacro("\\injlim", "\\DOTSB\\operatorname*{inj\\,lim}");
defineMacro("\\projlim", "\\DOTSB\\operatorname*{proj\\,lim}");
defineMacro("\\varlimsup", "\\DOTSB\\operatorname*{\\overline{lim}}");
defineMacro("\\varliminf", "\\DOTSB\\operatorname*{\\underline{lim}}");
defineMacro("\\varinjlim", "\\DOTSB\\operatorname*{\\underrightarrow{lim}}");
defineMacro("\\varprojlim", "\\DOTSB\\operatorname*{\\underleftarrow{lim}}");
defineMacro("\\gvertneqq", "\\html@mathml{\\@gvertneqq}{\u2269}");
defineMacro("\\lvertneqq", "\\html@mathml{\\@lvertneqq}{\u2268}");
defineMacro("\\ngeqq", "\\html@mathml{\\@ngeqq}{\u2271}");
defineMacro("\\ngeqslant", "\\html@mathml{\\@ngeqslant}{\u2271}");
defineMacro("\\nleqq", "\\html@mathml{\\@nleqq}{\u2270}");
defineMacro("\\nleqslant", "\\html@mathml{\\@nleqslant}{\u2270}");
defineMacro("\\nshortmid", "\\html@mathml{\\@nshortmid}{\u2224}");
defineMacro("\\nshortparallel", "\\html@mathml{\\@nshortparallel}{\u2226}");
defineMacro("\\nsubseteqq", "\\html@mathml{\\@nsubseteqq}{\u2288}");
defineMacro("\\nsupseteqq", "\\html@mathml{\\@nsupseteqq}{\u2289}");
defineMacro("\\varsubsetneq", "\\html@mathml{\\@varsubsetneq}{\u228A}");
defineMacro("\\varsubsetneqq", "\\html@mathml{\\@varsubsetneqq}{\u2ACB}");
defineMacro("\\varsupsetneq", "\\html@mathml{\\@varsupsetneq}{\u228B}");
defineMacro("\\varsupsetneqq", "\\html@mathml{\\@varsupsetneqq}{\u2ACC}");
defineMacro("\\imath", "\\html@mathml{\\@imath}{\u0131}");
defineMacro("\\jmath", "\\html@mathml{\\@jmath}{\u0237}");
defineMacro("\\llbracket", "\\html@mathml{\\mathopen{[\\mkern-3.2mu[}}{\\mathopen{\\char`\u27E6}}");
defineMacro("\\rrbracket", "\\html@mathml{\\mathclose{]\\mkern-3.2mu]}}{\\mathclose{\\char`\u27E7}}");
defineMacro("\u27E6", "\\llbracket");
defineMacro("\u27E7", "\\rrbracket");
defineMacro("\\lBrace", "\\html@mathml{\\mathopen{\\{\\mkern-3.2mu[}}{\\mathopen{\\char`\u2983}}");
defineMacro("\\rBrace", "\\html@mathml{\\mathclose{]\\mkern-3.2mu\\}}}{\\mathclose{\\char`\u2984}}");
defineMacro("\u2983", "\\lBrace");
defineMacro("\u2984", "\\rBrace");
defineMacro("\\minuso", "\\mathbin{\\html@mathml{{\\mathrlap{\\mathchoice{\\kern{0.145em}}{\\kern{0.145em}}{\\kern{0.1015em}}{\\kern{0.0725em}}\\circ}{-}}}{\\char`\u29B5}}");
defineMacro("\u29B5", "\\minuso");
defineMacro("\\darr", "\\downarrow");
defineMacro("\\dArr", "\\Downarrow");
defineMacro("\\Darr", "\\Downarrow");
defineMacro("\\lang", "\\langle");
defineMacro("\\rang", "\\rangle");
defineMacro("\\uarr", "\\uparrow");
defineMacro("\\uArr", "\\Uparrow");
defineMacro("\\Uarr", "\\Uparrow");
defineMacro("\\N", "\\mathbb{N}");
defineMacro("\\R", "\\mathbb{R}");
defineMacro("\\Z", "\\mathbb{Z}");
defineMacro("\\alef", "\\aleph");
defineMacro("\\alefsym", "\\aleph");
defineMacro("\\Alpha", "\\mathrm{A}");
defineMacro("\\Beta", "\\mathrm{B}");
defineMacro("\\bull", "\\bullet");
defineMacro("\\Chi", "\\mathrm{X}");
defineMacro("\\clubs", "\\clubsuit");
defineMacro("\\cnums", "\\mathbb{C}");
defineMacro("\\Complex", "\\mathbb{C}");
defineMacro("\\Dagger", "\\ddagger");
defineMacro("\\diamonds", "\\diamondsuit");
defineMacro("\\empty", "\\emptyset");
defineMacro("\\Epsilon", "\\mathrm{E}");
defineMacro("\\Eta", "\\mathrm{H}");
defineMacro("\\exist", "\\exists");
defineMacro("\\harr", "\\leftrightarrow");
defineMacro("\\hArr", "\\Leftrightarrow");
defineMacro("\\Harr", "\\Leftrightarrow");
defineMacro("\\hearts", "\\heartsuit");
defineMacro("\\image", "\\Im");
defineMacro("\\infin", "\\infty");
defineMacro("\\Iota", "\\mathrm{I}");
defineMacro("\\isin", "\\in");
defineMacro("\\Kappa", "\\mathrm{K}");
defineMacro("\\larr", "\\leftarrow");
defineMacro("\\lArr", "\\Leftarrow");
defineMacro("\\Larr", "\\Leftarrow");
defineMacro("\\lrarr", "\\leftrightarrow");
defineMacro("\\lrArr", "\\Leftrightarrow");
defineMacro("\\Lrarr", "\\Leftrightarrow");
defineMacro("\\Mu", "\\mathrm{M}");
defineMacro("\\natnums", "\\mathbb{N}");
defineMacro("\\Nu", "\\mathrm{N}");
defineMacro("\\Omicron", "\\mathrm{O}");
defineMacro("\\plusmn", "\\pm");
defineMacro("\\rarr", "\\rightarrow");
defineMacro("\\rArr", "\\Rightarrow");
defineMacro("\\Rarr", "\\Rightarrow");
defineMacro("\\real", "\\Re");
defineMacro("\\reals", "\\mathbb{R}");
defineMacro("\\Reals", "\\mathbb{R}");
defineMacro("\\Rho", "\\mathrm{P}");
defineMacro("\\sdot", "\\cdot");
defineMacro("\\sect", "\\S");
defineMacro("\\spades", "\\spadesuit");
defineMacro("\\sub", "\\subset");
defineMacro("\\sube", "\\subseteq");
defineMacro("\\supe", "\\supseteq");
defineMacro("\\Tau", "\\mathrm{T}");
defineMacro("\\thetasym", "\\vartheta");
defineMacro("\\weierp", "\\wp");
defineMacro("\\Zeta", "\\mathrm{Z}");
defineMacro("\\argmin", "\\DOTSB\\operatorname*{arg\\,min}");
defineMacro("\\argmax", "\\DOTSB\\operatorname*{arg\\,max}");
defineMacro("\\plim", "\\DOTSB\\mathop{\\operatorname{plim}}\\limits");
defineMacro("\\bra", "\\mathinner{\\langle{#1}|}");
defineMacro("\\ket", "\\mathinner{|{#1}\\rangle}");
defineMacro("\\braket", "\\mathinner{\\langle{#1}\\rangle}");
defineMacro("\\Bra", "\\left\\langle#1\\right|");
defineMacro("\\Ket", "\\left|#1\\right\\rangle");
var braketHelper = (one2) => (context) => {
  var left = context.consumeArg().tokens;
  var middle = context.consumeArg().tokens;
  var middleDouble = context.consumeArg().tokens;
  var right = context.consumeArg().tokens;
  var oldMiddle = context.macros.get("|");
  var oldMiddleDouble = context.macros.get("\\|");
  context.macros.beginGroup();
  var midMacro = (double) => (context2) => {
    if (one2) {
      context2.macros.set("|", oldMiddle);
      if (middleDouble.length) {
        context2.macros.set("\\|", oldMiddleDouble);
      }
    }
    var doubled = double;
    if (!double && middleDouble.length) {
      var nextToken = context2.future();
      if (nextToken.text === "|") {
        context2.popToken();
        doubled = true;
      }
    }
    return {
      tokens: doubled ? middleDouble : middle,
      numArgs: 0
    };
  };
  context.macros.set("|", midMacro(false));
  if (middleDouble.length) {
    context.macros.set("\\|", midMacro(true));
  }
  var arg = context.consumeArg().tokens;
  var expanded = context.expandTokens([
    ...right,
    ...arg,
    ...left
    // reversed
  ]);
  context.macros.endGroup();
  return {
    tokens: expanded.reverse(),
    numArgs: 0
  };
};
defineMacro("\\bra@ket", braketHelper(false));
defineMacro("\\bra@set", braketHelper(true));
defineMacro("\\Braket", "\\bra@ket{\\left\\langle}{\\,\\middle\\vert\\,}{\\,\\middle\\vert\\,}{\\right\\rangle}");
defineMacro("\\Set", "\\bra@set{\\left\\{\\:}{\\;\\middle\\vert\\;}{\\;\\middle\\Vert\\;}{\\:\\right\\}}");
defineMacro("\\set", "\\bra@set{\\{\\,}{\\mid}{}{\\,\\}}");
defineMacro("\\angln", "{\\angl n}");
defineMacro("\\blue", "\\textcolor{##6495ed}{#1}");
defineMacro("\\orange", "\\textcolor{##ffa500}{#1}");
defineMacro("\\pink", "\\textcolor{##ff00af}{#1}");
defineMacro("\\red", "\\textcolor{##df0030}{#1}");
defineMacro("\\green", "\\textcolor{##28ae7b}{#1}");
defineMacro("\\gray", "\\textcolor{gray}{#1}");
defineMacro("\\purple", "\\textcolor{##9d38bd}{#1}");
defineMacro("\\blueA", "\\textcolor{##ccfaff}{#1}");
defineMacro("\\blueB", "\\textcolor{##80f6ff}{#1}");
defineMacro("\\blueC", "\\textcolor{##63d9ea}{#1}");
defineMacro("\\blueD", "\\textcolor{##11accd}{#1}");
defineMacro("\\blueE", "\\textcolor{##0c7f99}{#1}");
defineMacro("\\tealA", "\\textcolor{##94fff5}{#1}");
defineMacro("\\tealB", "\\textcolor{##26edd5}{#1}");
defineMacro("\\tealC", "\\textcolor{##01d1c1}{#1}");
defineMacro("\\tealD", "\\textcolor{##01a995}{#1}");
defineMacro("\\tealE", "\\textcolor{##208170}{#1}");
defineMacro("\\greenA", "\\textcolor{##b6ffb0}{#1}");
defineMacro("\\greenB", "\\textcolor{##8af281}{#1}");
defineMacro("\\greenC", "\\textcolor{##74cf70}{#1}");
defineMacro("\\greenD", "\\textcolor{##1fab54}{#1}");
defineMacro("\\greenE", "\\textcolor{##0d923f}{#1}");
defineMacro("\\goldA", "\\textcolor{##ffd0a9}{#1}");
defineMacro("\\goldB", "\\textcolor{##ffbb71}{#1}");
defineMacro("\\goldC", "\\textcolor{##ff9c39}{#1}");
defineMacro("\\goldD", "\\textcolor{##e07d10}{#1}");
defineMacro("\\goldE", "\\textcolor{##a75a05}{#1}");
defineMacro("\\redA", "\\textcolor{##fca9a9}{#1}");
defineMacro("\\redB", "\\textcolor{##ff8482}{#1}");
defineMacro("\\redC", "\\textcolor{##f9685d}{#1}");
defineMacro("\\redD", "\\textcolor{##e84d39}{#1}");
defineMacro("\\redE", "\\textcolor{##bc2612}{#1}");
defineMacro("\\maroonA", "\\textcolor{##ffbde0}{#1}");
defineMacro("\\maroonB", "\\textcolor{##ff92c6}{#1}");
defineMacro("\\maroonC", "\\textcolor{##ed5fa6}{#1}");
defineMacro("\\maroonD", "\\textcolor{##ca337c}{#1}");
defineMacro("\\maroonE", "\\textcolor{##9e034e}{#1}");
defineMacro("\\purpleA", "\\textcolor{##ddd7ff}{#1}");
defineMacro("\\purpleB", "\\textcolor{##c6b9fc}{#1}");
defineMacro("\\purpleC", "\\textcolor{##aa87ff}{#1}");
defineMacro("\\purpleD", "\\textcolor{##7854ab}{#1}");
defineMacro("\\purpleE", "\\textcolor{##543b78}{#1}");
defineMacro("\\mintA", "\\textcolor{##f5f9e8}{#1}");
defineMacro("\\mintB", "\\textcolor{##edf2df}{#1}");
defineMacro("\\mintC", "\\textcolor{##e0e5cc}{#1}");
defineMacro("\\grayA", "\\textcolor{##f6f7f7}{#1}");
defineMacro("\\grayB", "\\textcolor{##f0f1f2}{#1}");
defineMacro("\\grayC", "\\textcolor{##e3e5e6}{#1}");
defineMacro("\\grayD", "\\textcolor{##d6d8da}{#1}");
defineMacro("\\grayE", "\\textcolor{##babec2}{#1}");
defineMacro("\\grayF", "\\textcolor{##888d93}{#1}");
defineMacro("\\grayG", "\\textcolor{##626569}{#1}");
defineMacro("\\grayH", "\\textcolor{##3b3e40}{#1}");
defineMacro("\\grayI", "\\textcolor{##21242c}{#1}");
defineMacro("\\kaBlue", "\\textcolor{##314453}{#1}");
defineMacro("\\kaGreen", "\\textcolor{##71B307}{#1}");
var implicitCommands = {
  "^": true,
  // Parser.js
  "_": true,
  // Parser.js
  "\\limits": true,
  // Parser.js
  "\\nolimits": true
  // Parser.js
};
var MacroExpander = class {
  constructor(input, settings, mode) {
    this.settings = void 0;
    this.expansionCount = void 0;
    this.lexer = void 0;
    this.macros = void 0;
    this.stack = void 0;
    this.mode = void 0;
    this.settings = settings;
    this.expansionCount = 0;
    this.feed(input);
    this.macros = new Namespace(macros, settings.macros);
    this.mode = mode;
    this.stack = [];
  }
  /**
   * Feed a new input string to the same MacroExpander
   * (with existing macros etc.).
   */
  feed(input) {
    this.lexer = new Lexer(input, this.settings);
  }
  /**
   * Switches between "text" and "math" modes.
   */
  switchMode(newMode) {
    this.mode = newMode;
  }
  /**
   * Start a new group nesting within all namespaces.
   */
  beginGroup() {
    this.macros.beginGroup();
  }
  /**
   * End current group nesting within all namespaces.
   */
  endGroup() {
    this.macros.endGroup();
  }
  /**
   * Ends all currently nested groups (if any), restoring values before the
   * groups began.  Useful in case of an error in the middle of parsing.
   */
  endGroups() {
    this.macros.endGroups();
  }
  /**
   * Returns the topmost token on the stack, without expanding it.
   * Similar in behavior to TeX's `\futurelet`.
   */
  future() {
    if (this.stack.length === 0) {
      this.pushToken(this.lexer.lex());
    }
    return this.stack[this.stack.length - 1];
  }
  /**
   * Remove and return the next unexpanded token.
   */
  popToken() {
    this.future();
    return this.stack.pop();
  }
  /**
   * Add a given token to the token stack.  In particular, this get be used
   * to put back a token returned from one of the other methods.
   */
  pushToken(token) {
    this.stack.push(token);
  }
  /**
   * Append an array of tokens to the token stack.
   */
  pushTokens(tokens) {
    this.stack.push(...tokens);
  }
  /**
   * Find an macro argument without expanding tokens and append the array of
   * tokens to the token stack. Uses Token as a container for the result.
   */
  scanArgument(isOptional) {
    var start;
    var end;
    var tokens;
    if (isOptional) {
      this.consumeSpaces();
      if (this.future().text !== "[") {
        return null;
      }
      start = this.popToken();
      ({
        tokens,
        end
      } = this.consumeArg(["]"]));
    } else {
      ({
        tokens,
        start,
        end
      } = this.consumeArg());
    }
    this.pushToken(new Token("EOF", end.loc));
    this.pushTokens(tokens);
    return start.range(end, "");
  }
  /**
   * Consume all following space tokens, without expansion.
   */
  consumeSpaces() {
    for (; ; ) {
      var token = this.future();
      if (token.text === " ") {
        this.stack.pop();
      } else {
        break;
      }
    }
  }
  /**
   * Consume an argument from the token stream, and return the resulting array
   * of tokens and start/end token.
   */
  consumeArg(delims) {
    var tokens = [];
    var isDelimited = delims && delims.length > 0;
    if (!isDelimited) {
      this.consumeSpaces();
    }
    var start = this.future();
    var tok;
    var depth = 0;
    var match = 0;
    do {
      tok = this.popToken();
      tokens.push(tok);
      if (tok.text === "{") {
        ++depth;
      } else if (tok.text === "}") {
        --depth;
        if (depth === -1) {
          throw new ParseError("Extra }", tok);
        }
      } else if (tok.text === "EOF") {
        throw new ParseError("Unexpected end of input in a macro argument, expected '" + (delims && isDelimited ? delims[match] : "}") + "'", tok);
      }
      if (delims && isDelimited) {
        if ((depth === 0 || depth === 1 && delims[match] === "{") && tok.text === delims[match]) {
          ++match;
          if (match === delims.length) {
            tokens.splice(-match, match);
            break;
          }
        } else {
          match = 0;
        }
      }
    } while (depth !== 0 || isDelimited);
    if (start.text === "{" && tokens[tokens.length - 1].text === "}") {
      tokens.pop();
      tokens.shift();
    }
    tokens.reverse();
    return {
      tokens,
      start,
      end: tok
    };
  }
  /**
   * Consume the specified number of (delimited) arguments from the token
   * stream and return the resulting array of arguments.
   */
  consumeArgs(numArgs, delimiters2) {
    if (delimiters2) {
      if (delimiters2.length !== numArgs + 1) {
        throw new ParseError("The length of delimiters doesn't match the number of args!");
      }
      var delims = delimiters2[0];
      for (var i2 = 0; i2 < delims.length; i2++) {
        var tok = this.popToken();
        if (delims[i2] !== tok.text) {
          throw new ParseError("Use of the macro doesn't match its definition", tok);
        }
      }
    }
    var args = [];
    for (var _i = 0; _i < numArgs; _i++) {
      args.push(this.consumeArg(delimiters2 && delimiters2[_i + 1]).tokens);
    }
    return args;
  }
  /**
   * Expand the next token only once if possible.
   *
   * If the token is expanded, the resulting tokens will be pushed onto
   * the stack in reverse order, and the number of such tokens will be
   * returned.  This number might be zero or positive.
   *
   * If not, the return value is `false`, and the next token remains at the
   * top of the stack.
   *
   * In either case, the next token will be on the top of the stack,
   * or the stack will be empty (in case of empty expansion
   * and no other tokens).
   *
   * Used to implement `expandAfterFuture` and `expandNextToken`.
   *
   * If expandableOnly, only expandable tokens are expanded and
   * an undefined control sequence results in an error.
   */
  expandOnce(expandableOnly) {
    var topToken = this.popToken();
    var name = topToken.text;
    var expansion = !topToken.noexpand ? this._getExpansion(name) : null;
    if (expansion == null || expandableOnly && expansion.unexpandable) {
      if (expandableOnly && expansion == null && name[0] === "\\" && !this.isDefined(name)) {
        throw new ParseError("Undefined control sequence: " + name);
      }
      this.pushToken(topToken);
      return false;
    }
    this.expansionCount++;
    if (this.expansionCount > this.settings.maxExpand) {
      throw new ParseError("Too many expansions: infinite loop or need to increase maxExpand setting");
    }
    var tokens = expansion.tokens;
    var args = this.consumeArgs(expansion.numArgs, expansion.delimiters);
    if (expansion.numArgs) {
      tokens = tokens.slice();
      for (var i2 = tokens.length - 1; i2 >= 0; --i2) {
        var tok = tokens[i2];
        if (tok.text === "#") {
          if (i2 === 0) {
            throw new ParseError("Incomplete placeholder at end of macro body", tok);
          }
          tok = tokens[--i2];
          if (tok.text === "#") {
            tokens.splice(i2 + 1, 1);
          } else if (/^[1-9]$/.test(tok.text)) {
            tokens.splice(i2, 2, ...args[+tok.text - 1]);
          } else {
            throw new ParseError("Not a valid argument number", tok);
          }
        }
      }
    }
    this.pushTokens(tokens);
    return tokens.length;
  }
  /**
   * Expand the next token only once (if possible), and return the resulting
   * top token on the stack (without removing anything from the stack).
   * Similar in behavior to TeX's `\expandafter\futurelet`.
   * Equivalent to expandOnce() followed by future().
   */
  expandAfterFuture() {
    this.expandOnce();
    return this.future();
  }
  /**
   * Recursively expand first token, then return first non-expandable token.
   */
  expandNextToken() {
    for (; ; ) {
      if (this.expandOnce() === false) {
        var token = this.stack.pop();
        if (token.treatAsRelax) {
          token.text = "\\relax";
        }
        return token;
      }
    }
    throw new Error();
  }
  /**
   * Fully expand the given macro name and return the resulting list of
   * tokens, or return `undefined` if no such macro is defined.
   */
  expandMacro(name) {
    return this.macros.has(name) ? this.expandTokens([new Token(name)]) : void 0;
  }
  /**
   * Fully expand the given token stream and return the resulting list of
   * tokens.  Note that the input tokens are in reverse order, but the
   * output tokens are in forward order.
   */
  expandTokens(tokens) {
    var output = [];
    var oldStackLength = this.stack.length;
    this.pushTokens(tokens);
    while (this.stack.length > oldStackLength) {
      if (this.expandOnce(true) === false) {
        var token = this.stack.pop();
        if (token.treatAsRelax) {
          token.noexpand = false;
          token.treatAsRelax = false;
        }
        output.push(token);
      }
    }
    return output;
  }
  /**
   * Fully expand the given macro name and return the result as a string,
   * or return `undefined` if no such macro is defined.
   */
  expandMacroAsText(name) {
    var tokens = this.expandMacro(name);
    if (tokens) {
      return tokens.map((token) => token.text).join("");
    } else {
      return tokens;
    }
  }
  /**
   * Returns the expanded macro as a reversed array of tokens and a macro
   * argument count.  Or returns `null` if no such macro.
   */
  _getExpansion(name) {
    var definition2 = this.macros.get(name);
    if (definition2 == null) {
      return definition2;
    }
    if (name.length === 1) {
      var catcode = this.lexer.catcodes[name];
      if (catcode != null && catcode !== 13) {
        return;
      }
    }
    var expansion = typeof definition2 === "function" ? definition2(this) : definition2;
    if (typeof expansion === "string") {
      var numArgs = 0;
      if (expansion.indexOf("#") !== -1) {
        var stripped = expansion.replace(/##/g, "");
        while (stripped.indexOf("#" + (numArgs + 1)) !== -1) {
          ++numArgs;
        }
      }
      var bodyLexer = new Lexer(expansion, this.settings);
      var tokens = [];
      var tok = bodyLexer.lex();
      while (tok.text !== "EOF") {
        tokens.push(tok);
        tok = bodyLexer.lex();
      }
      tokens.reverse();
      var expanded = {
        tokens,
        numArgs
      };
      return expanded;
    }
    return expansion;
  }
  /**
   * Determine whether a command is currently "defined" (has some
   * functionality), meaning that it's a macro (in the current group),
   * a function, a symbol, or one of the special commands listed in
   * `implicitCommands`.
   */
  isDefined(name) {
    return this.macros.has(name) || functions.hasOwnProperty(name) || symbols.math.hasOwnProperty(name) || symbols.text.hasOwnProperty(name) || implicitCommands.hasOwnProperty(name);
  }
  /**
   * Determine whether a command is expandable.
   */
  isExpandable(name) {
    var macro = this.macros.get(name);
    return macro != null ? typeof macro === "string" || typeof macro === "function" || !macro.unexpandable : functions.hasOwnProperty(name) && !functions[name].primitive;
  }
};
var unicodeSubRegEx = /^[₊₋₌₍₎₀₁₂₃₄₅₆₇₈₉ₐₑₕᵢⱼₖₗₘₙₒₚᵣₛₜᵤᵥₓᵦᵧᵨᵩᵪ]/;
var uSubsAndSups = Object.freeze({
  "\u208A": "+",
  "\u208B": "-",
  "\u208C": "=",
  "\u208D": "(",
  "\u208E": ")",
  "\u2080": "0",
  "\u2081": "1",
  "\u2082": "2",
  "\u2083": "3",
  "\u2084": "4",
  "\u2085": "5",
  "\u2086": "6",
  "\u2087": "7",
  "\u2088": "8",
  "\u2089": "9",
  "\u2090": "a",
  "\u2091": "e",
  "\u2095": "h",
  "\u1D62": "i",
  "\u2C7C": "j",
  "\u2096": "k",
  "\u2097": "l",
  "\u2098": "m",
  "\u2099": "n",
  "\u2092": "o",
  "\u209A": "p",
  "\u1D63": "r",
  "\u209B": "s",
  "\u209C": "t",
  "\u1D64": "u",
  "\u1D65": "v",
  "\u2093": "x",
  "\u1D66": "\u03B2",
  "\u1D67": "\u03B3",
  "\u1D68": "\u03C1",
  "\u1D69": "\u03D5",
  "\u1D6A": "\u03C7",
  "\u207A": "+",
  "\u207B": "-",
  "\u207C": "=",
  "\u207D": "(",
  "\u207E": ")",
  "\u2070": "0",
  "\xB9": "1",
  "\xB2": "2",
  "\xB3": "3",
  "\u2074": "4",
  "\u2075": "5",
  "\u2076": "6",
  "\u2077": "7",
  "\u2078": "8",
  "\u2079": "9",
  "\u1D2C": "A",
  "\u1D2E": "B",
  "\u1D30": "D",
  "\u1D31": "E",
  "\u1D33": "G",
  "\u1D34": "H",
  "\u1D35": "I",
  "\u1D36": "J",
  "\u1D37": "K",
  "\u1D38": "L",
  "\u1D39": "M",
  "\u1D3A": "N",
  "\u1D3C": "O",
  "\u1D3E": "P",
  "\u1D3F": "R",
  "\u1D40": "T",
  "\u1D41": "U",
  "\u2C7D": "V",
  "\u1D42": "W",
  "\u1D43": "a",
  "\u1D47": "b",
  "\u1D9C": "c",
  "\u1D48": "d",
  "\u1D49": "e",
  "\u1DA0": "f",
  "\u1D4D": "g",
  "\u02B0": "h",
  "\u2071": "i",
  "\u02B2": "j",
  "\u1D4F": "k",
  "\u02E1": "l",
  "\u1D50": "m",
  "\u207F": "n",
  "\u1D52": "o",
  "\u1D56": "p",
  "\u02B3": "r",
  "\u02E2": "s",
  "\u1D57": "t",
  "\u1D58": "u",
  "\u1D5B": "v",
  "\u02B7": "w",
  "\u02E3": "x",
  "\u02B8": "y",
  "\u1DBB": "z",
  "\u1D5D": "\u03B2",
  "\u1D5E": "\u03B3",
  "\u1D5F": "\u03B4",
  "\u1D60": "\u03D5",
  "\u1D61": "\u03C7",
  "\u1DBF": "\u03B8"
});
var unicodeAccents = {
  "\u0301": {
    "text": "\\'",
    "math": "\\acute"
  },
  "\u0300": {
    "text": "\\`",
    "math": "\\grave"
  },
  "\u0308": {
    "text": '\\"',
    "math": "\\ddot"
  },
  "\u0303": {
    "text": "\\~",
    "math": "\\tilde"
  },
  "\u0304": {
    "text": "\\=",
    "math": "\\bar"
  },
  "\u0306": {
    "text": "\\u",
    "math": "\\breve"
  },
  "\u030C": {
    "text": "\\v",
    "math": "\\check"
  },
  "\u0302": {
    "text": "\\^",
    "math": "\\hat"
  },
  "\u0307": {
    "text": "\\.",
    "math": "\\dot"
  },
  "\u030A": {
    "text": "\\r",
    "math": "\\mathring"
  },
  "\u030B": {
    "text": "\\H"
  },
  "\u0327": {
    "text": "\\c"
  }
};
var unicodeSymbols = {
  "\xE1": "a\u0301",
  "\xE0": "a\u0300",
  "\xE4": "a\u0308",
  "\u01DF": "a\u0308\u0304",
  "\xE3": "a\u0303",
  "\u0101": "a\u0304",
  "\u0103": "a\u0306",
  "\u1EAF": "a\u0306\u0301",
  "\u1EB1": "a\u0306\u0300",
  "\u1EB5": "a\u0306\u0303",
  "\u01CE": "a\u030C",
  "\xE2": "a\u0302",
  "\u1EA5": "a\u0302\u0301",
  "\u1EA7": "a\u0302\u0300",
  "\u1EAB": "a\u0302\u0303",
  "\u0227": "a\u0307",
  "\u01E1": "a\u0307\u0304",
  "\xE5": "a\u030A",
  "\u01FB": "a\u030A\u0301",
  "\u1E03": "b\u0307",
  "\u0107": "c\u0301",
  "\u1E09": "c\u0327\u0301",
  "\u010D": "c\u030C",
  "\u0109": "c\u0302",
  "\u010B": "c\u0307",
  "\xE7": "c\u0327",
  "\u010F": "d\u030C",
  "\u1E0B": "d\u0307",
  "\u1E11": "d\u0327",
  "\xE9": "e\u0301",
  "\xE8": "e\u0300",
  "\xEB": "e\u0308",
  "\u1EBD": "e\u0303",
  "\u0113": "e\u0304",
  "\u1E17": "e\u0304\u0301",
  "\u1E15": "e\u0304\u0300",
  "\u0115": "e\u0306",
  "\u1E1D": "e\u0327\u0306",
  "\u011B": "e\u030C",
  "\xEA": "e\u0302",
  "\u1EBF": "e\u0302\u0301",
  "\u1EC1": "e\u0302\u0300",
  "\u1EC5": "e\u0302\u0303",
  "\u0117": "e\u0307",
  "\u0229": "e\u0327",
  "\u1E1F": "f\u0307",
  "\u01F5": "g\u0301",
  "\u1E21": "g\u0304",
  "\u011F": "g\u0306",
  "\u01E7": "g\u030C",
  "\u011D": "g\u0302",
  "\u0121": "g\u0307",
  "\u0123": "g\u0327",
  "\u1E27": "h\u0308",
  "\u021F": "h\u030C",
  "\u0125": "h\u0302",
  "\u1E23": "h\u0307",
  "\u1E29": "h\u0327",
  "\xED": "i\u0301",
  "\xEC": "i\u0300",
  "\xEF": "i\u0308",
  "\u1E2F": "i\u0308\u0301",
  "\u0129": "i\u0303",
  "\u012B": "i\u0304",
  "\u012D": "i\u0306",
  "\u01D0": "i\u030C",
  "\xEE": "i\u0302",
  "\u01F0": "j\u030C",
  "\u0135": "j\u0302",
  "\u1E31": "k\u0301",
  "\u01E9": "k\u030C",
  "\u0137": "k\u0327",
  "\u013A": "l\u0301",
  "\u013E": "l\u030C",
  "\u013C": "l\u0327",
  "\u1E3F": "m\u0301",
  "\u1E41": "m\u0307",
  "\u0144": "n\u0301",
  "\u01F9": "n\u0300",
  "\xF1": "n\u0303",
  "\u0148": "n\u030C",
  "\u1E45": "n\u0307",
  "\u0146": "n\u0327",
  "\xF3": "o\u0301",
  "\xF2": "o\u0300",
  "\xF6": "o\u0308",
  "\u022B": "o\u0308\u0304",
  "\xF5": "o\u0303",
  "\u1E4D": "o\u0303\u0301",
  "\u1E4F": "o\u0303\u0308",
  "\u022D": "o\u0303\u0304",
  "\u014D": "o\u0304",
  "\u1E53": "o\u0304\u0301",
  "\u1E51": "o\u0304\u0300",
  "\u014F": "o\u0306",
  "\u01D2": "o\u030C",
  "\xF4": "o\u0302",
  "\u1ED1": "o\u0302\u0301",
  "\u1ED3": "o\u0302\u0300",
  "\u1ED7": "o\u0302\u0303",
  "\u022F": "o\u0307",
  "\u0231": "o\u0307\u0304",
  "\u0151": "o\u030B",
  "\u1E55": "p\u0301",
  "\u1E57": "p\u0307",
  "\u0155": "r\u0301",
  "\u0159": "r\u030C",
  "\u1E59": "r\u0307",
  "\u0157": "r\u0327",
  "\u015B": "s\u0301",
  "\u1E65": "s\u0301\u0307",
  "\u0161": "s\u030C",
  "\u1E67": "s\u030C\u0307",
  "\u015D": "s\u0302",
  "\u1E61": "s\u0307",
  "\u015F": "s\u0327",
  "\u1E97": "t\u0308",
  "\u0165": "t\u030C",
  "\u1E6B": "t\u0307",
  "\u0163": "t\u0327",
  "\xFA": "u\u0301",
  "\xF9": "u\u0300",
  "\xFC": "u\u0308",
  "\u01D8": "u\u0308\u0301",
  "\u01DC": "u\u0308\u0300",
  "\u01D6": "u\u0308\u0304",
  "\u01DA": "u\u0308\u030C",
  "\u0169": "u\u0303",
  "\u1E79": "u\u0303\u0301",
  "\u016B": "u\u0304",
  "\u1E7B": "u\u0304\u0308",
  "\u016D": "u\u0306",
  "\u01D4": "u\u030C",
  "\xFB": "u\u0302",
  "\u016F": "u\u030A",
  "\u0171": "u\u030B",
  "\u1E7D": "v\u0303",
  "\u1E83": "w\u0301",
  "\u1E81": "w\u0300",
  "\u1E85": "w\u0308",
  "\u0175": "w\u0302",
  "\u1E87": "w\u0307",
  "\u1E98": "w\u030A",
  "\u1E8D": "x\u0308",
  "\u1E8B": "x\u0307",
  "\xFD": "y\u0301",
  "\u1EF3": "y\u0300",
  "\xFF": "y\u0308",
  "\u1EF9": "y\u0303",
  "\u0233": "y\u0304",
  "\u0177": "y\u0302",
  "\u1E8F": "y\u0307",
  "\u1E99": "y\u030A",
  "\u017A": "z\u0301",
  "\u017E": "z\u030C",
  "\u1E91": "z\u0302",
  "\u017C": "z\u0307",
  "\xC1": "A\u0301",
  "\xC0": "A\u0300",
  "\xC4": "A\u0308",
  "\u01DE": "A\u0308\u0304",
  "\xC3": "A\u0303",
  "\u0100": "A\u0304",
  "\u0102": "A\u0306",
  "\u1EAE": "A\u0306\u0301",
  "\u1EB0": "A\u0306\u0300",
  "\u1EB4": "A\u0306\u0303",
  "\u01CD": "A\u030C",
  "\xC2": "A\u0302",
  "\u1EA4": "A\u0302\u0301",
  "\u1EA6": "A\u0302\u0300",
  "\u1EAA": "A\u0302\u0303",
  "\u0226": "A\u0307",
  "\u01E0": "A\u0307\u0304",
  "\xC5": "A\u030A",
  "\u01FA": "A\u030A\u0301",
  "\u1E02": "B\u0307",
  "\u0106": "C\u0301",
  "\u1E08": "C\u0327\u0301",
  "\u010C": "C\u030C",
  "\u0108": "C\u0302",
  "\u010A": "C\u0307",
  "\xC7": "C\u0327",
  "\u010E": "D\u030C",
  "\u1E0A": "D\u0307",
  "\u1E10": "D\u0327",
  "\xC9": "E\u0301",
  "\xC8": "E\u0300",
  "\xCB": "E\u0308",
  "\u1EBC": "E\u0303",
  "\u0112": "E\u0304",
  "\u1E16": "E\u0304\u0301",
  "\u1E14": "E\u0304\u0300",
  "\u0114": "E\u0306",
  "\u1E1C": "E\u0327\u0306",
  "\u011A": "E\u030C",
  "\xCA": "E\u0302",
  "\u1EBE": "E\u0302\u0301",
  "\u1EC0": "E\u0302\u0300",
  "\u1EC4": "E\u0302\u0303",
  "\u0116": "E\u0307",
  "\u0228": "E\u0327",
  "\u1E1E": "F\u0307",
  "\u01F4": "G\u0301",
  "\u1E20": "G\u0304",
  "\u011E": "G\u0306",
  "\u01E6": "G\u030C",
  "\u011C": "G\u0302",
  "\u0120": "G\u0307",
  "\u0122": "G\u0327",
  "\u1E26": "H\u0308",
  "\u021E": "H\u030C",
  "\u0124": "H\u0302",
  "\u1E22": "H\u0307",
  "\u1E28": "H\u0327",
  "\xCD": "I\u0301",
  "\xCC": "I\u0300",
  "\xCF": "I\u0308",
  "\u1E2E": "I\u0308\u0301",
  "\u0128": "I\u0303",
  "\u012A": "I\u0304",
  "\u012C": "I\u0306",
  "\u01CF": "I\u030C",
  "\xCE": "I\u0302",
  "\u0130": "I\u0307",
  "\u0134": "J\u0302",
  "\u1E30": "K\u0301",
  "\u01E8": "K\u030C",
  "\u0136": "K\u0327",
  "\u0139": "L\u0301",
  "\u013D": "L\u030C",
  "\u013B": "L\u0327",
  "\u1E3E": "M\u0301",
  "\u1E40": "M\u0307",
  "\u0143": "N\u0301",
  "\u01F8": "N\u0300",
  "\xD1": "N\u0303",
  "\u0147": "N\u030C",
  "\u1E44": "N\u0307",
  "\u0145": "N\u0327",
  "\xD3": "O\u0301",
  "\xD2": "O\u0300",
  "\xD6": "O\u0308",
  "\u022A": "O\u0308\u0304",
  "\xD5": "O\u0303",
  "\u1E4C": "O\u0303\u0301",
  "\u1E4E": "O\u0303\u0308",
  "\u022C": "O\u0303\u0304",
  "\u014C": "O\u0304",
  "\u1E52": "O\u0304\u0301",
  "\u1E50": "O\u0304\u0300",
  "\u014E": "O\u0306",
  "\u01D1": "O\u030C",
  "\xD4": "O\u0302",
  "\u1ED0": "O\u0302\u0301",
  "\u1ED2": "O\u0302\u0300",
  "\u1ED6": "O\u0302\u0303",
  "\u022E": "O\u0307",
  "\u0230": "O\u0307\u0304",
  "\u0150": "O\u030B",
  "\u1E54": "P\u0301",
  "\u1E56": "P\u0307",
  "\u0154": "R\u0301",
  "\u0158": "R\u030C",
  "\u1E58": "R\u0307",
  "\u0156": "R\u0327",
  "\u015A": "S\u0301",
  "\u1E64": "S\u0301\u0307",
  "\u0160": "S\u030C",
  "\u1E66": "S\u030C\u0307",
  "\u015C": "S\u0302",
  "\u1E60": "S\u0307",
  "\u015E": "S\u0327",
  "\u0164": "T\u030C",
  "\u1E6A": "T\u0307",
  "\u0162": "T\u0327",
  "\xDA": "U\u0301",
  "\xD9": "U\u0300",
  "\xDC": "U\u0308",
  "\u01D7": "U\u0308\u0301",
  "\u01DB": "U\u0308\u0300",
  "\u01D5": "U\u0308\u0304",
  "\u01D9": "U\u0308\u030C",
  "\u0168": "U\u0303",
  "\u1E78": "U\u0303\u0301",
  "\u016A": "U\u0304",
  "\u1E7A": "U\u0304\u0308",
  "\u016C": "U\u0306",
  "\u01D3": "U\u030C",
  "\xDB": "U\u0302",
  "\u016E": "U\u030A",
  "\u0170": "U\u030B",
  "\u1E7C": "V\u0303",
  "\u1E82": "W\u0301",
  "\u1E80": "W\u0300",
  "\u1E84": "W\u0308",
  "\u0174": "W\u0302",
  "\u1E86": "W\u0307",
  "\u1E8C": "X\u0308",
  "\u1E8A": "X\u0307",
  "\xDD": "Y\u0301",
  "\u1EF2": "Y\u0300",
  "\u0178": "Y\u0308",
  "\u1EF8": "Y\u0303",
  "\u0232": "Y\u0304",
  "\u0176": "Y\u0302",
  "\u1E8E": "Y\u0307",
  "\u0179": "Z\u0301",
  "\u017D": "Z\u030C",
  "\u1E90": "Z\u0302",
  "\u017B": "Z\u0307",
  "\u03AC": "\u03B1\u0301",
  "\u1F70": "\u03B1\u0300",
  "\u1FB1": "\u03B1\u0304",
  "\u1FB0": "\u03B1\u0306",
  "\u03AD": "\u03B5\u0301",
  "\u1F72": "\u03B5\u0300",
  "\u03AE": "\u03B7\u0301",
  "\u1F74": "\u03B7\u0300",
  "\u03AF": "\u03B9\u0301",
  "\u1F76": "\u03B9\u0300",
  "\u03CA": "\u03B9\u0308",
  "\u0390": "\u03B9\u0308\u0301",
  "\u1FD2": "\u03B9\u0308\u0300",
  "\u1FD1": "\u03B9\u0304",
  "\u1FD0": "\u03B9\u0306",
  "\u03CC": "\u03BF\u0301",
  "\u1F78": "\u03BF\u0300",
  "\u03CD": "\u03C5\u0301",
  "\u1F7A": "\u03C5\u0300",
  "\u03CB": "\u03C5\u0308",
  "\u03B0": "\u03C5\u0308\u0301",
  "\u1FE2": "\u03C5\u0308\u0300",
  "\u1FE1": "\u03C5\u0304",
  "\u1FE0": "\u03C5\u0306",
  "\u03CE": "\u03C9\u0301",
  "\u1F7C": "\u03C9\u0300",
  "\u038E": "\u03A5\u0301",
  "\u1FEA": "\u03A5\u0300",
  "\u03AB": "\u03A5\u0308",
  "\u1FE9": "\u03A5\u0304",
  "\u1FE8": "\u03A5\u0306",
  "\u038F": "\u03A9\u0301",
  "\u1FFA": "\u03A9\u0300"
};
var Parser2 = class {
  constructor(input, settings) {
    this.mode = void 0;
    this.gullet = void 0;
    this.settings = void 0;
    this.leftrightDepth = void 0;
    this.nextToken = void 0;
    this.mode = "math";
    this.gullet = new MacroExpander(input, settings, this.mode);
    this.settings = settings;
    this.leftrightDepth = 0;
  }
  /**
   * Checks a result to make sure it has the right type, and throws an
   * appropriate error otherwise.
   */
  expect(text4, consume) {
    if (consume === void 0) {
      consume = true;
    }
    if (this.fetch().text !== text4) {
      throw new ParseError("Expected '" + text4 + "', got '" + this.fetch().text + "'", this.fetch());
    }
    if (consume) {
      this.consume();
    }
  }
  /**
   * Discards the current lookahead token, considering it consumed.
   */
  consume() {
    this.nextToken = null;
  }
  /**
   * Return the current lookahead token, or if there isn't one (at the
   * beginning, or if the previous lookahead token was consume()d),
   * fetch the next token as the new lookahead token and return it.
   */
  fetch() {
    if (this.nextToken == null) {
      this.nextToken = this.gullet.expandNextToken();
    }
    return this.nextToken;
  }
  /**
   * Switches between "text" and "math" modes.
   */
  switchMode(newMode) {
    this.mode = newMode;
    this.gullet.switchMode(newMode);
  }
  /**
   * Main parsing function, which parses an entire input.
   */
  parse() {
    if (!this.settings.globalGroup) {
      this.gullet.beginGroup();
    }
    if (this.settings.colorIsTextColor) {
      this.gullet.macros.set("\\color", "\\textcolor");
    }
    try {
      var parse2 = this.parseExpression(false);
      this.expect("EOF");
      if (!this.settings.globalGroup) {
        this.gullet.endGroup();
      }
      return parse2;
    } finally {
      this.gullet.endGroups();
    }
  }
  /**
   * Fully parse a separate sequence of tokens as a separate job.
   * Tokens should be specified in reverse order, as in a MacroDefinition.
   */
  subparse(tokens) {
    var oldToken = this.nextToken;
    this.consume();
    this.gullet.pushToken(new Token("}"));
    this.gullet.pushTokens(tokens);
    var parse2 = this.parseExpression(false);
    this.expect("}");
    this.nextToken = oldToken;
    return parse2;
  }
  /**
   * Parses an "expression", which is a list of atoms.
   *
   * `breakOnInfix`: Should the parsing stop when we hit infix nodes? This
   *                 happens when functions have higher precedence han infix
   *                 nodes in implicit parses.
   *
   * `breakOnTokenText`: The text of the token that the expression should end
   *                     with, or `null` if something else should end the
   *                     expression.
   */
  parseExpression(breakOnInfix, breakOnTokenText) {
    var body = [];
    while (true) {
      if (this.mode === "math") {
        this.consumeSpaces();
      }
      var lex = this.fetch();
      if (Parser2.endOfExpression.indexOf(lex.text) !== -1) {
        break;
      }
      if (breakOnTokenText && lex.text === breakOnTokenText) {
        break;
      }
      if (breakOnInfix && functions[lex.text] && functions[lex.text].infix) {
        break;
      }
      var atom = this.parseAtom(breakOnTokenText);
      if (!atom) {
        break;
      } else if (atom.type === "internal") {
        continue;
      }
      body.push(atom);
    }
    if (this.mode === "text") {
      this.formLigatures(body);
    }
    return this.handleInfixNodes(body);
  }
  /**
   * Rewrites infix operators such as \over with corresponding commands such
   * as \frac.
   *
   * There can only be one infix operator per group.  If there's more than one
   * then the expression is ambiguous.  This can be resolved by adding {}.
   */
  handleInfixNodes(body) {
    var overIndex = -1;
    var funcName;
    for (var i2 = 0; i2 < body.length; i2++) {
      if (body[i2].type === "infix") {
        if (overIndex !== -1) {
          throw new ParseError("only one infix operator per group", body[i2].token);
        }
        overIndex = i2;
        funcName = body[i2].replaceWith;
      }
    }
    if (overIndex !== -1 && funcName) {
      var numerNode;
      var denomNode;
      var numerBody = body.slice(0, overIndex);
      var denomBody = body.slice(overIndex + 1);
      if (numerBody.length === 1 && numerBody[0].type === "ordgroup") {
        numerNode = numerBody[0];
      } else {
        numerNode = {
          type: "ordgroup",
          mode: this.mode,
          body: numerBody
        };
      }
      if (denomBody.length === 1 && denomBody[0].type === "ordgroup") {
        denomNode = denomBody[0];
      } else {
        denomNode = {
          type: "ordgroup",
          mode: this.mode,
          body: denomBody
        };
      }
      var node3;
      if (funcName === "\\\\abovefrac") {
        node3 = this.callFunction(funcName, [numerNode, body[overIndex], denomNode], []);
      } else {
        node3 = this.callFunction(funcName, [numerNode, denomNode], []);
      }
      return [node3];
    } else {
      return body;
    }
  }
  /**
   * Handle a subscript or superscript with nice errors.
   */
  handleSupSubscript(name) {
    var symbolToken = this.fetch();
    var symbol = symbolToken.text;
    this.consume();
    this.consumeSpaces();
    var group = this.parseGroup(name);
    if (!group) {
      throw new ParseError("Expected group after '" + symbol + "'", symbolToken);
    }
    return group;
  }
  /**
   * Converts the textual input of an unsupported command into a text node
   * contained within a color node whose color is determined by errorColor
   */
  formatUnsupportedCmd(text4) {
    var textordArray = [];
    for (var i2 = 0; i2 < text4.length; i2++) {
      textordArray.push({
        type: "textord",
        mode: "text",
        text: text4[i2]
      });
    }
    var textNode = {
      type: "text",
      mode: this.mode,
      body: textordArray
    };
    var colorNode = {
      type: "color",
      mode: this.mode,
      color: this.settings.errorColor,
      body: [textNode]
    };
    return colorNode;
  }
  /**
   * Parses a group with optional super/subscripts.
   */
  parseAtom(breakOnTokenText) {
    var base = this.parseGroup("atom", breakOnTokenText);
    if (this.mode === "text") {
      return base;
    }
    var superscript;
    var subscript;
    while (true) {
      this.consumeSpaces();
      var lex = this.fetch();
      if (lex.text === "\\limits" || lex.text === "\\nolimits") {
        if (base && base.type === "op") {
          var limits = lex.text === "\\limits";
          base.limits = limits;
          base.alwaysHandleSupSub = true;
        } else if (base && base.type === "operatorname") {
          if (base.alwaysHandleSupSub) {
            base.limits = lex.text === "\\limits";
          }
        } else {
          throw new ParseError("Limit controls must follow a math operator", lex);
        }
        this.consume();
      } else if (lex.text === "^") {
        if (superscript) {
          throw new ParseError("Double superscript", lex);
        }
        superscript = this.handleSupSubscript("superscript");
      } else if (lex.text === "_") {
        if (subscript) {
          throw new ParseError("Double subscript", lex);
        }
        subscript = this.handleSupSubscript("subscript");
      } else if (lex.text === "'") {
        if (superscript) {
          throw new ParseError("Double superscript", lex);
        }
        var prime = {
          type: "textord",
          mode: this.mode,
          text: "\\prime"
        };
        var primes = [prime];
        this.consume();
        while (this.fetch().text === "'") {
          primes.push(prime);
          this.consume();
        }
        if (this.fetch().text === "^") {
          primes.push(this.handleSupSubscript("superscript"));
        }
        superscript = {
          type: "ordgroup",
          mode: this.mode,
          body: primes
        };
      } else if (uSubsAndSups[lex.text]) {
        var str = uSubsAndSups[lex.text];
        var isSub = unicodeSubRegEx.test(lex.text);
        this.consume();
        while (true) {
          var token = this.fetch().text;
          if (!uSubsAndSups[token]) {
            break;
          }
          if (unicodeSubRegEx.test(token) !== isSub) {
            break;
          }
          this.consume();
          str += uSubsAndSups[token];
        }
        var body = new Parser2(str, this.settings).parse();
        if (isSub) {
          subscript = {
            type: "ordgroup",
            mode: "math",
            body
          };
        } else {
          superscript = {
            type: "ordgroup",
            mode: "math",
            body
          };
        }
      } else {
        break;
      }
    }
    if (superscript || subscript) {
      return {
        type: "supsub",
        mode: this.mode,
        base,
        sup: superscript,
        sub: subscript
      };
    } else {
      return base;
    }
  }
  /**
   * Parses an entire function, including its base and all of its arguments.
   */
  parseFunction(breakOnTokenText, name) {
    var token = this.fetch();
    var func = token.text;
    var funcData = functions[func];
    if (!funcData) {
      return null;
    }
    this.consume();
    if (name && name !== "atom" && !funcData.allowedInArgument) {
      throw new ParseError("Got function '" + func + "' with no arguments" + (name ? " as " + name : ""), token);
    } else if (this.mode === "text" && !funcData.allowedInText) {
      throw new ParseError("Can't use function '" + func + "' in text mode", token);
    } else if (this.mode === "math" && funcData.allowedInMath === false) {
      throw new ParseError("Can't use function '" + func + "' in math mode", token);
    }
    var {
      args,
      optArgs
    } = this.parseArguments(func, funcData);
    return this.callFunction(func, args, optArgs, token, breakOnTokenText);
  }
  /**
   * Call a function handler with a suitable context and arguments.
   */
  callFunction(name, args, optArgs, token, breakOnTokenText) {
    var context = {
      funcName: name,
      parser: this,
      token,
      breakOnTokenText
    };
    var func = functions[name];
    if (func && func.handler) {
      return func.handler(context, args, optArgs);
    } else {
      throw new ParseError("No function handler for " + name);
    }
  }
  /**
   * Parses the arguments of a function or environment
   */
  parseArguments(func, funcData) {
    var totalArgs = funcData.numArgs + funcData.numOptionalArgs;
    if (totalArgs === 0) {
      return {
        args: [],
        optArgs: []
      };
    }
    var args = [];
    var optArgs = [];
    for (var i2 = 0; i2 < totalArgs; i2++) {
      var argType = funcData.argTypes && funcData.argTypes[i2];
      var isOptional = i2 < funcData.numOptionalArgs;
      if (funcData.primitive && argType == null || // \sqrt expands into primitive if optional argument doesn't exist
      funcData.type === "sqrt" && i2 === 1 && optArgs[0] == null) {
        argType = "primitive";
      }
      var arg = this.parseGroupOfType("argument to '" + func + "'", argType, isOptional);
      if (isOptional) {
        optArgs.push(arg);
      } else if (arg != null) {
        args.push(arg);
      } else {
        throw new ParseError("Null argument, please report this as a bug");
      }
    }
    return {
      args,
      optArgs
    };
  }
  /**
   * Parses a group when the mode is changing.
   */
  parseGroupOfType(name, type, optional) {
    switch (type) {
      case "color":
        return this.parseColorGroup(optional);
      case "size":
        return this.parseSizeGroup(optional);
      case "url":
        return this.parseUrlGroup(optional);
      case "math":
      case "text":
        return this.parseArgumentGroup(optional, type);
      case "hbox": {
        var group = this.parseArgumentGroup(optional, "text");
        return group != null ? {
          type: "styling",
          mode: group.mode,
          body: [group],
          style: "text"
          // simulate \textstyle
        } : null;
      }
      case "raw": {
        var token = this.parseStringGroup("raw", optional);
        return token != null ? {
          type: "raw",
          mode: "text",
          string: token.text
        } : null;
      }
      case "primitive": {
        if (optional) {
          throw new ParseError("A primitive argument cannot be optional");
        }
        var _group = this.parseGroup(name);
        if (_group == null) {
          throw new ParseError("Expected group as " + name, this.fetch());
        }
        return _group;
      }
      case "original":
      case null:
      case void 0:
        return this.parseArgumentGroup(optional);
      default:
        throw new ParseError("Unknown group type as " + name, this.fetch());
    }
  }
  /**
   * Discard any space tokens, fetching the next non-space token.
   */
  consumeSpaces() {
    while (this.fetch().text === " ") {
      this.consume();
    }
  }
  /**
   * Parses a group, essentially returning the string formed by the
   * brace-enclosed tokens plus some position information.
   */
  parseStringGroup(modeName, optional) {
    var argToken = this.gullet.scanArgument(optional);
    if (argToken == null) {
      return null;
    }
    var str = "";
    var nextToken;
    while ((nextToken = this.fetch()).text !== "EOF") {
      str += nextToken.text;
      this.consume();
    }
    this.consume();
    argToken.text = str;
    return argToken;
  }
  /**
   * Parses a regex-delimited group: the largest sequence of tokens
   * whose concatenated strings match `regex`. Returns the string
   * formed by the tokens plus some position information.
   */
  parseRegexGroup(regex, modeName) {
    var firstToken = this.fetch();
    var lastToken = firstToken;
    var str = "";
    var nextToken;
    while ((nextToken = this.fetch()).text !== "EOF" && regex.test(str + nextToken.text)) {
      lastToken = nextToken;
      str += lastToken.text;
      this.consume();
    }
    if (str === "") {
      throw new ParseError("Invalid " + modeName + ": '" + firstToken.text + "'", firstToken);
    }
    return firstToken.range(lastToken, str);
  }
  /**
   * Parses a color description.
   */
  parseColorGroup(optional) {
    var res = this.parseStringGroup("color", optional);
    if (res == null) {
      return null;
    }
    var match = /^(#[a-f0-9]{3}|#?[a-f0-9]{6}|[a-z]+)$/i.exec(res.text);
    if (!match) {
      throw new ParseError("Invalid color: '" + res.text + "'", res);
    }
    var color = match[0];
    if (/^[0-9a-f]{6}$/i.test(color)) {
      color = "#" + color;
    }
    return {
      type: "color-token",
      mode: this.mode,
      color
    };
  }
  /**
   * Parses a size specification, consisting of magnitude and unit.
   */
  parseSizeGroup(optional) {
    var res;
    var isBlank2 = false;
    this.gullet.consumeSpaces();
    if (!optional && this.gullet.future().text !== "{") {
      res = this.parseRegexGroup(/^[-+]? *(?:$|\d+|\d+\.\d*|\.\d*) *[a-z]{0,2} *$/, "size");
    } else {
      res = this.parseStringGroup("size", optional);
    }
    if (!res) {
      return null;
    }
    if (!optional && res.text.length === 0) {
      res.text = "0pt";
      isBlank2 = true;
    }
    var match = /([-+]?) *(\d+(?:\.\d*)?|\.\d+) *([a-z]{2})/.exec(res.text);
    if (!match) {
      throw new ParseError("Invalid size: '" + res.text + "'", res);
    }
    var data2 = {
      number: +(match[1] + match[2]),
      // sign + magnitude, cast to number
      unit: match[3]
    };
    if (!validUnit(data2)) {
      throw new ParseError("Invalid unit: '" + data2.unit + "'", res);
    }
    return {
      type: "size",
      mode: this.mode,
      value: data2,
      isBlank: isBlank2
    };
  }
  /**
   * Parses an URL, checking escaped letters and allowed protocols,
   * and setting the catcode of % as an active character (as in \hyperref).
   */
  parseUrlGroup(optional) {
    this.gullet.lexer.setCatcode("%", 13);
    this.gullet.lexer.setCatcode("~", 12);
    var res = this.parseStringGroup("url", optional);
    this.gullet.lexer.setCatcode("%", 14);
    this.gullet.lexer.setCatcode("~", 13);
    if (res == null) {
      return null;
    }
    var url = res.text.replace(/\\([#$%&~_^{}])/g, "$1");
    return {
      type: "url",
      mode: this.mode,
      url
    };
  }
  /**
   * Parses an argument with the mode specified.
   */
  parseArgumentGroup(optional, mode) {
    var argToken = this.gullet.scanArgument(optional);
    if (argToken == null) {
      return null;
    }
    var outerMode = this.mode;
    if (mode) {
      this.switchMode(mode);
    }
    this.gullet.beginGroup();
    var expression = this.parseExpression(false, "EOF");
    this.expect("EOF");
    this.gullet.endGroup();
    var result = {
      type: "ordgroup",
      mode: this.mode,
      loc: argToken.loc,
      body: expression
    };
    if (mode) {
      this.switchMode(outerMode);
    }
    return result;
  }
  /**
   * Parses an ordinary group, which is either a single nucleus (like "x")
   * or an expression in braces (like "{x+y}") or an implicit group, a group
   * that starts at the current position, and ends right before a higher explicit
   * group ends, or at EOF.
   */
  parseGroup(name, breakOnTokenText) {
    var firstToken = this.fetch();
    var text4 = firstToken.text;
    var result;
    if (text4 === "{" || text4 === "\\begingroup") {
      this.consume();
      var groupEnd = text4 === "{" ? "}" : "\\endgroup";
      this.gullet.beginGroup();
      var expression = this.parseExpression(false, groupEnd);
      var lastToken = this.fetch();
      this.expect(groupEnd);
      this.gullet.endGroup();
      result = {
        type: "ordgroup",
        mode: this.mode,
        loc: SourceLocation.range(firstToken, lastToken),
        body: expression,
        // A group formed by \begingroup...\endgroup is a semi-simple group
        // which doesn't affect spacing in math mode, i.e., is transparent.
        // https://tex.stackexchange.com/questions/1930/when-should-one-
        // use-begingroup-instead-of-bgroup
        semisimple: text4 === "\\begingroup" || void 0
      };
    } else {
      result = this.parseFunction(breakOnTokenText, name) || this.parseSymbol();
      if (result == null && text4[0] === "\\" && !implicitCommands.hasOwnProperty(text4)) {
        if (this.settings.throwOnError) {
          throw new ParseError("Undefined control sequence: " + text4, firstToken);
        }
        result = this.formatUnsupportedCmd(text4);
        this.consume();
      }
    }
    return result;
  }
  /**
   * Form ligature-like combinations of characters for text mode.
   * This includes inputs like "--", "---", "``" and "''".
   * The result will simply replace multiple textord nodes with a single
   * character in each value by a single textord node having multiple
   * characters in its value.  The representation is still ASCII source.
   * The group will be modified in place.
   */
  formLigatures(group) {
    var n2 = group.length - 1;
    for (var i2 = 0; i2 < n2; ++i2) {
      var a2 = group[i2];
      var v2 = a2.text;
      if (v2 === "-" && group[i2 + 1].text === "-") {
        if (i2 + 1 < n2 && group[i2 + 2].text === "-") {
          group.splice(i2, 3, {
            type: "textord",
            mode: "text",
            loc: SourceLocation.range(a2, group[i2 + 2]),
            text: "---"
          });
          n2 -= 2;
        } else {
          group.splice(i2, 2, {
            type: "textord",
            mode: "text",
            loc: SourceLocation.range(a2, group[i2 + 1]),
            text: "--"
          });
          n2 -= 1;
        }
      }
      if ((v2 === "'" || v2 === "`") && group[i2 + 1].text === v2) {
        group.splice(i2, 2, {
          type: "textord",
          mode: "text",
          loc: SourceLocation.range(a2, group[i2 + 1]),
          text: v2 + v2
        });
        n2 -= 1;
      }
    }
  }
  /**
   * Parse a single symbol out of the string. Here, we handle single character
   * symbols and special functions like \verb.
   */
  parseSymbol() {
    var nucleus = this.fetch();
    var text4 = nucleus.text;
    if (/^\\verb[^a-zA-Z]/.test(text4)) {
      this.consume();
      var arg = text4.slice(5);
      var star = arg.charAt(0) === "*";
      if (star) {
        arg = arg.slice(1);
      }
      if (arg.length < 2 || arg.charAt(0) !== arg.slice(-1)) {
        throw new ParseError("\\verb assertion failed --\n                    please report what input caused this bug");
      }
      arg = arg.slice(1, -1);
      return {
        type: "verb",
        mode: "text",
        body: arg,
        star
      };
    }
    if (unicodeSymbols.hasOwnProperty(text4[0]) && !symbols[this.mode][text4[0]]) {
      if (this.settings.strict && this.mode === "math") {
        this.settings.reportNonstrict("unicodeTextInMathMode", 'Accented Unicode text character "' + text4[0] + '" used in math mode', nucleus);
      }
      text4 = unicodeSymbols[text4[0]] + text4.slice(1);
    }
    var match = combiningDiacriticalMarksEndRegex.exec(text4);
    if (match) {
      text4 = text4.substring(0, match.index);
      if (text4 === "i") {
        text4 = "\u0131";
      } else if (text4 === "j") {
        text4 = "\u0237";
      }
    }
    var symbol;
    if (symbols[this.mode][text4]) {
      if (this.settings.strict && this.mode === "math" && extraLatin.indexOf(text4) >= 0) {
        this.settings.reportNonstrict("unicodeTextInMathMode", 'Latin-1/Unicode text character "' + text4[0] + '" used in math mode', nucleus);
      }
      var group = symbols[this.mode][text4].group;
      var loc = SourceLocation.range(nucleus);
      var s2;
      if (ATOMS.hasOwnProperty(group)) {
        var family = group;
        s2 = {
          type: "atom",
          mode: this.mode,
          family,
          loc,
          text: text4
        };
      } else {
        s2 = {
          type: group,
          mode: this.mode,
          loc,
          text: text4
        };
      }
      symbol = s2;
    } else if (text4.charCodeAt(0) >= 128) {
      if (this.settings.strict) {
        if (!supportedCodepoint(text4.charCodeAt(0))) {
          this.settings.reportNonstrict("unknownSymbol", 'Unrecognized Unicode character "' + text4[0] + '"' + (" (" + text4.charCodeAt(0) + ")"), nucleus);
        } else if (this.mode === "math") {
          this.settings.reportNonstrict("unicodeTextInMathMode", 'Unicode text character "' + text4[0] + '" used in math mode', nucleus);
        }
      }
      symbol = {
        type: "textord",
        mode: "text",
        loc: SourceLocation.range(nucleus),
        text: text4
      };
    } else {
      return null;
    }
    this.consume();
    if (match) {
      for (var i2 = 0; i2 < match[0].length; i2++) {
        var accent2 = match[0][i2];
        if (!unicodeAccents[accent2]) {
          throw new ParseError("Unknown accent ' " + accent2 + "'", nucleus);
        }
        var command = unicodeAccents[accent2][this.mode] || unicodeAccents[accent2].text;
        if (!command) {
          throw new ParseError("Accent " + accent2 + " unsupported in " + this.mode + " mode", nucleus);
        }
        symbol = {
          type: "accent",
          mode: this.mode,
          loc: SourceLocation.range(nucleus),
          label: command,
          isStretchy: false,
          isShifty: true,
          // $FlowFixMe
          base: symbol
        };
      }
    }
    return symbol;
  }
};
Parser2.endOfExpression = ["}", "\\endgroup", "\\end", "\\right", "&"];
var parseTree = function parseTree2(toParse, settings) {
  if (!(typeof toParse === "string" || toParse instanceof String)) {
    throw new TypeError("KaTeX can only parse string typed expression");
  }
  var parser2 = new Parser2(toParse, settings);
  delete parser2.gullet.macros.current["\\df@tag"];
  var tree = parser2.parse();
  delete parser2.gullet.macros.current["\\current@color"];
  delete parser2.gullet.macros.current["\\color"];
  if (parser2.gullet.macros.get("\\df@tag")) {
    if (!settings.displayMode) {
      throw new ParseError("\\tag works only in display equations");
    }
    tree = [{
      type: "tag",
      mode: "text",
      body: tree,
      tag: parser2.subparse([new Token("\\df@tag")])
    }];
  }
  return tree;
};
var render = function render2(expression, baseNode, options) {
  baseNode.textContent = "";
  var node3 = renderToDomTree(expression, options).toNode();
  baseNode.appendChild(node3);
};
if (typeof document !== "undefined") {
  if (document.compatMode !== "CSS1Compat") {
    typeof console !== "undefined" && console.warn("Warning: KaTeX doesn't work in quirks mode. Make sure your website has a suitable doctype.");
    render = function render3() {
      throw new ParseError("KaTeX doesn't work in quirks mode.");
    };
  }
}
var renderToString = function renderToString2(expression, options) {
  var markup = renderToDomTree(expression, options).toMarkup();
  return markup;
};
var generateParseTree = function generateParseTree2(expression, options) {
  var settings = new Settings(options);
  return parseTree(expression, settings);
};
var renderError = function renderError2(error, expression, options) {
  if (options.throwOnError || !(error instanceof ParseError)) {
    throw error;
  }
  var node3 = buildCommon.makeSpan(["katex-error"], [new SymbolNode(expression)]);
  node3.setAttribute("title", error.toString());
  node3.setAttribute("style", "color:" + options.errorColor);
  return node3;
};
var renderToDomTree = function renderToDomTree2(expression, options) {
  var settings = new Settings(options);
  try {
    var tree = parseTree(expression, settings);
    return buildTree(tree, expression, settings);
  } catch (error) {
    return renderError(error, expression, settings);
  }
};
var renderToHTMLTree = function renderToHTMLTree2(expression, options) {
  var settings = new Settings(options);
  try {
    var tree = parseTree(expression, settings);
    return buildHTMLTree(tree, expression, settings);
  } catch (error) {
    return renderError(error, expression, settings);
  }
};
var katex = {
  /**
   * Current KaTeX version
   */
  version: "0.16.8",
  /**
   * Renders the given LaTeX into an HTML+MathML combination, and adds
   * it as a child to the specified DOM node.
   */
  render,
  /**
   * Renders the given LaTeX into an HTML+MathML combination string,
   * for sending to the client.
   */
  renderToString,
  /**
   * KaTeX error, usually during parsing.
   */
  ParseError,
  /**
   * The shema of Settings
   */
  SETTINGS_SCHEMA,
  /**
   * Parses the given LaTeX into KaTeX's internal parse tree structure,
   * without rendering to HTML or MathML.
   *
   * NOTE: This method is not currently recommended for public use.
   * The internal tree representation is unstable and is very likely
   * to change. Use at your own risk.
   */
  __parse: generateParseTree,
  /**
   * Renders the given LaTeX into an HTML+MathML internal DOM tree
   * representation, without flattening that representation to a string.
   *
   * NOTE: This method is not currently recommended for public use.
   * The internal tree representation is unstable and is very likely
   * to change. Use at your own risk.
   */
  __renderToDomTree: renderToDomTree,
  /**
   * Renders the given LaTeX into an HTML internal DOM tree representation,
   * without MathML and without flattening that representation to a string.
   *
   * NOTE: This method is not currently recommended for public use.
   * The internal tree representation is unstable and is very likely
   * to change. Use at your own risk.
   */
  __renderToHTMLTree: renderToHTMLTree,
  /**
   * extends internal font metrics object with a new object
   * each key in the new object represents a font name
  */
  __setFontMetrics: setFontMetrics,
  /**
   * adds a new symbol to builtin symbols table
   */
  __defineSymbol: defineSymbol,
  /**
   * adds a new function to builtin function list,
   * which directly produce parse tree elements
   * and have their own html/mathml builders
   */
  __defineFunction: defineFunction,
  /**
   * adds a new macro to builtin macro list
   */
  __defineMacro: defineMacro,
  /**
   * Expose the dom tree node types, which can be useful for type checking nodes.
   *
   * NOTE: This method is not currently recommended for public use.
   * The internal tree representation is unstable and is very likely
   * to change. Use at your own risk.
   */
  __domTree: {
    Span,
    Anchor,
    SymbolNode,
    SvgNode,
    PathNode,
    LineNode
  }
};

// ../simple-mind-map/src/plugins/Formula.js
var import_quill2 = __toESM(require_quill());
var Formula = class {
  //  构造函数
  constructor(opt) {
    this.opt = opt;
    this.mindMap = opt.mindMap;
    window.katex = katex;
    this.extendQuill();
  }
  // 修改formula格式工具
  extendQuill() {
    const QuillFormula = import_quill2.default.import("formats/formula");
    class CustomFormulaBlot extends QuillFormula {
      static create(value) {
        let node3 = super.create(value);
        if (typeof value === "string") {
          katex.render(value, node3, {
            throwOnError: false,
            errorColor: "#f00",
            output: "mathml"
            // 增加该配置，默认只输出公式
          });
          node3.setAttribute("data-value", value);
        }
        return node3;
      }
    }
    import_quill2.default.register("formats/formula", CustomFormulaBlot, true);
  }
  // 给指定的节点插入指定公式
  insertFormulaToNode(node3, formula) {
    let richTextPlugin = this.mindMap.richText;
    richTextPlugin.showEditText({ node: node3 });
    richTextPlugin.quill.insertEmbed(
      richTextPlugin.quill.getLength() - 1,
      "formula",
      formula
    );
    richTextPlugin.setTextStyleIfNotRichText(richTextPlugin.node);
    richTextPlugin.hideEditText([node3]);
  }
};
Formula.instanceName = "formula";
var Formula_default = Formula;

// ../simple-mind-map/node_modules/mdast-util-to-string/lib/index.js
function toString(value, options) {
  const includeImageAlt = (options || {}).includeImageAlt;
  return one(
    value,
    typeof includeImageAlt === "boolean" ? includeImageAlt : true
  );
}
function one(value, includeImageAlt) {
  return node2(value) && ("value" in value && value.value || includeImageAlt && "alt" in value && value.alt || "children" in value && all(value.children, includeImageAlt)) || Array.isArray(value) && all(value, includeImageAlt) || "";
}
function all(values, includeImageAlt) {
  const result = [];
  let index3 = -1;
  while (++index3 < values.length) {
    result[index3] = one(values[index3], includeImageAlt);
  }
  return result.join("");
}
function node2(value) {
  return Boolean(value && typeof value === "object");
}

// ../simple-mind-map/node_modules/micromark-util-chunked/index.js
function splice(list2, start, remove2, items) {
  const end = list2.length;
  let chunkStart = 0;
  let parameters;
  if (start < 0) {
    start = -start > end ? 0 : end + start;
  } else {
    start = start > end ? end : start;
  }
  remove2 = remove2 > 0 ? remove2 : 0;
  if (items.length < 1e4) {
    parameters = Array.from(items);
    parameters.unshift(start, remove2);
    [].splice.apply(list2, parameters);
  } else {
    if (remove2)
      [].splice.apply(list2, [start, remove2]);
    while (chunkStart < items.length) {
      parameters = items.slice(chunkStart, chunkStart + 1e4);
      parameters.unshift(start, 0);
      [].splice.apply(list2, parameters);
      chunkStart += 1e4;
      start += 1e4;
    }
  }
}
function push(list2, items) {
  if (list2.length > 0) {
    splice(list2, list2.length, 0, items);
    return list2;
  }
  return items;
}

// ../simple-mind-map/node_modules/micromark-util-combine-extensions/index.js
var hasOwnProperty = {}.hasOwnProperty;
function combineExtensions(extensions) {
  const all2 = {};
  let index3 = -1;
  while (++index3 < extensions.length) {
    syntaxExtension(all2, extensions[index3]);
  }
  return all2;
}
function syntaxExtension(all2, extension2) {
  let hook;
  for (hook in extension2) {
    const maybe = hasOwnProperty.call(all2, hook) ? all2[hook] : void 0;
    const left = maybe || (all2[hook] = {});
    const right = extension2[hook];
    let code;
    for (code in right) {
      if (!hasOwnProperty.call(left, code))
        left[code] = [];
      const value = right[code];
      constructs(
        // @ts-expect-error Looks like a list.
        left[code],
        Array.isArray(value) ? value : value ? [value] : []
      );
    }
  }
}
function constructs(existing, list2) {
  let index3 = -1;
  const before2 = [];
  while (++index3 < list2.length) {
    ;
    (list2[index3].add === "after" ? existing : before2).push(list2[index3]);
  }
  splice(existing, 0, 0, before2);
}

// ../simple-mind-map/node_modules/micromark-util-character/lib/unicode-punctuation-regex.js
var unicodePunctuationRegex = /[!-/:-@[-`{-~\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u2E52\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]/;

// ../simple-mind-map/node_modules/micromark-util-character/index.js
var asciiAlpha = regexCheck(/[A-Za-z]/);
var asciiDigit = regexCheck(/\d/);
var asciiHexDigit = regexCheck(/[\dA-Fa-f]/);
var asciiAlphanumeric = regexCheck(/[\dA-Za-z]/);
var asciiPunctuation = regexCheck(/[!-/:-@[-`{-~]/);
var asciiAtext = regexCheck(/[#-'*+\--9=?A-Z^-~]/);
function asciiControl(code) {
  return (
    // Special whitespace codes (which have negative values), C0 and Control
    // character DEL
    code !== null && (code < 32 || code === 127)
  );
}
function markdownLineEndingOrSpace(code) {
  return code !== null && (code < 0 || code === 32);
}
function markdownLineEnding(code) {
  return code !== null && code < -2;
}
function markdownSpace(code) {
  return code === -2 || code === -1 || code === 32;
}
var unicodeWhitespace = regexCheck(/\s/);
var unicodePunctuation = regexCheck(unicodePunctuationRegex);
function regexCheck(regex) {
  return check;
  function check(code) {
    return code !== null && regex.test(String.fromCharCode(code));
  }
}

// ../simple-mind-map/node_modules/micromark-factory-space/index.js
function factorySpace(effects, ok, type, max2) {
  const limit = max2 ? max2 - 1 : Number.POSITIVE_INFINITY;
  let size2 = 0;
  return start;
  function start(code) {
    if (markdownSpace(code)) {
      effects.enter(type);
      return prefix(code);
    }
    return ok(code);
  }
  function prefix(code) {
    if (markdownSpace(code) && size2++ < limit) {
      effects.consume(code);
      return prefix;
    }
    effects.exit(type);
    return ok(code);
  }
}

// ../simple-mind-map/node_modules/micromark/lib/initialize/content.js
var content = {
  tokenize: initializeContent
};
function initializeContent(effects) {
  const contentStart = effects.attempt(
    this.parser.constructs.contentInitial,
    afterContentStartConstruct,
    paragraphInitial
  );
  let previous2;
  return contentStart;
  function afterContentStartConstruct(code) {
    if (code === null) {
      effects.consume(code);
      return;
    }
    effects.enter("lineEnding");
    effects.consume(code);
    effects.exit("lineEnding");
    return factorySpace(effects, contentStart, "linePrefix");
  }
  function paragraphInitial(code) {
    effects.enter("paragraph");
    return lineStart(code);
  }
  function lineStart(code) {
    const token = effects.enter("chunkText", {
      contentType: "text",
      previous: previous2
    });
    if (previous2) {
      previous2.next = token;
    }
    previous2 = token;
    return data2(code);
  }
  function data2(code) {
    if (code === null) {
      effects.exit("chunkText");
      effects.exit("paragraph");
      effects.consume(code);
      return;
    }
    if (markdownLineEnding(code)) {
      effects.consume(code);
      effects.exit("chunkText");
      return lineStart;
    }
    effects.consume(code);
    return data2;
  }
}

// ../simple-mind-map/node_modules/micromark/lib/initialize/document.js
var document2 = {
  tokenize: initializeDocument
};
var containerConstruct = {
  tokenize: tokenizeContainer
};
function initializeDocument(effects) {
  const self2 = this;
  const stack = [];
  let continued = 0;
  let childFlow;
  let childToken;
  let lineStartOffset;
  return start;
  function start(code) {
    if (continued < stack.length) {
      const item = stack[continued];
      self2.containerState = item[1];
      return effects.attempt(
        item[0].continuation,
        documentContinue,
        checkNewContainers
      )(code);
    }
    return checkNewContainers(code);
  }
  function documentContinue(code) {
    continued++;
    if (self2.containerState._closeFlow) {
      self2.containerState._closeFlow = void 0;
      if (childFlow) {
        closeFlow();
      }
      const indexBeforeExits = self2.events.length;
      let indexBeforeFlow = indexBeforeExits;
      let point4;
      while (indexBeforeFlow--) {
        if (self2.events[indexBeforeFlow][0] === "exit" && self2.events[indexBeforeFlow][1].type === "chunkFlow") {
          point4 = self2.events[indexBeforeFlow][1].end;
          break;
        }
      }
      exitContainers(continued);
      let index3 = indexBeforeExits;
      while (index3 < self2.events.length) {
        self2.events[index3][1].end = Object.assign({}, point4);
        index3++;
      }
      splice(
        self2.events,
        indexBeforeFlow + 1,
        0,
        self2.events.slice(indexBeforeExits)
      );
      self2.events.length = index3;
      return checkNewContainers(code);
    }
    return start(code);
  }
  function checkNewContainers(code) {
    if (continued === stack.length) {
      if (!childFlow) {
        return documentContinued(code);
      }
      if (childFlow.currentConstruct && childFlow.currentConstruct.concrete) {
        return flowStart(code);
      }
      self2.interrupt = Boolean(
        childFlow.currentConstruct && !childFlow._gfmTableDynamicInterruptHack
      );
    }
    self2.containerState = {};
    return effects.check(
      containerConstruct,
      thereIsANewContainer,
      thereIsNoNewContainer
    )(code);
  }
  function thereIsANewContainer(code) {
    if (childFlow)
      closeFlow();
    exitContainers(continued);
    return documentContinued(code);
  }
  function thereIsNoNewContainer(code) {
    self2.parser.lazy[self2.now().line] = continued !== stack.length;
    lineStartOffset = self2.now().offset;
    return flowStart(code);
  }
  function documentContinued(code) {
    self2.containerState = {};
    return effects.attempt(
      containerConstruct,
      containerContinue,
      flowStart
    )(code);
  }
  function containerContinue(code) {
    continued++;
    stack.push([self2.currentConstruct, self2.containerState]);
    return documentContinued(code);
  }
  function flowStart(code) {
    if (code === null) {
      if (childFlow)
        closeFlow();
      exitContainers(0);
      effects.consume(code);
      return;
    }
    childFlow = childFlow || self2.parser.flow(self2.now());
    effects.enter("chunkFlow", {
      contentType: "flow",
      previous: childToken,
      _tokenizer: childFlow
    });
    return flowContinue(code);
  }
  function flowContinue(code) {
    if (code === null) {
      writeToChild(effects.exit("chunkFlow"), true);
      exitContainers(0);
      effects.consume(code);
      return;
    }
    if (markdownLineEnding(code)) {
      effects.consume(code);
      writeToChild(effects.exit("chunkFlow"));
      continued = 0;
      self2.interrupt = void 0;
      return start;
    }
    effects.consume(code);
    return flowContinue;
  }
  function writeToChild(token, eof) {
    const stream = self2.sliceStream(token);
    if (eof)
      stream.push(null);
    token.previous = childToken;
    if (childToken)
      childToken.next = token;
    childToken = token;
    childFlow.defineSkip(token.start);
    childFlow.write(stream);
    if (self2.parser.lazy[token.start.line]) {
      let index3 = childFlow.events.length;
      while (index3--) {
        if (
          // The token starts before the line ending…
          childFlow.events[index3][1].start.offset < lineStartOffset && // …and either is not ended yet…
          (!childFlow.events[index3][1].end || // …or ends after it.
          childFlow.events[index3][1].end.offset > lineStartOffset)
        ) {
          return;
        }
      }
      const indexBeforeExits = self2.events.length;
      let indexBeforeFlow = indexBeforeExits;
      let seen;
      let point4;
      while (indexBeforeFlow--) {
        if (self2.events[indexBeforeFlow][0] === "exit" && self2.events[indexBeforeFlow][1].type === "chunkFlow") {
          if (seen) {
            point4 = self2.events[indexBeforeFlow][1].end;
            break;
          }
          seen = true;
        }
      }
      exitContainers(continued);
      index3 = indexBeforeExits;
      while (index3 < self2.events.length) {
        self2.events[index3][1].end = Object.assign({}, point4);
        index3++;
      }
      splice(
        self2.events,
        indexBeforeFlow + 1,
        0,
        self2.events.slice(indexBeforeExits)
      );
      self2.events.length = index3;
    }
  }
  function exitContainers(size2) {
    let index3 = stack.length;
    while (index3-- > size2) {
      const entry = stack[index3];
      self2.containerState = entry[1];
      entry[0].exit.call(self2, effects);
    }
    stack.length = size2;
  }
  function closeFlow() {
    childFlow.write([null]);
    childToken = void 0;
    childFlow = void 0;
    self2.containerState._closeFlow = void 0;
  }
}
function tokenizeContainer(effects, ok, nok) {
  return factorySpace(
    effects,
    effects.attempt(this.parser.constructs.document, ok, nok),
    "linePrefix",
    this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
  );
}

// ../simple-mind-map/node_modules/micromark-util-classify-character/index.js
function classifyCharacter(code) {
  if (code === null || markdownLineEndingOrSpace(code) || unicodeWhitespace(code)) {
    return 1;
  }
  if (unicodePunctuation(code)) {
    return 2;
  }
}

// ../simple-mind-map/node_modules/micromark-util-resolve-all/index.js
function resolveAll(constructs2, events, context) {
  const called = [];
  let index3 = -1;
  while (++index3 < constructs2.length) {
    const resolve = constructs2[index3].resolveAll;
    if (resolve && !called.includes(resolve)) {
      events = resolve(events, context);
      called.push(resolve);
    }
  }
  return events;
}

// ../simple-mind-map/node_modules/micromark-core-commonmark/lib/attention.js
var attention = {
  name: "attention",
  tokenize: tokenizeAttention,
  resolveAll: resolveAllAttention
};
function resolveAllAttention(events, context) {
  let index3 = -1;
  let open4;
  let group;
  let text4;
  let openingSequence;
  let closingSequence;
  let use;
  let nextEvents;
  let offset;
  while (++index3 < events.length) {
    if (events[index3][0] === "enter" && events[index3][1].type === "attentionSequence" && events[index3][1]._close) {
      open4 = index3;
      while (open4--) {
        if (events[open4][0] === "exit" && events[open4][1].type === "attentionSequence" && events[open4][1]._open && // If the markers are the same:
        context.sliceSerialize(events[open4][1]).charCodeAt(0) === context.sliceSerialize(events[index3][1]).charCodeAt(0)) {
          if ((events[open4][1]._close || events[index3][1]._open) && (events[index3][1].end.offset - events[index3][1].start.offset) % 3 && !((events[open4][1].end.offset - events[open4][1].start.offset + events[index3][1].end.offset - events[index3][1].start.offset) % 3)) {
            continue;
          }
          use = events[open4][1].end.offset - events[open4][1].start.offset > 1 && events[index3][1].end.offset - events[index3][1].start.offset > 1 ? 2 : 1;
          const start = Object.assign({}, events[open4][1].end);
          const end = Object.assign({}, events[index3][1].start);
          movePoint(start, -use);
          movePoint(end, use);
          openingSequence = {
            type: use > 1 ? "strongSequence" : "emphasisSequence",
            start,
            end: Object.assign({}, events[open4][1].end)
          };
          closingSequence = {
            type: use > 1 ? "strongSequence" : "emphasisSequence",
            start: Object.assign({}, events[index3][1].start),
            end
          };
          text4 = {
            type: use > 1 ? "strongText" : "emphasisText",
            start: Object.assign({}, events[open4][1].end),
            end: Object.assign({}, events[index3][1].start)
          };
          group = {
            type: use > 1 ? "strong" : "emphasis",
            start: Object.assign({}, openingSequence.start),
            end: Object.assign({}, closingSequence.end)
          };
          events[open4][1].end = Object.assign({}, openingSequence.start);
          events[index3][1].start = Object.assign({}, closingSequence.end);
          nextEvents = [];
          if (events[open4][1].end.offset - events[open4][1].start.offset) {
            nextEvents = push(nextEvents, [
              ["enter", events[open4][1], context],
              ["exit", events[open4][1], context]
            ]);
          }
          nextEvents = push(nextEvents, [
            ["enter", group, context],
            ["enter", openingSequence, context],
            ["exit", openingSequence, context],
            ["enter", text4, context]
          ]);
          nextEvents = push(
            nextEvents,
            resolveAll(
              context.parser.constructs.insideSpan.null,
              events.slice(open4 + 1, index3),
              context
            )
          );
          nextEvents = push(nextEvents, [
            ["exit", text4, context],
            ["enter", closingSequence, context],
            ["exit", closingSequence, context],
            ["exit", group, context]
          ]);
          if (events[index3][1].end.offset - events[index3][1].start.offset) {
            offset = 2;
            nextEvents = push(nextEvents, [
              ["enter", events[index3][1], context],
              ["exit", events[index3][1], context]
            ]);
          } else {
            offset = 0;
          }
          splice(events, open4 - 1, index3 - open4 + 3, nextEvents);
          index3 = open4 + nextEvents.length - offset - 2;
          break;
        }
      }
    }
  }
  index3 = -1;
  while (++index3 < events.length) {
    if (events[index3][1].type === "attentionSequence") {
      events[index3][1].type = "data";
    }
  }
  return events;
}
function tokenizeAttention(effects, ok) {
  const attentionMarkers2 = this.parser.constructs.attentionMarkers.null;
  const previous2 = this.previous;
  const before2 = classifyCharacter(previous2);
  let marker;
  return start;
  function start(code) {
    effects.enter("attentionSequence");
    marker = code;
    return sequence(code);
  }
  function sequence(code) {
    if (code === marker) {
      effects.consume(code);
      return sequence;
    }
    const token = effects.exit("attentionSequence");
    const after2 = classifyCharacter(code);
    const open4 = !after2 || after2 === 2 && before2 || attentionMarkers2.includes(code);
    const close3 = !before2 || before2 === 2 && after2 || attentionMarkers2.includes(previous2);
    token._open = Boolean(marker === 42 ? open4 : open4 && (before2 || !close3));
    token._close = Boolean(marker === 42 ? close3 : close3 && (after2 || !open4));
    return ok(code);
  }
}
function movePoint(point4, offset) {
  point4.column += offset;
  point4.offset += offset;
  point4._bufferIndex += offset;
}

// ../simple-mind-map/node_modules/micromark-core-commonmark/lib/autolink.js
var autolink = {
  name: "autolink",
  tokenize: tokenizeAutolink
};
function tokenizeAutolink(effects, ok, nok) {
  let size2 = 1;
  return start;
  function start(code) {
    effects.enter("autolink");
    effects.enter("autolinkMarker");
    effects.consume(code);
    effects.exit("autolinkMarker");
    effects.enter("autolinkProtocol");
    return open4;
  }
  function open4(code) {
    if (asciiAlpha(code)) {
      effects.consume(code);
      return schemeOrEmailAtext;
    }
    return asciiAtext(code) ? emailAtext(code) : nok(code);
  }
  function schemeOrEmailAtext(code) {
    return code === 43 || code === 45 || code === 46 || asciiAlphanumeric(code) ? schemeInsideOrEmailAtext(code) : emailAtext(code);
  }
  function schemeInsideOrEmailAtext(code) {
    if (code === 58) {
      effects.consume(code);
      return urlInside;
    }
    if ((code === 43 || code === 45 || code === 46 || asciiAlphanumeric(code)) && size2++ < 32) {
      effects.consume(code);
      return schemeInsideOrEmailAtext;
    }
    return emailAtext(code);
  }
  function urlInside(code) {
    if (code === 62) {
      effects.exit("autolinkProtocol");
      return end(code);
    }
    if (code === null || code === 32 || code === 60 || asciiControl(code)) {
      return nok(code);
    }
    effects.consume(code);
    return urlInside;
  }
  function emailAtext(code) {
    if (code === 64) {
      effects.consume(code);
      size2 = 0;
      return emailAtSignOrDot;
    }
    if (asciiAtext(code)) {
      effects.consume(code);
      return emailAtext;
    }
    return nok(code);
  }
  function emailAtSignOrDot(code) {
    return asciiAlphanumeric(code) ? emailLabel(code) : nok(code);
  }
  function emailLabel(code) {
    if (code === 46) {
      effects.consume(code);
      size2 = 0;
      return emailAtSignOrDot;
    }
    if (code === 62) {
      effects.exit("autolinkProtocol").type = "autolinkEmail";
      return end(code);
    }
    return emailValue(code);
  }
  function emailValue(code) {
    if ((code === 45 || asciiAlphanumeric(code)) && size2++ < 63) {
      effects.consume(code);
      return code === 45 ? emailValue : emailLabel;
    }
    return nok(code);
  }
  function end(code) {
    effects.enter("autolinkMarker");
    effects.consume(code);
    effects.exit("autolinkMarker");
    effects.exit("autolink");
    return ok;
  }
}

// ../simple-mind-map/node_modules/micromark-core-commonmark/lib/blank-line.js
var blankLine = {
  tokenize: tokenizeBlankLine,
  partial: true
};
function tokenizeBlankLine(effects, ok, nok) {
  return factorySpace(effects, afterWhitespace, "linePrefix");
  function afterWhitespace(code) {
    return code === null || markdownLineEnding(code) ? ok(code) : nok(code);
  }
}

// ../simple-mind-map/node_modules/micromark-core-commonmark/lib/block-quote.js
var blockQuote = {
  name: "blockQuote",
  tokenize: tokenizeBlockQuoteStart,
  continuation: {
    tokenize: tokenizeBlockQuoteContinuation
  },
  exit
};
function tokenizeBlockQuoteStart(effects, ok, nok) {
  const self2 = this;
  return start;
  function start(code) {
    if (code === 62) {
      const state = self2.containerState;
      if (!state.open) {
        effects.enter("blockQuote", {
          _container: true
        });
        state.open = true;
      }
      effects.enter("blockQuotePrefix");
      effects.enter("blockQuoteMarker");
      effects.consume(code);
      effects.exit("blockQuoteMarker");
      return after2;
    }
    return nok(code);
  }
  function after2(code) {
    if (markdownSpace(code)) {
      effects.enter("blockQuotePrefixWhitespace");
      effects.consume(code);
      effects.exit("blockQuotePrefixWhitespace");
      effects.exit("blockQuotePrefix");
      return ok;
    }
    effects.exit("blockQuotePrefix");
    return ok(code);
  }
}
function tokenizeBlockQuoteContinuation(effects, ok, nok) {
  return factorySpace(
    effects,
    effects.attempt(blockQuote, ok, nok),
    "linePrefix",
    this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
  );
}
function exit(effects) {
  effects.exit("blockQuote");
}

// ../simple-mind-map/node_modules/micromark-core-commonmark/lib/character-escape.js
var characterEscape = {
  name: "characterEscape",
  tokenize: tokenizeCharacterEscape
};
function tokenizeCharacterEscape(effects, ok, nok) {
  return start;
  function start(code) {
    effects.enter("characterEscape");
    effects.enter("escapeMarker");
    effects.consume(code);
    effects.exit("escapeMarker");
    return open4;
  }
  function open4(code) {
    if (asciiPunctuation(code)) {
      effects.enter("characterEscapeValue");
      effects.consume(code);
      effects.exit("characterEscapeValue");
      effects.exit("characterEscape");
      return ok;
    }
    return nok(code);
  }
}

// ../simple-mind-map/node_modules/decode-named-character-reference/index.dom.js
var element = document.createElement("i");
function decodeNamedCharacterReference(value) {
  const characterReference2 = "&" + value + ";";
  element.innerHTML = characterReference2;
  const char = element.textContent;
  if (char.charCodeAt(char.length - 1) === 59 && value !== "semi") {
    return false;
  }
  return char === characterReference2 ? false : char;
}

// ../simple-mind-map/node_modules/micromark-core-commonmark/lib/character-reference.js
var characterReference = {
  name: "characterReference",
  tokenize: tokenizeCharacterReference
};
function tokenizeCharacterReference(effects, ok, nok) {
  const self2 = this;
  let size2 = 0;
  let max2;
  let test;
  return start;
  function start(code) {
    effects.enter("characterReference");
    effects.enter("characterReferenceMarker");
    effects.consume(code);
    effects.exit("characterReferenceMarker");
    return open4;
  }
  function open4(code) {
    if (code === 35) {
      effects.enter("characterReferenceMarkerNumeric");
      effects.consume(code);
      effects.exit("characterReferenceMarkerNumeric");
      return numeric;
    }
    effects.enter("characterReferenceValue");
    max2 = 31;
    test = asciiAlphanumeric;
    return value(code);
  }
  function numeric(code) {
    if (code === 88 || code === 120) {
      effects.enter("characterReferenceMarkerHexadecimal");
      effects.consume(code);
      effects.exit("characterReferenceMarkerHexadecimal");
      effects.enter("characterReferenceValue");
      max2 = 6;
      test = asciiHexDigit;
      return value;
    }
    effects.enter("characterReferenceValue");
    max2 = 7;
    test = asciiDigit;
    return value(code);
  }
  function value(code) {
    let token;
    if (code === 59 && size2) {
      token = effects.exit("characterReferenceValue");
      if (test === asciiAlphanumeric && !decodeNamedCharacterReference(self2.sliceSerialize(token))) {
        return nok(code);
      }
      effects.enter("characterReferenceMarker");
      effects.consume(code);
      effects.exit("characterReferenceMarker");
      effects.exit("characterReference");
      return ok;
    }
    if (test(code) && size2++ < max2) {
      effects.consume(code);
      return value;
    }
    return nok(code);
  }
}

// ../simple-mind-map/node_modules/micromark-core-commonmark/lib/code-fenced.js
var codeFenced = {
  name: "codeFenced",
  tokenize: tokenizeCodeFenced,
  concrete: true
};
function tokenizeCodeFenced(effects, ok, nok) {
  const self2 = this;
  const closingFenceConstruct = {
    tokenize: tokenizeClosingFence,
    partial: true
  };
  const nonLazyLine = {
    tokenize: tokenizeNonLazyLine,
    partial: true
  };
  const tail = this.events[this.events.length - 1];
  const initialPrefix = tail && tail[1].type === "linePrefix" ? tail[2].sliceSerialize(tail[1], true).length : 0;
  let sizeOpen = 0;
  let marker;
  return start;
  function start(code) {
    effects.enter("codeFenced");
    effects.enter("codeFencedFence");
    effects.enter("codeFencedFenceSequence");
    marker = code;
    return sequenceOpen(code);
  }
  function sequenceOpen(code) {
    if (code === marker) {
      effects.consume(code);
      sizeOpen++;
      return sequenceOpen;
    }
    effects.exit("codeFencedFenceSequence");
    return sizeOpen < 3 ? nok(code) : factorySpace(effects, infoOpen, "whitespace")(code);
  }
  function infoOpen(code) {
    if (code === null || markdownLineEnding(code)) {
      return openAfter(code);
    }
    effects.enter("codeFencedFenceInfo");
    effects.enter("chunkString", {
      contentType: "string"
    });
    return info(code);
  }
  function info(code) {
    if (code === null || markdownLineEndingOrSpace(code)) {
      effects.exit("chunkString");
      effects.exit("codeFencedFenceInfo");
      return factorySpace(effects, infoAfter, "whitespace")(code);
    }
    if (code === 96 && code === marker)
      return nok(code);
    effects.consume(code);
    return info;
  }
  function infoAfter(code) {
    if (code === null || markdownLineEnding(code)) {
      return openAfter(code);
    }
    effects.enter("codeFencedFenceMeta");
    effects.enter("chunkString", {
      contentType: "string"
    });
    return meta(code);
  }
  function meta(code) {
    if (code === null || markdownLineEnding(code)) {
      effects.exit("chunkString");
      effects.exit("codeFencedFenceMeta");
      return openAfter(code);
    }
    if (code === 96 && code === marker)
      return nok(code);
    effects.consume(code);
    return meta;
  }
  function openAfter(code) {
    effects.exit("codeFencedFence");
    return self2.interrupt ? ok(code) : contentStart(code);
  }
  function contentStart(code) {
    if (code === null) {
      return after2(code);
    }
    if (markdownLineEnding(code)) {
      return effects.attempt(
        nonLazyLine,
        effects.attempt(
          closingFenceConstruct,
          after2,
          initialPrefix ? factorySpace(
            effects,
            contentStart,
            "linePrefix",
            initialPrefix + 1
          ) : contentStart
        ),
        after2
      )(code);
    }
    effects.enter("codeFlowValue");
    return contentContinue(code);
  }
  function contentContinue(code) {
    if (code === null || markdownLineEnding(code)) {
      effects.exit("codeFlowValue");
      return contentStart(code);
    }
    effects.consume(code);
    return contentContinue;
  }
  function after2(code) {
    effects.exit("codeFenced");
    return ok(code);
  }
  function tokenizeNonLazyLine(effects2, ok2, nok2) {
    const self3 = this;
    return start2;
    function start2(code) {
      effects2.enter("lineEnding");
      effects2.consume(code);
      effects2.exit("lineEnding");
      return lineStart;
    }
    function lineStart(code) {
      return self3.parser.lazy[self3.now().line] ? nok2(code) : ok2(code);
    }
  }
  function tokenizeClosingFence(effects2, ok2, nok2) {
    let size2 = 0;
    return factorySpace(
      effects2,
      closingSequenceStart,
      "linePrefix",
      this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
    );
    function closingSequenceStart(code) {
      effects2.enter("codeFencedFence");
      effects2.enter("codeFencedFenceSequence");
      return closingSequence(code);
    }
    function closingSequence(code) {
      if (code === marker) {
        effects2.consume(code);
        size2++;
        return closingSequence;
      }
      if (size2 < sizeOpen)
        return nok2(code);
      effects2.exit("codeFencedFenceSequence");
      return factorySpace(effects2, closingSequenceEnd, "whitespace")(code);
    }
    function closingSequenceEnd(code) {
      if (code === null || markdownLineEnding(code)) {
        effects2.exit("codeFencedFence");
        return ok2(code);
      }
      return nok2(code);
    }
  }
}

// ../simple-mind-map/node_modules/micromark-core-commonmark/lib/code-indented.js
var codeIndented = {
  name: "codeIndented",
  tokenize: tokenizeCodeIndented
};
var indentedContent = {
  tokenize: tokenizeIndentedContent,
  partial: true
};
function tokenizeCodeIndented(effects, ok, nok) {
  const self2 = this;
  return start;
  function start(code) {
    effects.enter("codeIndented");
    return factorySpace(effects, afterStartPrefix, "linePrefix", 4 + 1)(code);
  }
  function afterStartPrefix(code) {
    const tail = self2.events[self2.events.length - 1];
    return tail && tail[1].type === "linePrefix" && tail[2].sliceSerialize(tail[1], true).length >= 4 ? afterPrefix(code) : nok(code);
  }
  function afterPrefix(code) {
    if (code === null) {
      return after2(code);
    }
    if (markdownLineEnding(code)) {
      return effects.attempt(indentedContent, afterPrefix, after2)(code);
    }
    effects.enter("codeFlowValue");
    return content3(code);
  }
  function content3(code) {
    if (code === null || markdownLineEnding(code)) {
      effects.exit("codeFlowValue");
      return afterPrefix(code);
    }
    effects.consume(code);
    return content3;
  }
  function after2(code) {
    effects.exit("codeIndented");
    return ok(code);
  }
}
function tokenizeIndentedContent(effects, ok, nok) {
  const self2 = this;
  return start;
  function start(code) {
    if (self2.parser.lazy[self2.now().line]) {
      return nok(code);
    }
    if (markdownLineEnding(code)) {
      effects.enter("lineEnding");
      effects.consume(code);
      effects.exit("lineEnding");
      return start;
    }
    return factorySpace(effects, afterPrefix, "linePrefix", 4 + 1)(code);
  }
  function afterPrefix(code) {
    const tail = self2.events[self2.events.length - 1];
    return tail && tail[1].type === "linePrefix" && tail[2].sliceSerialize(tail[1], true).length >= 4 ? ok(code) : markdownLineEnding(code) ? start(code) : nok(code);
  }
}

// ../simple-mind-map/node_modules/micromark-core-commonmark/lib/code-text.js
var codeText = {
  name: "codeText",
  tokenize: tokenizeCodeText,
  resolve: resolveCodeText,
  previous
};
function resolveCodeText(events) {
  let tailExitIndex = events.length - 4;
  let headEnterIndex = 3;
  let index3;
  let enter;
  if ((events[headEnterIndex][1].type === "lineEnding" || events[headEnterIndex][1].type === "space") && (events[tailExitIndex][1].type === "lineEnding" || events[tailExitIndex][1].type === "space")) {
    index3 = headEnterIndex;
    while (++index3 < tailExitIndex) {
      if (events[index3][1].type === "codeTextData") {
        events[headEnterIndex][1].type = "codeTextPadding";
        events[tailExitIndex][1].type = "codeTextPadding";
        headEnterIndex += 2;
        tailExitIndex -= 2;
        break;
      }
    }
  }
  index3 = headEnterIndex - 1;
  tailExitIndex++;
  while (++index3 <= tailExitIndex) {
    if (enter === void 0) {
      if (index3 !== tailExitIndex && events[index3][1].type !== "lineEnding") {
        enter = index3;
      }
    } else if (index3 === tailExitIndex || events[index3][1].type === "lineEnding") {
      events[enter][1].type = "codeTextData";
      if (index3 !== enter + 2) {
        events[enter][1].end = events[index3 - 1][1].end;
        events.splice(enter + 2, index3 - enter - 2);
        tailExitIndex -= index3 - enter - 2;
        index3 = enter + 2;
      }
      enter = void 0;
    }
  }
  return events;
}
function previous(code) {
  return code !== 96 || this.events[this.events.length - 1][1].type === "characterEscape";
}
function tokenizeCodeText(effects, ok, nok) {
  const self2 = this;
  let sizeOpen = 0;
  let size2;
  let token;
  return start;
  function start(code) {
    effects.enter("codeText");
    effects.enter("codeTextSequence");
    return openingSequence(code);
  }
  function openingSequence(code) {
    if (code === 96) {
      effects.consume(code);
      sizeOpen++;
      return openingSequence;
    }
    effects.exit("codeTextSequence");
    return gap(code);
  }
  function gap(code) {
    if (code === null) {
      return nok(code);
    }
    if (code === 96) {
      token = effects.enter("codeTextSequence");
      size2 = 0;
      return closingSequence(code);
    }
    if (code === 32) {
      effects.enter("space");
      effects.consume(code);
      effects.exit("space");
      return gap;
    }
    if (markdownLineEnding(code)) {
      effects.enter("lineEnding");
      effects.consume(code);
      effects.exit("lineEnding");
      return gap;
    }
    effects.enter("codeTextData");
    return data2(code);
  }
  function data2(code) {
    if (code === null || code === 32 || code === 96 || markdownLineEnding(code)) {
      effects.exit("codeTextData");
      return gap(code);
    }
    effects.consume(code);
    return data2;
  }
  function closingSequence(code) {
    if (code === 96) {
      effects.consume(code);
      size2++;
      return closingSequence;
    }
    if (size2 === sizeOpen) {
      effects.exit("codeTextSequence");
      effects.exit("codeText");
      return ok(code);
    }
    token.type = "codeTextData";
    return data2(code);
  }
}

// ../simple-mind-map/node_modules/micromark-util-subtokenize/index.js
function subtokenize(events) {
  const jumps = {};
  let index3 = -1;
  let event;
  let lineIndex;
  let otherIndex;
  let otherEvent;
  let parameters;
  let subevents;
  let more;
  while (++index3 < events.length) {
    while (index3 in jumps) {
      index3 = jumps[index3];
    }
    event = events[index3];
    if (index3 && event[1].type === "chunkFlow" && events[index3 - 1][1].type === "listItemPrefix") {
      subevents = event[1]._tokenizer.events;
      otherIndex = 0;
      if (otherIndex < subevents.length && subevents[otherIndex][1].type === "lineEndingBlank") {
        otherIndex += 2;
      }
      if (otherIndex < subevents.length && subevents[otherIndex][1].type === "content") {
        while (++otherIndex < subevents.length) {
          if (subevents[otherIndex][1].type === "content") {
            break;
          }
          if (subevents[otherIndex][1].type === "chunkText") {
            subevents[otherIndex][1]._isInFirstContentOfListItem = true;
            otherIndex++;
          }
        }
      }
    }
    if (event[0] === "enter") {
      if (event[1].contentType) {
        Object.assign(jumps, subcontent(events, index3));
        index3 = jumps[index3];
        more = true;
      }
    } else if (event[1]._container) {
      otherIndex = index3;
      lineIndex = void 0;
      while (otherIndex--) {
        otherEvent = events[otherIndex];
        if (otherEvent[1].type === "lineEnding" || otherEvent[1].type === "lineEndingBlank") {
          if (otherEvent[0] === "enter") {
            if (lineIndex) {
              events[lineIndex][1].type = "lineEndingBlank";
            }
            otherEvent[1].type = "lineEnding";
            lineIndex = otherIndex;
          }
        } else {
          break;
        }
      }
      if (lineIndex) {
        event[1].end = Object.assign({}, events[lineIndex][1].start);
        parameters = events.slice(lineIndex, index3);
        parameters.unshift(event);
        splice(events, lineIndex, index3 - lineIndex + 1, parameters);
      }
    }
  }
  return !more;
}
function subcontent(events, eventIndex) {
  const token = events[eventIndex][1];
  const context = events[eventIndex][2];
  let startPosition = eventIndex - 1;
  const startPositions = [];
  const tokenizer = token._tokenizer || context.parser[token.contentType](token.start);
  const childEvents = tokenizer.events;
  const jumps = [];
  const gaps = {};
  let stream;
  let previous2;
  let index3 = -1;
  let current = token;
  let adjust = 0;
  let start = 0;
  const breaks = [start];
  while (current) {
    while (events[++startPosition][1] !== current) {
    }
    startPositions.push(startPosition);
    if (!current._tokenizer) {
      stream = context.sliceStream(current);
      if (!current.next) {
        stream.push(null);
      }
      if (previous2) {
        tokenizer.defineSkip(current.start);
      }
      if (current._isInFirstContentOfListItem) {
        tokenizer._gfmTasklistFirstContentOfListItem = true;
      }
      tokenizer.write(stream);
      if (current._isInFirstContentOfListItem) {
        tokenizer._gfmTasklistFirstContentOfListItem = void 0;
      }
    }
    previous2 = current;
    current = current.next;
  }
  current = token;
  while (++index3 < childEvents.length) {
    if (
      // Find a void token that includes a break.
      childEvents[index3][0] === "exit" && childEvents[index3 - 1][0] === "enter" && childEvents[index3][1].type === childEvents[index3 - 1][1].type && childEvents[index3][1].start.line !== childEvents[index3][1].end.line
    ) {
      start = index3 + 1;
      breaks.push(start);
      current._tokenizer = void 0;
      current.previous = void 0;
      current = current.next;
    }
  }
  tokenizer.events = [];
  if (current) {
    current._tokenizer = void 0;
    current.previous = void 0;
  } else {
    breaks.pop();
  }
  index3 = breaks.length;
  while (index3--) {
    const slice = childEvents.slice(breaks[index3], breaks[index3 + 1]);
    const start2 = startPositions.pop();
    jumps.unshift([start2, start2 + slice.length - 1]);
    splice(events, start2, 2, slice);
  }
  index3 = -1;
  while (++index3 < jumps.length) {
    gaps[adjust + jumps[index3][0]] = adjust + jumps[index3][1];
    adjust += jumps[index3][1] - jumps[index3][0] - 1;
  }
  return gaps;
}

// ../simple-mind-map/node_modules/micromark-core-commonmark/lib/content.js
var content2 = {
  tokenize: tokenizeContent,
  resolve: resolveContent
};
var continuationConstruct = {
  tokenize: tokenizeContinuation,
  partial: true
};
function resolveContent(events) {
  subtokenize(events);
  return events;
}
function tokenizeContent(effects, ok) {
  let previous2;
  return start;
  function start(code) {
    effects.enter("content");
    previous2 = effects.enter("chunkContent", {
      contentType: "content"
    });
    return data2(code);
  }
  function data2(code) {
    if (code === null) {
      return contentEnd(code);
    }
    if (markdownLineEnding(code)) {
      return effects.check(
        continuationConstruct,
        contentContinue,
        contentEnd
      )(code);
    }
    effects.consume(code);
    return data2;
  }
  function contentEnd(code) {
    effects.exit("chunkContent");
    effects.exit("content");
    return ok(code);
  }
  function contentContinue(code) {
    effects.consume(code);
    effects.exit("chunkContent");
    previous2.next = effects.enter("chunkContent", {
      contentType: "content",
      previous: previous2
    });
    previous2 = previous2.next;
    return data2;
  }
}
function tokenizeContinuation(effects, ok, nok) {
  const self2 = this;
  return startLookahead;
  function startLookahead(code) {
    effects.exit("chunkContent");
    effects.enter("lineEnding");
    effects.consume(code);
    effects.exit("lineEnding");
    return factorySpace(effects, prefixed, "linePrefix");
  }
  function prefixed(code) {
    if (code === null || markdownLineEnding(code)) {
      return nok(code);
    }
    const tail = self2.events[self2.events.length - 1];
    if (!self2.parser.constructs.disable.null.includes("codeIndented") && tail && tail[1].type === "linePrefix" && tail[2].sliceSerialize(tail[1], true).length >= 4) {
      return ok(code);
    }
    return effects.interrupt(self2.parser.constructs.flow, nok, ok)(code);
  }
}

// ../simple-mind-map/node_modules/micromark-factory-destination/index.js
function factoryDestination(effects, ok, nok, type, literalType, literalMarkerType, rawType, stringType, max2) {
  const limit = max2 || Number.POSITIVE_INFINITY;
  let balance = 0;
  return start;
  function start(code) {
    if (code === 60) {
      effects.enter(type);
      effects.enter(literalType);
      effects.enter(literalMarkerType);
      effects.consume(code);
      effects.exit(literalMarkerType);
      return destinationEnclosedBefore;
    }
    if (code === null || code === 41 || asciiControl(code)) {
      return nok(code);
    }
    effects.enter(type);
    effects.enter(rawType);
    effects.enter(stringType);
    effects.enter("chunkString", {
      contentType: "string"
    });
    return destinationRaw(code);
  }
  function destinationEnclosedBefore(code) {
    if (code === 62) {
      effects.enter(literalMarkerType);
      effects.consume(code);
      effects.exit(literalMarkerType);
      effects.exit(literalType);
      effects.exit(type);
      return ok;
    }
    effects.enter(stringType);
    effects.enter("chunkString", {
      contentType: "string"
    });
    return destinationEnclosed(code);
  }
  function destinationEnclosed(code) {
    if (code === 62) {
      effects.exit("chunkString");
      effects.exit(stringType);
      return destinationEnclosedBefore(code);
    }
    if (code === null || code === 60 || markdownLineEnding(code)) {
      return nok(code);
    }
    effects.consume(code);
    return code === 92 ? destinationEnclosedEscape : destinationEnclosed;
  }
  function destinationEnclosedEscape(code) {
    if (code === 60 || code === 62 || code === 92) {
      effects.consume(code);
      return destinationEnclosed;
    }
    return destinationEnclosed(code);
  }
  function destinationRaw(code) {
    if (code === 40) {
      if (++balance > limit)
        return nok(code);
      effects.consume(code);
      return destinationRaw;
    }
    if (code === 41) {
      if (!balance--) {
        effects.exit("chunkString");
        effects.exit(stringType);
        effects.exit(rawType);
        effects.exit(type);
        return ok(code);
      }
      effects.consume(code);
      return destinationRaw;
    }
    if (code === null || markdownLineEndingOrSpace(code)) {
      if (balance)
        return nok(code);
      effects.exit("chunkString");
      effects.exit(stringType);
      effects.exit(rawType);
      effects.exit(type);
      return ok(code);
    }
    if (asciiControl(code))
      return nok(code);
    effects.consume(code);
    return code === 92 ? destinationRawEscape : destinationRaw;
  }
  function destinationRawEscape(code) {
    if (code === 40 || code === 41 || code === 92) {
      effects.consume(code);
      return destinationRaw;
    }
    return destinationRaw(code);
  }
}

// ../simple-mind-map/node_modules/micromark-factory-label/index.js
function factoryLabel(effects, ok, nok, type, markerType, stringType) {
  const self2 = this;
  let size2 = 0;
  let data2;
  return start;
  function start(code) {
    effects.enter(type);
    effects.enter(markerType);
    effects.consume(code);
    effects.exit(markerType);
    effects.enter(stringType);
    return atBreak;
  }
  function atBreak(code) {
    if (code === null || code === 91 || code === 93 && !data2 || /* To do: remove in the future once we’ve switched from
     * `micromark-extension-footnote` to `micromark-extension-gfm-footnote`,
     * which doesn’t need this */
    /* Hidden footnotes hook */
    /* c8 ignore next 3 */
    code === 94 && !size2 && "_hiddenFootnoteSupport" in self2.parser.constructs || size2 > 999) {
      return nok(code);
    }
    if (code === 93) {
      effects.exit(stringType);
      effects.enter(markerType);
      effects.consume(code);
      effects.exit(markerType);
      effects.exit(type);
      return ok;
    }
    if (markdownLineEnding(code)) {
      effects.enter("lineEnding");
      effects.consume(code);
      effects.exit("lineEnding");
      return atBreak;
    }
    effects.enter("chunkString", {
      contentType: "string"
    });
    return label(code);
  }
  function label(code) {
    if (code === null || code === 91 || code === 93 || markdownLineEnding(code) || size2++ > 999) {
      effects.exit("chunkString");
      return atBreak(code);
    }
    effects.consume(code);
    data2 = data2 || !markdownSpace(code);
    return code === 92 ? labelEscape : label;
  }
  function labelEscape(code) {
    if (code === 91 || code === 92 || code === 93) {
      effects.consume(code);
      size2++;
      return label;
    }
    return label(code);
  }
}

// ../simple-mind-map/node_modules/micromark-factory-title/index.js
function factoryTitle(effects, ok, nok, type, markerType, stringType) {
  let marker;
  return start;
  function start(code) {
    effects.enter(type);
    effects.enter(markerType);
    effects.consume(code);
    effects.exit(markerType);
    marker = code === 40 ? 41 : code;
    return atFirstTitleBreak;
  }
  function atFirstTitleBreak(code) {
    if (code === marker) {
      effects.enter(markerType);
      effects.consume(code);
      effects.exit(markerType);
      effects.exit(type);
      return ok;
    }
    effects.enter(stringType);
    return atTitleBreak(code);
  }
  function atTitleBreak(code) {
    if (code === marker) {
      effects.exit(stringType);
      return atFirstTitleBreak(marker);
    }
    if (code === null) {
      return nok(code);
    }
    if (markdownLineEnding(code)) {
      effects.enter("lineEnding");
      effects.consume(code);
      effects.exit("lineEnding");
      return factorySpace(effects, atTitleBreak, "linePrefix");
    }
    effects.enter("chunkString", {
      contentType: "string"
    });
    return title(code);
  }
  function title(code) {
    if (code === marker || code === null || markdownLineEnding(code)) {
      effects.exit("chunkString");
      return atTitleBreak(code);
    }
    effects.consume(code);
    return code === 92 ? titleEscape : title;
  }
  function titleEscape(code) {
    if (code === marker || code === 92) {
      effects.consume(code);
      return title;
    }
    return title(code);
  }
}

// ../simple-mind-map/node_modules/micromark-factory-whitespace/index.js
function factoryWhitespace(effects, ok) {
  let seen;
  return start;
  function start(code) {
    if (markdownLineEnding(code)) {
      effects.enter("lineEnding");
      effects.consume(code);
      effects.exit("lineEnding");
      seen = true;
      return start;
    }
    if (markdownSpace(code)) {
      return factorySpace(
        effects,
        start,
        seen ? "linePrefix" : "lineSuffix"
      )(code);
    }
    return ok(code);
  }
}

// ../simple-mind-map/node_modules/micromark-util-normalize-identifier/index.js
function normalizeIdentifier(value) {
  return value.replace(/[\t\n\r ]+/g, " ").replace(/^ | $/g, "").toLowerCase().toUpperCase();
}

// ../simple-mind-map/node_modules/micromark-core-commonmark/lib/definition.js
var definition = {
  name: "definition",
  tokenize: tokenizeDefinition
};
var titleConstruct = {
  tokenize: tokenizeTitle,
  partial: true
};
function tokenizeDefinition(effects, ok, nok) {
  const self2 = this;
  let identifier;
  return start;
  function start(code) {
    effects.enter("definition");
    return factoryLabel.call(
      self2,
      effects,
      labelAfter,
      nok,
      "definitionLabel",
      "definitionLabelMarker",
      "definitionLabelString"
    )(code);
  }
  function labelAfter(code) {
    identifier = normalizeIdentifier(
      self2.sliceSerialize(self2.events[self2.events.length - 1][1]).slice(1, -1)
    );
    if (code === 58) {
      effects.enter("definitionMarker");
      effects.consume(code);
      effects.exit("definitionMarker");
      return factoryWhitespace(
        effects,
        factoryDestination(
          effects,
          effects.attempt(
            titleConstruct,
            factorySpace(effects, after2, "whitespace"),
            factorySpace(effects, after2, "whitespace")
          ),
          nok,
          "definitionDestination",
          "definitionDestinationLiteral",
          "definitionDestinationLiteralMarker",
          "definitionDestinationRaw",
          "definitionDestinationString"
        )
      );
    }
    return nok(code);
  }
  function after2(code) {
    if (code === null || markdownLineEnding(code)) {
      effects.exit("definition");
      if (!self2.parser.defined.includes(identifier)) {
        self2.parser.defined.push(identifier);
      }
      return ok(code);
    }
    return nok(code);
  }
}
function tokenizeTitle(effects, ok, nok) {
  return start;
  function start(code) {
    return markdownLineEndingOrSpace(code) ? factoryWhitespace(effects, before2)(code) : nok(code);
  }
  function before2(code) {
    if (code === 34 || code === 39 || code === 40) {
      return factoryTitle(
        effects,
        factorySpace(effects, after2, "whitespace"),
        nok,
        "definitionTitle",
        "definitionTitleMarker",
        "definitionTitleString"
      )(code);
    }
    return nok(code);
  }
  function after2(code) {
    return code === null || markdownLineEnding(code) ? ok(code) : nok(code);
  }
}

// ../simple-mind-map/node_modules/micromark-core-commonmark/lib/hard-break-escape.js
var hardBreakEscape = {
  name: "hardBreakEscape",
  tokenize: tokenizeHardBreakEscape
};
function tokenizeHardBreakEscape(effects, ok, nok) {
  return start;
  function start(code) {
    effects.enter("hardBreakEscape");
    effects.enter("escapeMarker");
    effects.consume(code);
    return open4;
  }
  function open4(code) {
    if (markdownLineEnding(code)) {
      effects.exit("escapeMarker");
      effects.exit("hardBreakEscape");
      return ok(code);
    }
    return nok(code);
  }
}

// ../simple-mind-map/node_modules/micromark-core-commonmark/lib/heading-atx.js
var headingAtx = {
  name: "headingAtx",
  tokenize: tokenizeHeadingAtx,
  resolve: resolveHeadingAtx
};
function resolveHeadingAtx(events, context) {
  let contentEnd = events.length - 2;
  let contentStart = 3;
  let content3;
  let text4;
  if (events[contentStart][1].type === "whitespace") {
    contentStart += 2;
  }
  if (contentEnd - 2 > contentStart && events[contentEnd][1].type === "whitespace") {
    contentEnd -= 2;
  }
  if (events[contentEnd][1].type === "atxHeadingSequence" && (contentStart === contentEnd - 1 || contentEnd - 4 > contentStart && events[contentEnd - 2][1].type === "whitespace")) {
    contentEnd -= contentStart + 1 === contentEnd ? 2 : 4;
  }
  if (contentEnd > contentStart) {
    content3 = {
      type: "atxHeadingText",
      start: events[contentStart][1].start,
      end: events[contentEnd][1].end
    };
    text4 = {
      type: "chunkText",
      start: events[contentStart][1].start,
      end: events[contentEnd][1].end,
      // @ts-expect-error Constants are fine to assign.
      contentType: "text"
    };
    splice(events, contentStart, contentEnd - contentStart + 1, [
      ["enter", content3, context],
      ["enter", text4, context],
      ["exit", text4, context],
      ["exit", content3, context]
    ]);
  }
  return events;
}
function tokenizeHeadingAtx(effects, ok, nok) {
  const self2 = this;
  let size2 = 0;
  return start;
  function start(code) {
    effects.enter("atxHeading");
    effects.enter("atxHeadingSequence");
    return fenceOpenInside(code);
  }
  function fenceOpenInside(code) {
    if (code === 35 && size2++ < 6) {
      effects.consume(code);
      return fenceOpenInside;
    }
    if (code === null || markdownLineEndingOrSpace(code)) {
      effects.exit("atxHeadingSequence");
      return self2.interrupt ? ok(code) : headingBreak(code);
    }
    return nok(code);
  }
  function headingBreak(code) {
    if (code === 35) {
      effects.enter("atxHeadingSequence");
      return sequence(code);
    }
    if (code === null || markdownLineEnding(code)) {
      effects.exit("atxHeading");
      return ok(code);
    }
    if (markdownSpace(code)) {
      return factorySpace(effects, headingBreak, "whitespace")(code);
    }
    effects.enter("atxHeadingText");
    return data2(code);
  }
  function sequence(code) {
    if (code === 35) {
      effects.consume(code);
      return sequence;
    }
    effects.exit("atxHeadingSequence");
    return headingBreak(code);
  }
  function data2(code) {
    if (code === null || code === 35 || markdownLineEndingOrSpace(code)) {
      effects.exit("atxHeadingText");
      return headingBreak(code);
    }
    effects.consume(code);
    return data2;
  }
}

// ../simple-mind-map/node_modules/micromark-util-html-tag-name/index.js
var htmlBlockNames = [
  "address",
  "article",
  "aside",
  "base",
  "basefont",
  "blockquote",
  "body",
  "caption",
  "center",
  "col",
  "colgroup",
  "dd",
  "details",
  "dialog",
  "dir",
  "div",
  "dl",
  "dt",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "frame",
  "frameset",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hr",
  "html",
  "iframe",
  "legend",
  "li",
  "link",
  "main",
  "menu",
  "menuitem",
  "nav",
  "noframes",
  "ol",
  "optgroup",
  "option",
  "p",
  "param",
  "section",
  "summary",
  "table",
  "tbody",
  "td",
  "tfoot",
  "th",
  "thead",
  "title",
  "tr",
  "track",
  "ul"
];
var htmlRawNames = ["pre", "script", "style", "textarea"];

// ../simple-mind-map/node_modules/micromark-core-commonmark/lib/html-flow.js
var htmlFlow = {
  name: "htmlFlow",
  tokenize: tokenizeHtmlFlow,
  resolveTo: resolveToHtmlFlow,
  concrete: true
};
var nextBlankConstruct = {
  tokenize: tokenizeNextBlank,
  partial: true
};
function resolveToHtmlFlow(events) {
  let index3 = events.length;
  while (index3--) {
    if (events[index3][0] === "enter" && events[index3][1].type === "htmlFlow") {
      break;
    }
  }
  if (index3 > 1 && events[index3 - 2][1].type === "linePrefix") {
    events[index3][1].start = events[index3 - 2][1].start;
    events[index3 + 1][1].start = events[index3 - 2][1].start;
    events.splice(index3 - 2, 2);
  }
  return events;
}
function tokenizeHtmlFlow(effects, ok, nok) {
  const self2 = this;
  let kind;
  let startTag;
  let buffer;
  let index3;
  let marker;
  return start;
  function start(code) {
    effects.enter("htmlFlow");
    effects.enter("htmlFlowData");
    effects.consume(code);
    return open4;
  }
  function open4(code) {
    if (code === 33) {
      effects.consume(code);
      return declarationStart;
    }
    if (code === 47) {
      effects.consume(code);
      return tagCloseStart;
    }
    if (code === 63) {
      effects.consume(code);
      kind = 3;
      return self2.interrupt ? ok : continuationDeclarationInside;
    }
    if (asciiAlpha(code)) {
      effects.consume(code);
      buffer = String.fromCharCode(code);
      startTag = true;
      return tagName;
    }
    return nok(code);
  }
  function declarationStart(code) {
    if (code === 45) {
      effects.consume(code);
      kind = 2;
      return commentOpenInside;
    }
    if (code === 91) {
      effects.consume(code);
      kind = 5;
      buffer = "CDATA[";
      index3 = 0;
      return cdataOpenInside;
    }
    if (asciiAlpha(code)) {
      effects.consume(code);
      kind = 4;
      return self2.interrupt ? ok : continuationDeclarationInside;
    }
    return nok(code);
  }
  function commentOpenInside(code) {
    if (code === 45) {
      effects.consume(code);
      return self2.interrupt ? ok : continuationDeclarationInside;
    }
    return nok(code);
  }
  function cdataOpenInside(code) {
    if (code === buffer.charCodeAt(index3++)) {
      effects.consume(code);
      return index3 === buffer.length ? self2.interrupt ? ok : continuation : cdataOpenInside;
    }
    return nok(code);
  }
  function tagCloseStart(code) {
    if (asciiAlpha(code)) {
      effects.consume(code);
      buffer = String.fromCharCode(code);
      return tagName;
    }
    return nok(code);
  }
  function tagName(code) {
    if (code === null || code === 47 || code === 62 || markdownLineEndingOrSpace(code)) {
      if (code !== 47 && startTag && htmlRawNames.includes(buffer.toLowerCase())) {
        kind = 1;
        return self2.interrupt ? ok(code) : continuation(code);
      }
      if (htmlBlockNames.includes(buffer.toLowerCase())) {
        kind = 6;
        if (code === 47) {
          effects.consume(code);
          return basicSelfClosing;
        }
        return self2.interrupt ? ok(code) : continuation(code);
      }
      kind = 7;
      return self2.interrupt && !self2.parser.lazy[self2.now().line] ? nok(code) : startTag ? completeAttributeNameBefore(code) : completeClosingTagAfter(code);
    }
    if (code === 45 || asciiAlphanumeric(code)) {
      effects.consume(code);
      buffer += String.fromCharCode(code);
      return tagName;
    }
    return nok(code);
  }
  function basicSelfClosing(code) {
    if (code === 62) {
      effects.consume(code);
      return self2.interrupt ? ok : continuation;
    }
    return nok(code);
  }
  function completeClosingTagAfter(code) {
    if (markdownSpace(code)) {
      effects.consume(code);
      return completeClosingTagAfter;
    }
    return completeEnd(code);
  }
  function completeAttributeNameBefore(code) {
    if (code === 47) {
      effects.consume(code);
      return completeEnd;
    }
    if (code === 58 || code === 95 || asciiAlpha(code)) {
      effects.consume(code);
      return completeAttributeName;
    }
    if (markdownSpace(code)) {
      effects.consume(code);
      return completeAttributeNameBefore;
    }
    return completeEnd(code);
  }
  function completeAttributeName(code) {
    if (code === 45 || code === 46 || code === 58 || code === 95 || asciiAlphanumeric(code)) {
      effects.consume(code);
      return completeAttributeName;
    }
    return completeAttributeNameAfter(code);
  }
  function completeAttributeNameAfter(code) {
    if (code === 61) {
      effects.consume(code);
      return completeAttributeValueBefore;
    }
    if (markdownSpace(code)) {
      effects.consume(code);
      return completeAttributeNameAfter;
    }
    return completeAttributeNameBefore(code);
  }
  function completeAttributeValueBefore(code) {
    if (code === null || code === 60 || code === 61 || code === 62 || code === 96) {
      return nok(code);
    }
    if (code === 34 || code === 39) {
      effects.consume(code);
      marker = code;
      return completeAttributeValueQuoted;
    }
    if (markdownSpace(code)) {
      effects.consume(code);
      return completeAttributeValueBefore;
    }
    marker = null;
    return completeAttributeValueUnquoted(code);
  }
  function completeAttributeValueQuoted(code) {
    if (code === null || markdownLineEnding(code)) {
      return nok(code);
    }
    if (code === marker) {
      effects.consume(code);
      return completeAttributeValueQuotedAfter;
    }
    effects.consume(code);
    return completeAttributeValueQuoted;
  }
  function completeAttributeValueUnquoted(code) {
    if (code === null || code === 34 || code === 39 || code === 60 || code === 61 || code === 62 || code === 96 || markdownLineEndingOrSpace(code)) {
      return completeAttributeNameAfter(code);
    }
    effects.consume(code);
    return completeAttributeValueUnquoted;
  }
  function completeAttributeValueQuotedAfter(code) {
    if (code === 47 || code === 62 || markdownSpace(code)) {
      return completeAttributeNameBefore(code);
    }
    return nok(code);
  }
  function completeEnd(code) {
    if (code === 62) {
      effects.consume(code);
      return completeAfter;
    }
    return nok(code);
  }
  function completeAfter(code) {
    if (markdownSpace(code)) {
      effects.consume(code);
      return completeAfter;
    }
    return code === null || markdownLineEnding(code) ? continuation(code) : nok(code);
  }
  function continuation(code) {
    if (code === 45 && kind === 2) {
      effects.consume(code);
      return continuationCommentInside;
    }
    if (code === 60 && kind === 1) {
      effects.consume(code);
      return continuationRawTagOpen;
    }
    if (code === 62 && kind === 4) {
      effects.consume(code);
      return continuationClose;
    }
    if (code === 63 && kind === 3) {
      effects.consume(code);
      return continuationDeclarationInside;
    }
    if (code === 93 && kind === 5) {
      effects.consume(code);
      return continuationCharacterDataInside;
    }
    if (markdownLineEnding(code) && (kind === 6 || kind === 7)) {
      return effects.check(
        nextBlankConstruct,
        continuationClose,
        continuationAtLineEnding
      )(code);
    }
    if (code === null || markdownLineEnding(code)) {
      return continuationAtLineEnding(code);
    }
    effects.consume(code);
    return continuation;
  }
  function continuationAtLineEnding(code) {
    effects.exit("htmlFlowData");
    return htmlContinueStart(code);
  }
  function htmlContinueStart(code) {
    if (code === null) {
      return done(code);
    }
    if (markdownLineEnding(code)) {
      return effects.attempt(
        {
          tokenize: htmlLineEnd,
          partial: true
        },
        htmlContinueStart,
        done
      )(code);
    }
    effects.enter("htmlFlowData");
    return continuation(code);
  }
  function htmlLineEnd(effects2, ok2, nok2) {
    return start2;
    function start2(code) {
      effects2.enter("lineEnding");
      effects2.consume(code);
      effects2.exit("lineEnding");
      return lineStart;
    }
    function lineStart(code) {
      return self2.parser.lazy[self2.now().line] ? nok2(code) : ok2(code);
    }
  }
  function continuationCommentInside(code) {
    if (code === 45) {
      effects.consume(code);
      return continuationDeclarationInside;
    }
    return continuation(code);
  }
  function continuationRawTagOpen(code) {
    if (code === 47) {
      effects.consume(code);
      buffer = "";
      return continuationRawEndTag;
    }
    return continuation(code);
  }
  function continuationRawEndTag(code) {
    if (code === 62 && htmlRawNames.includes(buffer.toLowerCase())) {
      effects.consume(code);
      return continuationClose;
    }
    if (asciiAlpha(code) && buffer.length < 8) {
      effects.consume(code);
      buffer += String.fromCharCode(code);
      return continuationRawEndTag;
    }
    return continuation(code);
  }
  function continuationCharacterDataInside(code) {
    if (code === 93) {
      effects.consume(code);
      return continuationDeclarationInside;
    }
    return continuation(code);
  }
  function continuationDeclarationInside(code) {
    if (code === 62) {
      effects.consume(code);
      return continuationClose;
    }
    if (code === 45 && kind === 2) {
      effects.consume(code);
      return continuationDeclarationInside;
    }
    return continuation(code);
  }
  function continuationClose(code) {
    if (code === null || markdownLineEnding(code)) {
      effects.exit("htmlFlowData");
      return done(code);
    }
    effects.consume(code);
    return continuationClose;
  }
  function done(code) {
    effects.exit("htmlFlow");
    return ok(code);
  }
}
function tokenizeNextBlank(effects, ok, nok) {
  return start;
  function start(code) {
    effects.exit("htmlFlowData");
    effects.enter("lineEndingBlank");
    effects.consume(code);
    effects.exit("lineEndingBlank");
    return effects.attempt(blankLine, ok, nok);
  }
}

// ../simple-mind-map/node_modules/micromark-core-commonmark/lib/html-text.js
var htmlText = {
  name: "htmlText",
  tokenize: tokenizeHtmlText
};
function tokenizeHtmlText(effects, ok, nok) {
  const self2 = this;
  let marker;
  let buffer;
  let index3;
  let returnState;
  return start;
  function start(code) {
    effects.enter("htmlText");
    effects.enter("htmlTextData");
    effects.consume(code);
    return open4;
  }
  function open4(code) {
    if (code === 33) {
      effects.consume(code);
      return declarationOpen;
    }
    if (code === 47) {
      effects.consume(code);
      return tagCloseStart;
    }
    if (code === 63) {
      effects.consume(code);
      return instruction;
    }
    if (asciiAlpha(code)) {
      effects.consume(code);
      return tagOpen;
    }
    return nok(code);
  }
  function declarationOpen(code) {
    if (code === 45) {
      effects.consume(code);
      return commentOpen;
    }
    if (code === 91) {
      effects.consume(code);
      buffer = "CDATA[";
      index3 = 0;
      return cdataOpen;
    }
    if (asciiAlpha(code)) {
      effects.consume(code);
      return declaration;
    }
    return nok(code);
  }
  function commentOpen(code) {
    if (code === 45) {
      effects.consume(code);
      return commentStart;
    }
    return nok(code);
  }
  function commentStart(code) {
    if (code === null || code === 62) {
      return nok(code);
    }
    if (code === 45) {
      effects.consume(code);
      return commentStartDash;
    }
    return comment(code);
  }
  function commentStartDash(code) {
    if (code === null || code === 62) {
      return nok(code);
    }
    return comment(code);
  }
  function comment(code) {
    if (code === null) {
      return nok(code);
    }
    if (code === 45) {
      effects.consume(code);
      return commentClose;
    }
    if (markdownLineEnding(code)) {
      returnState = comment;
      return atLineEnding(code);
    }
    effects.consume(code);
    return comment;
  }
  function commentClose(code) {
    if (code === 45) {
      effects.consume(code);
      return end;
    }
    return comment(code);
  }
  function cdataOpen(code) {
    if (code === buffer.charCodeAt(index3++)) {
      effects.consume(code);
      return index3 === buffer.length ? cdata : cdataOpen;
    }
    return nok(code);
  }
  function cdata(code) {
    if (code === null) {
      return nok(code);
    }
    if (code === 93) {
      effects.consume(code);
      return cdataClose;
    }
    if (markdownLineEnding(code)) {
      returnState = cdata;
      return atLineEnding(code);
    }
    effects.consume(code);
    return cdata;
  }
  function cdataClose(code) {
    if (code === 93) {
      effects.consume(code);
      return cdataEnd;
    }
    return cdata(code);
  }
  function cdataEnd(code) {
    if (code === 62) {
      return end(code);
    }
    if (code === 93) {
      effects.consume(code);
      return cdataEnd;
    }
    return cdata(code);
  }
  function declaration(code) {
    if (code === null || code === 62) {
      return end(code);
    }
    if (markdownLineEnding(code)) {
      returnState = declaration;
      return atLineEnding(code);
    }
    effects.consume(code);
    return declaration;
  }
  function instruction(code) {
    if (code === null) {
      return nok(code);
    }
    if (code === 63) {
      effects.consume(code);
      return instructionClose;
    }
    if (markdownLineEnding(code)) {
      returnState = instruction;
      return atLineEnding(code);
    }
    effects.consume(code);
    return instruction;
  }
  function instructionClose(code) {
    return code === 62 ? end(code) : instruction(code);
  }
  function tagCloseStart(code) {
    if (asciiAlpha(code)) {
      effects.consume(code);
      return tagClose;
    }
    return nok(code);
  }
  function tagClose(code) {
    if (code === 45 || asciiAlphanumeric(code)) {
      effects.consume(code);
      return tagClose;
    }
    return tagCloseBetween(code);
  }
  function tagCloseBetween(code) {
    if (markdownLineEnding(code)) {
      returnState = tagCloseBetween;
      return atLineEnding(code);
    }
    if (markdownSpace(code)) {
      effects.consume(code);
      return tagCloseBetween;
    }
    return end(code);
  }
  function tagOpen(code) {
    if (code === 45 || asciiAlphanumeric(code)) {
      effects.consume(code);
      return tagOpen;
    }
    if (code === 47 || code === 62 || markdownLineEndingOrSpace(code)) {
      return tagOpenBetween(code);
    }
    return nok(code);
  }
  function tagOpenBetween(code) {
    if (code === 47) {
      effects.consume(code);
      return end;
    }
    if (code === 58 || code === 95 || asciiAlpha(code)) {
      effects.consume(code);
      return tagOpenAttributeName;
    }
    if (markdownLineEnding(code)) {
      returnState = tagOpenBetween;
      return atLineEnding(code);
    }
    if (markdownSpace(code)) {
      effects.consume(code);
      return tagOpenBetween;
    }
    return end(code);
  }
  function tagOpenAttributeName(code) {
    if (code === 45 || code === 46 || code === 58 || code === 95 || asciiAlphanumeric(code)) {
      effects.consume(code);
      return tagOpenAttributeName;
    }
    return tagOpenAttributeNameAfter(code);
  }
  function tagOpenAttributeNameAfter(code) {
    if (code === 61) {
      effects.consume(code);
      return tagOpenAttributeValueBefore;
    }
    if (markdownLineEnding(code)) {
      returnState = tagOpenAttributeNameAfter;
      return atLineEnding(code);
    }
    if (markdownSpace(code)) {
      effects.consume(code);
      return tagOpenAttributeNameAfter;
    }
    return tagOpenBetween(code);
  }
  function tagOpenAttributeValueBefore(code) {
    if (code === null || code === 60 || code === 61 || code === 62 || code === 96) {
      return nok(code);
    }
    if (code === 34 || code === 39) {
      effects.consume(code);
      marker = code;
      return tagOpenAttributeValueQuoted;
    }
    if (markdownLineEnding(code)) {
      returnState = tagOpenAttributeValueBefore;
      return atLineEnding(code);
    }
    if (markdownSpace(code)) {
      effects.consume(code);
      return tagOpenAttributeValueBefore;
    }
    effects.consume(code);
    marker = void 0;
    return tagOpenAttributeValueUnquoted;
  }
  function tagOpenAttributeValueQuoted(code) {
    if (code === marker) {
      effects.consume(code);
      return tagOpenAttributeValueQuotedAfter;
    }
    if (code === null) {
      return nok(code);
    }
    if (markdownLineEnding(code)) {
      returnState = tagOpenAttributeValueQuoted;
      return atLineEnding(code);
    }
    effects.consume(code);
    return tagOpenAttributeValueQuoted;
  }
  function tagOpenAttributeValueQuotedAfter(code) {
    if (code === 62 || code === 47 || markdownLineEndingOrSpace(code)) {
      return tagOpenBetween(code);
    }
    return nok(code);
  }
  function tagOpenAttributeValueUnquoted(code) {
    if (code === null || code === 34 || code === 39 || code === 60 || code === 61 || code === 96) {
      return nok(code);
    }
    if (code === 62 || markdownLineEndingOrSpace(code)) {
      return tagOpenBetween(code);
    }
    effects.consume(code);
    return tagOpenAttributeValueUnquoted;
  }
  function atLineEnding(code) {
    effects.exit("htmlTextData");
    effects.enter("lineEnding");
    effects.consume(code);
    effects.exit("lineEnding");
    return factorySpace(
      effects,
      afterPrefix,
      "linePrefix",
      self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
    );
  }
  function afterPrefix(code) {
    effects.enter("htmlTextData");
    return returnState(code);
  }
  function end(code) {
    if (code === 62) {
      effects.consume(code);
      effects.exit("htmlTextData");
      effects.exit("htmlText");
      return ok;
    }
    return nok(code);
  }
}

// ../simple-mind-map/node_modules/micromark-core-commonmark/lib/label-end.js
var labelEnd = {
  name: "labelEnd",
  tokenize: tokenizeLabelEnd,
  resolveTo: resolveToLabelEnd,
  resolveAll: resolveAllLabelEnd
};
var resourceConstruct = {
  tokenize: tokenizeResource
};
var fullReferenceConstruct = {
  tokenize: tokenizeFullReference
};
var collapsedReferenceConstruct = {
  tokenize: tokenizeCollapsedReference
};
function resolveAllLabelEnd(events) {
  let index3 = -1;
  let token;
  while (++index3 < events.length) {
    token = events[index3][1];
    if (token.type === "labelImage" || token.type === "labelLink" || token.type === "labelEnd") {
      events.splice(index3 + 1, token.type === "labelImage" ? 4 : 2);
      token.type = "data";
      index3++;
    }
  }
  return events;
}
function resolveToLabelEnd(events, context) {
  let index3 = events.length;
  let offset = 0;
  let token;
  let open4;
  let close3;
  let media;
  while (index3--) {
    token = events[index3][1];
    if (open4) {
      if (token.type === "link" || token.type === "labelLink" && token._inactive) {
        break;
      }
      if (events[index3][0] === "enter" && token.type === "labelLink") {
        token._inactive = true;
      }
    } else if (close3) {
      if (events[index3][0] === "enter" && (token.type === "labelImage" || token.type === "labelLink") && !token._balanced) {
        open4 = index3;
        if (token.type !== "labelLink") {
          offset = 2;
          break;
        }
      }
    } else if (token.type === "labelEnd") {
      close3 = index3;
    }
  }
  const group = {
    type: events[open4][1].type === "labelLink" ? "link" : "image",
    start: Object.assign({}, events[open4][1].start),
    end: Object.assign({}, events[events.length - 1][1].end)
  };
  const label = {
    type: "label",
    start: Object.assign({}, events[open4][1].start),
    end: Object.assign({}, events[close3][1].end)
  };
  const text4 = {
    type: "labelText",
    start: Object.assign({}, events[open4 + offset + 2][1].end),
    end: Object.assign({}, events[close3 - 2][1].start)
  };
  media = [
    ["enter", group, context],
    ["enter", label, context]
  ];
  media = push(media, events.slice(open4 + 1, open4 + offset + 3));
  media = push(media, [["enter", text4, context]]);
  media = push(
    media,
    resolveAll(
      context.parser.constructs.insideSpan.null,
      events.slice(open4 + offset + 4, close3 - 3),
      context
    )
  );
  media = push(media, [
    ["exit", text4, context],
    events[close3 - 2],
    events[close3 - 1],
    ["exit", label, context]
  ]);
  media = push(media, events.slice(close3 + 1));
  media = push(media, [["exit", group, context]]);
  splice(events, open4, events.length, media);
  return events;
}
function tokenizeLabelEnd(effects, ok, nok) {
  const self2 = this;
  let index3 = self2.events.length;
  let labelStart;
  let defined;
  while (index3--) {
    if ((self2.events[index3][1].type === "labelImage" || self2.events[index3][1].type === "labelLink") && !self2.events[index3][1]._balanced) {
      labelStart = self2.events[index3][1];
      break;
    }
  }
  return start;
  function start(code) {
    if (!labelStart) {
      return nok(code);
    }
    if (labelStart._inactive)
      return balanced(code);
    defined = self2.parser.defined.includes(
      normalizeIdentifier(
        self2.sliceSerialize({
          start: labelStart.end,
          end: self2.now()
        })
      )
    );
    effects.enter("labelEnd");
    effects.enter("labelMarker");
    effects.consume(code);
    effects.exit("labelMarker");
    effects.exit("labelEnd");
    return afterLabelEnd;
  }
  function afterLabelEnd(code) {
    if (code === 40) {
      return effects.attempt(
        resourceConstruct,
        ok,
        defined ? ok : balanced
      )(code);
    }
    if (code === 91) {
      return effects.attempt(
        fullReferenceConstruct,
        ok,
        defined ? effects.attempt(collapsedReferenceConstruct, ok, balanced) : balanced
      )(code);
    }
    return defined ? ok(code) : balanced(code);
  }
  function balanced(code) {
    labelStart._balanced = true;
    return nok(code);
  }
}
function tokenizeResource(effects, ok, nok) {
  return start;
  function start(code) {
    effects.enter("resource");
    effects.enter("resourceMarker");
    effects.consume(code);
    effects.exit("resourceMarker");
    return factoryWhitespace(effects, open4);
  }
  function open4(code) {
    if (code === 41) {
      return end(code);
    }
    return factoryDestination(
      effects,
      destinationAfter,
      nok,
      "resourceDestination",
      "resourceDestinationLiteral",
      "resourceDestinationLiteralMarker",
      "resourceDestinationRaw",
      "resourceDestinationString",
      32
    )(code);
  }
  function destinationAfter(code) {
    return markdownLineEndingOrSpace(code) ? factoryWhitespace(effects, between)(code) : end(code);
  }
  function between(code) {
    if (code === 34 || code === 39 || code === 40) {
      return factoryTitle(
        effects,
        factoryWhitespace(effects, end),
        nok,
        "resourceTitle",
        "resourceTitleMarker",
        "resourceTitleString"
      )(code);
    }
    return end(code);
  }
  function end(code) {
    if (code === 41) {
      effects.enter("resourceMarker");
      effects.consume(code);
      effects.exit("resourceMarker");
      effects.exit("resource");
      return ok;
    }
    return nok(code);
  }
}
function tokenizeFullReference(effects, ok, nok) {
  const self2 = this;
  return start;
  function start(code) {
    return factoryLabel.call(
      self2,
      effects,
      afterLabel,
      nok,
      "reference",
      "referenceMarker",
      "referenceString"
    )(code);
  }
  function afterLabel(code) {
    return self2.parser.defined.includes(
      normalizeIdentifier(
        self2.sliceSerialize(self2.events[self2.events.length - 1][1]).slice(1, -1)
      )
    ) ? ok(code) : nok(code);
  }
}
function tokenizeCollapsedReference(effects, ok, nok) {
  return start;
  function start(code) {
    effects.enter("reference");
    effects.enter("referenceMarker");
    effects.consume(code);
    effects.exit("referenceMarker");
    return open4;
  }
  function open4(code) {
    if (code === 93) {
      effects.enter("referenceMarker");
      effects.consume(code);
      effects.exit("referenceMarker");
      effects.exit("reference");
      return ok;
    }
    return nok(code);
  }
}

// ../simple-mind-map/node_modules/micromark-core-commonmark/lib/label-start-image.js
var labelStartImage = {
  name: "labelStartImage",
  tokenize: tokenizeLabelStartImage,
  resolveAll: labelEnd.resolveAll
};
function tokenizeLabelStartImage(effects, ok, nok) {
  const self2 = this;
  return start;
  function start(code) {
    effects.enter("labelImage");
    effects.enter("labelImageMarker");
    effects.consume(code);
    effects.exit("labelImageMarker");
    return open4;
  }
  function open4(code) {
    if (code === 91) {
      effects.enter("labelMarker");
      effects.consume(code);
      effects.exit("labelMarker");
      effects.exit("labelImage");
      return after2;
    }
    return nok(code);
  }
  function after2(code) {
    return code === 94 && "_hiddenFootnoteSupport" in self2.parser.constructs ? nok(code) : ok(code);
  }
}

// ../simple-mind-map/node_modules/micromark-core-commonmark/lib/label-start-link.js
var labelStartLink = {
  name: "labelStartLink",
  tokenize: tokenizeLabelStartLink,
  resolveAll: labelEnd.resolveAll
};
function tokenizeLabelStartLink(effects, ok, nok) {
  const self2 = this;
  return start;
  function start(code) {
    effects.enter("labelLink");
    effects.enter("labelMarker");
    effects.consume(code);
    effects.exit("labelMarker");
    effects.exit("labelLink");
    return after2;
  }
  function after2(code) {
    return code === 94 && "_hiddenFootnoteSupport" in self2.parser.constructs ? nok(code) : ok(code);
  }
}

// ../simple-mind-map/node_modules/micromark-core-commonmark/lib/line-ending.js
var lineEnding = {
  name: "lineEnding",
  tokenize: tokenizeLineEnding
};
function tokenizeLineEnding(effects, ok) {
  return start;
  function start(code) {
    effects.enter("lineEnding");
    effects.consume(code);
    effects.exit("lineEnding");
    return factorySpace(effects, ok, "linePrefix");
  }
}

// ../simple-mind-map/node_modules/micromark-core-commonmark/lib/thematic-break.js
var thematicBreak = {
  name: "thematicBreak",
  tokenize: tokenizeThematicBreak
};
function tokenizeThematicBreak(effects, ok, nok) {
  let size2 = 0;
  let marker;
  return start;
  function start(code) {
    effects.enter("thematicBreak");
    marker = code;
    return atBreak(code);
  }
  function atBreak(code) {
    if (code === marker) {
      effects.enter("thematicBreakSequence");
      return sequence(code);
    }
    if (markdownSpace(code)) {
      return factorySpace(effects, atBreak, "whitespace")(code);
    }
    if (size2 < 3 || code !== null && !markdownLineEnding(code)) {
      return nok(code);
    }
    effects.exit("thematicBreak");
    return ok(code);
  }
  function sequence(code) {
    if (code === marker) {
      effects.consume(code);
      size2++;
      return sequence;
    }
    effects.exit("thematicBreakSequence");
    return atBreak(code);
  }
}

// ../simple-mind-map/node_modules/micromark-core-commonmark/lib/list.js
var list = {
  name: "list",
  tokenize: tokenizeListStart,
  continuation: {
    tokenize: tokenizeListContinuation
  },
  exit: tokenizeListEnd
};
var listItemPrefixWhitespaceConstruct = {
  tokenize: tokenizeListItemPrefixWhitespace,
  partial: true
};
var indentConstruct = {
  tokenize: tokenizeIndent,
  partial: true
};
function tokenizeListStart(effects, ok, nok) {
  const self2 = this;
  const tail = self2.events[self2.events.length - 1];
  let initialSize = tail && tail[1].type === "linePrefix" ? tail[2].sliceSerialize(tail[1], true).length : 0;
  let size2 = 0;
  return start;
  function start(code) {
    const kind = self2.containerState.type || (code === 42 || code === 43 || code === 45 ? "listUnordered" : "listOrdered");
    if (kind === "listUnordered" ? !self2.containerState.marker || code === self2.containerState.marker : asciiDigit(code)) {
      if (!self2.containerState.type) {
        self2.containerState.type = kind;
        effects.enter(kind, {
          _container: true
        });
      }
      if (kind === "listUnordered") {
        effects.enter("listItemPrefix");
        return code === 42 || code === 45 ? effects.check(thematicBreak, nok, atMarker)(code) : atMarker(code);
      }
      if (!self2.interrupt || code === 49) {
        effects.enter("listItemPrefix");
        effects.enter("listItemValue");
        return inside2(code);
      }
    }
    return nok(code);
  }
  function inside2(code) {
    if (asciiDigit(code) && ++size2 < 10) {
      effects.consume(code);
      return inside2;
    }
    if ((!self2.interrupt || size2 < 2) && (self2.containerState.marker ? code === self2.containerState.marker : code === 41 || code === 46)) {
      effects.exit("listItemValue");
      return atMarker(code);
    }
    return nok(code);
  }
  function atMarker(code) {
    effects.enter("listItemMarker");
    effects.consume(code);
    effects.exit("listItemMarker");
    self2.containerState.marker = self2.containerState.marker || code;
    return effects.check(
      blankLine,
      // Can’t be empty when interrupting.
      self2.interrupt ? nok : onBlank,
      effects.attempt(
        listItemPrefixWhitespaceConstruct,
        endOfPrefix,
        otherPrefix
      )
    );
  }
  function onBlank(code) {
    self2.containerState.initialBlankLine = true;
    initialSize++;
    return endOfPrefix(code);
  }
  function otherPrefix(code) {
    if (markdownSpace(code)) {
      effects.enter("listItemPrefixWhitespace");
      effects.consume(code);
      effects.exit("listItemPrefixWhitespace");
      return endOfPrefix;
    }
    return nok(code);
  }
  function endOfPrefix(code) {
    self2.containerState.size = initialSize + self2.sliceSerialize(effects.exit("listItemPrefix"), true).length;
    return ok(code);
  }
}
function tokenizeListContinuation(effects, ok, nok) {
  const self2 = this;
  self2.containerState._closeFlow = void 0;
  return effects.check(blankLine, onBlank, notBlank);
  function onBlank(code) {
    self2.containerState.furtherBlankLines = self2.containerState.furtherBlankLines || self2.containerState.initialBlankLine;
    return factorySpace(
      effects,
      ok,
      "listItemIndent",
      self2.containerState.size + 1
    )(code);
  }
  function notBlank(code) {
    if (self2.containerState.furtherBlankLines || !markdownSpace(code)) {
      self2.containerState.furtherBlankLines = void 0;
      self2.containerState.initialBlankLine = void 0;
      return notInCurrentItem(code);
    }
    self2.containerState.furtherBlankLines = void 0;
    self2.containerState.initialBlankLine = void 0;
    return effects.attempt(indentConstruct, ok, notInCurrentItem)(code);
  }
  function notInCurrentItem(code) {
    self2.containerState._closeFlow = true;
    self2.interrupt = void 0;
    return factorySpace(
      effects,
      effects.attempt(list, ok, nok),
      "linePrefix",
      self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
    )(code);
  }
}
function tokenizeIndent(effects, ok, nok) {
  const self2 = this;
  return factorySpace(
    effects,
    afterPrefix,
    "listItemIndent",
    self2.containerState.size + 1
  );
  function afterPrefix(code) {
    const tail = self2.events[self2.events.length - 1];
    return tail && tail[1].type === "listItemIndent" && tail[2].sliceSerialize(tail[1], true).length === self2.containerState.size ? ok(code) : nok(code);
  }
}
function tokenizeListEnd(effects) {
  effects.exit(this.containerState.type);
}
function tokenizeListItemPrefixWhitespace(effects, ok, nok) {
  const self2 = this;
  return factorySpace(
    effects,
    afterPrefix,
    "listItemPrefixWhitespace",
    self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4 + 1
  );
  function afterPrefix(code) {
    const tail = self2.events[self2.events.length - 1];
    return !markdownSpace(code) && tail && tail[1].type === "listItemPrefixWhitespace" ? ok(code) : nok(code);
  }
}

// ../simple-mind-map/node_modules/micromark-core-commonmark/lib/setext-underline.js
var setextUnderline = {
  name: "setextUnderline",
  tokenize: tokenizeSetextUnderline,
  resolveTo: resolveToSetextUnderline
};
function resolveToSetextUnderline(events, context) {
  let index3 = events.length;
  let content3;
  let text4;
  let definition2;
  while (index3--) {
    if (events[index3][0] === "enter") {
      if (events[index3][1].type === "content") {
        content3 = index3;
        break;
      }
      if (events[index3][1].type === "paragraph") {
        text4 = index3;
      }
    } else {
      if (events[index3][1].type === "content") {
        events.splice(index3, 1);
      }
      if (!definition2 && events[index3][1].type === "definition") {
        definition2 = index3;
      }
    }
  }
  const heading = {
    type: "setextHeading",
    start: Object.assign({}, events[text4][1].start),
    end: Object.assign({}, events[events.length - 1][1].end)
  };
  events[text4][1].type = "setextHeadingText";
  if (definition2) {
    events.splice(text4, 0, ["enter", heading, context]);
    events.splice(definition2 + 1, 0, ["exit", events[content3][1], context]);
    events[content3][1].end = Object.assign({}, events[definition2][1].end);
  } else {
    events[content3][1] = heading;
  }
  events.push(["exit", heading, context]);
  return events;
}
function tokenizeSetextUnderline(effects, ok, nok) {
  const self2 = this;
  let index3 = self2.events.length;
  let marker;
  let paragraph;
  while (index3--) {
    if (self2.events[index3][1].type !== "lineEnding" && self2.events[index3][1].type !== "linePrefix" && self2.events[index3][1].type !== "content") {
      paragraph = self2.events[index3][1].type === "paragraph";
      break;
    }
  }
  return start;
  function start(code) {
    if (!self2.parser.lazy[self2.now().line] && (self2.interrupt || paragraph)) {
      effects.enter("setextHeadingLine");
      effects.enter("setextHeadingLineSequence");
      marker = code;
      return closingSequence(code);
    }
    return nok(code);
  }
  function closingSequence(code) {
    if (code === marker) {
      effects.consume(code);
      return closingSequence;
    }
    effects.exit("setextHeadingLineSequence");
    return factorySpace(effects, closingSequenceEnd, "lineSuffix")(code);
  }
  function closingSequenceEnd(code) {
    if (code === null || markdownLineEnding(code)) {
      effects.exit("setextHeadingLine");
      return ok(code);
    }
    return nok(code);
  }
}

// ../simple-mind-map/node_modules/micromark/lib/initialize/flow.js
var flow = {
  tokenize: initializeFlow
};
function initializeFlow(effects) {
  const self2 = this;
  const initial = effects.attempt(
    // Try to parse a blank line.
    blankLine,
    atBlankEnding,
    // Try to parse initial flow (essentially, only code).
    effects.attempt(
      this.parser.constructs.flowInitial,
      afterConstruct,
      factorySpace(
        effects,
        effects.attempt(
          this.parser.constructs.flow,
          afterConstruct,
          effects.attempt(content2, afterConstruct)
        ),
        "linePrefix"
      )
    )
  );
  return initial;
  function atBlankEnding(code) {
    if (code === null) {
      effects.consume(code);
      return;
    }
    effects.enter("lineEndingBlank");
    effects.consume(code);
    effects.exit("lineEndingBlank");
    self2.currentConstruct = void 0;
    return initial;
  }
  function afterConstruct(code) {
    if (code === null) {
      effects.consume(code);
      return;
    }
    effects.enter("lineEnding");
    effects.consume(code);
    effects.exit("lineEnding");
    self2.currentConstruct = void 0;
    return initial;
  }
}

// ../simple-mind-map/node_modules/micromark/lib/initialize/text.js
var resolver = {
  resolveAll: createResolver()
};
var string = initializeFactory("string");
var text2 = initializeFactory("text");
function initializeFactory(field) {
  return {
    tokenize: initializeText,
    resolveAll: createResolver(
      field === "text" ? resolveAllLineSuffixes : void 0
    )
  };
  function initializeText(effects) {
    const self2 = this;
    const constructs2 = this.parser.constructs[field];
    const text4 = effects.attempt(constructs2, start, notText);
    return start;
    function start(code) {
      return atBreak(code) ? text4(code) : notText(code);
    }
    function notText(code) {
      if (code === null) {
        effects.consume(code);
        return;
      }
      effects.enter("data");
      effects.consume(code);
      return data2;
    }
    function data2(code) {
      if (atBreak(code)) {
        effects.exit("data");
        return text4(code);
      }
      effects.consume(code);
      return data2;
    }
    function atBreak(code) {
      if (code === null) {
        return true;
      }
      const list2 = constructs2[code];
      let index3 = -1;
      if (list2) {
        while (++index3 < list2.length) {
          const item = list2[index3];
          if (!item.previous || item.previous.call(self2, self2.previous)) {
            return true;
          }
        }
      }
      return false;
    }
  }
}
function createResolver(extraResolver) {
  return resolveAllText;
  function resolveAllText(events, context) {
    let index3 = -1;
    let enter;
    while (++index3 <= events.length) {
      if (enter === void 0) {
        if (events[index3] && events[index3][1].type === "data") {
          enter = index3;
          index3++;
        }
      } else if (!events[index3] || events[index3][1].type !== "data") {
        if (index3 !== enter + 2) {
          events[enter][1].end = events[index3 - 1][1].end;
          events.splice(enter + 2, index3 - enter - 2);
          index3 = enter + 2;
        }
        enter = void 0;
      }
    }
    return extraResolver ? extraResolver(events, context) : events;
  }
}
function resolveAllLineSuffixes(events, context) {
  let eventIndex = 0;
  while (++eventIndex <= events.length) {
    if ((eventIndex === events.length || events[eventIndex][1].type === "lineEnding") && events[eventIndex - 1][1].type === "data") {
      const data2 = events[eventIndex - 1][1];
      const chunks = context.sliceStream(data2);
      let index3 = chunks.length;
      let bufferIndex = -1;
      let size2 = 0;
      let tabs;
      while (index3--) {
        const chunk = chunks[index3];
        if (typeof chunk === "string") {
          bufferIndex = chunk.length;
          while (chunk.charCodeAt(bufferIndex - 1) === 32) {
            size2++;
            bufferIndex--;
          }
          if (bufferIndex)
            break;
          bufferIndex = -1;
        } else if (chunk === -2) {
          tabs = true;
          size2++;
        } else if (chunk === -1) {
        } else {
          index3++;
          break;
        }
      }
      if (size2) {
        const token = {
          type: eventIndex === events.length || tabs || size2 < 2 ? "lineSuffix" : "hardBreakTrailing",
          start: {
            line: data2.end.line,
            column: data2.end.column - size2,
            offset: data2.end.offset - size2,
            _index: data2.start._index + index3,
            _bufferIndex: index3 ? bufferIndex : data2.start._bufferIndex + bufferIndex
          },
          end: Object.assign({}, data2.end)
        };
        data2.end = Object.assign({}, token.start);
        if (data2.start.offset === data2.end.offset) {
          Object.assign(data2, token);
        } else {
          events.splice(
            eventIndex,
            0,
            ["enter", token, context],
            ["exit", token, context]
          );
          eventIndex += 2;
        }
      }
      eventIndex++;
    }
  }
  return events;
}

// ../simple-mind-map/node_modules/micromark/lib/create-tokenizer.js
function createTokenizer(parser2, initialize, from2) {
  let point4 = Object.assign(
    from2 ? Object.assign({}, from2) : {
      line: 1,
      column: 1,
      offset: 0
    },
    {
      _index: 0,
      _bufferIndex: -1
    }
  );
  const columnStart = {};
  const resolveAllConstructs = [];
  let chunks = [];
  let stack = [];
  let consumed = true;
  const effects = {
    consume,
    enter,
    exit: exit2,
    attempt: constructFactory(onsuccessfulconstruct),
    check: constructFactory(onsuccessfulcheck),
    interrupt: constructFactory(onsuccessfulcheck, {
      interrupt: true
    })
  };
  const context = {
    previous: null,
    code: null,
    containerState: {},
    events: [],
    parser: parser2,
    sliceStream,
    sliceSerialize,
    now,
    defineSkip,
    write
  };
  let state = initialize.tokenize.call(context, effects);
  let expectedCode;
  if (initialize.resolveAll) {
    resolveAllConstructs.push(initialize);
  }
  return context;
  function write(slice) {
    chunks = push(chunks, slice);
    main2();
    if (chunks[chunks.length - 1] !== null) {
      return [];
    }
    addResult(initialize, 0);
    context.events = resolveAll(resolveAllConstructs, context.events, context);
    return context.events;
  }
  function sliceSerialize(token, expandTabs) {
    return serializeChunks(sliceStream(token), expandTabs);
  }
  function sliceStream(token) {
    return sliceChunks(chunks, token);
  }
  function now() {
    return Object.assign({}, point4);
  }
  function defineSkip(value) {
    columnStart[value.line] = value.column;
    accountForPotentialSkip();
  }
  function main2() {
    let chunkIndex;
    while (point4._index < chunks.length) {
      const chunk = chunks[point4._index];
      if (typeof chunk === "string") {
        chunkIndex = point4._index;
        if (point4._bufferIndex < 0) {
          point4._bufferIndex = 0;
        }
        while (point4._index === chunkIndex && point4._bufferIndex < chunk.length) {
          go(chunk.charCodeAt(point4._bufferIndex));
        }
      } else {
        go(chunk);
      }
    }
  }
  function go(code) {
    consumed = void 0;
    expectedCode = code;
    state = state(code);
  }
  function consume(code) {
    if (markdownLineEnding(code)) {
      point4.line++;
      point4.column = 1;
      point4.offset += code === -3 ? 2 : 1;
      accountForPotentialSkip();
    } else if (code !== -1) {
      point4.column++;
      point4.offset++;
    }
    if (point4._bufferIndex < 0) {
      point4._index++;
    } else {
      point4._bufferIndex++;
      if (point4._bufferIndex === chunks[point4._index].length) {
        point4._bufferIndex = -1;
        point4._index++;
      }
    }
    context.previous = code;
    consumed = true;
  }
  function enter(type, fields) {
    const token = fields || {};
    token.type = type;
    token.start = now();
    context.events.push(["enter", token, context]);
    stack.push(token);
    return token;
  }
  function exit2(type) {
    const token = stack.pop();
    token.end = now();
    context.events.push(["exit", token, context]);
    return token;
  }
  function onsuccessfulconstruct(construct, info) {
    addResult(construct, info.from);
  }
  function onsuccessfulcheck(_2, info) {
    info.restore();
  }
  function constructFactory(onreturn, fields) {
    return hook;
    function hook(constructs2, returnState, bogusState) {
      let listOfConstructs;
      let constructIndex;
      let currentConstruct;
      let info;
      return Array.isArray(constructs2) ? (
        /* c8 ignore next 1 */
        handleListOfConstructs(constructs2)
      ) : "tokenize" in constructs2 ? handleListOfConstructs([constructs2]) : handleMapOfConstructs(constructs2);
      function handleMapOfConstructs(map3) {
        return start;
        function start(code) {
          const def = code !== null && map3[code];
          const all2 = code !== null && map3.null;
          const list2 = [
            // To do: add more extension tests.
            /* c8 ignore next 2 */
            ...Array.isArray(def) ? def : def ? [def] : [],
            ...Array.isArray(all2) ? all2 : all2 ? [all2] : []
          ];
          return handleListOfConstructs(list2)(code);
        }
      }
      function handleListOfConstructs(list2) {
        listOfConstructs = list2;
        constructIndex = 0;
        if (list2.length === 0) {
          return bogusState;
        }
        return handleConstruct(list2[constructIndex]);
      }
      function handleConstruct(construct) {
        return start;
        function start(code) {
          info = store();
          currentConstruct = construct;
          if (!construct.partial) {
            context.currentConstruct = construct;
          }
          if (construct.name && context.parser.constructs.disable.null.includes(construct.name)) {
            return nok(code);
          }
          return construct.tokenize.call(
            // If we do have fields, create an object w/ `context` as its
            // prototype.
            // This allows a “live binding”, which is needed for `interrupt`.
            fields ? Object.assign(Object.create(context), fields) : context,
            effects,
            ok,
            nok
          )(code);
        }
      }
      function ok(code) {
        consumed = true;
        onreturn(currentConstruct, info);
        return returnState;
      }
      function nok(code) {
        consumed = true;
        info.restore();
        if (++constructIndex < listOfConstructs.length) {
          return handleConstruct(listOfConstructs[constructIndex]);
        }
        return bogusState;
      }
    }
  }
  function addResult(construct, from3) {
    if (construct.resolveAll && !resolveAllConstructs.includes(construct)) {
      resolveAllConstructs.push(construct);
    }
    if (construct.resolve) {
      splice(
        context.events,
        from3,
        context.events.length - from3,
        construct.resolve(context.events.slice(from3), context)
      );
    }
    if (construct.resolveTo) {
      context.events = construct.resolveTo(context.events, context);
    }
  }
  function store() {
    const startPoint = now();
    const startPrevious = context.previous;
    const startCurrentConstruct = context.currentConstruct;
    const startEventsIndex = context.events.length;
    const startStack = Array.from(stack);
    return {
      restore,
      from: startEventsIndex
    };
    function restore() {
      point4 = startPoint;
      context.previous = startPrevious;
      context.currentConstruct = startCurrentConstruct;
      context.events.length = startEventsIndex;
      stack = startStack;
      accountForPotentialSkip();
    }
  }
  function accountForPotentialSkip() {
    if (point4.line in columnStart && point4.column < 2) {
      point4.column = columnStart[point4.line];
      point4.offset += columnStart[point4.line] - 1;
    }
  }
}
function sliceChunks(chunks, token) {
  const startIndex = token.start._index;
  const startBufferIndex = token.start._bufferIndex;
  const endIndex = token.end._index;
  const endBufferIndex = token.end._bufferIndex;
  let view;
  if (startIndex === endIndex) {
    view = [chunks[startIndex].slice(startBufferIndex, endBufferIndex)];
  } else {
    view = chunks.slice(startIndex, endIndex);
    if (startBufferIndex > -1) {
      view[0] = view[0].slice(startBufferIndex);
    }
    if (endBufferIndex > 0) {
      view.push(chunks[endIndex].slice(0, endBufferIndex));
    }
  }
  return view;
}
function serializeChunks(chunks, expandTabs) {
  let index3 = -1;
  const result = [];
  let atTab;
  while (++index3 < chunks.length) {
    const chunk = chunks[index3];
    let value;
    if (typeof chunk === "string") {
      value = chunk;
    } else
      switch (chunk) {
        case -5: {
          value = "\r";
          break;
        }
        case -4: {
          value = "\n";
          break;
        }
        case -3: {
          value = "\r\n";
          break;
        }
        case -2: {
          value = expandTabs ? " " : "	";
          break;
        }
        case -1: {
          if (!expandTabs && atTab)
            continue;
          value = " ";
          break;
        }
        default: {
          value = String.fromCharCode(chunk);
        }
      }
    atTab = chunk === -2;
    result.push(value);
  }
  return result.join("");
}

// ../simple-mind-map/node_modules/micromark/lib/constructs.js
var constructs_exports = {};
__export(constructs_exports, {
  attentionMarkers: () => attentionMarkers,
  contentInitial: () => contentInitial,
  disable: () => disable,
  document: () => document3,
  flow: () => flow2,
  flowInitial: () => flowInitial,
  insideSpan: () => insideSpan,
  string: () => string2,
  text: () => text3
});
var document3 = {
  [42]: list,
  [43]: list,
  [45]: list,
  [48]: list,
  [49]: list,
  [50]: list,
  [51]: list,
  [52]: list,
  [53]: list,
  [54]: list,
  [55]: list,
  [56]: list,
  [57]: list,
  [62]: blockQuote
};
var contentInitial = {
  [91]: definition
};
var flowInitial = {
  [-2]: codeIndented,
  [-1]: codeIndented,
  [32]: codeIndented
};
var flow2 = {
  [35]: headingAtx,
  [42]: thematicBreak,
  [45]: [setextUnderline, thematicBreak],
  [60]: htmlFlow,
  [61]: setextUnderline,
  [95]: thematicBreak,
  [96]: codeFenced,
  [126]: codeFenced
};
var string2 = {
  [38]: characterReference,
  [92]: characterEscape
};
var text3 = {
  [-5]: lineEnding,
  [-4]: lineEnding,
  [-3]: lineEnding,
  [33]: labelStartImage,
  [38]: characterReference,
  [42]: attention,
  [60]: [autolink, htmlText],
  [91]: labelStartLink,
  [92]: [hardBreakEscape, characterEscape],
  [93]: labelEnd,
  [95]: attention,
  [96]: codeText
};
var insideSpan = {
  null: [attention, resolver]
};
var attentionMarkers = {
  null: [42, 95]
};
var disable = {
  null: []
};

// ../simple-mind-map/node_modules/micromark/lib/parse.js
function parse(options = {}) {
  const constructs2 = combineExtensions(
    // @ts-expect-error Same as above.
    [constructs_exports].concat(options.extensions || [])
  );
  const parser2 = {
    defined: [],
    lazy: {},
    constructs: constructs2,
    content: create2(content),
    document: create2(document2),
    flow: create2(flow),
    string: create2(string),
    text: create2(text2)
  };
  return parser2;
  function create2(initial) {
    return creator;
    function creator(from2) {
      return createTokenizer(parser2, initial, from2);
    }
  }
}

// ../simple-mind-map/node_modules/micromark/lib/preprocess.js
var search = /[\0\t\n\r]/g;
function preprocess() {
  let column = 1;
  let buffer = "";
  let start = true;
  let atCarriageReturn;
  return preprocessor;
  function preprocessor(value, encoding, end) {
    const chunks = [];
    let match;
    let next2;
    let startPosition;
    let endPosition;
    let code;
    value = buffer + value.toString(encoding);
    startPosition = 0;
    buffer = "";
    if (start) {
      if (value.charCodeAt(0) === 65279) {
        startPosition++;
      }
      start = void 0;
    }
    while (startPosition < value.length) {
      search.lastIndex = startPosition;
      match = search.exec(value);
      endPosition = match && match.index !== void 0 ? match.index : value.length;
      code = value.charCodeAt(endPosition);
      if (!match) {
        buffer = value.slice(startPosition);
        break;
      }
      if (code === 10 && startPosition === endPosition && atCarriageReturn) {
        chunks.push(-3);
        atCarriageReturn = void 0;
      } else {
        if (atCarriageReturn) {
          chunks.push(-5);
          atCarriageReturn = void 0;
        }
        if (startPosition < endPosition) {
          chunks.push(value.slice(startPosition, endPosition));
          column += endPosition - startPosition;
        }
        switch (code) {
          case 0: {
            chunks.push(65533);
            column++;
            break;
          }
          case 9: {
            next2 = Math.ceil(column / 4) * 4;
            chunks.push(-2);
            while (column++ < next2)
              chunks.push(-1);
            break;
          }
          case 10: {
            chunks.push(-4);
            column = 1;
            break;
          }
          default: {
            atCarriageReturn = true;
            column = 1;
          }
        }
      }
      startPosition = endPosition + 1;
    }
    if (end) {
      if (atCarriageReturn)
        chunks.push(-5);
      if (buffer)
        chunks.push(buffer);
      chunks.push(null);
    }
    return chunks;
  }
}

// ../simple-mind-map/node_modules/micromark/lib/postprocess.js
function postprocess(events) {
  while (!subtokenize(events)) {
  }
  return events;
}

// ../simple-mind-map/node_modules/micromark-util-decode-numeric-character-reference/index.js
function decodeNumericCharacterReference(value, base) {
  const code = Number.parseInt(value, base);
  if (
    // C0 except for HT, LF, FF, CR, space
    code < 9 || code === 11 || code > 13 && code < 32 || // Control character (DEL) of the basic block and C1 controls.
    code > 126 && code < 160 || // Lone high surrogates and low surrogates.
    code > 55295 && code < 57344 || // Noncharacters.
    code > 64975 && code < 65008 || (code & 65535) === 65535 || (code & 65535) === 65534 || // Out of range
    code > 1114111
  ) {
    return "\uFFFD";
  }
  return String.fromCharCode(code);
}

// ../simple-mind-map/node_modules/micromark-util-decode-string/index.js
var characterEscapeOrReference = /\\([!-/:-@[-`{-~])|&(#(?:\d{1,7}|x[\da-f]{1,6})|[\da-z]{1,31});/gi;
function decodeString(value) {
  return value.replace(characterEscapeOrReference, decode);
}
function decode($0, $1, $2) {
  if ($1) {
    return $1;
  }
  const head = $2.charCodeAt(0);
  if (head === 35) {
    const head2 = $2.charCodeAt(1);
    const hex3 = head2 === 120 || head2 === 88;
    return decodeNumericCharacterReference($2.slice(hex3 ? 2 : 1), hex3 ? 16 : 10);
  }
  return decodeNamedCharacterReference($2) || $0;
}

// ../simple-mind-map/node_modules/unist-util-stringify-position/lib/index.js
function stringifyPosition(value) {
  if (!value || typeof value !== "object") {
    return "";
  }
  if ("position" in value || "type" in value) {
    return position2(value.position);
  }
  if ("start" in value || "end" in value) {
    return position2(value);
  }
  if ("line" in value || "column" in value) {
    return point2(value);
  }
  return "";
}
function point2(point4) {
  return index2(point4 && point4.line) + ":" + index2(point4 && point4.column);
}
function position2(pos) {
  return point2(pos && pos.start) + "-" + point2(pos && pos.end);
}
function index2(value) {
  return value && typeof value === "number" ? value : 1;
}

// ../simple-mind-map/node_modules/mdast-util-from-markdown/lib/index.js
var own = {}.hasOwnProperty;
var fromMarkdown = (
  /**
   * @type {(
   *   ((value: Value, encoding: Encoding, options?: Options | null | undefined) => Root) &
   *   ((value: Value, options?: Options | null | undefined) => Root)
   * )}
   */
  /**
   * @param {Value} value
   * @param {Encoding | Options | null | undefined} [encoding]
   * @param {Options | null | undefined} [options]
   * @returns {Root}
   */
  function(value, encoding, options) {
    if (typeof encoding !== "string") {
      options = encoding;
      encoding = void 0;
    }
    return compiler(options)(
      postprocess(
        // @ts-expect-error: micromark types need to accept `null`.
        parse(options).document().write(preprocess()(value, encoding, true))
      )
    );
  }
);
function compiler(options) {
  const config = {
    transforms: [],
    canContainEols: ["emphasis", "fragment", "heading", "paragraph", "strong"],
    enter: {
      autolink: opener(link),
      autolinkProtocol: onenterdata,
      autolinkEmail: onenterdata,
      atxHeading: opener(heading),
      blockQuote: opener(blockQuote2),
      characterEscape: onenterdata,
      characterReference: onenterdata,
      codeFenced: opener(codeFlow),
      codeFencedFenceInfo: buffer,
      codeFencedFenceMeta: buffer,
      codeIndented: opener(codeFlow, buffer),
      codeText: opener(codeText2, buffer),
      codeTextData: onenterdata,
      data: onenterdata,
      codeFlowValue: onenterdata,
      definition: opener(definition2),
      definitionDestinationString: buffer,
      definitionLabelString: buffer,
      definitionTitleString: buffer,
      emphasis: opener(emphasis),
      hardBreakEscape: opener(hardBreak),
      hardBreakTrailing: opener(hardBreak),
      htmlFlow: opener(html2, buffer),
      htmlFlowData: onenterdata,
      htmlText: opener(html2, buffer),
      htmlTextData: onenterdata,
      image: opener(image),
      label: buffer,
      link: opener(link),
      listItem: opener(listItem),
      listItemValue: onenterlistitemvalue,
      listOrdered: opener(list2, onenterlistordered),
      listUnordered: opener(list2),
      paragraph: opener(paragraph),
      reference: onenterreference,
      referenceString: buffer,
      resourceDestinationString: buffer,
      resourceTitleString: buffer,
      setextHeading: opener(heading),
      strong: opener(strong),
      thematicBreak: opener(thematicBreak2)
    },
    exit: {
      atxHeading: closer(),
      atxHeadingSequence: onexitatxheadingsequence,
      autolink: closer(),
      autolinkEmail: onexitautolinkemail,
      autolinkProtocol: onexitautolinkprotocol,
      blockQuote: closer(),
      characterEscapeValue: onexitdata,
      characterReferenceMarkerHexadecimal: onexitcharacterreferencemarker,
      characterReferenceMarkerNumeric: onexitcharacterreferencemarker,
      characterReferenceValue: onexitcharacterreferencevalue,
      codeFenced: closer(onexitcodefenced),
      codeFencedFence: onexitcodefencedfence,
      codeFencedFenceInfo: onexitcodefencedfenceinfo,
      codeFencedFenceMeta: onexitcodefencedfencemeta,
      codeFlowValue: onexitdata,
      codeIndented: closer(onexitcodeindented),
      codeText: closer(onexitcodetext),
      codeTextData: onexitdata,
      data: onexitdata,
      definition: closer(),
      definitionDestinationString: onexitdefinitiondestinationstring,
      definitionLabelString: onexitdefinitionlabelstring,
      definitionTitleString: onexitdefinitiontitlestring,
      emphasis: closer(),
      hardBreakEscape: closer(onexithardbreak),
      hardBreakTrailing: closer(onexithardbreak),
      htmlFlow: closer(onexithtmlflow),
      htmlFlowData: onexitdata,
      htmlText: closer(onexithtmltext),
      htmlTextData: onexitdata,
      image: closer(onexitimage),
      label: onexitlabel,
      labelText: onexitlabeltext,
      lineEnding: onexitlineending,
      link: closer(onexitlink),
      listItem: closer(),
      listOrdered: closer(),
      listUnordered: closer(),
      paragraph: closer(),
      referenceString: onexitreferencestring,
      resourceDestinationString: onexitresourcedestinationstring,
      resourceTitleString: onexitresourcetitlestring,
      resource: onexitresource,
      setextHeading: closer(onexitsetextheading),
      setextHeadingLineSequence: onexitsetextheadinglinesequence,
      setextHeadingText: onexitsetextheadingtext,
      strong: closer(),
      thematicBreak: closer()
    }
  };
  configure(config, (options || {}).mdastExtensions || []);
  const data2 = {};
  return compile;
  function compile(events) {
    let tree = {
      type: "root",
      children: []
    };
    const context = {
      stack: [tree],
      tokenStack: [],
      config,
      enter,
      exit: exit2,
      buffer,
      resume,
      setData: setData2,
      getData
    };
    const listStack = [];
    let index3 = -1;
    while (++index3 < events.length) {
      if (events[index3][1].type === "listOrdered" || events[index3][1].type === "listUnordered") {
        if (events[index3][0] === "enter") {
          listStack.push(index3);
        } else {
          const tail = listStack.pop();
          index3 = prepareList(events, tail, index3);
        }
      }
    }
    index3 = -1;
    while (++index3 < events.length) {
      const handler = config[events[index3][0]];
      if (own.call(handler, events[index3][1].type)) {
        handler[events[index3][1].type].call(
          Object.assign(
            {
              sliceSerialize: events[index3][2].sliceSerialize
            },
            context
          ),
          events[index3][1]
        );
      }
    }
    if (context.tokenStack.length > 0) {
      const tail = context.tokenStack[context.tokenStack.length - 1];
      const handler = tail[1] || defaultOnError;
      handler.call(context, void 0, tail[0]);
    }
    tree.position = {
      start: point3(
        events.length > 0 ? events[0][1].start : {
          line: 1,
          column: 1,
          offset: 0
        }
      ),
      end: point3(
        events.length > 0 ? events[events.length - 2][1].end : {
          line: 1,
          column: 1,
          offset: 0
        }
      )
    };
    index3 = -1;
    while (++index3 < config.transforms.length) {
      tree = config.transforms[index3](tree) || tree;
    }
    return tree;
  }
  function prepareList(events, start, length2) {
    let index3 = start - 1;
    let containerBalance = -1;
    let listSpread = false;
    let listItem2;
    let lineIndex;
    let firstBlankLineIndex;
    let atMarker;
    while (++index3 <= length2) {
      const event = events[index3];
      if (event[1].type === "listUnordered" || event[1].type === "listOrdered" || event[1].type === "blockQuote") {
        if (event[0] === "enter") {
          containerBalance++;
        } else {
          containerBalance--;
        }
        atMarker = void 0;
      } else if (event[1].type === "lineEndingBlank") {
        if (event[0] === "enter") {
          if (listItem2 && !atMarker && !containerBalance && !firstBlankLineIndex) {
            firstBlankLineIndex = index3;
          }
          atMarker = void 0;
        }
      } else if (event[1].type === "linePrefix" || event[1].type === "listItemValue" || event[1].type === "listItemMarker" || event[1].type === "listItemPrefix" || event[1].type === "listItemPrefixWhitespace") {
      } else {
        atMarker = void 0;
      }
      if (!containerBalance && event[0] === "enter" && event[1].type === "listItemPrefix" || containerBalance === -1 && event[0] === "exit" && (event[1].type === "listUnordered" || event[1].type === "listOrdered")) {
        if (listItem2) {
          let tailIndex = index3;
          lineIndex = void 0;
          while (tailIndex--) {
            const tailEvent = events[tailIndex];
            if (tailEvent[1].type === "lineEnding" || tailEvent[1].type === "lineEndingBlank") {
              if (tailEvent[0] === "exit")
                continue;
              if (lineIndex) {
                events[lineIndex][1].type = "lineEndingBlank";
                listSpread = true;
              }
              tailEvent[1].type = "lineEnding";
              lineIndex = tailIndex;
            } else if (tailEvent[1].type === "linePrefix" || tailEvent[1].type === "blockQuotePrefix" || tailEvent[1].type === "blockQuotePrefixWhitespace" || tailEvent[1].type === "blockQuoteMarker" || tailEvent[1].type === "listItemIndent") {
            } else {
              break;
            }
          }
          if (firstBlankLineIndex && (!lineIndex || firstBlankLineIndex < lineIndex)) {
            listItem2._spread = true;
          }
          listItem2.end = Object.assign(
            {},
            lineIndex ? events[lineIndex][1].start : event[1].end
          );
          events.splice(lineIndex || index3, 0, ["exit", listItem2, event[2]]);
          index3++;
          length2++;
        }
        if (event[1].type === "listItemPrefix") {
          listItem2 = {
            type: "listItem",
            // @ts-expect-error Patched
            _spread: false,
            start: Object.assign({}, event[1].start)
          };
          events.splice(index3, 0, ["enter", listItem2, event[2]]);
          index3++;
          length2++;
          firstBlankLineIndex = void 0;
          atMarker = true;
        }
      }
    }
    events[start][1]._spread = listSpread;
    return length2;
  }
  function setData2(key, value) {
    data2[key] = value;
  }
  function getData(key) {
    return data2[key];
  }
  function opener(create2, and) {
    return open4;
    function open4(token) {
      enter.call(this, create2(token), token);
      if (and)
        and.call(this, token);
    }
  }
  function buffer() {
    this.stack.push({
      type: "fragment",
      children: []
    });
  }
  function enter(node3, token, errorHandler) {
    const parent = this.stack[this.stack.length - 1];
    parent.children.push(node3);
    this.stack.push(node3);
    this.tokenStack.push([token, errorHandler]);
    node3.position = {
      start: point3(token.start)
    };
    return node3;
  }
  function closer(and) {
    return close3;
    function close3(token) {
      if (and)
        and.call(this, token);
      exit2.call(this, token);
    }
  }
  function exit2(token, onExitError) {
    const node3 = this.stack.pop();
    const open4 = this.tokenStack.pop();
    if (!open4) {
      throw new Error(
        "Cannot close `" + token.type + "` (" + stringifyPosition({
          start: token.start,
          end: token.end
        }) + "): it\u2019s not open"
      );
    } else if (open4[0].type !== token.type) {
      if (onExitError) {
        onExitError.call(this, token, open4[0]);
      } else {
        const handler = open4[1] || defaultOnError;
        handler.call(this, token, open4[0]);
      }
    }
    node3.position.end = point3(token.end);
    return node3;
  }
  function resume() {
    return toString(this.stack.pop());
  }
  function onenterlistordered() {
    setData2("expectingFirstListItemValue", true);
  }
  function onenterlistitemvalue(token) {
    if (getData("expectingFirstListItemValue")) {
      const ancestor = this.stack[this.stack.length - 2];
      ancestor.start = Number.parseInt(this.sliceSerialize(token), 10);
      setData2("expectingFirstListItemValue");
    }
  }
  function onexitcodefencedfenceinfo() {
    const data3 = this.resume();
    const node3 = this.stack[this.stack.length - 1];
    node3.lang = data3;
  }
  function onexitcodefencedfencemeta() {
    const data3 = this.resume();
    const node3 = this.stack[this.stack.length - 1];
    node3.meta = data3;
  }
  function onexitcodefencedfence() {
    if (getData("flowCodeInside"))
      return;
    this.buffer();
    setData2("flowCodeInside", true);
  }
  function onexitcodefenced() {
    const data3 = this.resume();
    const node3 = this.stack[this.stack.length - 1];
    node3.value = data3.replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, "");
    setData2("flowCodeInside");
  }
  function onexitcodeindented() {
    const data3 = this.resume();
    const node3 = this.stack[this.stack.length - 1];
    node3.value = data3.replace(/(\r?\n|\r)$/g, "");
  }
  function onexitdefinitionlabelstring(token) {
    const label = this.resume();
    const node3 = this.stack[this.stack.length - 1];
    node3.label = label;
    node3.identifier = normalizeIdentifier(
      this.sliceSerialize(token)
    ).toLowerCase();
  }
  function onexitdefinitiontitlestring() {
    const data3 = this.resume();
    const node3 = this.stack[this.stack.length - 1];
    node3.title = data3;
  }
  function onexitdefinitiondestinationstring() {
    const data3 = this.resume();
    const node3 = this.stack[this.stack.length - 1];
    node3.url = data3;
  }
  function onexitatxheadingsequence(token) {
    const node3 = this.stack[this.stack.length - 1];
    if (!node3.depth) {
      const depth = this.sliceSerialize(token).length;
      node3.depth = depth;
    }
  }
  function onexitsetextheadingtext() {
    setData2("setextHeadingSlurpLineEnding", true);
  }
  function onexitsetextheadinglinesequence(token) {
    const node3 = this.stack[this.stack.length - 1];
    node3.depth = this.sliceSerialize(token).charCodeAt(0) === 61 ? 1 : 2;
  }
  function onexitsetextheading() {
    setData2("setextHeadingSlurpLineEnding");
  }
  function onenterdata(token) {
    const node3 = this.stack[this.stack.length - 1];
    let tail = node3.children[node3.children.length - 1];
    if (!tail || tail.type !== "text") {
      tail = text4();
      tail.position = {
        start: point3(token.start)
      };
      node3.children.push(tail);
    }
    this.stack.push(tail);
  }
  function onexitdata(token) {
    const tail = this.stack.pop();
    tail.value += this.sliceSerialize(token);
    tail.position.end = point3(token.end);
  }
  function onexitlineending(token) {
    const context = this.stack[this.stack.length - 1];
    if (getData("atHardBreak")) {
      const tail = context.children[context.children.length - 1];
      tail.position.end = point3(token.end);
      setData2("atHardBreak");
      return;
    }
    if (!getData("setextHeadingSlurpLineEnding") && config.canContainEols.includes(context.type)) {
      onenterdata.call(this, token);
      onexitdata.call(this, token);
    }
  }
  function onexithardbreak() {
    setData2("atHardBreak", true);
  }
  function onexithtmlflow() {
    const data3 = this.resume();
    const node3 = this.stack[this.stack.length - 1];
    node3.value = data3;
  }
  function onexithtmltext() {
    const data3 = this.resume();
    const node3 = this.stack[this.stack.length - 1];
    node3.value = data3;
  }
  function onexitcodetext() {
    const data3 = this.resume();
    const node3 = this.stack[this.stack.length - 1];
    node3.value = data3;
  }
  function onexitlink() {
    const node3 = this.stack[this.stack.length - 1];
    if (getData("inReference")) {
      const referenceType = getData("referenceType") || "shortcut";
      node3.type += "Reference";
      node3.referenceType = referenceType;
      delete node3.url;
      delete node3.title;
    } else {
      delete node3.identifier;
      delete node3.label;
    }
    setData2("referenceType");
  }
  function onexitimage() {
    const node3 = this.stack[this.stack.length - 1];
    if (getData("inReference")) {
      const referenceType = getData("referenceType") || "shortcut";
      node3.type += "Reference";
      node3.referenceType = referenceType;
      delete node3.url;
      delete node3.title;
    } else {
      delete node3.identifier;
      delete node3.label;
    }
    setData2("referenceType");
  }
  function onexitlabeltext(token) {
    const string3 = this.sliceSerialize(token);
    const ancestor = this.stack[this.stack.length - 2];
    ancestor.label = decodeString(string3);
    ancestor.identifier = normalizeIdentifier(string3).toLowerCase();
  }
  function onexitlabel() {
    const fragment = this.stack[this.stack.length - 1];
    const value = this.resume();
    const node3 = this.stack[this.stack.length - 1];
    setData2("inReference", true);
    if (node3.type === "link") {
      const children = fragment.children;
      node3.children = children;
    } else {
      node3.alt = value;
    }
  }
  function onexitresourcedestinationstring() {
    const data3 = this.resume();
    const node3 = this.stack[this.stack.length - 1];
    node3.url = data3;
  }
  function onexitresourcetitlestring() {
    const data3 = this.resume();
    const node3 = this.stack[this.stack.length - 1];
    node3.title = data3;
  }
  function onexitresource() {
    setData2("inReference");
  }
  function onenterreference() {
    setData2("referenceType", "collapsed");
  }
  function onexitreferencestring(token) {
    const label = this.resume();
    const node3 = this.stack[this.stack.length - 1];
    node3.label = label;
    node3.identifier = normalizeIdentifier(
      this.sliceSerialize(token)
    ).toLowerCase();
    setData2("referenceType", "full");
  }
  function onexitcharacterreferencemarker(token) {
    setData2("characterReferenceType", token.type);
  }
  function onexitcharacterreferencevalue(token) {
    const data3 = this.sliceSerialize(token);
    const type = getData("characterReferenceType");
    let value;
    if (type) {
      value = decodeNumericCharacterReference(
        data3,
        type === "characterReferenceMarkerNumeric" ? 10 : 16
      );
      setData2("characterReferenceType");
    } else {
      const result = decodeNamedCharacterReference(data3);
      value = result;
    }
    const tail = this.stack.pop();
    tail.value += value;
    tail.position.end = point3(token.end);
  }
  function onexitautolinkprotocol(token) {
    onexitdata.call(this, token);
    const node3 = this.stack[this.stack.length - 1];
    node3.url = this.sliceSerialize(token);
  }
  function onexitautolinkemail(token) {
    onexitdata.call(this, token);
    const node3 = this.stack[this.stack.length - 1];
    node3.url = "mailto:" + this.sliceSerialize(token);
  }
  function blockQuote2() {
    return {
      type: "blockquote",
      children: []
    };
  }
  function codeFlow() {
    return {
      type: "code",
      lang: null,
      meta: null,
      value: ""
    };
  }
  function codeText2() {
    return {
      type: "inlineCode",
      value: ""
    };
  }
  function definition2() {
    return {
      type: "definition",
      identifier: "",
      label: null,
      title: null,
      url: ""
    };
  }
  function emphasis() {
    return {
      type: "emphasis",
      children: []
    };
  }
  function heading() {
    return {
      type: "heading",
      depth: void 0,
      children: []
    };
  }
  function hardBreak() {
    return {
      type: "break"
    };
  }
  function html2() {
    return {
      type: "html",
      value: ""
    };
  }
  function image() {
    return {
      type: "image",
      title: null,
      url: "",
      alt: null
    };
  }
  function link() {
    return {
      type: "link",
      title: null,
      url: "",
      children: []
    };
  }
  function list2(token) {
    return {
      type: "list",
      ordered: token.type === "listOrdered",
      start: null,
      // @ts-expect-error Patched.
      spread: token._spread,
      children: []
    };
  }
  function listItem(token) {
    return {
      type: "listItem",
      // @ts-expect-error Patched.
      spread: token._spread,
      checked: null,
      children: []
    };
  }
  function paragraph() {
    return {
      type: "paragraph",
      children: []
    };
  }
  function strong() {
    return {
      type: "strong",
      children: []
    };
  }
  function text4() {
    return {
      type: "text",
      value: ""
    };
  }
  function thematicBreak2() {
    return {
      type: "thematicBreak"
    };
  }
}
function point3(d) {
  return {
    line: d.line,
    column: d.column,
    offset: d.offset
  };
}
function configure(combined, extensions) {
  let index3 = -1;
  while (++index3 < extensions.length) {
    const value = extensions[index3];
    if (Array.isArray(value)) {
      configure(combined, value);
    } else {
      extension(combined, value);
    }
  }
}
function extension(combined, extension2) {
  let key;
  for (key in extension2) {
    if (own.call(extension2, key)) {
      if (key === "canContainEols") {
        const right = extension2[key];
        if (right) {
          combined[key].push(...right);
        }
      } else if (key === "transforms") {
        const right = extension2[key];
        if (right) {
          combined[key].push(...right);
        }
      } else if (key === "enter" || key === "exit") {
        const right = extension2[key];
        if (right) {
          Object.assign(combined[key], right);
        }
      }
    }
  }
}
function defaultOnError(left, right) {
  if (left) {
    throw new Error(
      "Cannot close `" + left.type + "` (" + stringifyPosition({
        start: left.start,
        end: left.end
      }) + "): a different token (`" + right.type + "`, " + stringifyPosition({
        start: right.start,
        end: right.end
      }) + ") is open"
    );
  } else {
    throw new Error(
      "Cannot close document, a token (`" + right.type + "`, " + stringifyPosition({
        start: right.start,
        end: right.end
      }) + ") is still open"
    );
  }
}

// ../simple-mind-map/src/parse/markdownTo.js
var handleList = (node3) => {
  let list2 = [];
  let walk2 = (arr, newArr) => {
    for (let i2 = 0; i2 < arr.length; i2++) {
      let cur = arr[i2];
      let node4 = {};
      node4.data = {
        // 节点内容
        text: cur.children[0].children[0].value
      };
      node4.children = [];
      newArr.push(node4);
      if (cur.children.length > 1) {
        for (let j = 1; j < cur.children.length; j++) {
          let cur2 = cur.children[j];
          if (cur2.type === "list") {
            walk2(cur2.children, node4.children);
          }
        }
      }
    }
  };
  walk2(node3.children, list2);
  return list2;
};
var transformMarkdownTo = (md) => {
  const tree = fromMarkdown(md);
  let root2 = {
    children: []
  };
  let childrenQueue = [root2.children];
  let currentChildren = root2.children;
  let depthQueue = [-1];
  let currentDepth = -1;
  for (let i2 = 0; i2 < tree.children.length; i2++) {
    let cur = tree.children[i2];
    if (cur.type === "heading") {
      if (!cur.children[0])
        continue;
      let node3 = {};
      node3.data = {
        // 节点内容
        text: cur.children[0].value
      };
      node3.children = [];
      if (cur.depth > currentDepth) {
        currentChildren.push(node3);
        childrenQueue.push(node3.children);
        currentChildren = node3.children;
        depthQueue.push(cur.depth);
        currentDepth = cur.depth;
      } else if (cur.depth === currentDepth) {
        childrenQueue.pop();
        currentChildren = childrenQueue[childrenQueue.length - 1];
        depthQueue.pop();
        currentDepth = depthQueue[depthQueue.length - 1];
        currentChildren.push(node3);
        childrenQueue.push(node3.children);
        currentChildren = node3.children;
        depthQueue.push(cur.depth);
        currentDepth = cur.depth;
      } else {
        while (depthQueue.length) {
          childrenQueue.pop();
          currentChildren = childrenQueue[childrenQueue.length - 1];
          depthQueue.pop();
          currentDepth = depthQueue[depthQueue.length - 1];
          if (currentDepth < cur.depth) {
            currentChildren.push(node3);
            childrenQueue.push(node3.children);
            currentChildren = node3.children;
            depthQueue.push(cur.depth);
            currentDepth = cur.depth;
            break;
          }
        }
      }
    } else if (cur.type === "list") {
      currentChildren.push(...handleList(cur));
    }
  }
  return root2.children[0];
};

// ../simple-mind-map/src/parse/markdown.js
var markdown_default = {
  transformToMarkdown,
  transformMarkdownTo
};

// ../simple-mind-map/full.js
simple_mind_map_default.xmind = xmind_default;
simple_mind_map_default.markdown = markdown_default;
simple_mind_map_default.iconList = icons_default.nodeIconList;
simple_mind_map_default.constants = constant_exports;
simple_mind_map_default.themes = themes_default;
simple_mind_map_default.defaultTheme = default_exports;
simple_mind_map_default.usePlugin(MiniMap_default).usePlugin(Watermark_default).usePlugin(Drag_default).usePlugin(KeyboardNavigation_default).usePlugin(ExportXMind_default).usePlugin(ExportPDF_default).usePlugin(Export_default).usePlugin(Select_default).usePlugin(AssociativeLine_default).usePlugin(RichText_default).usePlugin(TouchEvent_default).usePlugin(NodeImgAdjust_default).usePlugin(Search_default).usePlugin(Painter_default).usePlugin(Scrollbar_default).usePlugin(Formula_default);
var full_default = simple_mind_map_default;
export {
  full_default as default
};
/** @license
 *
 * jsPDF - PDF Document creation from JavaScript
 * Version 2.5.1 Built on 2022-01-28T15:37:57.791Z
 *                      CommitID 00000000
 *
 * Copyright (c) 2010-2021 James Hall <james@parall.ax>, https://github.com/MrRio/jsPDF
 *               2015-2021 yWorks GmbH, http://www.yworks.com
 *               2015-2021 Lukas Holländer <lukas.hollaender@yworks.com>, https://github.com/HackbrettXXX
 *               2016-2018 Aras Abbasi <aras.abbasi@gmail.com>
 *               2010 Aaron Spike, https://github.com/acspike
 *               2012 Willow Systems Corporation, https://github.com/willowsystems
 *               2012 Pablo Hess, https://github.com/pablohess
 *               2012 Florian Jenett, https://github.com/fjenett
 *               2013 Warren Weckesser, https://github.com/warrenweckesser
 *               2013 Youssef Beddad, https://github.com/lifof
 *               2013 Lee Driscoll, https://github.com/lsdriscoll
 *               2013 Stefan Slonevskiy, https://github.com/stefslon
 *               2013 Jeremy Morel, https://github.com/jmorel
 *               2013 Christoph Hartmann, https://github.com/chris-rock
 *               2014 Juan Pablo Gaviria, https://github.com/juanpgaviria
 *               2014 James Makes, https://github.com/dollaruw
 *               2014 Diego Casorran, https://github.com/diegocr
 *               2014 Steven Spungin, https://github.com/Flamenco
 *               2014 Kenneth Glassey, https://github.com/Gavvers
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 * Contributor(s):
 *    siefkenj, ahwolf, rickygu, Midnith, saintclair, eaparango,
 *    kim3er, mfo, alnorth, Flamenco
 */
/**
 * A class to parse color values
 * @author Stoyan Stefanov <sstoo@gmail.com>
 * {@link   http://www.phpied.com/rgb-color-parser-in-javascript/}
 * @license Use it if you like it
 */
/**
 * @license
 * Joseph Myers does not specify a particular license for his work.
 *
 * Author: Joseph Myers
 * Accessed from: http://www.myersdaily.org/joseph/javascript/md5.js
 *
 * Modified by: Owen Leong
 */
/**
 * @license
 * FPDF is released under a permissive license: there is no usage restriction.
 * You may embed it freely in your application (commercial or not), with or
 * without modifications.
 *
 * Reference: http://www.fpdf.org/en/script/script37.php
 */
/**
 * @license
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 * Author: Owen Leong (@owenl131)
 * Date: 15 Oct 2020
 * References:
 * https://www.cs.cmu.edu/~dst/Adobe/Gallery/anon21jul01-pdf-encryption.txt
 * https://github.com/foliojs/pdfkit/blob/master/lib/security.js
 * http://www.fpdf.org/en/script/script37.php
 */
/**
 * @license
 * Copyright (c) 2014 Steven Spungin (TwelveTone LLC)  steven@twelvetone.tv
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
/**
 * @license
 * Copyright (c) 2017 Aras Abbasi
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
/** @license
 * jsPDF Autoprint Plugin
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
/**
 * @license
 * jsPDF filters PlugIn
 * Copyright (c) 2014 Aras Abbasi
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
/**
 * @license
 * jsPDF fileloading PlugIn
 * Copyright (c) 2018 Aras Abbasi (aras.abbasi@gmail.com)
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
/**
 * @license
 * ====================================================================
 * Copyright (c) 2013 Youssef Beddad, youssef.beddad@gmail.com
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * ====================================================================
 */
/**
 * @license
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
/**
 * @license
 *
 * Copyright (c) 2014 James Robb, https://github.com/jamesbrobb
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * ====================================================================
 */
/**
 * @license
 * (c) Dean McNamee <dean@gmail.com>, 2013.
 *
 * https://github.com/deanm/omggif
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to
 * deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *
 * omggif is a JavaScript implementation of a GIF 89a encoder and decoder,
 * including animation and compression.  It does not rely on any specific
 * underlying system, so should run in the browser, Node, or Plask.
 */
/**
 * @license
  Copyright (c) 2008, Adobe Systems Incorporated
  All rights reserved.

  Redistribution and use in source and binary forms, with or without 
  modification, are permitted provided that the following conditions are
  met:

  * Redistributions of source code must retain the above copyright notice, 
    this list of conditions and the following disclaimer.
  
  * Redistributions in binary form must reproduce the above copyright
    notice, this list of conditions and the following disclaimer in the 
    documentation and/or other materials provided with the distribution.
  
  * Neither the name of Adobe Systems Incorporated nor the names of its 
    contributors may be used to endorse or promote products derived from 
    this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
  IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR 
  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
/**
 * @license
 * Copyright (c) 2018 Aras Abbasi
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
/** @license
 * Copyright (c) 2017 Dominik Homberger
Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
https://webpjs.appspot.com
WebPRiffParser dominikhlbg@gmail.com
*/
/**
 * @license
 * Copyright (c) 2019 Aras Abbasi
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
/**
 * @license
 *
 * Copyright (c) 2021 Antti Palola, https://github.com/Pantura
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * ====================================================================
 */
/**
 * @license
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
/** @license
 * Copyright (c) 2012 Willow Systems Corporation, https://github.com/willowsystems
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * ====================================================================
 */
/**
 * @license
 * ====================================================================
 * Copyright (c) 2013 Eduardo Menezes de Morais, eduardo.morais@usp.br
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * ====================================================================
 */
/** ====================================================================
 * @license
 * jsPDF XMP metadata plugin
 * Copyright (c) 2016 Jussi Utunen, u-jussi@suomi24.fi
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * ====================================================================
 */
/**
 * @license
 * jsPDF virtual FileSystem functionality
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
/**
 * @license
 * Unicode Bidi Engine based on the work of Alex Shensis (@asthensis)
 * MIT License
 */
/*! Bundled license information:

jszip/dist/jszip.min.js:
  (*!
  
  JSZip v3.10.1 - A JavaScript class for generating and reading zip files
  <http://stuartk.com/jszip>
  
  (c) 2009-2016 Stuart Knightley <stuart [at] stuartk.com>
  Dual licenced under the MIT license or GPLv3. See https://raw.github.com/Stuk/jszip/main/LICENSE.markdown.
  
  JSZip uses the library pako released under the MIT license :
  https://github.com/nodeca/pako/blob/main/LICENSE
  *)

sax/lib/sax.js:
  (*! http://mths.be/fromcodepoint v0.1.0 by @mathias *)

html2canvas/dist/html2canvas.js:
  (*!
   * html2canvas 1.4.1 <https://html2canvas.hertzen.com>
   * Copyright (c) 2022 Niklas von Hertzen <https://hertzen.com>
   * Released under MIT License
   *)
  (*! *****************************************************************************
      Copyright (c) Microsoft Corporation.
  
      Permission to use, copy, modify, and/or distribute this software for any
      purpose with or without fee is hereby granted.
  
      THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
      REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
      AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
      INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
      LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
      OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
      PERFORMANCE OF THIS SOFTWARE.
      ***************************************************************************** *)

dompurify/dist/purify.js:
  (*! @license DOMPurify 2.4.7 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/2.4.7/LICENSE *)

svg-pathdata/lib/SVGPathData.module.js:
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** *)

quill/dist/quill.js:
  (*!
   * Quill Editor v1.3.6
   * https://quilljs.com/
   * Copyright (c) 2014, Jason Chen
   * Copyright (c) 2013, salesforce.com
   *)

@svgdotjs/svg.js/dist/svg.esm.js:
  (*!
  * @svgdotjs/svg.js - A lightweight library for manipulating and animating SVG.
  * @version 3.1.2
  * https://svgjs.dev/
  *
  * @copyright Wout Fierens <wout@mick-wout.com>
  * @license MIT
  *
  * BUILT: Wed Jan 26 2022 23:19:07 GMT+0100 (Mitteleuropäische Normalzeit)
  *)
*/
